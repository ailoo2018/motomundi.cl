window.ChannelizeLiveBroadcast = function (e) {
    var t = {};

    function r(n) {
        if (t[n]) return t[n].exports;
        var i = t[n] = {i: n, l: !1, exports: {}};
        return e[n].call(i.exports, i, i.exports, r), i.l = !0, i.exports
    }

    return r.m = e, r.c = t, r.d = function (e, t, n) {
        r.o(e, t) || Object.defineProperty(e, t, {enumerable: !0, get: n})
    }, r.r = function (e) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {value: "Module"}), Object.defineProperty(e, "__esModule", {value: !0})
    }, r.t = function (e, t) {
        if (1 & t && (e = r(e)), 8 & t) return e;
        if (4 & t && "object" == typeof e && e && e.__esModule) return e;
        var n = Object.create(null);
        if (r.r(n), Object.defineProperty(n, "default", {
            enumerable: !0,
            value: e
        }), 2 & t && "string" != typeof e) for (var i in e) r.d(n, i, function (t) {
            return e[t]
        }.bind(null, i));
        return n
    }, r.n = function (e) {
        var t = e && e.__esModule ? function () {
            return e.default
        } : function () {
            return e
        };
        return r.d(t, "a", t), t
    }, r.o = function (e, t) {
        return Object.prototype.hasOwnProperty.call(e, t)
    }, r.p = "", r(r.s = 157)
}([function (e, t, r) {
    "use strict";
    r.r(t), r.d(t, "errors", function () {
        return n
    });
    var n = {
        NOT_INITIALIZED: "You have not initialized channelize client yet..",
        ALREADY_CONNECTED: "Channelize server is already connected.",
        ALREADY_DISCONNECTED: "Channelize server is already disconnected.",
        INVALID_LIVE_BROADCAST_APP_ID: "Invalid Channelize Live Broadcast App Id provided.",
        REQUIRED_PUBLIC_KEY: "Public key is required.",
        INVALID_USER_ID: "User Id should be a string.",
        INVALID_ID: "Id should be a string.",
        INVALID_USER_NAME: "Display Name should be a string.",
        INVALID_DATA: "Data should be an object.",
        INVALID_PROFILE_IMG: "Img should be a file object.",
        INVALID_USER_IDS: "User Ids should be an array.",
        INVALID_EVENT: "%s event is not supported.",
        EVENT_NOT_ALLOWED: "%s event not allowed for %s role.",
        INVALID_DEVICE_ID: "Device Id should be a string.",
        INVALID_EMAIL: "Email Id is not valid.",
        INVALID_PASSWORD: "Password should be a string.",
        INVALID_ACCESS_TOKEN: "Access Token is required and should be a string.",
        INVALID_CLIENT_SERVER_TOKEN: "Channelize Client Server Token is required and should be a string.",
        INVALID_DATA_PARAM: "%s parameter is not allowed.",
        INVALID_PRODUCT_IDS: "Product Ids should be an array.",
        REQUIRED_SOCKET_EVENT_PARAM: "%s parameter is required in event %s.",
        INVALID_WEBRTC_SERVICE: "Invalid webRTC service provided. Valid Options is - agora.",
        BROWSER_NOT_COMPATIBLE: "Browser is not compatible to run WebRTC.",
        INVALID_MEDIA_VIEW: "Media view element must be a string value.",
        INVALID_OPTIONS: "Options should be an object.",
        INVALID_REACTION_TYPE: "Reaction type should be a string.",
        INVALID_REMOTE_MEDIA_USER: "No host exists with the user id provided.",
        INVALID_GUEST: "Guest should be either string or an object.",
        NOT_CONNECTED: "Channelize SDK is not connected.",
        NOT_ANONYMOUS_USER: "Channelize SDK is not connected as anonymous.",
        EVENT_ALREADY_ADDED: "Given event is already added.",
        INVALID_EVENT_NAME: "Event name should be a valid string.",
        INVALID_EVENT_TOPIC: "Event param topic should be a valid string.",
        INVALID_EVENT_VARS: "Event param vars should be an array.",
        INVALID_EVENT_ROLE: "Event param allowedRole should be a valid string.",
        REQUIRED_PRIVATE_KEY: "Private key is required.",
        INVALID_LOG_LEVEL: "Log level should be one of values - info, warn, error, none",
        INVALID_LOGGER: "Logger should be a function accepting three arguments - level, message & params",
        WEBSOCKET_CONNECTION_ERROR: "Error while connecting to websocket server.",
        WEBSOCKET_NOT_ENABLED: "The websocket connection should be enabled for this function. You have to ignore disableWebSocket option in connect function.",
        API_ERROR: "Error in API response.",
        LIVE_STREAMING_ERROR: "Urls not correct or rtmp servers are not running.",
        RTMP_NOT_CONFIGURED: "The rtmp is not configured.",
        RTMP_NOT_STARTED: "Please start RTMP streaming as there is no RTMP streaming.",
        UNSUPPORTED_RESOLUTION: "We support resolutions up to 720p. To go live, please use a resolution of 720p or lower in the Streaming Software.",
        BROADCAST_COMPLETED: "This livebroadcast is completed.",
        BROADCAST_PLATFORM_CHANGE_NOT_ALLOWED: "This livebroadcast is already live from other platform, the platform change is not allowed after livebroadcast is live.",
        SIMULCASTING_NOT_CONFIGURED: "The simulcasting is not configured properly.",
        EVENT_NOT_LIVE: "Event not live.",
        SUMULCASTING_DISABLED: "Simulcasting is not enabled.",
        ORIENTATION_CHANGE_NOT_ALLOWED: "Orientation is changed.",
        NO_LOGGED_IN_USER: "There is no logged in user",
        USER_IS_NOT_HOST: "The logged in user is not host of the event."
    }
}, function (e, t, r) {
    "use strict";
    r.d(t, "a", function () {
        return l
    });
    var n = r(6), i = r.n(n), o = r(8), s = r.n(o), a = r(3), c = r.n(a), u = r(2), d = u.a.LOG_LEVEL_PRECEDENCE,
        l = function () {
            function e() {
                i()(this, e)
            }

            return s()(e, null, [{
                key: "log", value: function (t, r, n) {
                    e.canLog(t) && e.logger(t, r, n)
                }
            }, {
                key: "getPrependText", value: function () {
                    var e = new Date, t = "".concat(e.toLocaleTimeString(), ":").concat(e.getMilliseconds());
                    return "".concat(t, " ChannelizeLiveBroadcast")
                }
            }]), e
        }();
    c()(l, "level", u.a.LOG_LEVELS.WARN), c()(l, "setLogLevel", function (e) {
        l.level = e
    }), c()(l, "canLog", function (e) {
        return d[e] >= d[l.level]
    }), c()(l, "setLogger", function (e) {
        l.logger = e
    }), c()(l, "logger", function (e, t, r) {
        var n = l.getPrependText();
        e === u.a.LOG_LEVELS.INFO ? console.log("".concat(n, " [INFO]: ").concat(t), r) : e === u.a.LOG_LEVELS.WARN ? console.warn("".concat(n, " [WARN]: ").concat(t), r) : e === u.a.LOG_LEVELS.ERROR && console.error("".concat(n, " [ERROR]: ").concat(t), r)
    })
}, function (e, t, r) {
    "use strict";
    r.d(t, "a", function () {
        return a
    });
    var n, i = r(3), o = r.n(i), s = {INFO: "info", WARN: "warn", ERROR: "error", NONE: "none"}, a = {
        BASEPATH_LIVE_BROADCASTS: "/live_broadcasts",
        BASEPATH_CONVERSATIONS: "/conversations",
        BASEPATH_MESSAGES: "/messages",
        BASEPATH_ACTIVITY: "/activity",
        BASEPATH_USERS: "/users",
        BASEPATH_MODULES: "/modules",
        BASEPATH_FILES: "/files",
        BASEPATH_PUSH_NOTIFICATION_SETTINGS: "/push_notification_settings",
        BASEPATH_PUSH_NOTIFICATION_TOKENS: "/push_notification_tokens",
        BASEPATH_SIMULCASTING: "/simulcasting",
        BASEPATH_SIMULCASTING_STATUS: "/status",
        BASEPATH_RTMP_CONFIG: "/rtmp",
        BASEPATH_SPOTLIGHT_PLAYBACK: "/playback/spotlight_products",
        BASEPATH_WEBRTC: "/webrtc",
        BASEPATH_ASK_TO_JOIN: "/ask_to_join",
        BASEPATH_ASK_TO_JOIN_ACTION: "/ask_to_join_action",
        BASEPATH_JOIN: "/join",
        BASEPATH_LIVEBROADCAST_GLOBAL_SETTINGS: "/livebroadcast_global_settings",
        LOCALSTORAGE_PREFIX: "channelize_storage_",
        ROLES: {ANONYMOUS: "anonymous", USER: "user", GUEST: "guest", HOST: "host"},
        ANONYMOUS_ID_PREFIX: "anonymous",
        ANONYMOUS_USER_DISPLAY_NAME: "Anonymous User",
        LOCALSTORAGE_EXPIRY_TIME: 2592e3,
        DEFAULT_CLIENT_OPTIONS: {autoSubscribeSocketEvents: !0},
        DEFAULT_SERVER_OPTIONS: {autoSubscribeSocketEvents: !1},
        DEFAULT_AGORA_INIT_OPTIONS: {mode: "live", codec: "h264"},
        DEFAULT_AGORA_STREAM_OPTIONS: {fit: "cover"},
        DEFAULT_AGORA_VIDEO_PROFILE: "720p_3",
        ROLE_PRECEDENCE: {anonymous: 0, guest: 1, user: 2, host: 3},
        STREAM_FALLBACK_TYPE: 1,
        LOG_LEVELS: s,
        LOG_LEVEL_PRECEDENCE: (n = {}, o()(n, s.INFO, 0), o()(n, s.WARN, 1), o()(n, s.ERROR, 2), o()(n, s.NONE, 3), n),
        INJECT_STREAM_CONFIG: {
            width: 1280,
            height: 720,
            videoGop: 30,
            videoFramerate: 30,
            videoBitrate: 3420,
            audioSampleRate: 44100,
            audioBitrate: 128,
            audioChannels: 1
        },
        VIDEO_PROFILES: [[640, 360, 30, 1200, "360p_4"], [480, 360, 30, 980, "360p_8"], [640, 480, 30, 1500, "480p_4"], [848, 480, 30, 1860, "480p_9"], [1280, 720, 30, 3420, "720p_3"], [960, 720, 30, 2760, "720p_6"]],
        DEFAULT_VIDEO_PROFILE: [[1280, 720, 30, 3420, "720p_3"]],
        RTMP_RTC_USER_ID: 666,
        ACTIVITY_TRACKING_EVENT_NAME: "channelize-live-shopping-activities-track",
        ACTIVITY_TRACKING_COOKIES_EXPIRY_IN_DAYS: 30,
        ACTIVITY_TRACKING_SHOW_IN_LIVE_COOKIE_EXPIRY_IN_HOURS: 24
    }
}, function (e, t) {
    e.exports = function (e, t, r) {
        return t in e ? Object.defineProperty(e, t, {
            value: r,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : e[t] = r, e
    }
}, function (e, t, r) {
    "use strict";
    (function (e) {
        function n(t, r) {
            if ("function" == typeof t) try {
                return r(t)
            } catch (t) {
                return e.nextTick(function () {
                    throw t
                })
            }
            return new Promise(function (e, t) {
                r(function (r, n) {
                    return null != r ? t(r) : arguments.length > 2 ? e(Array.prototype.slice.call(arguments, 1)) : void e(n)
                })
            })
        }

        r.d(t, "a", function () {
            return n
        })
    }).call(this, r(14))
}, function (e, t, r) {
    e.exports = r(161)
}, function (e, t) {
    e.exports = function (e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
    }
}, function (e, t) {
    function r(t) {
        return e.exports = r = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        }, r(t)
    }

    e.exports = r
}, function (e, t) {
    function r(e, t) {
        for (var r = 0; r < t.length; r++) {
            var n = t[r];
            n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
        }
    }

    e.exports = function (e, t, n) {
        return t && r(e.prototype, t), n && r(e, n), e
    }
}, function (e, t, r) {
    var n = {util: r(15)};
    ({}).toString(), e.exports = n, n.util.update(n, {
        VERSION: "2.802.0",
        Signers: {},
        Protocol: {Json: r(81), Query: r(114), Rest: r(54), RestJson: r(116), RestXml: r(117)},
        XML: {Builder: r(219), Parser: null},
        JSON: {Builder: r(82), Parser: r(83)},
        Model: {Api: r(118), Operation: r(119), Shape: r(49), Paginator: r(120), ResourceWaiter: r(121)},
        apiLoader: r(224),
        EndpointCache: r(225).EndpointCache
    }), r(123), r(227), r(230), r(126), r(231), r(234), r(236), r(237), r(238), r(245), n.events = new n.SequentialExecutor, n.util.memoizedProperty(n, "endpointCache", function () {
        return new n.EndpointCache(n.config.endpointCacheSize)
    }, !0)
}, function (e, t, r) {
    var n = r(179);
    e.exports = function (e, t) {
        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
        e.prototype = Object.create(t && t.prototype, {
            constructor: {
                value: e,
                writable: !0,
                configurable: !0
            }
        }), t && n(e, t)
    }
}, function (e, t, r) {
    var n = r(18), i = r(19);
    e.exports = function (e, t) {
        return !t || "object" !== n(t) && "function" != typeof t ? i(e) : t
    }
}, function (e, t) {
    function r(e, t, r, n, i, o, s) {
        try {
            var a = e[o](s), c = a.value
        } catch (e) {
            return void r(e)
        }
        a.done ? t(c) : Promise.resolve(c).then(n, i)
    }

    e.exports = function (e) {
        return function () {
            var t = this, n = arguments;
            return new Promise(function (i, o) {
                var s = e.apply(t, n);

                function a(e) {
                    r(s, i, o, a, c, "next", e)
                }

                function c(e) {
                    r(s, i, o, a, c, "throw", e)
                }

                a(void 0)
            })
        }
    }
}, function (e, t, r) {
    "use strict";
    r.d(t, "a", function () {
        return n
    });
    var n = {
        LOGGER: !1,
        VERSION: "v2",
        BASE_URL: "https://api.channelize.io/v2",
        LIVE_BROADCAST_BASE_URL: "https://live-broadcast-api.channelize.io/v2",
        AWS_REGION: "us-east-1",
        AWS_IOT_HOST: "am1p7ut7tcfuv-ats.iot.us-east-1.amazonaws.com",
        AWS_COGNITO_IDENTITY_POOL_ID: "us-east-1:63b1a2d1-849d-4f12-bcaf-bc275a0d5ba9"
    }
}, function (e, t) {
    var r, n, i = e.exports = {};

    function o() {
        throw new Error("setTimeout has not been defined")
    }

    function s() {
        throw new Error("clearTimeout has not been defined")
    }

    function a(e) {
        if (r === setTimeout) return setTimeout(e, 0);
        if ((r === o || !r) && setTimeout) return r = setTimeout, setTimeout(e, 0);
        try {
            return r(e, 0)
        } catch (t) {
            try {
                return r.call(null, e, 0)
            } catch (t) {
                return r.call(this, e, 0)
            }
        }
    }

    !function () {
        try {
            r = "function" == typeof setTimeout ? setTimeout : o
        } catch (e) {
            r = o
        }
        try {
            n = "function" == typeof clearTimeout ? clearTimeout : s
        } catch (e) {
            n = s
        }
    }();
    var c, u = [], d = !1, l = -1;

    function h() {
        d && c && (d = !1, c.length ? u = c.concat(u) : l = -1, u.length && p())
    }

    function p() {
        if (!d) {
            var e = a(h);
            d = !0;
            for (var t = u.length; t;) {
                for (c = u, u = []; ++l < t;) c && c[l].run();
                l = -1, t = u.length
            }
            c = null, d = !1, function (e) {
                if (n === clearTimeout) return clearTimeout(e);
                if ((n === s || !n) && clearTimeout) return n = clearTimeout, clearTimeout(e);
                try {
                    n(e)
                } catch (t) {
                    try {
                        return n.call(null, e)
                    } catch (t) {
                        return n.call(this, e)
                    }
                }
            }(e)
        }
    }

    function f(e, t) {
        this.fun = e, this.array = t
    }

    function m() {
    }

    i.nextTick = function (e) {
        var t = new Array(arguments.length - 1);
        if (arguments.length > 1) for (var r = 1; r < arguments.length; r++) t[r - 1] = arguments[r];
        u.push(new f(e, t)), 1 !== u.length || d || a(p)
    }, f.prototype.run = function () {
        this.fun.apply(null, this.array)
    }, i.title = "browser", i.browser = !0, i.env = {}, i.argv = [], i.version = "", i.versions = {}, i.on = m, i.addListener = m, i.once = m, i.off = m, i.removeListener = m, i.removeAllListeners = m, i.emit = m, i.prependListener = m, i.prependOnceListener = m, i.listeners = function (e) {
        return []
    }, i.binding = function (e) {
        throw new Error("process.binding is not supported")
    }, i.cwd = function () {
        return "/"
    }, i.chdir = function (e) {
        throw new Error("process.chdir is not supported")
    }, i.umask = function () {
        return 0
    }
}, function (e, t, r) {
    (function (t, n) {
        var i, o = {
            environment: "nodejs",
            engine: function () {
                if (o.isBrowser() && "undefined" != typeof navigator) return navigator.userAgent;
                var e = t.platform + "/" + t.version;
                return t.env.AWS_EXECUTION_ENV && (e += " exec-env/" + t.env.AWS_EXECUTION_ENV), e
            },
            userAgent: function () {
                var e = o.environment, t = "aws-sdk-" + e + "/" + r(9).VERSION;
                return "nodejs" === e && (t += " " + o.engine()), t
            },
            uriEscape: function (e) {
                var t = encodeURIComponent(e);
                return t = (t = t.replace(/[^A-Za-z0-9_.~\-%]+/g, escape)).replace(/[*]/g, function (e) {
                    return "%" + e.charCodeAt(0).toString(16).toUpperCase()
                })
            },
            uriEscapePath: function (e) {
                var t = [];
                return o.arrayEach(e.split("/"), function (e) {
                    t.push(o.uriEscape(e))
                }), t.join("/")
            },
            urlParse: function (e) {
                return o.url.parse(e)
            },
            urlFormat: function (e) {
                return o.url.format(e)
            },
            queryStringParse: function (e) {
                return o.querystring.parse(e)
            },
            queryParamsToString: function (e) {
                var t = [], r = o.uriEscape, n = Object.keys(e).sort();
                return o.arrayEach(n, function (n) {
                    var i = e[n], s = r(n), a = s + "=";
                    if (Array.isArray(i)) {
                        var c = [];
                        o.arrayEach(i, function (e) {
                            c.push(r(e))
                        }), a = s + "=" + c.sort().join("&" + s + "=")
                    } else void 0 !== i && null !== i && (a = s + "=" + r(i));
                    t.push(a)
                }), t.join("&")
            },
            readFileSync: function (e) {
                return o.isBrowser() ? null : r(86).readFileSync(e, "utf-8")
            },
            base64: {
                encode: function (e) {
                    if ("number" == typeof e) throw o.error(new Error("Cannot base64 encode number " + e));
                    return null === e || void 0 === e ? e : o.buffer.toBuffer(e).toString("base64")
                }, decode: function (e) {
                    if ("number" == typeof e) throw o.error(new Error("Cannot base64 decode number " + e));
                    return null === e || void 0 === e ? e : o.buffer.toBuffer(e, "base64")
                }
            },
            buffer: {
                toBuffer: function (e, t) {
                    return "function" == typeof o.Buffer.from && o.Buffer.from !== Uint8Array.from ? o.Buffer.from(e, t) : new o.Buffer(e, t)
                }, alloc: function (e, t, r) {
                    if ("number" != typeof e) throw new Error("size passed to alloc must be a number.");
                    if ("function" == typeof o.Buffer.alloc) return o.Buffer.alloc(e, t, r);
                    var n = new o.Buffer(e);
                    return void 0 !== t && "function" == typeof n.fill && n.fill(t, void 0, void 0, r), n
                }, toStream: function (e) {
                    o.Buffer.isBuffer(e) || (e = o.buffer.toBuffer(e));
                    var t = new o.stream.Readable, r = 0;
                    return t._read = function (n) {
                        if (r >= e.length) return t.push(null);
                        var i = r + n;
                        i > e.length && (i = e.length), t.push(e.slice(r, i)), r = i
                    }, t
                }, concat: function (e) {
                    var t, r, n = 0, i = 0;
                    for (r = 0; r < e.length; r++) n += e[r].length;
                    for (t = o.buffer.alloc(n), r = 0; r < e.length; r++) e[r].copy(t, i), i += e[r].length;
                    return t
                }
            },
            string: {
                byteLength: function (e) {
                    if (null === e || void 0 === e) return 0;
                    if ("string" == typeof e && (e = o.buffer.toBuffer(e)), "number" == typeof e.byteLength) return e.byteLength;
                    if ("number" == typeof e.length) return e.length;
                    if ("number" == typeof e.size) return e.size;
                    if ("string" == typeof e.path) return r(86).lstatSync(e.path).size;
                    throw o.error(new Error("Cannot determine length of " + e), {object: e})
                }, upperFirst: function (e) {
                    return e[0].toUpperCase() + e.substr(1)
                }, lowerFirst: function (e) {
                    return e[0].toLowerCase() + e.substr(1)
                }
            },
            ini: {
                parse: function (e) {
                    var t, r = {};
                    return o.arrayEach(e.split(/\r?\n/), function (e) {
                        var n = (e = e.split(/(^|\s)[;#]/)[0]).match(/^\s*\[([^\[\]]+)\]\s*$/);
                        if (n) t = n[1]; else if (t) {
                            var i = e.match(/^\s*(.+?)\s*=\s*(.+?)\s*$/);
                            i && (r[t] = r[t] || {}, r[t][i[1]] = i[2])
                        }
                    }), r
                }
            },
            fn: {
                noop: function () {
                }, callback: function (e) {
                    if (e) throw e
                }, makeAsync: function (e, t) {
                    return t && t <= e.length ? e : function () {
                        var t = Array.prototype.slice.call(arguments, 0);
                        t.pop()(e.apply(null, t))
                    }
                }
            },
            date: {
                getDate: function () {
                    return i || (i = r(9)), i.config.systemClockOffset ? new Date((new Date).getTime() + i.config.systemClockOffset) : new Date
                }, iso8601: function (e) {
                    return void 0 === e && (e = o.date.getDate()), e.toISOString().replace(/\.\d{3}Z$/, "Z")
                }, rfc822: function (e) {
                    return void 0 === e && (e = o.date.getDate()), e.toUTCString()
                }, unixTimestamp: function (e) {
                    return void 0 === e && (e = o.date.getDate()), e.getTime() / 1e3
                }, from: function (e) {
                    return "number" == typeof e ? new Date(1e3 * e) : new Date(e)
                }, format: function (e, t) {
                    return t || (t = "iso8601"), o.date[t](o.date.from(e))
                }, parseTimestamp: function (e) {
                    if ("number" == typeof e) return new Date(1e3 * e);
                    if (e.match(/^\d+$/)) return new Date(1e3 * e);
                    if (e.match(/^\d{4}/)) return new Date(e);
                    if (e.match(/^\w{3},/)) return new Date(e);
                    throw o.error(new Error("unhandled timestamp format: " + e), {code: "TimestampParserError"})
                }
            },
            crypto: {
                crc32Table: [0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918e3, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471, 3272380065, 1510334235, 755167117],
                crc32: function (e) {
                    var t = o.crypto.crc32Table, r = -1;
                    "string" == typeof e && (e = o.buffer.toBuffer(e));
                    for (var n = 0; n < e.length; n++) {
                        r = r >>> 8 ^ t[255 & (r ^ e.readUInt8(n))]
                    }
                    return (-1 ^ r) >>> 0
                },
                hmac: function (e, t, r, n) {
                    return r || (r = "binary"), "buffer" === r && (r = void 0), n || (n = "sha256"), "string" == typeof t && (t = o.buffer.toBuffer(t)), o.crypto.lib.createHmac(n, e).update(t).digest(r)
                },
                md5: function (e, t, r) {
                    return o.crypto.hash("md5", e, t, r)
                },
                sha256: function (e, t, r) {
                    return o.crypto.hash("sha256", e, t, r)
                },
                hash: function (e, t, r, n) {
                    var i = o.crypto.createHash(e);
                    r || (r = "binary"), "buffer" === r && (r = void 0), "string" == typeof t && (t = o.buffer.toBuffer(t));
                    var s = o.arraySliceFn(t), a = o.Buffer.isBuffer(t);
                    if (o.isBrowser() && "undefined" != typeof ArrayBuffer && t && t.buffer instanceof ArrayBuffer && (a = !0), n && "object" == typeof t && "function" == typeof t.on && !a) t.on("data", function (e) {
                        i.update(e)
                    }), t.on("error", function (e) {
                        n(e)
                    }), t.on("end", function () {
                        n(null, i.digest(r))
                    }); else {
                        if (!n || !s || a || "undefined" == typeof FileReader) {
                            o.isBrowser() && "object" == typeof t && !a && (t = new o.Buffer(new Uint8Array(t)));
                            var c = i.update(t).digest(r);
                            return n && n(null, c), c
                        }
                        var u = 0, d = new FileReader;
                        d.onerror = function () {
                            n(new Error("Failed to read data."))
                        }, d.onload = function () {
                            var e = new o.Buffer(new Uint8Array(d.result));
                            i.update(e), u += e.length, d._continueReading()
                        }, d._continueReading = function () {
                            if (u >= t.size) n(null, i.digest(r)); else {
                                var e = u + 524288;
                                e > t.size && (e = t.size), d.readAsArrayBuffer(s.call(t, u, e))
                            }
                        }, d._continueReading()
                    }
                },
                toHex: function (e) {
                    for (var t = [], r = 0; r < e.length; r++) t.push(("0" + e.charCodeAt(r).toString(16)).substr(-2, 2));
                    return t.join("")
                },
                createHash: function (e) {
                    return o.crypto.lib.createHash(e)
                }
            },
            abort: {},
            each: function (e, t) {
                for (var r in e) {
                    if (Object.prototype.hasOwnProperty.call(e, r)) if (t.call(this, r, e[r]) === o.abort) break
                }
            },
            arrayEach: function (e, t) {
                for (var r in e) {
                    if (Object.prototype.hasOwnProperty.call(e, r)) if (t.call(this, e[r], parseInt(r, 10)) === o.abort) break
                }
            },
            update: function (e, t) {
                return o.each(t, function (t, r) {
                    e[t] = r
                }), e
            },
            merge: function (e, t) {
                return o.update(o.copy(e), t)
            },
            copy: function (e) {
                if (null === e || void 0 === e) return e;
                var t = {};
                for (var r in e) t[r] = e[r];
                return t
            },
            isEmpty: function (e) {
                for (var t in e) if (Object.prototype.hasOwnProperty.call(e, t)) return !1;
                return !0
            },
            arraySliceFn: function (e) {
                var t = e.slice || e.webkitSlice || e.mozSlice;
                return "function" == typeof t ? t : null
            },
            isType: function (e, t) {
                return "function" == typeof t && (t = o.typeName(t)), Object.prototype.toString.call(e) === "[object " + t + "]"
            },
            typeName: function (e) {
                if (Object.prototype.hasOwnProperty.call(e, "name")) return e.name;
                var t = e.toString(), r = t.match(/^\s*function (.+)\(/);
                return r ? r[1] : t
            },
            error: function (e, t) {
                var r = null;
                return "string" == typeof e.message && "" !== e.message && ("string" == typeof t || t && t.message) && ((r = o.copy(e)).message = e.message), e.message = e.message || null, "string" == typeof t ? e.message = t : "object" == typeof t && null !== t && (o.update(e, t), t.message && (e.message = t.message), (t.code || t.name) && (e.code = t.code || t.name), t.stack && (e.stack = t.stack)), "function" == typeof Object.defineProperty && (Object.defineProperty(e, "name", {
                    writable: !0,
                    enumerable: !1
                }), Object.defineProperty(e, "message", {enumerable: !0})), e.name = String(t && t.name || e.name || e.code || "Error"), e.time = new Date, r && (e.originalError = r), e
            },
            inherit: function (e, t) {
                var r = null;
                if (void 0 === t) t = e, e = Object, r = {}; else {
                    var n = function () {
                    };
                    n.prototype = e.prototype, r = new n
                }
                return t.constructor === Object && (t.constructor = function () {
                    if (e !== Object) return e.apply(this, arguments)
                }), t.constructor.prototype = r, o.update(t.constructor.prototype, t), t.constructor.__super__ = e, t.constructor
            },
            mixin: function () {
                for (var e = arguments[0], t = 1; t < arguments.length; t++) for (var r in arguments[t].prototype) {
                    var n = arguments[t].prototype[r];
                    "constructor" !== r && (e.prototype[r] = n)
                }
                return e
            },
            hideProperties: function (e, t) {
                "function" == typeof Object.defineProperty && o.arrayEach(t, function (t) {
                    Object.defineProperty(e, t, {enumerable: !1, writable: !0, configurable: !0})
                })
            },
            property: function (e, t, r, n, i) {
                var o = {configurable: !0, enumerable: void 0 === n || n};
                "function" != typeof r || i ? (o.value = r, o.writable = !0) : o.get = r, Object.defineProperty(e, t, o)
            },
            memoizedProperty: function (e, t, r, n) {
                var i = null;
                o.property(e, t, function () {
                    return null === i && (i = r()), i
                }, n)
            },
            hoistPayloadMember: function (e) {
                var t = e.request, r = t.operation, n = t.service.api.operations[r], i = n.output;
                if (i.payload && !n.hasEventOutput) {
                    var s = i.members[i.payload], a = e.data[i.payload];
                    "structure" === s.type && o.each(a, function (t, r) {
                        o.property(e.data, t, r, !1)
                    })
                }
            },
            computeSha256: function (e, t) {
                if (o.isNode()) {
                    var n = o.stream.Stream, i = r(86);
                    if ("function" == typeof n && e instanceof n) {
                        if ("string" != typeof e.path) return t(new Error("Non-file stream objects are not supported with SigV4"));
                        var s = {};
                        "number" == typeof e.start && (s.start = e.start), "number" == typeof e.end && (s.end = e.end), e = i.createReadStream(e.path, s)
                    }
                }
                o.crypto.sha256(e, "hex", function (e, r) {
                    e ? t(e) : t(null, r)
                })
            },
            isClockSkewed: function (e) {
                if (e) return o.property(i.config, "isClockSkewed", Math.abs((new Date).getTime() - e) >= 3e5, !1), i.config.isClockSkewed
            },
            applyClockOffset: function (e) {
                e && (i.config.systemClockOffset = e - (new Date).getTime())
            },
            extractRequestId: function (e) {
                var t = e.httpResponse.headers["x-amz-request-id"] || e.httpResponse.headers["x-amzn-requestid"];
                !t && e.data && e.data.ResponseMetadata && (t = e.data.ResponseMetadata.RequestId), t && (e.requestId = t), e.error && (e.error.requestId = t)
            },
            addPromises: function (e, t) {
                var r = !1;
                void 0 === t && i && i.config && (t = i.config.getPromisesDependency()), void 0 === t && "undefined" != typeof Promise && (t = Promise), "function" != typeof t && (r = !0), Array.isArray(e) || (e = [e]);
                for (var n = 0; n < e.length; n++) {
                    var o = e[n];
                    r ? o.deletePromisesFromClass && o.deletePromisesFromClass() : o.addPromisesToClass && o.addPromisesToClass(t)
                }
            },
            promisifyMethod: function (e, t) {
                return function () {
                    var r = this, n = Array.prototype.slice.call(arguments);
                    return new t(function (t, i) {
                        n.push(function (e, r) {
                            e ? i(e) : t(r)
                        }), r[e].apply(r, n)
                    })
                }
            },
            isDualstackAvailable: function (e) {
                if (!e) return !1;
                var t = r(122);
                return "string" != typeof e && (e = e.serviceIdentifier), !("string" != typeof e || !t.hasOwnProperty(e)) && !!t[e].dualstackAvailable
            },
            calculateRetryDelay: function (e, t, r) {
                t || (t = {});
                var n = t.customBackoff || null;
                if ("function" == typeof n) return n(e, r);
                var i = "number" == typeof t.base ? t.base : 100;
                return Math.random() * (Math.pow(2, e) * i)
            },
            handleRequestWithRetries: function (e, t, r) {
                t || (t = {});
                var n = i.HttpClient.getInstance(), s = t.httpOptions || {}, a = 0, c = function (e) {
                    var n = t.maxRetries || 0;
                    if (e && "TimeoutError" === e.code && (e.retryable = !0), e && e.retryable && a < n) {
                        var i = o.calculateRetryDelay(a, t.retryDelayOptions, e);
                        if (i >= 0) return a++, void setTimeout(u, i + (e.retryAfter || 0))
                    }
                    r(e)
                }, u = function () {
                    var t = "";
                    n.handleRequest(e, s, function (e) {
                        e.on("data", function (e) {
                            t += e.toString()
                        }), e.on("end", function () {
                            var n = e.statusCode;
                            if (n < 300) r(null, t); else {
                                var i = 1e3 * parseInt(e.headers["retry-after"], 10) || 0,
                                    s = o.error(new Error, {statusCode: n, retryable: n >= 500 || 429 === n});
                                i && s.retryable && (s.retryAfter = i), c(s)
                            }
                        })
                    }, c)
                };
                i.util.defer(u)
            },
            uuid: {
                v4: function () {
                    return r(154).v4()
                }
            },
            convertPayloadToString: function (e) {
                var t = e.request, r = t.operation, n = t.service.api.operations[r].output || {};
                n.payload && e.data[n.payload] && (e.data[n.payload] = e.data[n.payload].toString())
            },
            defer: function (e) {
                "object" == typeof t && "function" == typeof t.nextTick ? t.nextTick(e) : "function" == typeof n ? n(e) : setTimeout(e, 0)
            },
            getRequestPayloadShape: function (e) {
                var t = e.service.api.operations;
                if (t) {
                    var r = (t || {})[e.operation];
                    if (r && r.input && r.input.payload) return r.input.members[r.input.payload]
                }
            },
            getProfilesFromSharedConfig: function (e, r) {
                var n = {}, i = {};
                if (t.env[o.configOptInEnv]) i = e.loadFrom({isConfig: !0, filename: t.env[o.sharedConfigFileEnv]});
                var s = {};
                try {
                    s = e.loadFrom({filename: r || t.env[o.configOptInEnv] && t.env[o.sharedCredentialsFileEnv]})
                } catch (e) {
                    if (!t.env[o.configOptInEnv]) throw e
                }
                for (var a = 0, c = Object.keys(i); a < c.length; a++) n[c[a]] = u(n[c[a]] || {}, i[c[a]]);
                for (a = 0, c = Object.keys(s); a < c.length; a++) n[c[a]] = u(n[c[a]] || {}, s[c[a]]);
                return n;

                function u(e, t) {
                    for (var r = 0, n = Object.keys(t); r < n.length; r++) e[n[r]] = t[n[r]];
                    return e
                }
            },
            ARN: {
                validate: function (e) {
                    return e && 0 === e.indexOf("arn:") && e.split(":").length >= 6
                }, parse: function (e) {
                    var t = e.split(":");
                    return {
                        partition: t[1],
                        service: t[2],
                        region: t[3],
                        accountId: t[4],
                        resource: t.slice(5).join(":")
                    }
                }, build: function (e) {
                    if (void 0 === e.service || void 0 === e.region || void 0 === e.accountId || void 0 === e.resource) throw o.error(new Error("Input ARN object is invalid"));
                    return "arn:" + (e.partition || "aws") + ":" + e.service + ":" + e.region + ":" + e.accountId + ":" + e.resource
                }
            },
            defaultProfile: "default",
            configOptInEnv: "AWS_SDK_LOAD_CONFIG",
            sharedCredentialsFileEnv: "AWS_SHARED_CREDENTIALS_FILE",
            sharedConfigFileEnv: "AWS_CONFIG_FILE",
            imdsDisabledEnv: "AWS_EC2_METADATA_DISABLED"
        };
        e.exports = o
    }).call(this, r(14), r(113).setImmediate)
}, function (e, t, r) {
    "use strict";
    r.d(t, "a", function () {
        return o
    });
    var n = r(6), i = r.n(n), o = function e() {
        i()(this, e)
    }
}, function (e, t, r) {
    "use strict";
    r.d(t, "a", function () {
        return _
    });
    var n = r(6), i = r.n(n), o = r(10), s = r.n(o), a = r(11), c = r.n(a), u = r(7), d = r.n(u), l = r(3), h = r.n(l),
        p = r(34), f = r(2);

    function m(e) {
        var t = function () {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function () {
                })), !0
            } catch (e) {
                return !1
            }
        }();
        return function () {
            var r, n = d()(e);
            if (t) {
                var i = d()(this).constructor;
                r = Reflect.construct(n, arguments, i)
            } else r = n.apply(this, arguments);
            return c()(this, r)
        }
    }

    var _ = function (e) {
        s()(r, e);
        var t = m(r);

        function r() {
            return i()(this, r), t.apply(this, arguments)
        }

        return r
    }(p.a);
    h()(_, "__properties", {
        id: null,
        createdAt: null,
        displayName: null,
        email: null,
        isOnline: null,
        language: null,
        lastSeen: null,
        notification: null,
        profileImageUrl: null,
        profileUrl: null,
        updatedAt: null,
        visibility: null,
        isDeleted: null,
        isActive: null,
        role: null,
        metaData: {},
        accessToken: null
    }), h()(_, "basePath", f.a.BASEPATH_USERS)
}, function (e, t) {
    function r(t) {
        "@babel/helpers - typeof";
        return "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? e.exports = r = function (e) {
            return typeof e
        } : e.exports = r = function (e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        }, r(t)
    }

    e.exports = r
}, function (e, t) {
    e.exports = function (e) {
        if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return e
    }
}, function (e, t, r) {
    r(80);
    var n = r(9);
    "undefined" != typeof window && (window.AWS = n), e.exports = n, "undefined" != typeof self && (self.AWS = n)
}, function (e, t, r) {
    "use strict";
    var n = r(100), i = r(163), o = Object.prototype.toString;

    function s(e) {
        return "[object Array]" === o.call(e)
    }

    function a(e) {
        return null !== e && "object" == typeof e
    }

    function c(e) {
        return "[object Function]" === o.call(e)
    }

    function u(e, t) {
        if (null !== e && void 0 !== e) if ("object" != typeof e && (e = [e]), s(e)) for (var r = 0, n = e.length; r < n; r++) t.call(null, e[r], r, e); else for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && t.call(null, e[i], i, e)
    }

    e.exports = {
        isArray: s, isArrayBuffer: function (e) {
            return "[object ArrayBuffer]" === o.call(e)
        }, isBuffer: i, isFormData: function (e) {
            return "undefined" != typeof FormData && e instanceof FormData
        }, isArrayBufferView: function (e) {
            return "undefined" != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(e) : e && e.buffer && e.buffer instanceof ArrayBuffer
        }, isString: function (e) {
            return "string" == typeof e
        }, isNumber: function (e) {
            return "number" == typeof e
        }, isObject: a, isUndefined: function (e) {
            return void 0 === e
        }, isDate: function (e) {
            return "[object Date]" === o.call(e)
        }, isFile: function (e) {
            return "[object File]" === o.call(e)
        }, isBlob: function (e) {
            return "[object Blob]" === o.call(e)
        }, isFunction: c, isStream: function (e) {
            return a(e) && c(e.pipe)
        }, isURLSearchParams: function (e) {
            return "undefined" != typeof URLSearchParams && e instanceof URLSearchParams
        }, isStandardBrowserEnv: function () {
            return ("undefined" == typeof navigator || "ReactNative" !== navigator.product) && "undefined" != typeof window && "undefined" != typeof document
        }, forEach: u, merge: function e() {
            var t = {};

            function r(r, n) {
                "object" == typeof t[n] && "object" == typeof r ? t[n] = e(t[n], r) : t[n] = r
            }

            for (var n = 0, i = arguments.length; n < i; n++) u(arguments[n], r);
            return t
        }, extend: function (e, t, r) {
            return u(t, function (t, i) {
                e[i] = r && "function" == typeof t ? n(t, r) : t
            }), e
        }, trim: function (e) {
            return e.replace(/^\s*/, "").replace(/\s*$/, "")
        }
    }
}, function (e, t, r) {
    "use strict";
    (function (e) {
        /*!
     * The buffer module from node.js, for the browser.
     *
     * @author   Feross Aboukhadijeh <http://feross.org>
     * @license  MIT
     */
        var n = r(248), i = r(249), o = r(128);

        function s() {
            return c.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823
        }

        function a(e, t) {
            if (s() < t) throw new RangeError("Invalid typed array length");
            return c.TYPED_ARRAY_SUPPORT ? (e = new Uint8Array(t)).__proto__ = c.prototype : (null === e && (e = new c(t)), e.length = t), e
        }

        function c(e, t, r) {
            if (!(c.TYPED_ARRAY_SUPPORT || this instanceof c)) return new c(e, t, r);
            if ("number" == typeof e) {
                if ("string" == typeof t) throw new Error("If encoding is specified then the first argument must be a string");
                return l(this, e)
            }
            return u(this, e, t, r)
        }

        function u(e, t, r, n) {
            if ("number" == typeof t) throw new TypeError('"value" argument must not be a number');
            return "undefined" != typeof ArrayBuffer && t instanceof ArrayBuffer ? function (e, t, r, n) {
                if (t.byteLength, r < 0 || t.byteLength < r) throw new RangeError("'offset' is out of bounds");
                if (t.byteLength < r + (n || 0)) throw new RangeError("'length' is out of bounds");
                t = void 0 === r && void 0 === n ? new Uint8Array(t) : void 0 === n ? new Uint8Array(t, r) : new Uint8Array(t, r, n);
                c.TYPED_ARRAY_SUPPORT ? (e = t).__proto__ = c.prototype : e = h(e, t);
                return e
            }(e, t, r, n) : "string" == typeof t ? function (e, t, r) {
                "string" == typeof r && "" !== r || (r = "utf8");
                if (!c.isEncoding(r)) throw new TypeError('"encoding" must be a valid string encoding');
                var n = 0 | f(t, r), i = (e = a(e, n)).write(t, r);
                i !== n && (e = e.slice(0, i));
                return e
            }(e, t, r) : function (e, t) {
                if (c.isBuffer(t)) {
                    var r = 0 | p(t.length);
                    return 0 === (e = a(e, r)).length ? e : (t.copy(e, 0, 0, r), e)
                }
                if (t) {
                    if ("undefined" != typeof ArrayBuffer && t.buffer instanceof ArrayBuffer || "length" in t) return "number" != typeof t.length || function (e) {
                        return e != e
                    }(t.length) ? a(e, 0) : h(e, t);
                    if ("Buffer" === t.type && o(t.data)) return h(e, t.data)
                }
                throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")
            }(e, t)
        }

        function d(e) {
            if ("number" != typeof e) throw new TypeError('"size" argument must be a number');
            if (e < 0) throw new RangeError('"size" argument must not be negative')
        }

        function l(e, t) {
            if (d(t), e = a(e, t < 0 ? 0 : 0 | p(t)), !c.TYPED_ARRAY_SUPPORT) for (var r = 0; r < t; ++r) e[r] = 0;
            return e
        }

        function h(e, t) {
            var r = t.length < 0 ? 0 : 0 | p(t.length);
            e = a(e, r);
            for (var n = 0; n < r; n += 1) e[n] = 255 & t[n];
            return e
        }

        function p(e) {
            if (e >= s()) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + s().toString(16) + " bytes");
            return 0 | e
        }

        function f(e, t) {
            if (c.isBuffer(e)) return e.length;
            if ("undefined" != typeof ArrayBuffer && "function" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(e) || e instanceof ArrayBuffer)) return e.byteLength;
            "string" != typeof e && (e = "" + e);
            var r = e.length;
            if (0 === r) return 0;
            for (var n = !1; ;) switch (t) {
                case"ascii":
                case"latin1":
                case"binary":
                    return r;
                case"utf8":
                case"utf-8":
                case void 0:
                    return F(e).length;
                case"ucs2":
                case"ucs-2":
                case"utf16le":
                case"utf-16le":
                    return 2 * r;
                case"hex":
                    return r >>> 1;
                case"base64":
                    return B(e).length;
                default:
                    if (n) return F(e).length;
                    t = ("" + t).toLowerCase(), n = !0
            }
        }

        function m(e, t, r) {
            var n = e[t];
            e[t] = e[r], e[r] = n
        }

        function _(e, t, r, n, i) {
            if (0 === e.length) return -1;
            if ("string" == typeof r ? (n = r, r = 0) : r > 2147483647 ? r = 2147483647 : r < -2147483648 && (r = -2147483648), r = +r, isNaN(r) && (r = i ? 0 : e.length - 1), r < 0 && (r = e.length + r), r >= e.length) {
                if (i) return -1;
                r = e.length - 1
            } else if (r < 0) {
                if (!i) return -1;
                r = 0
            }
            if ("string" == typeof t && (t = c.from(t, n)), c.isBuffer(t)) return 0 === t.length ? -1 : v(e, t, r, n, i);
            if ("number" == typeof t) return t &= 255, c.TYPED_ARRAY_SUPPORT && "function" == typeof Uint8Array.prototype.indexOf ? i ? Uint8Array.prototype.indexOf.call(e, t, r) : Uint8Array.prototype.lastIndexOf.call(e, t, r) : v(e, [t], r, n, i);
            throw new TypeError("val must be string, number or Buffer")
        }

        function v(e, t, r, n, i) {
            var o, s = 1, a = e.length, c = t.length;
            if (void 0 !== n && ("ucs2" === (n = String(n).toLowerCase()) || "ucs-2" === n || "utf16le" === n || "utf-16le" === n)) {
                if (e.length < 2 || t.length < 2) return -1;
                s = 2, a /= 2, c /= 2, r /= 2
            }

            function u(e, t) {
                return 1 === s ? e[t] : e.readUInt16BE(t * s)
            }

            if (i) {
                var d = -1;
                for (o = r; o < a; o++) if (u(e, o) === u(t, -1 === d ? 0 : o - d)) {
                    if (-1 === d && (d = o), o - d + 1 === c) return d * s
                } else -1 !== d && (o -= o - d), d = -1
            } else for (r + c > a && (r = a - c), o = r; o >= 0; o--) {
                for (var l = !0, h = 0; h < c; h++) if (u(e, o + h) !== u(t, h)) {
                    l = !1;
                    break
                }
                if (l) return o
            }
            return -1
        }

        function g(e, t, r, n) {
            r = Number(r) || 0;
            var i = e.length - r;
            n ? (n = Number(n)) > i && (n = i) : n = i;
            var o = t.length;
            if (o % 2 != 0) throw new TypeError("Invalid hex string");
            n > o / 2 && (n = o / 2);
            for (var s = 0; s < n; ++s) {
                var a = parseInt(t.substr(2 * s, 2), 16);
                if (isNaN(a)) return s;
                e[r + s] = a
            }
            return s
        }

        function E(e, t, r, n) {
            return W(F(t, e.length - r), e, r, n)
        }

        function y(e, t, r, n) {
            return W(function (e) {
                for (var t = [], r = 0; r < e.length; ++r) t.push(255 & e.charCodeAt(r));
                return t
            }(t), e, r, n)
        }

        function S(e, t, r, n) {
            return y(e, t, r, n)
        }

        function b(e, t, r, n) {
            return W(B(t), e, r, n)
        }

        function T(e, t, r, n) {
            return W(function (e, t) {
                for (var r, n, i, o = [], s = 0; s < e.length && !((t -= 2) < 0); ++s) r = e.charCodeAt(s), n = r >> 8, i = r % 256, o.push(i), o.push(n);
                return o
            }(t, e.length - r), e, r, n)
        }

        function R(e, t, r) {
            return 0 === t && r === e.length ? n.fromByteArray(e) : n.fromByteArray(e.slice(t, r))
        }

        function I(e, t, r) {
            r = Math.min(e.length, r);
            for (var n = [], i = t; i < r;) {
                var o, s, a, c, u = e[i], d = null, l = u > 239 ? 4 : u > 223 ? 3 : u > 191 ? 2 : 1;
                if (i + l <= r) switch (l) {
                    case 1:
                        u < 128 && (d = u);
                        break;
                    case 2:
                        128 == (192 & (o = e[i + 1])) && (c = (31 & u) << 6 | 63 & o) > 127 && (d = c);
                        break;
                    case 3:
                        o = e[i + 1], s = e[i + 2], 128 == (192 & o) && 128 == (192 & s) && (c = (15 & u) << 12 | (63 & o) << 6 | 63 & s) > 2047 && (c < 55296 || c > 57343) && (d = c);
                        break;
                    case 4:
                        o = e[i + 1], s = e[i + 2], a = e[i + 3], 128 == (192 & o) && 128 == (192 & s) && 128 == (192 & a) && (c = (15 & u) << 18 | (63 & o) << 12 | (63 & s) << 6 | 63 & a) > 65535 && c < 1114112 && (d = c)
                }
                null === d ? (d = 65533, l = 1) : d > 65535 && (d -= 65536, n.push(d >>> 10 & 1023 | 55296), d = 56320 | 1023 & d), n.push(d), i += l
            }
            return function (e) {
                var t = e.length;
                if (t <= w) return String.fromCharCode.apply(String, e);
                var r = "", n = 0;
                for (; n < t;) r += String.fromCharCode.apply(String, e.slice(n, n += w));
                return r
            }(n)
        }

        t.Buffer = c, t.SlowBuffer = function (e) {
            +e != e && (e = 0);
            return c.alloc(+e)
        }, t.INSPECT_MAX_BYTES = 50, c.TYPED_ARRAY_SUPPORT = void 0 !== e.TYPED_ARRAY_SUPPORT ? e.TYPED_ARRAY_SUPPORT : function () {
            try {
                var e = new Uint8Array(1);
                return e.__proto__ = {
                    __proto__: Uint8Array.prototype, foo: function () {
                        return 42
                    }
                }, 42 === e.foo() && "function" == typeof e.subarray && 0 === e.subarray(1, 1).byteLength
            } catch (e) {
                return !1
            }
        }(), t.kMaxLength = s(), c.poolSize = 8192, c._augment = function (e) {
            return e.__proto__ = c.prototype, e
        }, c.from = function (e, t, r) {
            return u(null, e, t, r)
        }, c.TYPED_ARRAY_SUPPORT && (c.prototype.__proto__ = Uint8Array.prototype, c.__proto__ = Uint8Array, "undefined" != typeof Symbol && Symbol.species && c[Symbol.species] === c && Object.defineProperty(c, Symbol.species, {
            value: null,
            configurable: !0
        })), c.alloc = function (e, t, r) {
            return function (e, t, r, n) {
                return d(t), t <= 0 ? a(e, t) : void 0 !== r ? "string" == typeof n ? a(e, t).fill(r, n) : a(e, t).fill(r) : a(e, t)
            }(null, e, t, r)
        }, c.allocUnsafe = function (e) {
            return l(null, e)
        }, c.allocUnsafeSlow = function (e) {
            return l(null, e)
        }, c.isBuffer = function (e) {
            return !(null == e || !e._isBuffer)
        }, c.compare = function (e, t) {
            if (!c.isBuffer(e) || !c.isBuffer(t)) throw new TypeError("Arguments must be Buffers");
            if (e === t) return 0;
            for (var r = e.length, n = t.length, i = 0, o = Math.min(r, n); i < o; ++i) if (e[i] !== t[i]) {
                r = e[i], n = t[i];
                break
            }
            return r < n ? -1 : n < r ? 1 : 0
        }, c.isEncoding = function (e) {
            switch (String(e).toLowerCase()) {
                case"hex":
                case"utf8":
                case"utf-8":
                case"ascii":
                case"latin1":
                case"binary":
                case"base64":
                case"ucs2":
                case"ucs-2":
                case"utf16le":
                case"utf-16le":
                    return !0;
                default:
                    return !1
            }
        }, c.concat = function (e, t) {
            if (!o(e)) throw new TypeError('"list" argument must be an Array of Buffers');
            if (0 === e.length) return c.alloc(0);
            var r;
            if (void 0 === t) for (t = 0, r = 0; r < e.length; ++r) t += e[r].length;
            var n = c.allocUnsafe(t), i = 0;
            for (r = 0; r < e.length; ++r) {
                var s = e[r];
                if (!c.isBuffer(s)) throw new TypeError('"list" argument must be an Array of Buffers');
                s.copy(n, i), i += s.length
            }
            return n
        }, c.byteLength = f, c.prototype._isBuffer = !0, c.prototype.swap16 = function () {
            var e = this.length;
            if (e % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
            for (var t = 0; t < e; t += 2) m(this, t, t + 1);
            return this
        }, c.prototype.swap32 = function () {
            var e = this.length;
            if (e % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
            for (var t = 0; t < e; t += 4) m(this, t, t + 3), m(this, t + 1, t + 2);
            return this
        }, c.prototype.swap64 = function () {
            var e = this.length;
            if (e % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
            for (var t = 0; t < e; t += 8) m(this, t, t + 7), m(this, t + 1, t + 6), m(this, t + 2, t + 5), m(this, t + 3, t + 4);
            return this
        }, c.prototype.toString = function () {
            var e = 0 | this.length;
            return 0 === e ? "" : 0 === arguments.length ? I(this, 0, e) : function (e, t, r) {
                var n = !1;
                if ((void 0 === t || t < 0) && (t = 0), t > this.length) return "";
                if ((void 0 === r || r > this.length) && (r = this.length), r <= 0) return "";
                if ((r >>>= 0) <= (t >>>= 0)) return "";
                for (e || (e = "utf8"); ;) switch (e) {
                    case"hex":
                        return O(this, t, r);
                    case"utf8":
                    case"utf-8":
                        return I(this, t, r);
                    case"ascii":
                        return C(this, t, r);
                    case"latin1":
                    case"binary":
                        return A(this, t, r);
                    case"base64":
                        return R(this, t, r);
                    case"ucs2":
                    case"ucs-2":
                    case"utf16le":
                    case"utf-16le":
                        return N(this, t, r);
                    default:
                        if (n) throw new TypeError("Unknown encoding: " + e);
                        e = (e + "").toLowerCase(), n = !0
                }
            }.apply(this, arguments)
        }, c.prototype.equals = function (e) {
            if (!c.isBuffer(e)) throw new TypeError("Argument must be a Buffer");
            return this === e || 0 === c.compare(this, e)
        }, c.prototype.inspect = function () {
            var e = "", r = t.INSPECT_MAX_BYTES;
            return this.length > 0 && (e = this.toString("hex", 0, r).match(/.{2}/g).join(" "), this.length > r && (e += " ... ")), "<Buffer " + e + ">"
        }, c.prototype.compare = function (e, t, r, n, i) {
            if (!c.isBuffer(e)) throw new TypeError("Argument must be a Buffer");
            if (void 0 === t && (t = 0), void 0 === r && (r = e ? e.length : 0), void 0 === n && (n = 0), void 0 === i && (i = this.length), t < 0 || r > e.length || n < 0 || i > this.length) throw new RangeError("out of range index");
            if (n >= i && t >= r) return 0;
            if (n >= i) return -1;
            if (t >= r) return 1;
            if (t >>>= 0, r >>>= 0, n >>>= 0, i >>>= 0, this === e) return 0;
            for (var o = i - n, s = r - t, a = Math.min(o, s), u = this.slice(n, i), d = e.slice(t, r), l = 0; l < a; ++l) if (u[l] !== d[l]) {
                o = u[l], s = d[l];
                break
            }
            return o < s ? -1 : s < o ? 1 : 0
        }, c.prototype.includes = function (e, t, r) {
            return -1 !== this.indexOf(e, t, r)
        }, c.prototype.indexOf = function (e, t, r) {
            return _(this, e, t, r, !0)
        }, c.prototype.lastIndexOf = function (e, t, r) {
            return _(this, e, t, r, !1)
        }, c.prototype.write = function (e, t, r, n) {
            if (void 0 === t) n = "utf8", r = this.length, t = 0; else if (void 0 === r && "string" == typeof t) n = t, r = this.length, t = 0; else {
                if (!isFinite(t)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                t |= 0, isFinite(r) ? (r |= 0, void 0 === n && (n = "utf8")) : (n = r, r = void 0)
            }
            var i = this.length - t;
            if ((void 0 === r || r > i) && (r = i), e.length > 0 && (r < 0 || t < 0) || t > this.length) throw new RangeError("Attempt to write outside buffer bounds");
            n || (n = "utf8");
            for (var o = !1; ;) switch (n) {
                case"hex":
                    return g(this, e, t, r);
                case"utf8":
                case"utf-8":
                    return E(this, e, t, r);
                case"ascii":
                    return y(this, e, t, r);
                case"latin1":
                case"binary":
                    return S(this, e, t, r);
                case"base64":
                    return b(this, e, t, r);
                case"ucs2":
                case"ucs-2":
                case"utf16le":
                case"utf-16le":
                    return T(this, e, t, r);
                default:
                    if (o) throw new TypeError("Unknown encoding: " + n);
                    n = ("" + n).toLowerCase(), o = !0
            }
        }, c.prototype.toJSON = function () {
            return {type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0)}
        };
        var w = 4096;

        function C(e, t, r) {
            var n = "";
            r = Math.min(e.length, r);
            for (var i = t; i < r; ++i) n += String.fromCharCode(127 & e[i]);
            return n
        }

        function A(e, t, r) {
            var n = "";
            r = Math.min(e.length, r);
            for (var i = t; i < r; ++i) n += String.fromCharCode(e[i]);
            return n
        }

        function O(e, t, r) {
            var n = e.length;
            (!t || t < 0) && (t = 0), (!r || r < 0 || r > n) && (r = n);
            for (var i = "", o = t; o < r; ++o) i += V(e[o]);
            return i
        }

        function N(e, t, r) {
            for (var n = e.slice(t, r), i = "", o = 0; o < n.length; o += 2) i += String.fromCharCode(n[o] + 256 * n[o + 1]);
            return i
        }

        function P(e, t, r) {
            if (e % 1 != 0 || e < 0) throw new RangeError("offset is not uint");
            if (e + t > r) throw new RangeError("Trying to access beyond buffer length")
        }

        function D(e, t, r, n, i, o) {
            if (!c.isBuffer(e)) throw new TypeError('"buffer" argument must be a Buffer instance');
            if (t > i || t < o) throw new RangeError('"value" argument is out of bounds');
            if (r + n > e.length) throw new RangeError("Index out of range")
        }

        function k(e, t, r, n) {
            t < 0 && (t = 65535 + t + 1);
            for (var i = 0, o = Math.min(e.length - r, 2); i < o; ++i) e[r + i] = (t & 255 << 8 * (n ? i : 1 - i)) >>> 8 * (n ? i : 1 - i)
        }

        function L(e, t, r, n) {
            t < 0 && (t = 4294967295 + t + 1);
            for (var i = 0, o = Math.min(e.length - r, 4); i < o; ++i) e[r + i] = t >>> 8 * (n ? i : 3 - i) & 255
        }

        function x(e, t, r, n, i, o) {
            if (r + n > e.length) throw new RangeError("Index out of range");
            if (r < 0) throw new RangeError("Index out of range")
        }

        function M(e, t, r, n, o) {
            return o || x(e, 0, r, 4), i.write(e, t, r, n, 23, 4), r + 4
        }

        function U(e, t, r, n, o) {
            return o || x(e, 0, r, 8), i.write(e, t, r, n, 52, 8), r + 8
        }

        c.prototype.slice = function (e, t) {
            var r, n = this.length;
            if (e = ~~e, t = void 0 === t ? n : ~~t, e < 0 ? (e += n) < 0 && (e = 0) : e > n && (e = n), t < 0 ? (t += n) < 0 && (t = 0) : t > n && (t = n), t < e && (t = e), c.TYPED_ARRAY_SUPPORT) (r = this.subarray(e, t)).__proto__ = c.prototype; else {
                var i = t - e;
                r = new c(i, void 0);
                for (var o = 0; o < i; ++o) r[o] = this[o + e]
            }
            return r
        }, c.prototype.readUIntLE = function (e, t, r) {
            e |= 0, t |= 0, r || P(e, t, this.length);
            for (var n = this[e], i = 1, o = 0; ++o < t && (i *= 256);) n += this[e + o] * i;
            return n
        }, c.prototype.readUIntBE = function (e, t, r) {
            e |= 0, t |= 0, r || P(e, t, this.length);
            for (var n = this[e + --t], i = 1; t > 0 && (i *= 256);) n += this[e + --t] * i;
            return n
        }, c.prototype.readUInt8 = function (e, t) {
            return t || P(e, 1, this.length), this[e]
        }, c.prototype.readUInt16LE = function (e, t) {
            return t || P(e, 2, this.length), this[e] | this[e + 1] << 8
        }, c.prototype.readUInt16BE = function (e, t) {
            return t || P(e, 2, this.length), this[e] << 8 | this[e + 1]
        }, c.prototype.readUInt32LE = function (e, t) {
            return t || P(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + 16777216 * this[e + 3]
        }, c.prototype.readUInt32BE = function (e, t) {
            return t || P(e, 4, this.length), 16777216 * this[e] + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3])
        }, c.prototype.readIntLE = function (e, t, r) {
            e |= 0, t |= 0, r || P(e, t, this.length);
            for (var n = this[e], i = 1, o = 0; ++o < t && (i *= 256);) n += this[e + o] * i;
            return n >= (i *= 128) && (n -= Math.pow(2, 8 * t)), n
        }, c.prototype.readIntBE = function (e, t, r) {
            e |= 0, t |= 0, r || P(e, t, this.length);
            for (var n = t, i = 1, o = this[e + --n]; n > 0 && (i *= 256);) o += this[e + --n] * i;
            return o >= (i *= 128) && (o -= Math.pow(2, 8 * t)), o
        }, c.prototype.readInt8 = function (e, t) {
            return t || P(e, 1, this.length), 128 & this[e] ? -1 * (255 - this[e] + 1) : this[e]
        }, c.prototype.readInt16LE = function (e, t) {
            t || P(e, 2, this.length);
            var r = this[e] | this[e + 1] << 8;
            return 32768 & r ? 4294901760 | r : r
        }, c.prototype.readInt16BE = function (e, t) {
            t || P(e, 2, this.length);
            var r = this[e + 1] | this[e] << 8;
            return 32768 & r ? 4294901760 | r : r
        }, c.prototype.readInt32LE = function (e, t) {
            return t || P(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24
        }, c.prototype.readInt32BE = function (e, t) {
            return t || P(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]
        }, c.prototype.readFloatLE = function (e, t) {
            return t || P(e, 4, this.length), i.read(this, e, !0, 23, 4)
        }, c.prototype.readFloatBE = function (e, t) {
            return t || P(e, 4, this.length), i.read(this, e, !1, 23, 4)
        }, c.prototype.readDoubleLE = function (e, t) {
            return t || P(e, 8, this.length), i.read(this, e, !0, 52, 8)
        }, c.prototype.readDoubleBE = function (e, t) {
            return t || P(e, 8, this.length), i.read(this, e, !1, 52, 8)
        }, c.prototype.writeUIntLE = function (e, t, r, n) {
            (e = +e, t |= 0, r |= 0, n) || D(this, e, t, r, Math.pow(2, 8 * r) - 1, 0);
            var i = 1, o = 0;
            for (this[t] = 255 & e; ++o < r && (i *= 256);) this[t + o] = e / i & 255;
            return t + r
        }, c.prototype.writeUIntBE = function (e, t, r, n) {
            (e = +e, t |= 0, r |= 0, n) || D(this, e, t, r, Math.pow(2, 8 * r) - 1, 0);
            var i = r - 1, o = 1;
            for (this[t + i] = 255 & e; --i >= 0 && (o *= 256);) this[t + i] = e / o & 255;
            return t + r
        }, c.prototype.writeUInt8 = function (e, t, r) {
            return e = +e, t |= 0, r || D(this, e, t, 1, 255, 0), c.TYPED_ARRAY_SUPPORT || (e = Math.floor(e)), this[t] = 255 & e, t + 1
        }, c.prototype.writeUInt16LE = function (e, t, r) {
            return e = +e, t |= 0, r || D(this, e, t, 2, 65535, 0), c.TYPED_ARRAY_SUPPORT ? (this[t] = 255 & e, this[t + 1] = e >>> 8) : k(this, e, t, !0), t + 2
        }, c.prototype.writeUInt16BE = function (e, t, r) {
            return e = +e, t |= 0, r || D(this, e, t, 2, 65535, 0), c.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 8, this[t + 1] = 255 & e) : k(this, e, t, !1), t + 2
        }, c.prototype.writeUInt32LE = function (e, t, r) {
            return e = +e, t |= 0, r || D(this, e, t, 4, 4294967295, 0), c.TYPED_ARRAY_SUPPORT ? (this[t + 3] = e >>> 24, this[t + 2] = e >>> 16, this[t + 1] = e >>> 8, this[t] = 255 & e) : L(this, e, t, !0), t + 4
        }, c.prototype.writeUInt32BE = function (e, t, r) {
            return e = +e, t |= 0, r || D(this, e, t, 4, 4294967295, 0), c.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e) : L(this, e, t, !1), t + 4
        }, c.prototype.writeIntLE = function (e, t, r, n) {
            if (e = +e, t |= 0, !n) {
                var i = Math.pow(2, 8 * r - 1);
                D(this, e, t, r, i - 1, -i)
            }
            var o = 0, s = 1, a = 0;
            for (this[t] = 255 & e; ++o < r && (s *= 256);) e < 0 && 0 === a && 0 !== this[t + o - 1] && (a = 1), this[t + o] = (e / s >> 0) - a & 255;
            return t + r
        }, c.prototype.writeIntBE = function (e, t, r, n) {
            if (e = +e, t |= 0, !n) {
                var i = Math.pow(2, 8 * r - 1);
                D(this, e, t, r, i - 1, -i)
            }
            var o = r - 1, s = 1, a = 0;
            for (this[t + o] = 255 & e; --o >= 0 && (s *= 256);) e < 0 && 0 === a && 0 !== this[t + o + 1] && (a = 1), this[t + o] = (e / s >> 0) - a & 255;
            return t + r
        }, c.prototype.writeInt8 = function (e, t, r) {
            return e = +e, t |= 0, r || D(this, e, t, 1, 127, -128), c.TYPED_ARRAY_SUPPORT || (e = Math.floor(e)), e < 0 && (e = 255 + e + 1), this[t] = 255 & e, t + 1
        }, c.prototype.writeInt16LE = function (e, t, r) {
            return e = +e, t |= 0, r || D(this, e, t, 2, 32767, -32768), c.TYPED_ARRAY_SUPPORT ? (this[t] = 255 & e, this[t + 1] = e >>> 8) : k(this, e, t, !0), t + 2
        }, c.prototype.writeInt16BE = function (e, t, r) {
            return e = +e, t |= 0, r || D(this, e, t, 2, 32767, -32768), c.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 8, this[t + 1] = 255 & e) : k(this, e, t, !1), t + 2
        }, c.prototype.writeInt32LE = function (e, t, r) {
            return e = +e, t |= 0, r || D(this, e, t, 4, 2147483647, -2147483648), c.TYPED_ARRAY_SUPPORT ? (this[t] = 255 & e, this[t + 1] = e >>> 8, this[t + 2] = e >>> 16, this[t + 3] = e >>> 24) : L(this, e, t, !0), t + 4
        }, c.prototype.writeInt32BE = function (e, t, r) {
            return e = +e, t |= 0, r || D(this, e, t, 4, 2147483647, -2147483648), e < 0 && (e = 4294967295 + e + 1), c.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e) : L(this, e, t, !1), t + 4
        }, c.prototype.writeFloatLE = function (e, t, r) {
            return M(this, e, t, !0, r)
        }, c.prototype.writeFloatBE = function (e, t, r) {
            return M(this, e, t, !1, r)
        }, c.prototype.writeDoubleLE = function (e, t, r) {
            return U(this, e, t, !0, r)
        }, c.prototype.writeDoubleBE = function (e, t, r) {
            return U(this, e, t, !1, r)
        }, c.prototype.copy = function (e, t, r, n) {
            if (r || (r = 0), n || 0 === n || (n = this.length), t >= e.length && (t = e.length), t || (t = 0), n > 0 && n < r && (n = r), n === r) return 0;
            if (0 === e.length || 0 === this.length) return 0;
            if (t < 0) throw new RangeError("targetStart out of bounds");
            if (r < 0 || r >= this.length) throw new RangeError("sourceStart out of bounds");
            if (n < 0) throw new RangeError("sourceEnd out of bounds");
            n > this.length && (n = this.length), e.length - t < n - r && (n = e.length - t + r);
            var i, o = n - r;
            if (this === e && r < t && t < n) for (i = o - 1; i >= 0; --i) e[i + t] = this[i + r]; else if (o < 1e3 || !c.TYPED_ARRAY_SUPPORT) for (i = 0; i < o; ++i) e[i + t] = this[i + r]; else Uint8Array.prototype.set.call(e, this.subarray(r, r + o), t);
            return o
        }, c.prototype.fill = function (e, t, r, n) {
            if ("string" == typeof e) {
                if ("string" == typeof t ? (n = t, t = 0, r = this.length) : "string" == typeof r && (n = r, r = this.length), 1 === e.length) {
                    var i = e.charCodeAt(0);
                    i < 256 && (e = i)
                }
                if (void 0 !== n && "string" != typeof n) throw new TypeError("encoding must be a string");
                if ("string" == typeof n && !c.isEncoding(n)) throw new TypeError("Unknown encoding: " + n)
            } else "number" == typeof e && (e &= 255);
            if (t < 0 || this.length < t || this.length < r) throw new RangeError("Out of range index");
            if (r <= t) return this;
            var o;
            if (t >>>= 0, r = void 0 === r ? this.length : r >>> 0, e || (e = 0), "number" == typeof e) for (o = t; o < r; ++o) this[o] = e; else {
                var s = c.isBuffer(e) ? e : F(new c(e, n).toString()), a = s.length;
                for (o = 0; o < r - t; ++o) this[o + t] = s[o % a]
            }
            return this
        };
        var j = /[^+\/0-9A-Za-z-_]/g;

        function V(e) {
            return e < 16 ? "0" + e.toString(16) : e.toString(16)
        }

        function F(e, t) {
            var r;
            t = t || 1 / 0;
            for (var n = e.length, i = null, o = [], s = 0; s < n; ++s) {
                if ((r = e.charCodeAt(s)) > 55295 && r < 57344) {
                    if (!i) {
                        if (r > 56319) {
                            (t -= 3) > -1 && o.push(239, 191, 189);
                            continue
                        }
                        if (s + 1 === n) {
                            (t -= 3) > -1 && o.push(239, 191, 189);
                            continue
                        }
                        i = r;
                        continue
                    }
                    if (r < 56320) {
                        (t -= 3) > -1 && o.push(239, 191, 189), i = r;
                        continue
                    }
                    r = 65536 + (i - 55296 << 10 | r - 56320)
                } else i && (t -= 3) > -1 && o.push(239, 191, 189);
                if (i = null, r < 128) {
                    if ((t -= 1) < 0) break;
                    o.push(r)
                } else if (r < 2048) {
                    if ((t -= 2) < 0) break;
                    o.push(r >> 6 | 192, 63 & r | 128)
                } else if (r < 65536) {
                    if ((t -= 3) < 0) break;
                    o.push(r >> 12 | 224, r >> 6 & 63 | 128, 63 & r | 128)
                } else {
                    if (!(r < 1114112)) throw new Error("Invalid code point");
                    if ((t -= 4) < 0) break;
                    o.push(r >> 18 | 240, r >> 12 & 63 | 128, r >> 6 & 63 | 128, 63 & r | 128)
                }
            }
            return o
        }

        function B(e) {
            return n.toByteArray(function (e) {
                if ((e = function (e) {
                    return e.trim ? e.trim() : e.replace(/^\s+|\s+$/g, "")
                }(e).replace(j, "")).length < 2) return "";
                for (; e.length % 4 != 0;) e += "=";
                return e
            }(e))
        }

        function W(e, t, r, n) {
            for (var i = 0; i < n && !(i + r >= t.length || i >= e.length); ++i) t[i + r] = e[i];
            return i
        }
    }).call(this, r(25))
}, function (e, t, r) {
    "use strict";
    r.d(t, "a", function () {
        return d
    });
    var n = r(3), i = r.n(n), o = r(6), s = r.n(o), a = r(8), c = r.n(a);

    function u(e, t) {
        var r = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
            var n = Object.getOwnPropertySymbols(e);
            t && (n = n.filter(function (t) {
                return Object.getOwnPropertyDescriptor(e, t).enumerable
            })), r.push.apply(r, n)
        }
        return r
    }

    var d = function () {
        function e(t) {
            s()(this, e), this._client = t
        }

        return c()(e, [{
            key: "__getCountFilter", value: function (e) {
                return e = function (e) {
                    for (var t = 1; t < arguments.length; t++) {
                        var r = null != arguments[t] ? arguments[t] : {};
                        t % 2 ? u(Object(r), !0).forEach(function (t) {
                            i()(e, t, r[t])
                        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : u(Object(r)).forEach(function (t) {
                            Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t))
                        })
                    }
                    return e
                }({}, e = e || this._filter), Object.prototype.hasOwnProperty.call(e, "include") && delete e.include, Object.prototype.hasOwnProperty.call(e, "sort") && delete e.sort, Object.prototype.hasOwnProperty.call(e, "skip") && delete e.skip, Object.prototype.hasOwnProperty.call(e, "limit") && delete e.limit, e
            }
        }]), e
    }()
}, function (e, t, r) {
    "use strict";
    r.d(t, "a", function () {
        return n
    });
    var n = {
        sprintf: function (e) {
            for (var t = 1; t < arguments.length; t += 1) e = e ? e.replace(/%s/, arguments[t]) : "";
            return e
        }, setMilliSeconds: function (e, t) {
            return "".concat(e.split(".")[0], ".").concat(t, "Z")
        }
    }
}, function (e, t) {
    var r;
    r = function () {
        return this
    }();
    try {
        r = r || new Function("return this")()
    } catch (e) {
        "object" == typeof window && (r = window)
    }
    e.exports = r
}, function (e, t) {
    "function" == typeof Object.create ? e.exports = function (e, t) {
        t && (e.super_ = t, e.prototype = Object.create(t.prototype, {
            constructor: {
                value: e,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        }))
    } : e.exports = function (e, t) {
        if (t) {
            e.super_ = t;
            var r = function () {
            };
            r.prototype = t.prototype, e.prototype = new r, e.prototype.constructor = e
        }
    }
}, function (e, t, r) {
    var n = r(22), i = n.Buffer;

    function o(e, t) {
        for (var r in e) t[r] = e[r]
    }

    function s(e, t, r) {
        return i(e, t, r)
    }

    i.from && i.alloc && i.allocUnsafe && i.allocUnsafeSlow ? e.exports = n : (o(n, t), t.Buffer = s), o(i, s), s.from = function (e, t, r) {
        if ("number" == typeof e) throw new TypeError("Argument must not be a number");
        return i(e, t, r)
    }, s.alloc = function (e, t, r) {
        if ("number" != typeof e) throw new TypeError("Argument must be a number");
        var n = i(e);
        return void 0 !== t ? "string" == typeof r ? n.fill(t, r) : n.fill(t) : n.fill(0), n
    }, s.allocUnsafe = function (e) {
        if ("number" != typeof e) throw new TypeError("Argument must be a number");
        return i(e)
    }, s.allocUnsafeSlow = function (e) {
        if ("number" != typeof e) throw new TypeError("Argument must be a number");
        return n.SlowBuffer(e)
    }
}, function (e, t, r) {
    "use strict";
    var n = r(43), i = r(141), o = r(91), s = r(142), a = r(143);
    (e.exports = function (e, t) {
        var r, i, c, u, d;
        return arguments.length < 2 || "string" != typeof e ? (u = t, t = e, e = null) : u = arguments[2], n(e) ? (r = a.call(e, "c"), i = a.call(e, "e"), c = a.call(e, "w")) : (r = c = !0, i = !1), d = {
            value: t,
            configurable: r,
            enumerable: i,
            writable: c
        }, u ? o(s(u), d) : d
    }).gs = function (e, t, r) {
        var c, u, d, l;
        return "string" != typeof e ? (d = r, r = t, t = e, e = null) : d = arguments[3], n(t) ? i(t) ? n(r) ? i(r) || (d = r, r = void 0) : r = void 0 : (d = t, t = r = void 0) : t = void 0, n(e) ? (c = a.call(e, "c"), u = a.call(e, "e")) : (c = !0, u = !1), l = {
            get: t,
            set: r,
            configurable: c,
            enumerable: u
        }, d ? o(s(d), l) : l
    }
}, function (e, t, r) {
    "use strict";
    var n, i = "object" == typeof Reflect ? Reflect : null,
        o = i && "function" == typeof i.apply ? i.apply : function (e, t, r) {
            return Function.prototype.apply.call(e, t, r)
        };
    n = i && "function" == typeof i.ownKeys ? i.ownKeys : Object.getOwnPropertySymbols ? function (e) {
        return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))
    } : function (e) {
        return Object.getOwnPropertyNames(e)
    };
    var s = Number.isNaN || function (e) {
        return e != e
    };

    function a() {
        a.init.call(this)
    }

    e.exports = a, e.exports.once = function (e, t) {
        return new Promise(function (r, n) {
            function i() {
                void 0 !== o && e.removeListener("error", o), r([].slice.call(arguments))
            }

            var o;
            "error" !== t && (o = function (r) {
                e.removeListener(t, i), n(r)
            }, e.once("error", o)), e.once(t, i)
        })
    }, a.EventEmitter = a, a.prototype._events = void 0, a.prototype._eventsCount = 0, a.prototype._maxListeners = void 0;
    var c = 10;

    function u(e) {
        if ("function" != typeof e) throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e)
    }

    function d(e) {
        return void 0 === e._maxListeners ? a.defaultMaxListeners : e._maxListeners
    }

    function l(e, t, r, n) {
        var i, o, s;
        if (u(r), void 0 === (o = e._events) ? (o = e._events = Object.create(null), e._eventsCount = 0) : (void 0 !== o.newListener && (e.emit("newListener", t, r.listener ? r.listener : r), o = e._events), s = o[t]), void 0 === s) s = o[t] = r, ++e._eventsCount; else if ("function" == typeof s ? s = o[t] = n ? [r, s] : [s, r] : n ? s.unshift(r) : s.push(r), (i = d(e)) > 0 && s.length > i && !s.warned) {
            s.warned = !0;
            var a = new Error("Possible EventEmitter memory leak detected. " + s.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
            a.name = "MaxListenersExceededWarning", a.emitter = e, a.type = t, a.count = s.length, function (e) {
                console && console.warn && console.warn(e)
            }(a)
        }
        return e
    }

    function h(e, t, r) {
        var n = {fired: !1, wrapFn: void 0, target: e, type: t, listener: r}, i = function () {
            if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments)
        }.bind(n);
        return i.listener = r, n.wrapFn = i, i
    }

    function p(e, t, r) {
        var n = e._events;
        if (void 0 === n) return [];
        var i = n[t];
        return void 0 === i ? [] : "function" == typeof i ? r ? [i.listener || i] : [i] : r ? function (e) {
            for (var t = new Array(e.length), r = 0; r < t.length; ++r) t[r] = e[r].listener || e[r];
            return t
        }(i) : m(i, i.length)
    }

    function f(e) {
        var t = this._events;
        if (void 0 !== t) {
            var r = t[e];
            if ("function" == typeof r) return 1;
            if (void 0 !== r) return r.length
        }
        return 0
    }

    function m(e, t) {
        for (var r = new Array(t), n = 0; n < t; ++n) r[n] = e[n];
        return r
    }

    Object.defineProperty(a, "defaultMaxListeners", {
        enumerable: !0, get: function () {
            return c
        }, set: function (e) {
            if ("number" != typeof e || e < 0 || s(e)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e + ".");
            c = e
        }
    }), a.init = function () {
        void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0
    }, a.prototype.setMaxListeners = function (e) {
        if ("number" != typeof e || e < 0 || s(e)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
        return this._maxListeners = e, this
    }, a.prototype.getMaxListeners = function () {
        return d(this)
    }, a.prototype.emit = function (e) {
        for (var t = [], r = 1; r < arguments.length; r++) t.push(arguments[r]);
        var n = "error" === e, i = this._events;
        if (void 0 !== i) n = n && void 0 === i.error; else if (!n) return !1;
        if (n) {
            var s;
            if (t.length > 0 && (s = t[0]), s instanceof Error) throw s;
            var a = new Error("Unhandled error." + (s ? " (" + s.message + ")" : ""));
            throw a.context = s, a
        }
        var c = i[e];
        if (void 0 === c) return !1;
        if ("function" == typeof c) o(c, this, t); else {
            var u = c.length, d = m(c, u);
            for (r = 0; r < u; ++r) o(d[r], this, t)
        }
        return !0
    }, a.prototype.addListener = function (e, t) {
        return l(this, e, t, !1)
    }, a.prototype.on = a.prototype.addListener, a.prototype.prependListener = function (e, t) {
        return l(this, e, t, !0)
    }, a.prototype.once = function (e, t) {
        return u(t), this.on(e, h(this, e, t)), this
    }, a.prototype.prependOnceListener = function (e, t) {
        return u(t), this.prependListener(e, h(this, e, t)), this
    }, a.prototype.removeListener = function (e, t) {
        var r, n, i, o, s;
        if (u(t), void 0 === (n = this._events)) return this;
        if (void 0 === (r = n[e])) return this;
        if (r === t || r.listener === t) 0 == --this._eventsCount ? this._events = Object.create(null) : (delete n[e], n.removeListener && this.emit("removeListener", e, r.listener || t)); else if ("function" != typeof r) {
            for (i = -1, o = r.length - 1; o >= 0; o--) if (r[o] === t || r[o].listener === t) {
                s = r[o].listener, i = o;
                break
            }
            if (i < 0) return this;
            0 === i ? r.shift() : function (e, t) {
                for (; t + 1 < e.length; t++) e[t] = e[t + 1];
                e.pop()
            }(r, i), 1 === r.length && (n[e] = r[0]), void 0 !== n.removeListener && this.emit("removeListener", e, s || t)
        }
        return this
    }, a.prototype.off = a.prototype.removeListener, a.prototype.removeAllListeners = function (e) {
        var t, r, n;
        if (void 0 === (r = this._events)) return this;
        if (void 0 === r.removeListener) return 0 === arguments.length ? (this._events = Object.create(null), this._eventsCount = 0) : void 0 !== r[e] && (0 == --this._eventsCount ? this._events = Object.create(null) : delete r[e]), this;
        if (0 === arguments.length) {
            var i, o = Object.keys(r);
            for (n = 0; n < o.length; ++n) "removeListener" !== (i = o[n]) && this.removeAllListeners(i);
            return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this
        }
        if ("function" == typeof (t = r[e])) this.removeListener(e, t); else if (void 0 !== t) for (n = t.length - 1; n >= 0; n--) this.removeListener(e, t[n]);
        return this
    }, a.prototype.listeners = function (e) {
        return p(this, e, !0)
    }, a.prototype.rawListeners = function (e) {
        return p(this, e, !1)
    }, a.listenerCount = function (e, t) {
        return "function" == typeof e.listenerCount ? e.listenerCount(t) : f.call(e, t)
    }, a.prototype.listenerCount = f, a.prototype.eventNames = function () {
        return this._eventsCount > 0 ? n(this._events) : []
    }
}, function (e, t, r) {
    "use strict";
    var n = r(42);
    e.exports = function (e) {
        if (!n(e)) throw new TypeError("Cannot use null or undefined");
        return e
    }
}, function (e, t, r) {
    "use strict";
    e.exports = r(312)() ? r(58).Symbol : r(315)
}, function (e, t, r) {
    "use strict";
    for (var n = r(33), i = [], o = 0; o < 256; ++o) i.push((o + 256).toString(16).substr(1));
    t.a = function (e) {
        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
            r = (i[e[t + 0]] + i[e[t + 1]] + i[e[t + 2]] + i[e[t + 3]] + "-" + i[e[t + 4]] + i[e[t + 5]] + "-" + i[e[t + 6]] + i[e[t + 7]] + "-" + i[e[t + 8]] + i[e[t + 9]] + "-" + i[e[t + 10]] + i[e[t + 11]] + i[e[t + 12]] + i[e[t + 13]] + i[e[t + 14]] + i[e[t + 15]]).toLowerCase();
        if (!Object(n.a)(r)) throw TypeError("Stringified UUID is invalid");
        return r
    }
}, function (e, t, r) {
    "use strict";
    var n = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
    t.a = function (e) {
        return "string" == typeof e && n.test(e)
    }
}, function (e, t, r) {
    "use strict";
    r.d(t, "a", function () {
        return a
    });
    var n = r(6), i = r.n(n), o = r(8), s = r.n(o), a = function () {
        function e(t, r) {
            var n = this;
            i()(this, e), this._client = t;
            var o = {}, s = this.constructor.__properties || {};
            Object.keys(s).forEach(function (e) {
                o[e] = Object.prototype.hasOwnProperty.call(r, e) ? r[e] : s[e]
            }), Object.keys(s).forEach(function (e) {
                Object.defineProperty(n, e, {
                    get: function () {
                        return o[e]
                    }, set: function (t) {
                        o[e] = t
                    }
                })
            })
        }

        return s()(e, [{
            key: "toJSON", value: function () {
                var e = this, t = this.constructor.__properties || {}, r = {};
                return Object.keys(t).forEach(function (t) {
                    r[t] = e[t]
                }), r
            }
        }]), e
    }()
}, function (e, t, r) {
    "use strict";
    r.d(t, "a", function () {
        return T
    });
    var n = r(6), i = r.n(n), o = r(8), s = r.n(o), a = r(10), c = r.n(a), u = r(11), d = r.n(u), l = r(7), h = r.n(l),
        p = r(3), f = r.n(p), m = r(16), _ = r(2), v = r(0), g = r(4), E = r(1);

    function y(e) {
        var t = function () {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function () {
                })), !0
            } catch (e) {
                return !1
            }
        }();
        return function () {
            var r, n = h()(e);
            if (t) {
                var i = h()(this).constructor;
                r = Reflect.construct(n, arguments, i)
            } else r = n.apply(this, arguments);
            return d()(this, r)
        }
    }

    var S = _.a.LOG_LEVELS, b = (S.INFO, S.WARN, S.ERROR), T = function (e) {
        c()(r, e);
        var t = y(r);

        function r() {
            return i()(this, r), t.apply(this, arguments)
        }

        return s()(r, null, [{
            key: "get", value: function (e, t) {
                return Object(g.a)(t, function (t) {
                    if (!r.Client || !r.Client.getInstance()) return t(v.errors.NOT_INITIALIZED);
                    var n = r.Client.getInstance();
                    if ("string" != typeof e) return E.a.log(b, v.errors.INVALID_ID, {}), t(v.errors.INVALID_ID);
                    n.request("".concat(r.basePath, "/").concat(e), {method: "get"}).then(function (e) {
                        var r = e.data, n = {};
                        return r.settings = r.settings || [], r.settings.forEach(function (e) {
                            n[e.key] = e.value
                        }), r.settings = n, t(null, r)
                    }).catch(function (e) {
                        return E.a.log(b, v.errors.API_ERROR, {err: n.error(e)}), t(n.error(e))
                    })
                })
            }
        }]), r
    }(m.a);
    f()(T, "basePath", _.a.BASEPATH_MODULES)
}, function (e, t, r) {
    "use strict";
    var n = r(52), i = Object.keys || function (e) {
        var t = [];
        for (var r in e) t.push(r);
        return t
    };
    e.exports = l;
    var o = Object.create(r(53));
    o.inherits = r(26);
    var s = r(131), a = r(134);
    o.inherits(l, s);
    for (var c = i(a.prototype), u = 0; u < c.length; u++) {
        var d = c[u];
        l.prototype[d] || (l.prototype[d] = a.prototype[d])
    }

    function l(e) {
        if (!(this instanceof l)) return new l(e);
        s.call(this, e), a.call(this, e), e && !1 === e.readable && (this.readable = !1), e && !1 === e.writable && (this.writable = !1), this.allowHalfOpen = !0, e && !1 === e.allowHalfOpen && (this.allowHalfOpen = !1), this.once("end", h)
    }

    function h() {
        this.allowHalfOpen || this._writableState.ended || n.nextTick(p, this)
    }

    function p(e) {
        e.end()
    }

    Object.defineProperty(l.prototype, "writableHighWaterMark", {
        enumerable: !1, get: function () {
            return this._writableState.highWaterMark
        }
    }), Object.defineProperty(l.prototype, "destroyed", {
        get: function () {
            return void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed && this._writableState.destroyed)
        }, set: function (e) {
            void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed = e, this._writableState.destroyed = e)
        }
    }), l.prototype._destroy = function (e, t) {
        this.push(null), this.end(), n.nextTick(t, e)
    }
}, function (e, t, r) {
    "use strict";
    e.exports = function (e) {
        if ("function" != typeof e) throw new TypeError(e + " is not a function");
        return e
    }
}, function (e, t, r) {
    "use strict";
    r.d(t, "a", function () {
        return d
    });
    var n = r(6), i = r.n(n), o = r(8), s = r.n(o), a = r(3), c = r.n(a), u = r(180), d = function () {
        function e() {
            i()(this, e), e.ajv.addKeyword("isNotEmpty", {
                type: "string", validate: function (e, t) {
                    return "string" == typeof t && "" !== t.trim()
                }, errors: !1
            })
        }

        return s()(e, null, [{
            key: "validate", value: function (t, r) {
                return !e.ajv.validate(r, t) && e.ajv.errorsText(e.ajv.errors)
            }
        }]), e
    }();
    c()(d, "ajv", new u({useDefaults: !0, removeAdditional: !0}))
}, function (e, t) {
    var r = {oneOf: [{type: "string", format: "url"}, {type: "null"}]},
        n = {type: "object", properties: {enableConversation: {type: "boolean"}}}, i = {
            type: "object",
            additionalProperties: !1,
            properties: {
                allow_watch: {type: "string", enum: ["anonymous", "guest", "user"]},
                allow_chat: {type: "string", enum: ["guest", "user"]}
            }
        }, o = {type: "object", properties: {type: {type: "string", isNotEmpty: !0}}, required: ["type"]};
    e.exports = {
        createSchema: function () {
            return {
                type: "object",
                additionalProperties: !1,
                properties: {
                    id: {type: "string", isNotEmpty: !0},
                    title: {type: "string", isNotEmpty: !0},
                    description: {type: "string"},
                    startTime: {type: "string", format: "date-time"},
                    endTime: {type: "string", format: "date-time"},
                    bannerImageUrl: r,
                    bannerVideoUrl: r,
                    published: {type: "boolean", default: !0},
                    recording: {type: "boolean", default: !0},
                    hosts: {type: "array", items: {type: "object"}, default: []},
                    products: {type: "array", items: {type: "object"}, default: []},
                    metaData: {type: "object", default: {}},
                    events: n,
                    config: i
                },
                required: ["title", "startTime", "endTime"]
            }
        }, updateSchema: function () {
            return {
                type: "object",
                additionalProperties: !1,
                properties: {
                    title: {type: "string", isNotEmpty: !0},
                    description: {type: "string"},
                    startTime: {type: "string", format: "date-time"},
                    endTime: {type: "string", format: "date-time"},
                    bannerImageUrl: r,
                    bannerVideoUrl: r,
                    published: {type: "boolean"},
                    recording: {type: "boolean"},
                    products: {type: "array", items: {type: "object"}},
                    config: i
                }
            }
        }, streamConfigSchema: function () {
            return {
                type: "object",
                additionalProperties: !1,
                properties: {
                    width: {type: "number"},
                    height: {type: "number"},
                    fps: {type: "number"},
                    bitrate: {type: "number"}
                },
                required: ["width", "height", "fps", "bitrate"]
            }
        }, banUsersSchema: function () {
            return {
                type: "object",
                properties: {
                    userIds: {type: "array", items: {type: "string", isNotEmpty: !0}, minItems: 1},
                    expires: {type: "number"},
                    reason: {type: "string", isNotEmpty: !0, maxLength: 80}
                }
            }
        }, sendMessageSchema: function () {
            return {
                type: "object",
                properties: {
                    body: {type: "string", isNotEmpty: !0},
                    attachments: {type: "array", items: o, maxItems: 10},
                    customType: {type: "string", isNotEmpty: !0},
                    parentId: {type: "string"},
                    showInConversation: {type: "boolean"},
                    metaData: {type: "object", maxProperties: 5}
                },
                anyOf: [{required: ["body"]}, {required: ["attachments"]}]
            }
        }
    }
}, function (e, t, r) {
    (function (t, r, n) {
        e.exports = function () {
            "use strict";
            var e = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : void 0 !== t ? t : "undefined" != typeof self ? self : {},
                i = function (e) {
                    try {
                        return !!e()
                    } catch (e) {
                        return !0
                    }
                }, o = !i(function () {
                    var e = function () {
                    }.bind();
                    return "function" != typeof e || e.hasOwnProperty("prototype")
                }), s = o, a = Function.prototype, c = a.bind, u = a.call, d = s && c.bind(u, u), l = s ? function (e) {
                    return e && d(e)
                } : function (e) {
                    return e && function () {
                        return u.apply(e, arguments)
                    }
                }, h = l({}.isPrototypeOf), p = function (e) {
                    return e && e.Math == Math && e
                },
                f = p("object" == typeof globalThis && globalThis) || p("object" == typeof window && window) || p("object" == typeof self && self) || p("object" == typeof e && e) || function () {
                    return this
                }() || Function("return this")(), m = o, _ = Function.prototype, v = _.apply, g = _.call,
                E = "object" == typeof Reflect && Reflect.apply || (m ? g.bind(v) : function () {
                    return g.apply(v, arguments)
                }), y = function (e) {
                    return "function" == typeof e
                }, S = {}, b = !i(function () {
                    return 7 != Object.defineProperty({}, 1, {
                        get: function () {
                            return 7
                        }
                    })[1]
                }), T = o, R = Function.prototype.call, I = T ? R.bind(R) : function () {
                    return R.apply(R, arguments)
                }, w = {}, C = {}.propertyIsEnumerable, A = Object.getOwnPropertyDescriptor, O = A && !C.call({1: 2}, 1);
            w.f = O ? function (e) {
                var t = A(this, e);
                return !!t && t.enumerable
            } : C;
            var N, P, D = function (e, t) {
                    return {enumerable: !(1 & e), configurable: !(2 & e), writable: !(4 & e), value: t}
                }, k = l, L = k({}.toString), x = k("".slice), M = function (e) {
                    return x(L(e), 8, -1)
                }, U = l, j = i, V = M, F = f.Object, B = U("".split), W = j(function () {
                    return !F("z").propertyIsEnumerable(0)
                }) ? function (e) {
                    return "String" == V(e) ? B(e, "") : F(e)
                } : F, G = f.TypeError, q = function (e) {
                    if (null == e) throw G("Can't call method on " + e);
                    return e
                }, H = W, K = q, z = function (e) {
                    return H(K(e))
                }, Y = y, J = function (e) {
                    return "object" == typeof e ? null !== e : Y(e)
                }, X = {}, Q = X, $ = f, Z = y, ee = function (e) {
                    return Z(e) ? e : void 0
                }, te = function (e, t) {
                    return arguments.length < 2 ? ee(Q[e]) || ee($[e]) : Q[e] && Q[e][t] || $[e] && $[e][t]
                }, re = te("navigator", "userAgent") || "", ne = f, ie = re, oe = ne.process, se = ne.Deno,
                ae = oe && oe.versions || se && se.version, ce = ae && ae.v8;
            ce && (P = (N = ce.split("."))[0] > 0 && N[0] < 4 ? 1 : +(N[0] + N[1])), !P && ie && (!(N = ie.match(/Edge\/(\d+)/)) || N[1] >= 74) && (N = ie.match(/Chrome\/(\d+)/)) && (P = +N[1]);
            var ue = P, de = ue, le = i, he = !!Object.getOwnPropertySymbols && !le(function () {
                    var e = Symbol();
                    return !String(e) || !(Object(e) instanceof Symbol) || !Symbol.sham && de && de < 41
                }), pe = he && !Symbol.sham && "symbol" == typeof Symbol.iterator, fe = te, me = y, _e = h, ve = pe,
                ge = f.Object, Ee = ve ? function (e) {
                    return "symbol" == typeof e
                } : function (e) {
                    var t = fe("Symbol");
                    return me(t) && _e(t.prototype, ge(e))
                }, ye = f.String, Se = function (e) {
                    try {
                        return ye(e)
                    } catch (e) {
                        return "Object"
                    }
                }, be = y, Te = Se, Re = f.TypeError, Ie = function (e) {
                    if (be(e)) return e;
                    throw Re(Te(e) + " is not a function")
                }, we = Ie, Ce = function (e, t) {
                    var r = e[t];
                    return null == r ? void 0 : we(r)
                }, Ae = I, Oe = y, Ne = J, Pe = f.TypeError, De = {exports: {}}, ke = f, Le = Object.defineProperty,
                xe = "__core-js_shared__", Me = f[xe] || function (e, t) {
                    try {
                        Le(ke, e, {value: t, configurable: !0, writable: !0})
                    } catch (r) {
                        ke[e] = t
                    }
                    return t
                }(xe, {}), Ue = Me;
            (De.exports = function (e, t) {
                return Ue[e] || (Ue[e] = void 0 !== t ? t : {})
            })("versions", []).push({
                version: "3.20.3",
                mode: "pure",
                copyright: " 2014-2022 Denis Pushkarev (zloirock.ru)",
                license: "https://github.com/zloirock/core-js/blob/v3.20.3/LICENSE",
                source: "https://github.com/zloirock/core-js"
            });
            var je = q, Ve = f.Object, Fe = function (e) {
                    return Ve(je(e))
                }, Be = Fe, We = l({}.hasOwnProperty), Ge = Object.hasOwn || function (e, t) {
                    return We(Be(e), t)
                }, qe = l, He = 0, Ke = Math.random(), ze = qe(1..toString), Ye = function (e) {
                    return "Symbol(" + (void 0 === e ? "" : e) + ")_" + ze(++He + Ke, 36)
                }, Je = f, Xe = De.exports, Qe = Ge, $e = Ye, Ze = he, et = pe, tt = Xe("wks"), rt = Je.Symbol,
                nt = rt && rt.for, it = et ? rt : rt && rt.withoutSetter || $e, ot = function (e) {
                    if (!Qe(tt, e) || !Ze && "string" != typeof tt[e]) {
                        var t = "Symbol." + e;
                        Ze && Qe(rt, e) ? tt[e] = rt[e] : tt[e] = et && nt ? nt(t) : it(t)
                    }
                    return tt[e]
                }, st = I, at = J, ct = Ee, ut = Ce, dt = ot, lt = f.TypeError, ht = dt("toPrimitive"),
                pt = function (e, t) {
                    if (!at(e) || ct(e)) return e;
                    var r, n = ut(e, ht);
                    if (n) {
                        if (void 0 === t && (t = "default"), r = st(n, e, t), !at(r) || ct(r)) return r;
                        throw lt("Can't convert object to primitive value")
                    }
                    return void 0 === t && (t = "number"), function (e, t) {
                        var r, n;
                        if ("string" === t && Oe(r = e.toString) && !Ne(n = Ae(r, e))) return n;
                        if (Oe(r = e.valueOf) && !Ne(n = Ae(r, e))) return n;
                        if ("string" !== t && Oe(r = e.toString) && !Ne(n = Ae(r, e))) return n;
                        throw Pe("Can't convert object to primitive value")
                    }(e, t)
                }, ft = Ee, mt = function (e) {
                    var t = pt(e, "string");
                    return ft(t) ? t : t + ""
                }, _t = J, vt = f.document, gt = _t(vt) && _t(vt.createElement), Et = function (e) {
                    return gt ? vt.createElement(e) : {}
                }, yt = Et, St = !b && !i(function () {
                    return 7 != Object.defineProperty(yt("div"), "a", {
                        get: function () {
                            return 7
                        }
                    }).a
                }), bt = b, Tt = I, Rt = w, It = D, wt = z, Ct = mt, At = Ge, Ot = St, Nt = Object.getOwnPropertyDescriptor;
            S.f = bt ? Nt : function (e, t) {
                if (e = wt(e), t = Ct(t), Ot) try {
                    return Nt(e, t)
                } catch (e) {
                }
                if (At(e, t)) return It(!Tt(Rt.f, e, t), e[t])
            };
            var Pt = i, Dt = y, kt = /#|\.prototype\./, Lt = function (e, t) {
                    var r = Mt[xt(e)];
                    return r == jt || r != Ut && (Dt(t) ? Pt(t) : !!t)
                }, xt = Lt.normalize = function (e) {
                    return String(e).replace(kt, ".").toLowerCase()
                }, Mt = Lt.data = {}, Ut = Lt.NATIVE = "N", jt = Lt.POLYFILL = "P", Vt = Lt, Ft = Ie, Bt = o,
                Wt = l(l.bind), Gt = function (e, t) {
                    return Ft(e), void 0 === t ? e : Bt ? Wt(e, t) : function () {
                        return e.apply(t, arguments)
                    }
                }, qt = {}, Ht = b && i(function () {
                    return 42 != Object.defineProperty(function () {
                    }, "prototype", {value: 42, writable: !1}).prototype
                }), Kt = f, zt = J, Yt = Kt.String, Jt = Kt.TypeError, Xt = function (e) {
                    if (zt(e)) return e;
                    throw Jt(Yt(e) + " is not an object")
                }, Qt = b, $t = St, Zt = Ht, er = Xt, tr = mt, rr = f.TypeError, nr = Object.defineProperty,
                ir = Object.getOwnPropertyDescriptor;
            qt.f = Qt ? Zt ? function (e, t, r) {
                if (er(e), t = tr(t), er(r), "function" == typeof e && "prototype" === t && "value" in r && "writable" in r && !r.writable) {
                    var n = ir(e, t);
                    n && n.writable && (e[t] = r.value, r = {
                        configurable: "configurable" in r ? r.configurable : n.configurable,
                        enumerable: "enumerable" in r ? r.enumerable : n.enumerable,
                        writable: !1
                    })
                }
                return nr(e, t, r)
            } : nr : function (e, t, r) {
                if (er(e), t = tr(t), er(r), $t) try {
                    return nr(e, t, r)
                } catch (e) {
                }
                if ("get" in r || "set" in r) throw rr("Accessors not supported");
                return "value" in r && (e[t] = r.value), e
            };
            var or = qt, sr = D, ar = b ? function (e, t, r) {
                return or.f(e, t, sr(1, r))
            } : function (e, t, r) {
                return e[t] = r, e
            }, cr = f, ur = E, dr = l, lr = y, hr = S.f, pr = Vt, fr = X, mr = Gt, _r = ar, vr = Ge, gr = function (e) {
                var t = function (r, n, i) {
                    if (this instanceof t) {
                        switch (arguments.length) {
                            case 0:
                                return new e;
                            case 1:
                                return new e(r);
                            case 2:
                                return new e(r, n)
                        }
                        return new e(r, n, i)
                    }
                    return ur(e, this, arguments)
                };
                return t.prototype = e.prototype, t
            }, Er = function (e, t) {
                var r, n, i, o, s, a, c, u, d = e.target, l = e.global, h = e.stat, p = e.proto,
                    f = l ? cr : h ? cr[d] : (cr[d] || {}).prototype, m = l ? fr : fr[d] || _r(fr, d, {})[d],
                    _ = m.prototype;
                for (i in t) r = !pr(l ? i : d + (h ? "." : "#") + i, e.forced) && f && vr(f, i), s = m[i], r && (a = e.noTargetGet ? (u = hr(f, i)) && u.value : f[i]), o = r && a ? a : t[i], r && typeof s == typeof o || (c = e.bind && r ? mr(o, cr) : e.wrap && r ? gr(o) : p && lr(o) ? dr(o) : o, (e.sham || o && o.sham || s && s.sham) && _r(c, "sham", !0), _r(m, i, c), p && (vr(fr, n = d + "Prototype") || _r(fr, n, {}), _r(fr[n], i, o), e.real && _ && !_[i] && _r(_, i, o)))
            }, yr = Math.ceil, Sr = Math.floor, br = function (e) {
                var t = +e;
                return t != t || 0 === t ? 0 : (t > 0 ? Sr : yr)(t)
            }, Tr = br, Rr = Math.min, Ir = function (e) {
                return function (e) {
                    return e > 0 ? Rr(Tr(e), 9007199254740991) : 0
                }(e.length)
            }, wr = Ie, Cr = Fe, Ar = W, Or = Ir, Nr = f.TypeError, Pr = function (e) {
                return function (t, r, n, i) {
                    wr(r);
                    var o = Cr(t), s = Ar(o), a = Or(o), c = e ? a - 1 : 0, u = e ? -1 : 1;
                    if (n < 2) for (; ;) {
                        if (c in s) {
                            i = s[c], c += u;
                            break
                        }
                        if (c += u, e ? c < 0 : a <= c) throw Nr("Reduce of empty array with no initial value")
                    }
                    for (; e ? c >= 0 : a > c; c += u) c in s && (i = r(i, s[c], c, o));
                    return i
                }
            }, Dr = {left: Pr(!1), right: Pr(!0)}, kr = i, Lr = function (e, t) {
                var r = [][e];
                return !!r && kr(function () {
                    r.call(null, t || function () {
                        throw 1
                    }, 1)
                })
            }, xr = "process" == M(f.process), Mr = Dr.left, Ur = ue, jr = xr;
            Er({target: "Array", proto: !0, forced: !Lr("reduce") || !jr && Ur > 79 && Ur < 83}, {
                reduce: function (e) {
                    var t = arguments.length;
                    return Mr(this, e, t, t > 1 ? arguments[1] : void 0)
                }
            });
            var Vr = X, Fr = function (e) {
                return Vr[e + "Prototype"]
            }, Br = Fr("Array").reduce, Wr = h, Gr = Br, qr = Array.prototype, Hr = function (e) {
                var t = e.reduce;
                return e === qr || Wr(qr, e) && t === qr.reduce ? Gr : t
            }, Kr = Hr;
            let zr = !0, Yr = !0;

            function Jr(e, t, r) {
                const n = e.match(t);
                return n && n.length >= r && parseInt(n[r], 10)
            }

            function Xr(e, t, r) {
                if (!e.RTCPeerConnection) return;
                const n = e.RTCPeerConnection.prototype, i = n.addEventListener;
                n.addEventListener = function (e, n) {
                    if (e !== t) return i.apply(this, arguments);
                    const o = e => {
                        const t = r(e);
                        t && (n.handleEvent ? n.handleEvent(t) : n(t))
                    };
                    return this._eventMap = this._eventMap || {}, this._eventMap[t] || (this._eventMap[t] = new Map), this._eventMap[t].set(n, o), i.apply(this, [e, o])
                };
                const o = n.removeEventListener;
                n.removeEventListener = function (e, r) {
                    if (e !== t || !this._eventMap || !this._eventMap[t]) return o.apply(this, arguments);
                    if (!this._eventMap[t].has(r)) return o.apply(this, arguments);
                    const n = this._eventMap[t].get(r);
                    return this._eventMap[t].delete(r), 0 === this._eventMap[t].size && delete this._eventMap[t], 0 === Object.keys(this._eventMap).length && delete this._eventMap, o.apply(this, [e, n])
                }, Object.defineProperty(n, "on" + t, {
                    get() {
                        return this["_on" + t]
                    }, set(e) {
                        this["_on" + t] && (this.removeEventListener(t, this["_on" + t]), delete this["_on" + t]), e && this.addEventListener(t, this["_on" + t] = e)
                    }, enumerable: !0, configurable: !0
                })
            }

            function Qr(e) {
                return "boolean" != typeof e ? new Error("Argument type: " + typeof e + ". Please use a boolean.") : (zr = e, e ? "adapter.js logging disabled" : "adapter.js logging enabled")
            }

            function $r(e) {
                return "boolean" != typeof e ? new Error("Argument type: " + typeof e + ". Please use a boolean.") : (Yr = !e, "adapter.js deprecation warnings " + (e ? "disabled" : "enabled"))
            }

            function Zr() {
                if ("object" == typeof window) {
                    if (zr) return;
                    "undefined" != typeof console && "function" == typeof console.log && console.log.apply(console, arguments)
                }
            }

            function en(e, t) {
                Yr && console.warn(e + " is deprecated, please use " + t + " instead.")
            }

            function tn(e) {
                return "[object Object]" === Object.prototype.toString.call(e)
            }

            function rn(e, t, r) {
                const n = r ? "outbound-rtp" : "inbound-rtp", i = new Map;
                if (null === t) return i;
                const o = [];
                return e.forEach(e => {
                    "track" === e.type && e.trackIdentifier === t.id && o.push(e)
                }), o.forEach(t => {
                    e.forEach(r => {
                        r.type === n && r.trackId === t.id && function e(t, r, n) {
                            r && !n.has(r.id) && (n.set(r.id, r), Object.keys(r).forEach(i => {
                                i.endsWith("Id") ? e(t, t.get(r[i]), n) : i.endsWith("Ids") && r[i].forEach(r => {
                                    e(t, t.get(r), n)
                                })
                            }))
                        }(e, r, i)
                    })
                }), i
            }

            var nn = De.exports, on = Ye, sn = nn("keys"), an = function (e) {
                    return sn[e] || (sn[e] = on(e))
                }, cn = !i(function () {
                    function e() {
                    }

                    return e.prototype.constructor = null, Object.getPrototypeOf(new e) !== e.prototype
                }), un = f, dn = Ge, ln = y, hn = Fe, pn = cn, fn = an("IE_PROTO"), mn = un.Object, _n = mn.prototype,
                vn = pn ? mn.getPrototypeOf : function (e) {
                    var t = hn(e);
                    if (dn(t, fn)) return t[fn];
                    var r = t.constructor;
                    return ln(r) && t instanceof r ? r.prototype : t instanceof mn ? _n : null
                }, gn = f, En = y, yn = gn.String, Sn = gn.TypeError, bn = l, Tn = Xt,
                Rn = Object.setPrototypeOf || ("__proto__" in {} ? function () {
                    var e, t = !1, r = {};
                    try {
                        (e = bn(Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set))(r, []), t = r instanceof Array
                    } catch (e) {
                    }
                    return function (r, n) {
                        return Tn(r), function (e) {
                            if ("object" == typeof e || En(e)) return e;
                            throw Sn("Can't set " + yn(e) + " as a prototype")
                        }(n), t ? e(r, n) : r.__proto__ = n, r
                    }
                }() : void 0), In = {}, wn = br, Cn = Math.max, An = Math.min, On = function (e, t) {
                    var r = wn(e);
                    return r < 0 ? Cn(r + t, 0) : An(r, t)
                }, Nn = z, Pn = On, Dn = Ir, kn = function (e) {
                    return function (t, r, n) {
                        var i, o = Nn(t), s = Dn(o), a = Pn(n, s);
                        if (e && r != r) {
                            for (; s > a;) if ((i = o[a++]) != i) return !0
                        } else for (; s > a; a++) if ((e || a in o) && o[a] === r) return e || a || 0;
                        return !e && -1
                    }
                }, Ln = {includes: kn(!0), indexOf: kn(!1)}, xn = {}, Mn = Ge, Un = z, jn = Ln.indexOf, Vn = xn,
                Fn = l([].push), Bn = function (e, t) {
                    var r, n = Un(e), i = 0, o = [];
                    for (r in n) !Mn(Vn, r) && Mn(n, r) && Fn(o, r);
                    for (; t.length > i;) Mn(n, r = t[i++]) && (~jn(o, r) || Fn(o, r));
                    return o
                },
                Wn = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"],
                Gn = Bn, qn = Wn.concat("length", "prototype");
            In.f = Object.getOwnPropertyNames || function (e) {
                return Gn(e, qn)
            };
            var Hn = {};
            Hn.f = Object.getOwnPropertySymbols;
            var Kn = te, zn = In, Yn = Hn, Jn = Xt, Xn = l([].concat), Qn = Kn("Reflect", "ownKeys") || function (e) {
                var t = zn.f(Jn(e)), r = Yn.f;
                return r ? Xn(t, r(e)) : t
            }, $n = Ge, Zn = Qn, ei = S, ti = qt, ri = {}, ni = Bn, ii = Wn, oi = Object.keys || function (e) {
                return ni(e, ii)
            }, si = b, ai = Ht, ci = qt, ui = Xt, di = z, li = oi;
            ri.f = si && !ai ? Object.defineProperties : function (e, t) {
                ui(e);
                for (var r, n = di(t), i = li(t), o = i.length, s = 0; o > s;) ci.f(e, r = i[s++], n[r]);
                return e
            };
            var hi, pi = te("document", "documentElement"), fi = Xt, mi = ri, _i = Wn, vi = xn, gi = pi, Ei = Et,
                yi = an("IE_PROTO"), Si = function () {
                }, bi = function (e) {
                    return "<script>" + e + "<\/script>"
                }, Ti = function (e) {
                    e.write(bi("")), e.close();
                    var t = e.parentWindow.Object;
                    return e = null, t
                }, Ri = function () {
                    try {
                        hi = new ActiveXObject("htmlfile")
                    } catch (e) {
                    }
                    var e, t;
                    Ri = "undefined" != typeof document ? document.domain && hi ? Ti(hi) : ((t = Ei("iframe")).style.display = "none", gi.appendChild(t), t.src = String("javascript:"), (e = t.contentWindow.document).open(), e.write(bi("document.F=Object")), e.close(), e.F) : Ti(hi);
                    for (var r = _i.length; r--;) delete Ri.prototype[_i[r]];
                    return Ri()
                };
            vi[yi] = !0;
            var Ii = Object.create || function (e, t) {
                    var r;
                    return null !== e ? (Si.prototype = fi(e), r = new Si, Si.prototype = null, r[yi] = e) : r = Ri(), void 0 === t ? r : mi.f(r, t)
                }, wi = l("".replace), Ci = String(Error("zxcasd").stack), Ai = /\n\s*at [^:]*:[^\n]*/, Oi = Ai.test(Ci),
                Ni = J, Pi = ar, Di = {}, ki = Di, Li = ot("iterator"), xi = Array.prototype, Mi = function (e) {
                    return void 0 !== e && (ki.Array === e || xi[Li] === e)
                }, Ui = {};
            Ui[ot("toStringTag")] = "z";
            var ji = "[object z]" === String(Ui), Vi = f, Fi = ji, Bi = y, Wi = M, Gi = ot("toStringTag"),
                qi = Vi.Object, Hi = "Arguments" == Wi(function () {
                    return arguments
                }()), Ki = Fi ? Wi : function (e) {
                    var t, r, n;
                    return void 0 === e ? "Undefined" : null === e ? "Null" : "string" == typeof (r = function (e, t) {
                        try {
                            return e[t]
                        } catch (e) {
                        }
                    }(t = qi(e), Gi)) ? r : Hi ? Wi(t) : "Object" == (n = Wi(t)) && Bi(t.callee) ? "Arguments" : n
                }, zi = Ki, Yi = Ce, Ji = Di, Xi = ot("iterator"), Qi = function (e) {
                    if (null != e) return Yi(e, Xi) || Yi(e, "@@iterator") || Ji[zi(e)]
                }, $i = I, Zi = Ie, eo = Xt, to = Se, ro = Qi, no = f.TypeError, io = function (e, t) {
                    var r = arguments.length < 2 ? ro(e) : t;
                    if (Zi(r)) return eo($i(r, e));
                    throw no(to(e) + " is not iterable")
                }, oo = I, so = Xt, ao = Ce, co = function (e, t, r) {
                    var n, i;
                    so(e);
                    try {
                        if (!(n = ao(e, "return"))) {
                            if ("throw" === t) throw r;
                            return r
                        }
                        n = oo(n, e)
                    } catch (e) {
                        i = !0, n = e
                    }
                    if ("throw" === t) throw r;
                    if (i) throw n;
                    return so(n), r
                }, uo = Gt, lo = I, ho = Xt, po = Se, fo = Mi, mo = Ir, _o = h, vo = io, go = Qi, Eo = co, yo = f.TypeError,
                So = function (e, t) {
                    this.stopped = e, this.result = t
                }, bo = So.prototype, To = function (e, t, r) {
                    var n, i, o, s, a, c, u, d = r && r.that, l = !(!r || !r.AS_ENTRIES), h = !(!r || !r.IS_ITERATOR),
                        p = !(!r || !r.INTERRUPTED), f = uo(t, d), m = function (e) {
                            return n && Eo(n, "normal", e), new So(!0, e)
                        }, _ = function (e) {
                            return l ? (ho(e), p ? f(e[0], e[1], m) : f(e[0], e[1])) : p ? f(e, m) : f(e)
                        };
                    if (h) n = e; else {
                        if (!(i = go(e))) throw yo(po(e) + " is not iterable");
                        if (fo(i)) {
                            for (o = 0, s = mo(e); s > o; o++) if ((a = _(e[o])) && _o(bo, a)) return a;
                            return new So(!1)
                        }
                        n = vo(e, i)
                    }
                    for (c = n.next; !(u = lo(c, n)).done;) {
                        try {
                            a = _(u.value)
                        } catch (e) {
                            Eo(n, "throw", e)
                        }
                        if ("object" == typeof a && a && _o(bo, a)) return a
                    }
                    return new So(!1)
                }, Ro = Ki, Io = f.String, wo = function (e) {
                    if ("Symbol" === Ro(e)) throw TypeError("Cannot convert a Symbol value to a string");
                    return Io(e)
                }, Co = wo, Ao = D, Oo = !i(function () {
                    var e = Error("a");
                    return !("stack" in e) || (Object.defineProperty(e, "stack", Ao(1, 7)), 7 !== e.stack)
                }), No = Er, Po = f, Do = h, ko = vn, Lo = Rn, xo = Ii, Mo = ar, Uo = D, jo = To, Vo = Oo,
                Fo = ot("toStringTag"), Bo = Po.Error, Wo = [].push, Go = function (e, t) {
                    var r, n = arguments.length > 2 ? arguments[2] : void 0, i = Do(qo, this);
                    Lo ? r = Lo(new Bo, i ? ko(this) : qo) : (r = i ? this : xo(qo), Mo(r, Fo, "Error")), void 0 !== t && Mo(r, "message", function (e, t) {
                        return void 0 === e ? arguments.length < 2 ? "" : t : Co(e)
                    }(t)), Vo && Mo(r, "stack", function (e, t) {
                        if (Oi && "string" == typeof e) for (; t--;) e = wi(e, Ai, "");
                        return e
                    }(r.stack, 1)), function (e, t) {
                        Ni(t) && "cause" in t && Pi(e, "cause", t.cause)
                    }(r, n);
                    var o = [];
                    return jo(e, Wo, {that: o}), Mo(r, "errors", o), r
                };
            Lo ? Lo(Go, Bo) : function (e, t, r) {
                for (var n = Zn(t), i = ti.f, o = ei.f, s = 0; s < n.length; s++) {
                    var a = n[s];
                    $n(e, a) || r && $n(r, a) || i(e, a, o(t, a))
                }
            }(Go, Bo, {name: !0});
            var qo = Go.prototype = xo(Bo.prototype, {
                constructor: Uo(1, Go),
                message: Uo(1, ""),
                name: Uo(1, "AggregateError")
            });
            No({global: !0}, {AggregateError: Go});
            var Ho = y, Ko = Me, zo = l(Function.toString);
            Ho(Ko.inspectSource) || (Ko.inspectSource = function (e) {
                return zo(e)
            });
            var Yo, Jo, Xo, Qo = Ko.inspectSource, $o = y, Zo = Qo, es = f.WeakMap,
                ts = $o(es) && /native code/.test(Zo(es)), rs = f, ns = l, is = J, os = ar, ss = Ge, as = Me, cs = an,
                us = xn, ds = "Object already initialized", ls = rs.TypeError, hs = rs.WeakMap;
            if (ts || as.state) {
                var ps = as.state || (as.state = new hs), fs = ns(ps.get), ms = ns(ps.has), _s = ns(ps.set);
                Yo = function (e, t) {
                    if (ms(ps, e)) throw new ls(ds);
                    return t.facade = e, _s(ps, e, t), t
                }, Jo = function (e) {
                    return fs(ps, e) || {}
                }, Xo = function (e) {
                    return ms(ps, e)
                }
            } else {
                var vs = cs("state");
                us[vs] = !0, Yo = function (e, t) {
                    if (ss(e, vs)) throw new ls(ds);
                    return t.facade = e, os(e, vs, t), t
                }, Jo = function (e) {
                    return ss(e, vs) ? e[vs] : {}
                }, Xo = function (e) {
                    return ss(e, vs)
                }
            }
            var gs, Es, ys, Ss = {
                    set: Yo, get: Jo, has: Xo, enforce: function (e) {
                        return Xo(e) ? Jo(e) : Yo(e, {})
                    }, getterFor: function (e) {
                        return function (t) {
                            var r;
                            if (!is(t) || (r = Jo(t)).type !== e) throw ls("Incompatible receiver, " + e + " required");
                            return r
                        }
                    }
                }, bs = b, Ts = Ge, Rs = Function.prototype, Is = bs && Object.getOwnPropertyDescriptor,
                ws = Ts(Rs, "name"), Cs = {
                    EXISTS: ws, PROPER: ws && "something" === function () {
                    }.name, CONFIGURABLE: ws && (!bs || bs && Is(Rs, "name").configurable)
                }, As = ar, Os = function (e, t, r, n) {
                    n && n.enumerable ? e[t] = r : As(e, t, r)
                }, Ns = i, Ps = y, Ds = Ii, ks = vn, Ls = Os, xs = ot("iterator"), Ms = !1;
            [].keys && ("next" in (ys = [].keys()) ? (Es = ks(ks(ys))) !== Object.prototype && (gs = Es) : Ms = !0);
            var Us = null == gs || Ns(function () {
                var e = {};
                return gs[xs].call(e) !== e
            });
            Ps((gs = Us ? {} : Ds(gs))[xs]) || Ls(gs, xs, function () {
                return this
            });
            var js = {IteratorPrototype: gs, BUGGY_SAFARI_ITERATORS: Ms}, Vs = Ki, Fs = ji ? {}.toString : function () {
                    return "[object " + Vs(this) + "]"
                }, Bs = ji, Ws = qt.f, Gs = ar, qs = Ge, Hs = Fs, Ks = ot("toStringTag"), zs = function (e, t, r, n) {
                    if (e) {
                        var i = r ? e : e.prototype;
                        qs(i, Ks) || Ws(i, Ks, {configurable: !0, value: t}), n && !Bs && Gs(i, "toString", Hs)
                    }
                }, Ys = js.IteratorPrototype, Js = Ii, Xs = D, Qs = zs, $s = Di, Zs = function () {
                    return this
                }, ea = function (e, t, r, n) {
                    var i = t + " Iterator";
                    return e.prototype = Js(Ys, {next: Xs(+!n, r)}), Qs(e, i, !1, !0), $s[i] = Zs, e
                }, ta = Er, ra = I, na = ea, ia = vn, oa = zs, sa = Os, aa = Di, ca = Cs.PROPER,
                ua = js.BUGGY_SAFARI_ITERATORS, da = ot("iterator"), la = "values", ha = "entries", pa = function () {
                    return this
                }, fa = function (e, t, r, n, i, o, s) {
                    na(r, t, n);
                    var a, c, u, d = function (e) {
                            if (e === i && m) return m;
                            if (!ua && e in p) return p[e];
                            switch (e) {
                                case"keys":
                                case la:
                                case ha:
                                    return function () {
                                        return new r(this, e)
                                    }
                            }
                            return function () {
                                return new r(this)
                            }
                        }, l = t + " Iterator", h = !1, p = e.prototype, f = p[da] || p["@@iterator"] || i && p[i],
                        m = !ua && f || d(i), _ = "Array" == t && p.entries || f;
                    if (_ && (a = ia(_.call(new e))) !== Object.prototype && a.next && (oa(a, l, !0, !0), aa[l] = pa), ca && i == la && f && f.name !== la && (h = !0, m = function () {
                        return ra(f, this)
                    }), i) if (c = {
                        values: d(la),
                        keys: o ? m : d("keys"),
                        entries: d(ha)
                    }, s) for (u in c) (ua || h || !(u in p)) && sa(p, u, c[u]); else ta({
                        target: t,
                        proto: !0,
                        forced: ua || h
                    }, c);
                    return s && p[da] !== m && sa(p, da, m, {name: i}), aa[t] = m, c
                }, ma = z, _a = Di, va = Ss;
            qt.f;
            var ga = fa, Ea = "Array Iterator", ya = va.set, Sa = va.getterFor(Ea);
            ga(Array, "Array", function (e, t) {
                ya(this, {type: Ea, target: ma(e), index: 0, kind: t})
            }, function () {
                var e = Sa(this), t = e.target, r = e.kind, n = e.index++;
                return !t || n >= t.length ? (e.target = void 0, {value: void 0, done: !0}) : "keys" == r ? {
                    value: n,
                    done: !1
                } : "values" == r ? {value: t[n], done: !1} : {value: [n, t[n]], done: !1}
            }, "values"), _a.Arguments = _a.Array;
            var ba = f.Promise, Ta = Os, Ra = function (e, t, r) {
                for (var n in t) r && r.unsafe && e[n] ? e[n] = t[n] : Ta(e, n, t[n], r);
                return e
            }, Ia = te, wa = qt, Ca = b, Aa = ot("species"), Oa = h, Na = f.TypeError, Pa = function (e, t) {
                if (Oa(t, e)) return e;
                throw Na("Incorrect invocation")
            }, Da = ot("iterator"), ka = !1;
            try {
                var La = 0, xa = {
                    next: function () {
                        return {done: !!La++}
                    }, return: function () {
                        ka = !0
                    }
                };
                xa[Da] = function () {
                    return this
                }, Array.from(xa, function () {
                    throw 2
                })
            } catch (e) {
            }
            var Ma = l, Ua = i, ja = y, Va = Ki, Fa = Qo, Ba = function () {
                }, Wa = [], Ga = te("Reflect", "construct"), qa = /^\s*(?:class|function)\b/, Ha = Ma(qa.exec),
                Ka = !qa.exec(Ba), za = function (e) {
                    if (!ja(e)) return !1;
                    try {
                        return Ga(Ba, Wa, e), !0
                    } catch (e) {
                        return !1
                    }
                }, Ya = function (e) {
                    if (!ja(e)) return !1;
                    switch (Va(e)) {
                        case"AsyncFunction":
                        case"GeneratorFunction":
                        case"AsyncGeneratorFunction":
                            return !1
                    }
                    try {
                        return Ka || !!Ha(qa, Fa(e))
                    } catch (e) {
                        return !0
                    }
                };
            Ya.sham = !0;
            var Ja, Xa, Qa, $a, Za = !Ga || Ua(function () {
                    var e;
                    return za(za.call) || !za(Object) || !za(function () {
                        e = !0
                    }) || e
                }) ? Ya : za, ec = Za, tc = Se, rc = f.TypeError, nc = Xt, ic = ot("species"), oc = function (e, t) {
                    var r, n = nc(e).constructor;
                    return void 0 === n || null == (r = nc(n)[ic]) ? t : function (e) {
                        if (ec(e)) return e;
                        throw rc(tc(e) + " is not a constructor")
                    }(r)
                }, sc = l([].slice), ac = /(?:ipad|iphone|ipod).*applewebkit/i.test(re), cc = f, uc = E, dc = Gt, lc = y,
                hc = Ge, pc = i, fc = pi, mc = sc, _c = Et, vc = ac, gc = xr, Ec = cc.setImmediate,
                yc = cc.clearImmediate, Sc = cc.process, bc = cc.Dispatch, Tc = cc.Function, Rc = cc.MessageChannel,
                Ic = cc.String, wc = 0, Cc = {};
            try {
                Ja = cc.location
            } catch (e) {
            }
            var Ac = function (e) {
                if (hc(Cc, e)) {
                    var t = Cc[e];
                    delete Cc[e], t()
                }
            }, Oc = function (e) {
                return function () {
                    Ac(e)
                }
            }, Nc = function (e) {
                Ac(e.data)
            }, Pc = function (e) {
                cc.postMessage(Ic(e), Ja.protocol + "//" + Ja.host)
            };
            Ec && yc || (Ec = function (e) {
                var t = mc(arguments, 1);
                return Cc[++wc] = function () {
                    uc(lc(e) ? e : Tc(e), void 0, t)
                }, Xa(wc), wc
            }, yc = function (e) {
                delete Cc[e]
            }, gc ? Xa = function (e) {
                Sc.nextTick(Oc(e))
            } : bc && bc.now ? Xa = function (e) {
                bc.now(Oc(e))
            } : Rc && !vc ? ($a = (Qa = new Rc).port2, Qa.port1.onmessage = Nc, Xa = dc($a.postMessage, $a)) : cc.addEventListener && lc(cc.postMessage) && !cc.importScripts && Ja && "file:" !== Ja.protocol && !pc(Pc) ? (Xa = Pc, cc.addEventListener("message", Nc, !1)) : Xa = "onreadystatechange" in _c("script") ? function (e) {
                fc.appendChild(_c("script")).onreadystatechange = function () {
                    fc.removeChild(this), Ac(e)
                }
            } : function (e) {
                setTimeout(Oc(e), 0)
            });
            var Dc, kc, Lc, xc, Mc, Uc, jc, Vc, Fc = {set: Ec, clear: yc}, Bc = f,
                Wc = /ipad|iphone|ipod/i.test(re) && void 0 !== Bc.Pebble, Gc = /web0s(?!.*chrome)/i.test(re), qc = f,
                Hc = Gt, Kc = S.f, zc = Fc.set, Yc = ac, Jc = Wc, Xc = Gc, Qc = xr,
                $c = qc.MutationObserver || qc.WebKitMutationObserver, Zc = qc.document, eu = qc.process,
                tu = qc.Promise, ru = Kc(qc, "queueMicrotask"), nu = ru && ru.value;
            nu || (Dc = function () {
                var e, t;
                for (Qc && (e = eu.domain) && e.exit(); kc;) {
                    t = kc.fn, kc = kc.next;
                    try {
                        t()
                    } catch (e) {
                        throw kc ? xc() : Lc = void 0, e
                    }
                }
                Lc = void 0, e && e.enter()
            }, Yc || Qc || Xc || !$c || !Zc ? !Jc && tu && tu.resolve ? ((jc = tu.resolve(void 0)).constructor = tu, Vc = Hc(jc.then, jc), xc = function () {
                Vc(Dc)
            }) : Qc ? xc = function () {
                eu.nextTick(Dc)
            } : (zc = Hc(zc, qc), xc = function () {
                zc(Dc)
            }) : (Mc = !0, Uc = Zc.createTextNode(""), new $c(Dc).observe(Uc, {characterData: !0}), xc = function () {
                Uc.data = Mc = !Mc
            }));
            var iu = nu || function (e) {
                var t = {fn: e, next: void 0};
                Lc && (Lc.next = t), kc || (kc = t, xc()), Lc = t
            }, ou = {}, su = Ie;
            ou.f = function (e) {
                return new function (e) {
                    var t, r;
                    this.promise = new e(function (e, n) {
                        if (void 0 !== t || void 0 !== r) throw TypeError("Bad Promise constructor");
                        t = e, r = n
                    }), this.resolve = su(t), this.reject = su(r)
                }(e)
            };
            var au = Xt, cu = J, uu = ou, du = function (e, t) {
                if (au(e), cu(t) && t.constructor === e) return t;
                var r = uu.f(e);
                return (0, r.resolve)(t), r.promise
            }, lu = f, hu = function (e) {
                try {
                    return {error: !1, value: e()}
                } catch (e) {
                    return {error: !0, value: e}
                }
            }, pu = function () {
                this.head = null, this.tail = null
            };
            pu.prototype = {
                add: function (e) {
                    var t = {item: e, next: null};
                    this.head ? this.tail.next = t : this.head = t, this.tail = t
                }, get: function () {
                    var e = this.head;
                    if (e) return this.head = e.next, this.tail === e && (this.tail = null), e.item
                }
            };
            var fu, mu, _u, vu = "object" == typeof window, gu = Er, Eu = f, yu = te, Su = I, bu = ba, Tu = Ra, Ru = zs,
                Iu = Ie, wu = y, Cu = J, Au = Pa, Ou = Qo, Nu = To, Pu = oc, Du = Fc.set, ku = iu, Lu = du, xu = ou,
                Mu = hu, Uu = pu, ju = Ss, Vu = Vt, Fu = vu, Bu = xr, Wu = ue, Gu = ot("species"), qu = "Promise",
                Hu = ju.getterFor(qu), Ku = ju.set, zu = ju.getterFor(qu), Yu = bu && bu.prototype, Ju = bu, Xu = Yu,
                Qu = Eu.TypeError, $u = Eu.document, Zu = Eu.process, ed = xu.f, td = ed,
                rd = !!($u && $u.createEvent && Eu.dispatchEvent), nd = wu(Eu.PromiseRejectionEvent),
                id = "unhandledrejection", od = Vu(qu, function () {
                    var e = Ou(Ju), t = e !== String(Ju);
                    if (!t && 66 === Wu) return !0;
                    if (!Xu.finally) return !0;
                    if (Wu >= 51 && /native code/.test(e)) return !1;
                    var r = new Ju(function (e) {
                        e(1)
                    }), n = function (e) {
                        e(function () {
                        }, function () {
                        })
                    };
                    return (r.constructor = {})[Gu] = n, !(r.then(function () {
                    }) instanceof n) || !t && Fu && !nd
                }), sd = od || !function (e, t) {
                    if (!t && !ka) return !1;
                    var r = !1;
                    try {
                        var n = {};
                        n[Da] = function () {
                            return {
                                next: function () {
                                    return {done: r = !0}
                                }
                            }
                        }, e(n)
                    } catch (e) {
                    }
                    return r
                }(function (e) {
                    Ju.all(e).catch(function () {
                    })
                }), ad = function (e) {
                    var t;
                    return !(!Cu(e) || !wu(t = e.then)) && t
                }, cd = function (e, t) {
                    var r, n, i, o = t.value, s = 1 == t.state, a = s ? e.ok : e.fail, c = e.resolve, u = e.reject,
                        d = e.domain;
                    try {
                        a ? (s || (2 === t.rejection && pd(t), t.rejection = 1), !0 === a ? r = o : (d && d.enter(), r = a(o), d && (d.exit(), i = !0)), r === e.promise ? u(Qu("Promise-chain cycle")) : (n = ad(r)) ? Su(n, r, c, u) : c(r)) : u(o)
                    } catch (e) {
                        d && !i && d.exit(), u(e)
                    }
                }, ud = function (e, t) {
                    e.notified || (e.notified = !0, ku(function () {
                        for (var r, n = e.reactions; r = n.get();) cd(r, e);
                        e.notified = !1, t && !e.rejection && ld(e)
                    }))
                }, dd = function (e, t, r) {
                    var n, i;
                    rd ? ((n = $u.createEvent("Event")).promise = t, n.reason = r, n.initEvent(e, !1, !0), Eu.dispatchEvent(n)) : n = {
                        promise: t,
                        reason: r
                    }, !nd && (i = Eu["on" + e]) ? i(n) : e === id && function (e, t) {
                        var r = lu.console;
                        r && r.error && (1 == arguments.length ? r.error(e) : r.error(e, t))
                    }("Unhandled promise rejection", r)
                }, ld = function (e) {
                    Su(Du, Eu, function () {
                        var t, r = e.facade, n = e.value;
                        if (hd(e) && (t = Mu(function () {
                            Bu ? Zu.emit("unhandledRejection", n, r) : dd(id, r, n)
                        }), e.rejection = Bu || hd(e) ? 2 : 1, t.error)) throw t.value
                    })
                }, hd = function (e) {
                    return 1 !== e.rejection && !e.parent
                }, pd = function (e) {
                    Su(Du, Eu, function () {
                        var t = e.facade;
                        Bu ? Zu.emit("rejectionHandled", t) : dd("rejectionhandled", t, e.value)
                    })
                }, fd = function (e, t, r) {
                    return function (n) {
                        e(t, n, r)
                    }
                }, md = function (e, t, r) {
                    e.done || (e.done = !0, r && (e = r), e.value = t, e.state = 2, ud(e, !0))
                }, _d = function (e, t, r) {
                    if (!e.done) {
                        e.done = !0, r && (e = r);
                        try {
                            if (e.facade === t) throw Qu("Promise can't be resolved itself");
                            var n = ad(t);
                            n ? ku(function () {
                                var r = {done: !1};
                                try {
                                    Su(n, t, fd(_d, r, e), fd(md, r, e))
                                } catch (t) {
                                    md(r, t, e)
                                }
                            }) : (e.value = t, e.state = 1, ud(e, !1))
                        } catch (t) {
                            md({done: !1}, t, e)
                        }
                    }
                };
            od && (Xu = (Ju = function (e) {
                Au(this, Xu), Iu(e), Su(fu, this);
                var t = Hu(this);
                try {
                    e(fd(_d, t), fd(md, t))
                } catch (e) {
                    md(t, e)
                }
            }).prototype, (fu = function (e) {
                Ku(this, {
                    type: qu,
                    done: !1,
                    notified: !1,
                    parent: !1,
                    reactions: new Uu,
                    rejection: !1,
                    state: 0,
                    value: void 0
                })
            }).prototype = Tu(Xu, {
                then: function (e, t) {
                    var r = zu(this), n = ed(Pu(this, Ju));
                    return r.parent = !0, n.ok = !wu(e) || e, n.fail = wu(t) && t, n.domain = Bu ? Zu.domain : void 0, 0 == r.state ? r.reactions.add(n) : ku(function () {
                        cd(n, r)
                    }), n.promise
                }, catch: function (e) {
                    return this.then(void 0, e)
                }
            }), mu = function () {
                var e = new fu, t = Hu(e);
                this.promise = e, this.resolve = fd(_d, t), this.reject = fd(md, t)
            }, xu.f = ed = function (e) {
                return e === Ju || e === _u ? new mu(e) : td(e)
            }), gu({global: !0, wrap: !0, forced: od}, {Promise: Ju}), Ru(Ju, qu, !1, !0), function (e) {
                var t = Ia(e), r = wa.f;
                Ca && t && !t[Aa] && r(t, Aa, {
                    configurable: !0, get: function () {
                        return this
                    }
                })
            }(qu), _u = yu(qu), gu({target: qu, stat: !0, forced: od}, {
                reject: function (e) {
                    var t = ed(this);
                    return Su(t.reject, void 0, e), t.promise
                }
            }), gu({target: qu, stat: !0, forced: !0}, {
                resolve: function (e) {
                    return Lu(this === _u ? Ju : this, e)
                }
            }), gu({target: qu, stat: !0, forced: sd}, {
                all: function (e) {
                    var t = this, r = ed(t), n = r.resolve, i = r.reject, o = Mu(function () {
                        var r = Iu(t.resolve), o = [], s = 0, a = 1;
                        Nu(e, function (e) {
                            var c = s++, u = !1;
                            a++, Su(r, t, e).then(function (e) {
                                u || (u = !0, o[c] = e, --a || n(o))
                            }, i)
                        }), --a || n(o)
                    });
                    return o.error && i(o.value), r.promise
                }, race: function (e) {
                    var t = this, r = ed(t), n = r.reject, i = Mu(function () {
                        var i = Iu(t.resolve);
                        Nu(e, function (e) {
                            Su(i, t, e).then(r.resolve, n)
                        })
                    });
                    return i.error && n(i.value), r.promise
                }
            });
            var vd = I, gd = Ie, Ed = ou, yd = hu, Sd = To;
            Er({target: "Promise", stat: !0}, {
                allSettled: function (e) {
                    var t = this, r = Ed.f(t), n = r.resolve, i = r.reject, o = yd(function () {
                        var r = gd(t.resolve), i = [], o = 0, s = 1;
                        Sd(e, function (e) {
                            var a = o++, c = !1;
                            s++, vd(r, t, e).then(function (e) {
                                c || (c = !0, i[a] = {status: "fulfilled", value: e}, --s || n(i))
                            }, function (e) {
                                c || (c = !0, i[a] = {status: "rejected", reason: e}, --s || n(i))
                            })
                        }), --s || n(i)
                    });
                    return o.error && i(o.value), r.promise
                }
            });
            var bd = Ie, Td = te, Rd = I, Id = ou, wd = hu, Cd = To, Ad = "No one promise resolved";
            Er({target: "Promise", stat: !0}, {
                any: function (e) {
                    var t = this, r = Td("AggregateError"), n = Id.f(t), i = n.resolve, o = n.reject,
                        s = wd(function () {
                            var n = bd(t.resolve), s = [], a = 0, c = 1, u = !1;
                            Cd(e, function (e) {
                                var d = a++, l = !1;
                                c++, Rd(n, t, e).then(function (e) {
                                    l || u || (u = !0, i(e))
                                }, function (e) {
                                    l || u || (l = !0, s[d] = e, --c || o(new r(s, Ad)))
                                })
                            }), --c || o(new r(s, Ad))
                        });
                    return s.error && o(s.value), n.promise
                }
            });
            var Od = ba, Nd = te, Pd = y, Dd = oc, kd = du;
            Er({
                target: "Promise", proto: !0, real: !0, forced: !!Od && i(function () {
                    Od.prototype.finally.call({
                        then: function () {
                        }
                    }, function () {
                    })
                })
            }, {
                finally: function (e) {
                    var t = Dd(this, Nd("Promise")), r = Pd(e);
                    return this.then(r ? function (r) {
                        return kd(t, e()).then(function () {
                            return r
                        })
                    } : e, r ? function (r) {
                        return kd(t, e()).then(function () {
                            throw r
                        })
                    } : e)
                }
            });
            var Ld = l, xd = br, Md = wo, Ud = q, jd = Ld("".charAt), Vd = Ld("".charCodeAt), Fd = Ld("".slice),
                Bd = function (e) {
                    return function (t, r) {
                        var n, i, o = Md(Ud(t)), s = xd(r), a = o.length;
                        return s < 0 || s >= a ? e ? "" : void 0 : (n = Vd(o, s)) < 55296 || n > 56319 || s + 1 === a || (i = Vd(o, s + 1)) < 56320 || i > 57343 ? e ? jd(o, s) : n : e ? Fd(o, s, s + 2) : i - 56320 + (n - 55296 << 10) + 65536
                    }
                }, Wd = {codeAt: Bd(!1), charAt: Bd(!0)}, Gd = Wd.charAt, qd = wo, Hd = Ss, Kd = fa,
                zd = "String Iterator", Yd = Hd.set, Jd = Hd.getterFor(zd);
            Kd(String, "String", function (e) {
                Yd(this, {type: zd, string: qd(e), index: 0})
            }, function () {
                var e, t = Jd(this), r = t.string, n = t.index;
                return n >= r.length ? {value: void 0, done: !0} : (e = Gd(r, n), t.index += e.length, {
                    value: e,
                    done: !1
                })
            });
            var Xd = X.Promise, Qd = f, $d = Ki, Zd = ar, el = Di, tl = ot("toStringTag");
            for (var rl in {
                CSSRuleList: 0,
                CSSStyleDeclaration: 0,
                CSSValueList: 0,
                ClientRectList: 0,
                DOMRectList: 0,
                DOMStringList: 0,
                DOMTokenList: 1,
                DataTransferItemList: 0,
                FileList: 0,
                HTMLAllCollection: 0,
                HTMLCollection: 0,
                HTMLFormElement: 0,
                HTMLSelectElement: 0,
                MediaList: 0,
                MimeTypeArray: 0,
                NamedNodeMap: 0,
                NodeList: 1,
                PaintRequestList: 0,
                Plugin: 0,
                PluginArray: 0,
                SVGLengthList: 0,
                SVGNumberList: 0,
                SVGPathSegList: 0,
                SVGPointList: 0,
                SVGStringList: 0,
                SVGTransformList: 0,
                SourceBufferList: 0,
                StyleSheetList: 0,
                TextTrackCueList: 0,
                TextTrackList: 0,
                TouchList: 0
            }) {
                var nl = Qd[rl], il = nl && nl.prototype;
                il && $d(il) !== tl && Zd(il, tl, rl), el[rl] = el.Array
            }
            var ol = Xd, sl = ol;
            const al = Zr;

            function cl(e, t) {
                const r = e && e.navigator;
                if (!r.mediaDevices) return;
                const n = function (e) {
                    if ("object" != typeof e || e.mandatory || e.optional) return e;
                    const t = {};
                    return Object.keys(e).forEach(r => {
                        if ("require" === r || "advanced" === r || "mediaSource" === r) return;
                        const n = "object" == typeof e[r] ? e[r] : {ideal: e[r]};
                        void 0 !== n.exact && "number" == typeof n.exact && (n.min = n.max = n.exact);
                        const i = function (e, t) {
                            return e ? e + t.charAt(0).toUpperCase() + t.slice(1) : "deviceId" === t ? "sourceId" : t
                        };
                        if (void 0 !== n.ideal) {
                            t.optional = t.optional || [];
                            let e = {};
                            "number" == typeof n.ideal ? (e[i("min", r)] = n.ideal, t.optional.push(e), (e = {})[i("max", r)] = n.ideal, t.optional.push(e)) : (e[i("", r)] = n.ideal, t.optional.push(e))
                        }
                        void 0 !== n.exact && "number" != typeof n.exact ? (t.mandatory = t.mandatory || {}, t.mandatory[i("", r)] = n.exact) : ["min", "max"].forEach(e => {
                            void 0 !== n[e] && (t.mandatory = t.mandatory || {}, t.mandatory[i(e, r)] = n[e])
                        })
                    }), e.advanced && (t.optional = (t.optional || []).concat(e.advanced)), t
                }, i = function (e, i) {
                    if (t.version >= 61) return i(e);
                    if ((e = JSON.parse(JSON.stringify(e))) && "object" == typeof e.audio) {
                        const t = function (e, t, r) {
                            t in e && !(r in e) && (e[r] = e[t], delete e[t])
                        };
                        t((e = JSON.parse(JSON.stringify(e))).audio, "autoGainControl", "googAutoGainControl"), t(e.audio, "noiseSuppression", "googNoiseSuppression"), e.audio = n(e.audio)
                    }
                    if (e && "object" == typeof e.video) {
                        let o = e.video.facingMode;
                        o = o && ("object" == typeof o ? o : {ideal: o});
                        const s = t.version < 66;
                        if (o && ("user" === o.exact || "environment" === o.exact || "user" === o.ideal || "environment" === o.ideal) && (!r.mediaDevices.getSupportedConstraints || !r.mediaDevices.getSupportedConstraints().facingMode || s)) {
                            let t;
                            if (delete e.video.facingMode, "environment" === o.exact || "environment" === o.ideal ? t = ["back", "rear"] : "user" !== o.exact && "user" !== o.ideal || (t = ["front"]), t) return r.mediaDevices.enumerateDevices().then(r => {
                                let s = (r = r.filter(e => "videoinput" === e.kind)).find(e => t.some(t => e.label.toLowerCase().includes(t)));
                                return !s && r.length && t.includes("back") && (s = r[r.length - 1]), s && (e.video.deviceId = o.exact ? {exact: s.deviceId} : {ideal: s.deviceId}), e.video = n(e.video), al("chrome: " + JSON.stringify(e)), i(e)
                            })
                        }
                        e.video = n(e.video)
                    }
                    return al("chrome: " + JSON.stringify(e)), i(e)
                }, o = function (e) {
                    return t.version >= 64 ? e : {
                        name: {
                            PermissionDeniedError: "NotAllowedError",
                            PermissionDismissedError: "NotAllowedError",
                            InvalidStateError: "NotAllowedError",
                            DevicesNotFoundError: "NotFoundError",
                            ConstraintNotSatisfiedError: "OverconstrainedError",
                            TrackStartError: "NotReadableError",
                            MediaDeviceFailedDueToShutdown: "NotAllowedError",
                            MediaDeviceKillSwitchOn: "NotAllowedError",
                            TabCaptureError: "AbortError",
                            ScreenCaptureError: "AbortError",
                            DeviceCaptureError: "AbortError"
                        }[e.name] || e.name,
                        message: e.message,
                        constraint: e.constraint || e.constraintName,
                        toString() {
                            return this.name + (this.message && ": ") + this.message
                        }
                    }
                };
                if (r.getUserMedia = function (e, t, n) {
                    i(e, e => {
                        r.webkitGetUserMedia(e, t, e => {
                            n && n(o(e))
                        })
                    })
                }.bind(r), r.mediaDevices.getUserMedia) {
                    const e = r.mediaDevices.getUserMedia.bind(r.mediaDevices);
                    r.mediaDevices.getUserMedia = function (t) {
                        return i(t, t => e(t).then(e => {
                            if (t.audio && !e.getAudioTracks().length || t.video && !e.getVideoTracks().length) throw e.getTracks().forEach(e => {
                                e.stop()
                            }), new DOMException("", "NotFoundError");
                            return e
                        }, e => sl.reject(o(e))))
                    }
                }
            }

            function ul(e) {
                e.MediaStream = e.MediaStream || e.webkitMediaStream
            }

            function dl(e) {
                if ("object" != typeof e || !e.RTCPeerConnection || "ontrack" in e.RTCPeerConnection.prototype) Xr(e, "track", e => (e.transceiver || Object.defineProperty(e, "transceiver", {value: {receiver: e.receiver}}), e)); else {
                    Object.defineProperty(e.RTCPeerConnection.prototype, "ontrack", {
                        get() {
                            return this._ontrack
                        }, set(e) {
                            this._ontrack && this.removeEventListener("track", this._ontrack), this.addEventListener("track", this._ontrack = e)
                        }, enumerable: !0, configurable: !0
                    });
                    const t = e.RTCPeerConnection.prototype.setRemoteDescription;
                    e.RTCPeerConnection.prototype.setRemoteDescription = function () {
                        return this._ontrackpoly || (this._ontrackpoly = (t => {
                            t.stream.addEventListener("addtrack", r => {
                                let n;
                                n = e.RTCPeerConnection.prototype.getReceivers ? this.getReceivers().find(e => e.track && e.track.id === r.track.id) : {track: r.track};
                                const i = new Event("track");
                                i.track = r.track, i.receiver = n, i.transceiver = {receiver: n}, i.streams = [t.stream], this.dispatchEvent(i)
                            }), t.stream.getTracks().forEach(r => {
                                let n;
                                n = e.RTCPeerConnection.prototype.getReceivers ? this.getReceivers().find(e => e.track && e.track.id === r.id) : {track: r};
                                const i = new Event("track");
                                i.track = r, i.receiver = n, i.transceiver = {receiver: n}, i.streams = [t.stream], this.dispatchEvent(i)
                            })
                        }), this.addEventListener("addstream", this._ontrackpoly)), t.apply(this, arguments)
                    }
                }
            }

            function ll(e) {
                if ("object" == typeof e && e.RTCPeerConnection && !("getSenders" in e.RTCPeerConnection.prototype) && "createDTMFSender" in e.RTCPeerConnection.prototype) {
                    const t = function (e, t) {
                        return {
                            track: t, get dtmf() {
                                return void 0 === this._dtmf && ("audio" === t.kind ? this._dtmf = e.createDTMFSender(t) : this._dtmf = null), this._dtmf
                            }, _pc: e
                        }
                    };
                    if (!e.RTCPeerConnection.prototype.getSenders) {
                        e.RTCPeerConnection.prototype.getSenders = function () {
                            return this._senders = this._senders || [], this._senders.slice()
                        };
                        const r = e.RTCPeerConnection.prototype.addTrack;
                        e.RTCPeerConnection.prototype.addTrack = function (e, n) {
                            let i = r.apply(this, arguments);
                            return i || (i = t(this, e), this._senders.push(i)), i
                        };
                        const n = e.RTCPeerConnection.prototype.removeTrack;
                        e.RTCPeerConnection.prototype.removeTrack = function (e) {
                            n.apply(this, arguments);
                            const t = this._senders.indexOf(e);
                            -1 !== t && this._senders.splice(t, 1)
                        }
                    }
                    const r = e.RTCPeerConnection.prototype.addStream;
                    e.RTCPeerConnection.prototype.addStream = function (e) {
                        this._senders = this._senders || [], r.apply(this, [e]), e.getTracks().forEach(e => {
                            this._senders.push(t(this, e))
                        })
                    };
                    const n = e.RTCPeerConnection.prototype.removeStream;
                    e.RTCPeerConnection.prototype.removeStream = function (e) {
                        this._senders = this._senders || [], n.apply(this, [e]), e.getTracks().forEach(e => {
                            const t = this._senders.find(t => t.track === e);
                            t && this._senders.splice(this._senders.indexOf(t), 1)
                        })
                    }
                } else if ("object" == typeof e && e.RTCPeerConnection && "getSenders" in e.RTCPeerConnection.prototype && "createDTMFSender" in e.RTCPeerConnection.prototype && e.RTCRtpSender && !("dtmf" in e.RTCRtpSender.prototype)) {
                    const t = e.RTCPeerConnection.prototype.getSenders;
                    e.RTCPeerConnection.prototype.getSenders = function () {
                        const e = t.apply(this, []);
                        return e.forEach(e => e._pc = this), e
                    }, Object.defineProperty(e.RTCRtpSender.prototype, "dtmf", {
                        get() {
                            return void 0 === this._dtmf && ("audio" === this.track.kind ? this._dtmf = this._pc.createDTMFSender(this.track) : this._dtmf = null), this._dtmf
                        }
                    })
                }
            }

            function hl(e) {
                if (!e.RTCPeerConnection) return;
                const t = e.RTCPeerConnection.prototype.getStats;
                e.RTCPeerConnection.prototype.getStats = function () {
                    const [e, r, n] = arguments;
                    if (arguments.length > 0 && "function" == typeof e) return t.apply(this, arguments);
                    if (0 === t.length && (0 === arguments.length || "function" != typeof e)) return t.apply(this, []);
                    const i = function (e) {
                        const t = {};
                        return e.result().forEach(e => {
                            const r = {
                                id: e.id,
                                timestamp: e.timestamp,
                                type: {
                                    localcandidate: "local-candidate",
                                    remotecandidate: "remote-candidate"
                                }[e.type] || e.type
                            };
                            e.names().forEach(t => {
                                r[t] = e.stat(t)
                            }), t[r.id] = r
                        }), t
                    }, o = function (e) {
                        return new Map(Object.keys(e).map(t => [t, e[t]]))
                    };
                    if (arguments.length >= 2) {
                        const n = function (e) {
                            r(o(i(e)))
                        };
                        return t.apply(this, [n, e])
                    }
                    return new sl((e, r) => {
                        t.apply(this, [function (t) {
                            e(o(i(t)))
                        }, r])
                    }).then(r, n)
                }
            }

            function pl(e) {
                if (!("object" == typeof e && e.RTCPeerConnection && e.RTCRtpSender && e.RTCRtpReceiver)) return;
                if (!("getStats" in e.RTCRtpSender.prototype)) {
                    const t = e.RTCPeerConnection.prototype.getSenders;
                    t && (e.RTCPeerConnection.prototype.getSenders = function () {
                        const e = t.apply(this, []);
                        return e.forEach(e => e._pc = this), e
                    });
                    const r = e.RTCPeerConnection.prototype.addTrack;
                    r && (e.RTCPeerConnection.prototype.addTrack = function () {
                        const e = r.apply(this, arguments);
                        return e._pc = this, e
                    }), e.RTCRtpSender.prototype.getStats = function () {
                        const e = this;
                        return this._pc.getStats().then(t => rn(t, e.track, !0))
                    }
                }
                if (!("getStats" in e.RTCRtpReceiver.prototype)) {
                    const t = e.RTCPeerConnection.prototype.getReceivers;
                    t && (e.RTCPeerConnection.prototype.getReceivers = function () {
                        const e = t.apply(this, []);
                        return e.forEach(e => e._pc = this), e
                    }), Xr(e, "track", e => (e.receiver._pc = e.srcElement, e)), e.RTCRtpReceiver.prototype.getStats = function () {
                        const e = this;
                        return this._pc.getStats().then(t => rn(t, e.track, !1))
                    }
                }
                if (!("getStats" in e.RTCRtpSender.prototype && "getStats" in e.RTCRtpReceiver.prototype)) return;
                const t = e.RTCPeerConnection.prototype.getStats;
                e.RTCPeerConnection.prototype.getStats = function () {
                    if (arguments.length > 0 && arguments[0] instanceof e.MediaStreamTrack) {
                        const e = arguments[0];
                        let t, r, n;
                        return this.getSenders().forEach(r => {
                            r.track === e && (t ? n = !0 : t = r)
                        }), this.getReceivers().forEach(t => (t.track === e && (r ? n = !0 : r = t), t.track === e)), n || t && r ? sl.reject(new DOMException("There are more than one sender or receiver for the track.", "InvalidAccessError")) : t ? t.getStats() : r ? r.getStats() : sl.reject(new DOMException("There is no sender or receiver for the track.", "InvalidAccessError"))
                    }
                    return t.apply(this, arguments)
                }
            }

            function fl(e) {
                e.RTCPeerConnection.prototype.getLocalStreams = function () {
                    return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, Object.keys(this._shimmedLocalStreams).map(e => this._shimmedLocalStreams[e][0])
                };
                const t = e.RTCPeerConnection.prototype.addTrack;
                e.RTCPeerConnection.prototype.addTrack = function (e, r) {
                    if (!r) return t.apply(this, arguments);
                    this._shimmedLocalStreams = this._shimmedLocalStreams || {};
                    const n = t.apply(this, arguments);
                    return this._shimmedLocalStreams[r.id] ? -1 === this._shimmedLocalStreams[r.id].indexOf(n) && this._shimmedLocalStreams[r.id].push(n) : this._shimmedLocalStreams[r.id] = [r, n], n
                };
                const r = e.RTCPeerConnection.prototype.addStream;
                e.RTCPeerConnection.prototype.addStream = function (e) {
                    this._shimmedLocalStreams = this._shimmedLocalStreams || {}, e.getTracks().forEach(e => {
                        if (this.getSenders().find(t => t.track === e)) throw new DOMException("Track already exists.", "InvalidAccessError")
                    });
                    const t = this.getSenders();
                    r.apply(this, arguments);
                    const n = this.getSenders().filter(e => -1 === t.indexOf(e));
                    this._shimmedLocalStreams[e.id] = [e].concat(n)
                };
                const n = e.RTCPeerConnection.prototype.removeStream;
                e.RTCPeerConnection.prototype.removeStream = function (e) {
                    return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, delete this._shimmedLocalStreams[e.id], n.apply(this, arguments)
                };
                const i = e.RTCPeerConnection.prototype.removeTrack;
                e.RTCPeerConnection.prototype.removeTrack = function (e) {
                    return this._shimmedLocalStreams = this._shimmedLocalStreams || {}, e && Object.keys(this._shimmedLocalStreams).forEach(t => {
                        const r = this._shimmedLocalStreams[t].indexOf(e);
                        -1 !== r && this._shimmedLocalStreams[t].splice(r, 1), 1 === this._shimmedLocalStreams[t].length && delete this._shimmedLocalStreams[t]
                    }), i.apply(this, arguments)
                }
            }

            function ml(e, t) {
                if (!e.RTCPeerConnection) return;
                if (e.RTCPeerConnection.prototype.addTrack && t.version >= 65) return fl(e);
                const r = e.RTCPeerConnection.prototype.getLocalStreams;
                e.RTCPeerConnection.prototype.getLocalStreams = function () {
                    const e = r.apply(this);
                    return this._reverseStreams = this._reverseStreams || {}, e.map(e => this._reverseStreams[e.id])
                };
                const n = e.RTCPeerConnection.prototype.addStream;
                e.RTCPeerConnection.prototype.addStream = function (t) {
                    if (this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, t.getTracks().forEach(e => {
                        if (this.getSenders().find(t => t.track === e)) throw new DOMException("Track already exists.", "InvalidAccessError")
                    }), !this._reverseStreams[t.id]) {
                        const r = new e.MediaStream(t.getTracks());
                        this._streams[t.id] = r, this._reverseStreams[r.id] = t, t = r
                    }
                    n.apply(this, [t])
                };
                const i = e.RTCPeerConnection.prototype.removeStream;

                function o(e, t) {
                    let r = t.sdp;
                    return Object.keys(e._reverseStreams || []).forEach(t => {
                        const n = e._reverseStreams[t], i = e._streams[n.id];
                        r = r.replace(new RegExp(i.id, "g"), n.id)
                    }), new RTCSessionDescription({type: t.type, sdp: r})
                }

                e.RTCPeerConnection.prototype.removeStream = function (e) {
                    this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {}, i.apply(this, [this._streams[e.id] || e]), delete this._reverseStreams[this._streams[e.id] ? this._streams[e.id].id : e.id], delete this._streams[e.id]
                }, e.RTCPeerConnection.prototype.addTrack = function (t, r) {
                    if ("closed" === this.signalingState) throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
                    const n = [].slice.call(arguments, 1);
                    if (1 !== n.length || !n[0].getTracks().find(e => e === t)) throw new DOMException("The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.", "NotSupportedError");
                    const i = this.getSenders().find(e => e.track === t);
                    if (i) throw new DOMException("Track already exists.", "InvalidAccessError");
                    this._streams = this._streams || {}, this._reverseStreams = this._reverseStreams || {};
                    const o = this._streams[r.id];
                    if (o) o.addTrack(t), sl.resolve().then(() => {
                        this.dispatchEvent(new Event("negotiationneeded"))
                    }); else {
                        const n = new e.MediaStream([t]);
                        this._streams[r.id] = n, this._reverseStreams[n.id] = r, this.addStream(n)
                    }
                    return this.getSenders().find(e => e.track === t)
                }, ["createOffer", "createAnswer"].forEach(function (t) {
                    const r = e.RTCPeerConnection.prototype[t], n = {
                        [t]() {
                            const e = arguments;
                            return arguments.length && "function" == typeof arguments[0] ? r.apply(this, [t => {
                                const r = o(this, t);
                                e[0].apply(null, [r])
                            }, t => {
                                e[1] && e[1].apply(null, t)
                            }, arguments[2]]) : r.apply(this, arguments).then(e => o(this, e))
                        }
                    };
                    e.RTCPeerConnection.prototype[t] = n[t]
                });
                const s = e.RTCPeerConnection.prototype.setLocalDescription;
                e.RTCPeerConnection.prototype.setLocalDescription = function () {
                    return arguments.length && arguments[0].type ? (arguments[0] = function (e, t) {
                        let r = t.sdp;
                        return Object.keys(e._reverseStreams || []).forEach(t => {
                            const n = e._reverseStreams[t], i = e._streams[n.id];
                            r = r.replace(new RegExp(n.id, "g"), i.id)
                        }), new RTCSessionDescription({type: t.type, sdp: r})
                    }(this, arguments[0]), s.apply(this, arguments)) : s.apply(this, arguments)
                };
                const a = Object.getOwnPropertyDescriptor(e.RTCPeerConnection.prototype, "localDescription");
                Object.defineProperty(e.RTCPeerConnection.prototype, "localDescription", {
                    get() {
                        const e = a.get.apply(this);
                        return "" === e.type ? e : o(this, e)
                    }
                }), e.RTCPeerConnection.prototype.removeTrack = function (e) {
                    if ("closed" === this.signalingState) throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
                    if (!e._pc) throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.", "TypeError");
                    if (e._pc !== this) throw new DOMException("Sender was not created by this connection.", "InvalidAccessError");
                    let t;
                    this._streams = this._streams || {}, Object.keys(this._streams).forEach(r => {
                        this._streams[r].getTracks().find(t => e.track === t) && (t = this._streams[r])
                    }), t && (1 === t.getTracks().length ? this.removeStream(this._reverseStreams[t.id]) : t.removeTrack(e.track), this.dispatchEvent(new Event("negotiationneeded")))
                }
            }

            function _l(e, t) {
                !e.RTCPeerConnection && e.webkitRTCPeerConnection && (e.RTCPeerConnection = e.webkitRTCPeerConnection), e.RTCPeerConnection && t.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function (t) {
                    const r = e.RTCPeerConnection.prototype[t], n = {
                        [t]() {
                            return arguments[0] = new ("addIceCandidate" === t ? e.RTCIceCandidate : e.RTCSessionDescription)(arguments[0]), r.apply(this, arguments)
                        }
                    };
                    e.RTCPeerConnection.prototype[t] = n[t]
                })
            }

            function vl(e, t) {
                Xr(e, "negotiationneeded", e => {
                    const r = e.target;
                    if (!(t.version < 72 || r.getConfiguration && "plan-b" === r.getConfiguration().sdpSemantics) || "stable" === r.signalingState) return e
                })
            }

            var gl = Object.freeze({
                __proto__: null,
                shimMediaStream: ul,
                shimOnTrack: dl,
                shimGetSendersWithDtmf: ll,
                shimGetStats: hl,
                shimSenderReceiverGetStats: pl,
                shimAddTrackRemoveTrackWithNative: fl,
                shimAddTrackRemoveTrack: ml,
                shimPeerConnection: _l,
                fixNegotiationNeeded: vl,
                shimGetUserMedia: cl,
                shimGetDisplayMedia: function (e, t) {
                    e.navigator.mediaDevices && "getDisplayMedia" in e.navigator.mediaDevices || e.navigator.mediaDevices && ("function" == typeof t ? e.navigator.mediaDevices.getDisplayMedia = function (r) {
                        return t(r).then(t => {
                            const n = r.video && r.video.width, i = r.video && r.video.height,
                                o = r.video && r.video.frameRate;
                            return r.video = {
                                mandatory: {
                                    chromeMediaSource: "desktop",
                                    chromeMediaSourceId: t,
                                    maxFrameRate: o || 3
                                }
                            }, n && (r.video.mandatory.maxWidth = n), i && (r.video.mandatory.maxHeight = i), e.navigator.mediaDevices.getUserMedia(r)
                        })
                    } : console.error("shimGetDisplayMedia: getSourceId argument is not a function"))
                }
            });

            function El(e, t) {
                const r = e && e.navigator, n = e && e.MediaStreamTrack;
                if (r.getUserMedia = function (e, t, n) {
                    en("navigator.getUserMedia", "navigator.mediaDevices.getUserMedia"), r.mediaDevices.getUserMedia(e).then(t, n)
                }, !(t.version > 55 && "autoGainControl" in r.mediaDevices.getSupportedConstraints())) {
                    const e = function (e, t, r) {
                        t in e && !(r in e) && (e[r] = e[t], delete e[t])
                    }, t = r.mediaDevices.getUserMedia.bind(r.mediaDevices);
                    if (r.mediaDevices.getUserMedia = function (r) {
                        return "object" == typeof r && "object" == typeof r.audio && (r = JSON.parse(JSON.stringify(r)), e(r.audio, "autoGainControl", "mozAutoGainControl"), e(r.audio, "noiseSuppression", "mozNoiseSuppression")), t(r)
                    }, n && n.prototype.getSettings) {
                        const t = n.prototype.getSettings;
                        n.prototype.getSettings = function () {
                            const r = t.apply(this, arguments);
                            return e(r, "mozAutoGainControl", "autoGainControl"), e(r, "mozNoiseSuppression", "noiseSuppression"), r
                        }
                    }
                    if (n && n.prototype.applyConstraints) {
                        const t = n.prototype.applyConstraints;
                        n.prototype.applyConstraints = function (r) {
                            return "audio" === this.kind && "object" == typeof r && (r = JSON.parse(JSON.stringify(r)), e(r, "autoGainControl", "mozAutoGainControl"), e(r, "noiseSuppression", "mozNoiseSuppression")), t.apply(this, [r])
                        }
                    }
                }
            }

            function yl(e) {
                "object" == typeof e && e.RTCTrackEvent && "receiver" in e.RTCTrackEvent.prototype && !("transceiver" in e.RTCTrackEvent.prototype) && Object.defineProperty(e.RTCTrackEvent.prototype, "transceiver", {
                    get() {
                        return {receiver: this.receiver}
                    }
                })
            }

            function Sl(e, t) {
                if ("object" != typeof e || !e.RTCPeerConnection && !e.mozRTCPeerConnection) return;
                !e.RTCPeerConnection && e.mozRTCPeerConnection && (e.RTCPeerConnection = e.mozRTCPeerConnection), t.version < 53 && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function (t) {
                    const r = e.RTCPeerConnection.prototype[t], n = {
                        [t]() {
                            return arguments[0] = new ("addIceCandidate" === t ? e.RTCIceCandidate : e.RTCSessionDescription)(arguments[0]), r.apply(this, arguments)
                        }
                    };
                    e.RTCPeerConnection.prototype[t] = n[t]
                });
                const r = {
                    inboundrtp: "inbound-rtp",
                    outboundrtp: "outbound-rtp",
                    candidatepair: "candidate-pair",
                    localcandidate: "local-candidate",
                    remotecandidate: "remote-candidate"
                }, n = e.RTCPeerConnection.prototype.getStats;
                e.RTCPeerConnection.prototype.getStats = function () {
                    const [e, i, o] = arguments;
                    return n.apply(this, [e || null]).then(e => {
                        if (t.version < 53 && !i) try {
                            e.forEach(e => {
                                e.type = r[e.type] || e.type
                            })
                        } catch (t) {
                            if ("TypeError" !== t.name) throw t;
                            e.forEach((t, n) => {
                                e.set(n, Object.assign({}, t, {type: r[t.type] || t.type}))
                            })
                        }
                        return e
                    }).then(i, o)
                }
            }

            function bl(e) {
                if ("object" != typeof e || !e.RTCPeerConnection || !e.RTCRtpSender) return;
                if (e.RTCRtpSender && "getStats" in e.RTCRtpSender.prototype) return;
                const t = e.RTCPeerConnection.prototype.getSenders;
                t && (e.RTCPeerConnection.prototype.getSenders = function () {
                    const e = t.apply(this, []);
                    return e.forEach(e => e._pc = this), e
                });
                const r = e.RTCPeerConnection.prototype.addTrack;
                r && (e.RTCPeerConnection.prototype.addTrack = function () {
                    const e = r.apply(this, arguments);
                    return e._pc = this, e
                }), e.RTCRtpSender.prototype.getStats = function () {
                    return this.track ? this._pc.getStats(this.track) : sl.resolve(new Map)
                }
            }

            function Tl(e) {
                if ("object" != typeof e || !e.RTCPeerConnection || !e.RTCRtpSender) return;
                if (e.RTCRtpSender && "getStats" in e.RTCRtpReceiver.prototype) return;
                const t = e.RTCPeerConnection.prototype.getReceivers;
                t && (e.RTCPeerConnection.prototype.getReceivers = function () {
                    const e = t.apply(this, []);
                    return e.forEach(e => e._pc = this), e
                }), Xr(e, "track", e => (e.receiver._pc = e.srcElement, e)), e.RTCRtpReceiver.prototype.getStats = function () {
                    return this._pc.getStats(this.track)
                }
            }

            function Rl(e) {
                e.RTCPeerConnection && !("removeStream" in e.RTCPeerConnection.prototype) && (e.RTCPeerConnection.prototype.removeStream = function (e) {
                    en("removeStream", "removeTrack"), this.getSenders().forEach(t => {
                        t.track && e.getTracks().includes(t.track) && this.removeTrack(t)
                    })
                })
            }

            function Il(e) {
                e.DataChannel && !e.RTCDataChannel && (e.RTCDataChannel = e.DataChannel)
            }

            function wl(e) {
                if ("object" != typeof e || !e.RTCPeerConnection) return;
                const t = e.RTCPeerConnection.prototype.addTransceiver;
                t && (e.RTCPeerConnection.prototype.addTransceiver = function () {
                    this.setParametersPromises = [];
                    let e = arguments[1] && arguments[1].sendEncodings;
                    void 0 === e && (e = []);
                    const r = (e = [...e]).length > 0;
                    r && e.forEach(e => {
                        if ("rid" in e && !/^[a-z0-9]{0,16}$/i.test(e.rid)) throw new TypeError("Invalid RID value provided.");
                        if ("scaleResolutionDownBy" in e && !(parseFloat(e.scaleResolutionDownBy) >= 1)) throw new RangeError("scale_resolution_down_by must be >= 1.0");
                        if ("maxFramerate" in e && !(parseFloat(e.maxFramerate) >= 0)) throw new RangeError("max_framerate must be >= 0.0")
                    });
                    const n = t.apply(this, arguments);
                    if (r) {
                        const {sender: t} = n, r = t.getParameters();
                        (!("encodings" in r) || 1 === r.encodings.length && 0 === Object.keys(r.encodings[0]).length) && (r.encodings = e, t.sendEncodings = e, this.setParametersPromises.push(t.setParameters(r).then(() => {
                            delete t.sendEncodings
                        }).catch(() => {
                            delete t.sendEncodings
                        })))
                    }
                    return n
                })
            }

            function Cl(e) {
                if ("object" != typeof e || !e.RTCRtpSender) return;
                const t = e.RTCRtpSender.prototype.getParameters;
                t && (e.RTCRtpSender.prototype.getParameters = function () {
                    const e = t.apply(this, arguments);
                    return "encodings" in e || (e.encodings = [].concat(this.sendEncodings || [{}])), e
                })
            }

            function Al(e) {
                if ("object" != typeof e || !e.RTCPeerConnection) return;
                const t = e.RTCPeerConnection.prototype.createOffer;
                e.RTCPeerConnection.prototype.createOffer = function () {
                    return this.setParametersPromises && this.setParametersPromises.length ? sl.all(this.setParametersPromises).then(() => t.apply(this, arguments)).finally(() => {
                        this.setParametersPromises = []
                    }) : t.apply(this, arguments)
                }
            }

            function Ol(e) {
                if ("object" != typeof e || !e.RTCPeerConnection) return;
                const t = e.RTCPeerConnection.prototype.createAnswer;
                e.RTCPeerConnection.prototype.createAnswer = function () {
                    return this.setParametersPromises && this.setParametersPromises.length ? sl.all(this.setParametersPromises).then(() => t.apply(this, arguments)).finally(() => {
                        this.setParametersPromises = []
                    }) : t.apply(this, arguments)
                }
            }

            var Nl = Object.freeze({
                __proto__: null,
                shimOnTrack: yl,
                shimPeerConnection: Sl,
                shimSenderGetStats: bl,
                shimReceiverGetStats: Tl,
                shimRemoveStream: Rl,
                shimRTCDataChannel: Il,
                shimAddTransceiver: wl,
                shimGetParameters: Cl,
                shimCreateOffer: Al,
                shimCreateAnswer: Ol,
                shimGetUserMedia: El,
                shimGetDisplayMedia: function (e, t) {
                    e.navigator.mediaDevices && "getDisplayMedia" in e.navigator.mediaDevices || e.navigator.mediaDevices && (e.navigator.mediaDevices.getDisplayMedia = function (r) {
                        if (!r || !r.video) {
                            const e = new DOMException("getDisplayMedia without video constraints is undefined");
                            return e.name = "NotFoundError", e.code = 8, sl.reject(e)
                        }
                        return !0 === r.video ? r.video = {mediaSource: t} : r.video.mediaSource = t, e.navigator.mediaDevices.getUserMedia(r)
                    })
                }
            });

            function Pl(e) {
                if ("object" == typeof e && e.RTCPeerConnection) {
                    if ("getLocalStreams" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.getLocalStreams = function () {
                        return this._localStreams || (this._localStreams = []), this._localStreams
                    }), !("addStream" in e.RTCPeerConnection.prototype)) {
                        const t = e.RTCPeerConnection.prototype.addTrack;
                        e.RTCPeerConnection.prototype.addStream = function (e) {
                            this._localStreams || (this._localStreams = []), this._localStreams.includes(e) || this._localStreams.push(e), e.getAudioTracks().forEach(r => t.call(this, r, e)), e.getVideoTracks().forEach(r => t.call(this, r, e))
                        }, e.RTCPeerConnection.prototype.addTrack = function (e) {
                            for (var r = arguments.length, n = new Array(r > 1 ? r - 1 : 0), i = 1; i < r; i++) n[i - 1] = arguments[i];
                            return n && n.forEach(e => {
                                this._localStreams ? this._localStreams.includes(e) || this._localStreams.push(e) : this._localStreams = [e]
                            }), t.apply(this, arguments)
                        }
                    }
                    "removeStream" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.removeStream = function (e) {
                        this._localStreams || (this._localStreams = []);
                        const t = this._localStreams.indexOf(e);
                        if (-1 === t) return;
                        this._localStreams.splice(t, 1);
                        const r = e.getTracks();
                        this.getSenders().forEach(e => {
                            r.includes(e.track) && this.removeTrack(e)
                        })
                    })
                }
            }

            function Dl(e) {
                if ("object" == typeof e && e.RTCPeerConnection && ("getRemoteStreams" in e.RTCPeerConnection.prototype || (e.RTCPeerConnection.prototype.getRemoteStreams = function () {
                    return this._remoteStreams ? this._remoteStreams : []
                }), !("onaddstream" in e.RTCPeerConnection.prototype))) {
                    Object.defineProperty(e.RTCPeerConnection.prototype, "onaddstream", {
                        get() {
                            return this._onaddstream
                        }, set(e) {
                            this._onaddstream && (this.removeEventListener("addstream", this._onaddstream), this.removeEventListener("track", this._onaddstreampoly)), this.addEventListener("addstream", this._onaddstream = e), this.addEventListener("track", this._onaddstreampoly = (e => {
                                e.streams.forEach(e => {
                                    if (this._remoteStreams || (this._remoteStreams = []), this._remoteStreams.includes(e)) return;
                                    this._remoteStreams.push(e);
                                    const t = new Event("addstream");
                                    t.stream = e, this.dispatchEvent(t)
                                })
                            }))
                        }
                    });
                    const t = e.RTCPeerConnection.prototype.setRemoteDescription;
                    e.RTCPeerConnection.prototype.setRemoteDescription = function () {
                        const e = this;
                        return this._onaddstreampoly || this.addEventListener("track", this._onaddstreampoly = function (t) {
                            t.streams.forEach(t => {
                                if (e._remoteStreams || (e._remoteStreams = []), e._remoteStreams.indexOf(t) >= 0) return;
                                e._remoteStreams.push(t);
                                const r = new Event("addstream");
                                r.stream = t, e.dispatchEvent(r)
                            })
                        }), t.apply(e, arguments)
                    }
                }
            }

            function kl(e) {
                if ("object" != typeof e || !e.RTCPeerConnection) return;
                const t = e.RTCPeerConnection.prototype, r = t.createOffer, n = t.createAnswer,
                    i = t.setLocalDescription, o = t.setRemoteDescription, s = t.addIceCandidate;
                t.createOffer = function (e, t) {
                    const n = arguments.length >= 2 ? arguments[2] : arguments[0], i = r.apply(this, [n]);
                    return t ? (i.then(e, t), sl.resolve()) : i
                }, t.createAnswer = function (e, t) {
                    const r = arguments.length >= 2 ? arguments[2] : arguments[0], i = n.apply(this, [r]);
                    return t ? (i.then(e, t), sl.resolve()) : i
                };
                let a = function (e, t, r) {
                    const n = i.apply(this, [e]);
                    return r ? (n.then(t, r), sl.resolve()) : n
                };
                t.setLocalDescription = a, a = function (e, t, r) {
                    const n = o.apply(this, [e]);
                    return r ? (n.then(t, r), sl.resolve()) : n
                }, t.setRemoteDescription = a, a = function (e, t, r) {
                    const n = s.apply(this, [e]);
                    return r ? (n.then(t, r), sl.resolve()) : n
                }, t.addIceCandidate = a
            }

            function Ll(e) {
                const t = e && e.navigator;
                if (t.mediaDevices && t.mediaDevices.getUserMedia) {
                    const e = t.mediaDevices, r = e.getUserMedia.bind(e);
                    t.mediaDevices.getUserMedia = (e => r(xl(e)))
                }
                !t.getUserMedia && t.mediaDevices && t.mediaDevices.getUserMedia && (t.getUserMedia = function (e, r, n) {
                    t.mediaDevices.getUserMedia(e).then(r, n)
                }.bind(t))
            }

            function xl(e) {
                return e && void 0 !== e.video ? Object.assign({}, e, {
                    video: function e(t) {
                        var r;
                        return tn(t) ? Kr(r = Object.keys(t)).call(r, function (r, n) {
                            const i = tn(t[n]), o = i ? e(t[n]) : t[n], s = i && !Object.keys(o).length;
                            return void 0 === o || s ? r : Object.assign(r, {[n]: o})
                        }, {}) : t
                    }(e.video)
                }) : e
            }

            function Ml(e) {
                if (!e.RTCPeerConnection) return;
                const t = e.RTCPeerConnection;
                e.RTCPeerConnection = function (e, r) {
                    if (e && e.iceServers) {
                        const t = [];
                        for (let r = 0; r < e.iceServers.length; r++) {
                            let n = e.iceServers[r];
                            !n.hasOwnProperty("urls") && n.hasOwnProperty("url") ? (en("RTCIceServer.url", "RTCIceServer.urls"), (n = JSON.parse(JSON.stringify(n))).urls = n.url, delete n.url, t.push(n)) : t.push(e.iceServers[r])
                        }
                        e.iceServers = t
                    }
                    return new t(e, r)
                }, e.RTCPeerConnection.prototype = t.prototype, "generateCertificate" in t && Object.defineProperty(e.RTCPeerConnection, "generateCertificate", {get: () => t.generateCertificate})
            }

            function Ul(e) {
                "object" == typeof e && e.RTCTrackEvent && "receiver" in e.RTCTrackEvent.prototype && !("transceiver" in e.RTCTrackEvent.prototype) && Object.defineProperty(e.RTCTrackEvent.prototype, "transceiver", {
                    get() {
                        return {receiver: this.receiver}
                    }
                })
            }

            function jl(e) {
                const t = e.RTCPeerConnection.prototype.createOffer;
                e.RTCPeerConnection.prototype.createOffer = function (e) {
                    if (e) {
                        void 0 !== e.offerToReceiveAudio && (e.offerToReceiveAudio = !!e.offerToReceiveAudio);
                        const t = this.getTransceivers().find(e => "audio" === e.receiver.track.kind);
                        !1 === e.offerToReceiveAudio && t ? "sendrecv" === t.direction ? t.setDirection ? t.setDirection("sendonly") : t.direction = "sendonly" : "recvonly" === t.direction && (t.setDirection ? t.setDirection("inactive") : t.direction = "inactive") : !0 !== e.offerToReceiveAudio || t || this.addTransceiver("audio", {direction: "recvonly"}), void 0 !== e.offerToReceiveVideo && (e.offerToReceiveVideo = !!e.offerToReceiveVideo);
                        const r = this.getTransceivers().find(e => "video" === e.receiver.track.kind);
                        !1 === e.offerToReceiveVideo && r ? "sendrecv" === r.direction ? r.setDirection ? r.setDirection("sendonly") : r.direction = "sendonly" : "recvonly" === r.direction && (r.setDirection ? r.setDirection("inactive") : r.direction = "inactive") : !0 !== e.offerToReceiveVideo || r || this.addTransceiver("video", {direction: "recvonly"})
                    }
                    return t.apply(this, arguments)
                }
            }

            function Vl(e) {
                "object" != typeof e || e.AudioContext || (e.AudioContext = e.webkitAudioContext)
            }

            var Fl = Object.freeze({
                    __proto__: null,
                    shimLocalStreamsAPI: Pl,
                    shimRemoteStreamsAPI: Dl,
                    shimCallbacksAPI: kl,
                    shimGetUserMedia: Ll,
                    shimConstraints: xl,
                    shimRTCIceServerUrls: Ml,
                    shimTrackEventTransceiver: Ul,
                    shimCreateOfferLegacy: jl,
                    shimAudioContext: Vl
                }), Bl = q, Wl = wo, Gl = l("".replace),
                ql = "[\t\n\v\f\r  ???????????????????????????\u2028\u2029\ufeff]",
                Hl = RegExp("^" + ql + ql + "*"), Kl = RegExp(ql + ql + "*$"), zl = function (e) {
                    return function (t) {
                        var r = Wl(Bl(t));
                        return 1 & e && (r = Gl(r, Hl, "")), 2 & e && (r = Gl(r, Kl, "")), r
                    }
                }, Yl = {start: zl(1), end: zl(2), trim: zl(3)}, Jl = Cs.PROPER, Xl = i,
                Ql = "\t\n\v\f\r  ???????????????????????????\u2028\u2029\ufeff", $l = Yl.trim;
            Er({
                target: "String", proto: !0, forced: function (e) {
                    return Xl(function () {
                        return !!Ql[e]() || "??? ?" !== "??? ?"[e]() || Jl && Ql[e].name !== e
                    })
                }("trim")
            }, {
                trim: function () {
                    return $l(this)
                }
            });
            var Zl = Fr("String").trim, eh = h, th = Zl, rh = String.prototype, nh = function (e) {
                var t = e.trim;
                return "string" == typeof e || e === rh || eh(rh, e) && t === rh.trim ? th : t
            }, ih = {exports: {}};
            !function (e) {
                const t = {
                    generateIdentifier: function () {
                        return Math.random().toString(36).substr(2, 10)
                    }
                };
                t.localCName = t.generateIdentifier(), t.splitLines = function (e) {
                    return nh(e).call(e).split("\n").map(e => nh(e).call(e))
                }, t.splitSections = function (e) {
                    return e.split("\nm=").map((e, t) => {
                        var r;
                        return nh(r = t > 0 ? "m=" + e : e).call(r) + "\r\n"
                    })
                }, t.getDescription = function (e) {
                    const r = t.splitSections(e);
                    return r && r[0]
                }, t.getMediaSections = function (e) {
                    const r = t.splitSections(e);
                    return r.shift(), r
                }, t.matchPrefix = function (e, r) {
                    return t.splitLines(e).filter(e => 0 === e.indexOf(r))
                }, t.parseCandidate = function (e) {
                    let t;
                    const r = {
                        foundation: (t = 0 === e.indexOf("a=candidate:") ? e.substring(12).split(" ") : e.substring(10).split(" "))[0],
                        component: {1: "rtp", 2: "rtcp"}[t[1]] || t[1],
                        protocol: t[2].toLowerCase(),
                        priority: parseInt(t[3], 10),
                        ip: t[4],
                        address: t[4],
                        port: parseInt(t[5], 10),
                        type: t[7]
                    };
                    for (let e = 8; e < t.length; e += 2) switch (t[e]) {
                        case"raddr":
                            r.relatedAddress = t[e + 1];
                            break;
                        case"rport":
                            r.relatedPort = parseInt(t[e + 1], 10);
                            break;
                        case"tcptype":
                            r.tcpType = t[e + 1];
                            break;
                        case"ufrag":
                            r.ufrag = t[e + 1], r.usernameFragment = t[e + 1];
                            break;
                        default:
                            void 0 === r[t[e]] && (r[t[e]] = t[e + 1])
                    }
                    return r
                }, t.writeCandidate = function (e) {
                    const t = [];
                    t.push(e.foundation);
                    const r = e.component;
                    "rtp" === r ? t.push(1) : "rtcp" === r ? t.push(2) : t.push(r), t.push(e.protocol.toUpperCase()), t.push(e.priority), t.push(e.address || e.ip), t.push(e.port);
                    const n = e.type;
                    return t.push("typ"), t.push(n), "host" !== n && e.relatedAddress && e.relatedPort && (t.push("raddr"), t.push(e.relatedAddress), t.push("rport"), t.push(e.relatedPort)), e.tcpType && "tcp" === e.protocol.toLowerCase() && (t.push("tcptype"), t.push(e.tcpType)), (e.usernameFragment || e.ufrag) && (t.push("ufrag"), t.push(e.usernameFragment || e.ufrag)), "candidate:" + t.join(" ")
                }, t.parseIceOptions = function (e) {
                    return e.substr(14).split(" ")
                }, t.parseRtpMap = function (e) {
                    let t = e.substr(9).split(" ");
                    const r = {payloadType: parseInt(t.shift(), 10)};
                    return t = t[0].split("/"), r.name = t[0], r.clockRate = parseInt(t[1], 10), r.channels = 3 === t.length ? parseInt(t[2], 10) : 1, r.numChannels = r.channels, r
                }, t.writeRtpMap = function (e) {
                    let t = e.payloadType;
                    void 0 !== e.preferredPayloadType && (t = e.preferredPayloadType);
                    const r = e.channels || e.numChannels || 1;
                    return "a=rtpmap:" + t + " " + e.name + "/" + e.clockRate + (1 !== r ? "/" + r : "") + "\r\n"
                }, t.parseExtmap = function (e) {
                    const t = e.substr(9).split(" ");
                    return {
                        id: parseInt(t[0], 10),
                        direction: t[0].indexOf("/") > 0 ? t[0].split("/")[1] : "sendrecv",
                        uri: t[1]
                    }
                }, t.writeExtmap = function (e) {
                    return "a=extmap:" + (e.id || e.preferredId) + (e.direction && "sendrecv" !== e.direction ? "/" + e.direction : "") + " " + e.uri + "\r\n"
                }, t.parseFmtp = function (e) {
                    const t = {};
                    let r;
                    const n = e.substr(e.indexOf(" ") + 1).split(";");
                    for (let e = 0; e < n.length; e++) {
                        var i, o;
                        r = nh(i = n[e]).call(i).split("="), t[nh(o = r[0]).call(o)] = r[1]
                    }
                    return t
                }, t.writeFmtp = function (e) {
                    let t = "", r = e.payloadType;
                    if (void 0 !== e.preferredPayloadType && (r = e.preferredPayloadType), e.parameters && Object.keys(e.parameters).length) {
                        const n = [];
                        Object.keys(e.parameters).forEach(t => {
                            void 0 !== e.parameters[t] ? n.push(t + "=" + e.parameters[t]) : n.push(t)
                        }), t += "a=fmtp:" + r + " " + n.join(";") + "\r\n"
                    }
                    return t
                }, t.parseRtcpFb = function (e) {
                    const t = e.substr(e.indexOf(" ") + 1).split(" ");
                    return {type: t.shift(), parameter: t.join(" ")}
                }, t.writeRtcpFb = function (e) {
                    let t = "", r = e.payloadType;
                    return void 0 !== e.preferredPayloadType && (r = e.preferredPayloadType), e.rtcpFeedback && e.rtcpFeedback.length && e.rtcpFeedback.forEach(e => {
                        t += "a=rtcp-fb:" + r + " " + e.type + (e.parameter && e.parameter.length ? " " + e.parameter : "") + "\r\n"
                    }), t
                }, t.parseSsrcMedia = function (e) {
                    const t = e.indexOf(" "), r = {ssrc: parseInt(e.substr(7, t - 7), 10)}, n = e.indexOf(":", t);
                    return n > -1 ? (r.attribute = e.substr(t + 1, n - t - 1), r.value = e.substr(n + 1)) : r.attribute = e.substr(t + 1), r
                }, t.parseSsrcGroup = function (e) {
                    const t = e.substr(13).split(" ");
                    return {semantics: t.shift(), ssrcs: t.map(e => parseInt(e, 10))}
                }, t.getMid = function (e) {
                    const r = t.matchPrefix(e, "a=mid:")[0];
                    if (r) return r.substr(6)
                }, t.parseFingerprint = function (e) {
                    const t = e.substr(14).split(" ");
                    return {algorithm: t[0].toLowerCase(), value: t[1].toUpperCase()}
                }, t.getDtlsParameters = function (e, r) {
                    return {role: "auto", fingerprints: t.matchPrefix(e + r, "a=fingerprint:").map(t.parseFingerprint)}
                }, t.writeDtlsParameters = function (e, t) {
                    let r = "a=setup:" + t + "\r\n";
                    return e.fingerprints.forEach(e => {
                        r += "a=fingerprint:" + e.algorithm + " " + e.value + "\r\n"
                    }), r
                }, t.parseCryptoLine = function (e) {
                    const t = e.substr(9).split(" ");
                    return {tag: parseInt(t[0], 10), cryptoSuite: t[1], keyParams: t[2], sessionParams: t.slice(3)}
                }, t.writeCryptoLine = function (e) {
                    return "a=crypto:" + e.tag + " " + e.cryptoSuite + " " + ("object" == typeof e.keyParams ? t.writeCryptoKeyParams(e.keyParams) : e.keyParams) + (e.sessionParams ? " " + e.sessionParams.join(" ") : "") + "\r\n"
                }, t.parseCryptoKeyParams = function (e) {
                    if (0 !== e.indexOf("inline:")) return null;
                    const t = e.substr(7).split("|");
                    return {
                        keyMethod: "inline",
                        keySalt: t[0],
                        lifeTime: t[1],
                        mkiValue: t[2] ? t[2].split(":")[0] : void 0,
                        mkiLength: t[2] ? t[2].split(":")[1] : void 0
                    }
                }, t.writeCryptoKeyParams = function (e) {
                    return e.keyMethod + ":" + e.keySalt + (e.lifeTime ? "|" + e.lifeTime : "") + (e.mkiValue && e.mkiLength ? "|" + e.mkiValue + ":" + e.mkiLength : "")
                }, t.getCryptoParameters = function (e, r) {
                    return t.matchPrefix(e + r, "a=crypto:").map(t.parseCryptoLine)
                }, t.getIceParameters = function (e, r) {
                    const n = t.matchPrefix(e + r, "a=ice-ufrag:")[0], i = t.matchPrefix(e + r, "a=ice-pwd:")[0];
                    return n && i ? {usernameFragment: n.substr(12), password: i.substr(10)} : null
                }, t.writeIceParameters = function (e) {
                    let t = "a=ice-ufrag:" + e.usernameFragment + "\r\na=ice-pwd:" + e.password + "\r\n";
                    return e.iceLite && (t += "a=ice-lite\r\n"), t
                }, t.parseRtpParameters = function (e) {
                    const r = {codecs: [], headerExtensions: [], fecMechanisms: [], rtcp: []},
                        n = t.splitLines(e)[0].split(" ");
                    for (let i = 3; i < n.length; i++) {
                        const o = n[i], s = t.matchPrefix(e, "a=rtpmap:" + o + " ")[0];
                        if (s) {
                            const n = t.parseRtpMap(s), i = t.matchPrefix(e, "a=fmtp:" + o + " ");
                            switch (n.parameters = i.length ? t.parseFmtp(i[0]) : {}, n.rtcpFeedback = t.matchPrefix(e, "a=rtcp-fb:" + o + " ").map(t.parseRtcpFb), r.codecs.push(n), n.name.toUpperCase()) {
                                case"RED":
                                case"ULPFEC":
                                    r.fecMechanisms.push(n.name.toUpperCase())
                            }
                        }
                    }
                    return t.matchPrefix(e, "a=extmap:").forEach(e => {
                        r.headerExtensions.push(t.parseExtmap(e))
                    }), r
                }, t.writeRtpDescription = function (e, r) {
                    let n = "";
                    n += "m=" + e + " ", n += r.codecs.length > 0 ? "9" : "0", n += " UDP/TLS/RTP/SAVPF ", n += r.codecs.map(e => void 0 !== e.preferredPayloadType ? e.preferredPayloadType : e.payloadType).join(" ") + "\r\n", n += "c=IN IP4 0.0.0.0\r\n", n += "a=rtcp:9 IN IP4 0.0.0.0\r\n", r.codecs.forEach(e => {
                        n += t.writeRtpMap(e), n += t.writeFmtp(e), n += t.writeRtcpFb(e)
                    });
                    let i = 0;
                    return r.codecs.forEach(e => {
                        e.maxptime > i && (i = e.maxptime)
                    }), i > 0 && (n += "a=maxptime:" + i + "\r\n"), r.headerExtensions && r.headerExtensions.forEach(e => {
                        n += t.writeExtmap(e)
                    }), n
                }, t.parseRtpEncodingParameters = function (e) {
                    const r = [], n = t.parseRtpParameters(e), i = -1 !== n.fecMechanisms.indexOf("RED"),
                        o = -1 !== n.fecMechanisms.indexOf("ULPFEC"),
                        s = t.matchPrefix(e, "a=ssrc:").map(e => t.parseSsrcMedia(e)).filter(e => "cname" === e.attribute),
                        a = s.length > 0 && s[0].ssrc;
                    let c;
                    const u = t.matchPrefix(e, "a=ssrc-group:FID").map(e => e.substr(17).split(" ").map(e => parseInt(e, 10)));
                    u.length > 0 && u[0].length > 1 && u[0][0] === a && (c = u[0][1]), n.codecs.forEach(e => {
                        if ("RTX" === e.name.toUpperCase() && e.parameters.apt) {
                            let t = {ssrc: a, codecPayloadType: parseInt(e.parameters.apt, 10)};
                            a && c && (t.rtx = {ssrc: c}), r.push(t), i && ((t = JSON.parse(JSON.stringify(t))).fec = {
                                ssrc: a,
                                mechanism: o ? "red+ulpfec" : "red"
                            }, r.push(t))
                        }
                    }), 0 === r.length && a && r.push({ssrc: a});
                    let d = t.matchPrefix(e, "b=");
                    return d.length && (d = 0 === d[0].indexOf("b=TIAS:") ? parseInt(d[0].substr(7), 10) : 0 === d[0].indexOf("b=AS:") ? 1e3 * parseInt(d[0].substr(5), 10) * .95 - 16e3 : void 0, r.forEach(e => {
                        e.maxBitrate = d
                    })), r
                }, t.parseRtcpParameters = function (e) {
                    const r = {},
                        n = t.matchPrefix(e, "a=ssrc:").map(e => t.parseSsrcMedia(e)).filter(e => "cname" === e.attribute)[0];
                    n && (r.cname = n.value, r.ssrc = n.ssrc);
                    const i = t.matchPrefix(e, "a=rtcp-rsize");
                    r.reducedSize = i.length > 0, r.compound = 0 === i.length;
                    const o = t.matchPrefix(e, "a=rtcp-mux");
                    return r.mux = o.length > 0, r
                }, t.writeRtcpParameters = function (e) {
                    let t = "";
                    return e.reducedSize && (t += "a=rtcp-rsize\r\n"), e.mux && (t += "a=rtcp-mux\r\n"), void 0 !== e.ssrc && e.cname && (t += "a=ssrc:" + e.ssrc + " cname:" + e.cname + "\r\n"), t
                }, t.parseMsid = function (e) {
                    let r;
                    const n = t.matchPrefix(e, "a=msid:");
                    if (1 === n.length) return {stream: (r = n[0].substr(7).split(" "))[0], track: r[1]};
                    const i = t.matchPrefix(e, "a=ssrc:").map(e => t.parseSsrcMedia(e)).filter(e => "msid" === e.attribute);
                    return i.length > 0 ? {stream: (r = i[0].value.split(" "))[0], track: r[1]} : void 0
                }, t.parseSctpDescription = function (e) {
                    const r = t.parseMLine(e), n = t.matchPrefix(e, "a=max-message-size:");
                    let i;
                    n.length > 0 && (i = parseInt(n[0].substr(19), 10)), isNaN(i) && (i = 65536);
                    const o = t.matchPrefix(e, "a=sctp-port:");
                    if (o.length > 0) return {port: parseInt(o[0].substr(12), 10), protocol: r.fmt, maxMessageSize: i};
                    const s = t.matchPrefix(e, "a=sctpmap:");
                    if (s.length > 0) {
                        const e = s[0].substr(10).split(" ");
                        return {port: parseInt(e[0], 10), protocol: e[1], maxMessageSize: i}
                    }
                }, t.writeSctpDescription = function (e, t) {
                    let r = [];
                    return r = "DTLS/SCTP" !== e.protocol ? ["m=" + e.kind + " 9 " + e.protocol + " " + t.protocol + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctp-port:" + t.port + "\r\n"] : ["m=" + e.kind + " 9 " + e.protocol + " " + t.port + "\r\n", "c=IN IP4 0.0.0.0\r\n", "a=sctpmap:" + t.port + " " + t.protocol + " 65535\r\n"], void 0 !== t.maxMessageSize && r.push("a=max-message-size:" + t.maxMessageSize + "\r\n"), r.join("")
                }, t.generateSessionId = function () {
                    return Math.random().toString().substr(2, 21)
                }, t.writeSessionBoilerplate = function (e, r, n) {
                    let i;
                    const o = void 0 !== r ? r : 2;
                    return i = e || t.generateSessionId(), "v=0\r\no=" + (n || "thisisadapterortc") + " " + i + " " + o + " IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\n"
                }, t.getDirection = function (e, r) {
                    const n = t.splitLines(e);
                    for (let e = 0; e < n.length; e++) switch (n[e]) {
                        case"a=sendrecv":
                        case"a=sendonly":
                        case"a=recvonly":
                        case"a=inactive":
                            return n[e].substr(2)
                    }
                    return r ? t.getDirection(r) : "sendrecv"
                }, t.getKind = function (e) {
                    return t.splitLines(e)[0].split(" ")[0].substr(2)
                }, t.isRejected = function (e) {
                    return "0" === e.split(" ", 2)[1]
                }, t.parseMLine = function (e) {
                    const r = t.splitLines(e)[0].substr(2).split(" ");
                    return {kind: r[0], port: parseInt(r[1], 10), protocol: r[2], fmt: r.slice(3).join(" ")}
                }, t.parseOLine = function (e) {
                    const r = t.matchPrefix(e, "o=")[0].substr(2).split(" ");
                    return {
                        username: r[0],
                        sessionId: r[1],
                        sessionVersion: parseInt(r[2], 10),
                        netType: r[3],
                        addressType: r[4],
                        address: r[5]
                    }
                }, t.isValidSDP = function (e) {
                    if ("string" != typeof e || 0 === e.length) return !1;
                    const r = t.splitLines(e);
                    for (let e = 0; e < r.length; e++) if (r[e].length < 2 || "=" !== r[e].charAt(1)) return !1;
                    return !0
                }, e.exports = t
            }(ih);
            var oh = ih.exports, sh = Object.freeze(function (e, t) {
                return t.forEach(function (t) {
                    t && "string" != typeof t && !Array.isArray(t) && Object.keys(t).forEach(function (r) {
                        if ("default" !== r && !(r in e)) {
                            var n = Object.getOwnPropertyDescriptor(t, r);
                            Object.defineProperty(e, r, n.get ? n : {
                                enumerable: !0, get: function () {
                                    return t[r]
                                }
                            })
                        }
                    })
                }), Object.freeze(e)
            }({__proto__: null, default: oh}, [ih.exports]));

            function ah(e) {
                if (!e.RTCIceCandidate || e.RTCIceCandidate && "foundation" in e.RTCIceCandidate.prototype) return;
                const t = e.RTCIceCandidate;
                e.RTCIceCandidate = function (e) {
                    if ("object" == typeof e && e.candidate && 0 === e.candidate.indexOf("a=") && ((e = JSON.parse(JSON.stringify(e))).candidate = e.candidate.substr(2)), e.candidate && e.candidate.length) {
                        const r = new t(e), n = oh.parseCandidate(e.candidate), i = Object.assign(r, n);
                        return i.toJSON = function () {
                            return {
                                candidate: i.candidate,
                                sdpMid: i.sdpMid,
                                sdpMLineIndex: i.sdpMLineIndex,
                                usernameFragment: i.usernameFragment
                            }
                        }, i
                    }
                    return new t(e)
                }, e.RTCIceCandidate.prototype = t.prototype, Xr(e, "icecandidate", t => (t.candidate && Object.defineProperty(t, "candidate", {
                    value: new e.RTCIceCandidate(t.candidate),
                    writable: "false"
                }), t))
            }

            function ch(e) {
                !e.RTCIceCandidate || e.RTCIceCandidate && "relayProtocol" in e.RTCIceCandidate.prototype || Xr(e, "icecandidate", e => {
                    if (e.candidate) {
                        const t = oh.parseCandidate(e.candidate.candidate);
                        "relay" === t.type && (e.candidate.relayProtocol = {
                            0: "tls",
                            1: "tcp",
                            2: "udp"
                        }[t.priority >> 24])
                    }
                    return e
                })
            }

            function uh(e, t) {
                if (!e.RTCPeerConnection) return;
                "sctp" in e.RTCPeerConnection.prototype || Object.defineProperty(e.RTCPeerConnection.prototype, "sctp", {
                    get() {
                        return void 0 === this._sctp ? null : this._sctp
                    }
                });
                const r = function (e) {
                    let r = 65536;
                    return "firefox" === t.browser && (r = t.version < 57 ? -1 === e ? 16384 : 2147483637 : t.version < 60 ? 57 === t.version ? 65535 : 65536 : 2147483637), r
                }, n = function (e, r) {
                    let n = 65536;
                    "firefox" === t.browser && 57 === t.version && (n = 65535);
                    const i = oh.matchPrefix(e.sdp, "a=max-message-size:");
                    return i.length > 0 ? n = parseInt(i[0].substr(19), 10) : "firefox" === t.browser && -1 !== r && (n = 2147483637), n
                }, i = e.RTCPeerConnection.prototype.setRemoteDescription;
                e.RTCPeerConnection.prototype.setRemoteDescription = function () {
                    if (this._sctp = null, "chrome" === t.browser && t.version >= 76) {
                        const {sdpSemantics: e} = this.getConfiguration();
                        "plan-b" === e && Object.defineProperty(this, "sctp", {
                            get() {
                                return void 0 === this._sctp ? null : this._sctp
                            }, enumerable: !0, configurable: !0
                        })
                    }
                    if (function (e) {
                        if (!e || !e.sdp) return !1;
                        const t = oh.splitSections(e.sdp);
                        return t.shift(), t.some(e => {
                            const t = oh.parseMLine(e);
                            return t && "application" === t.kind && -1 !== t.protocol.indexOf("SCTP")
                        })
                    }(arguments[0])) {
                        const e = function (e) {
                            const t = e.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
                            if (null === t || t.length < 2) return -1;
                            const r = parseInt(t[1], 10);
                            return r != r ? -1 : r
                        }(arguments[0]), t = r(e), i = n(arguments[0], e);
                        let o;
                        o = 0 === t && 0 === i ? Number.POSITIVE_INFINITY : 0 === t || 0 === i ? Math.max(t, i) : Math.min(t, i);
                        const s = {};
                        Object.defineProperty(s, "maxMessageSize", {get: () => o}), this._sctp = s
                    }
                    return i.apply(this, arguments)
                }
            }

            function dh(e) {
                if (!(e.RTCPeerConnection && "createDataChannel" in e.RTCPeerConnection.prototype)) return;

                function t(e, t) {
                    const r = e.send;
                    e.send = function () {
                        const n = arguments[0], i = n.length || n.size || n.byteLength;
                        if ("open" === e.readyState && t.sctp && i > t.sctp.maxMessageSize) throw new TypeError("Message too large (can send a maximum of " + t.sctp.maxMessageSize + " bytes)");
                        return r.apply(e, arguments)
                    }
                }

                const r = e.RTCPeerConnection.prototype.createDataChannel;
                e.RTCPeerConnection.prototype.createDataChannel = function () {
                    const e = r.apply(this, arguments);
                    return t(e, this), e
                }, Xr(e, "datachannel", e => (t(e.channel, e.target), e))
            }

            function lh(e) {
                if (!e.RTCPeerConnection || "connectionState" in e.RTCPeerConnection.prototype) return;
                const t = e.RTCPeerConnection.prototype;
                Object.defineProperty(t, "connectionState", {
                    get() {
                        return {
                            completed: "connected",
                            checking: "connecting"
                        }[this.iceConnectionState] || this.iceConnectionState
                    }, enumerable: !0, configurable: !0
                }), Object.defineProperty(t, "onconnectionstatechange", {
                    get() {
                        return this._onconnectionstatechange || null
                    }, set(e) {
                        this._onconnectionstatechange && (this.removeEventListener("connectionstatechange", this._onconnectionstatechange), delete this._onconnectionstatechange), e && this.addEventListener("connectionstatechange", this._onconnectionstatechange = e)
                    }, enumerable: !0, configurable: !0
                }), ["setLocalDescription", "setRemoteDescription"].forEach(e => {
                    const r = t[e];
                    t[e] = function () {
                        return this._connectionstatechangepoly || (this._connectionstatechangepoly = (e => {
                            const t = e.target;
                            if (t._lastConnectionState !== t.connectionState) {
                                t._lastConnectionState = t.connectionState;
                                const r = new Event("connectionstatechange", e);
                                t.dispatchEvent(r)
                            }
                            return e
                        }), this.addEventListener("iceconnectionstatechange", this._connectionstatechangepoly)), r.apply(this, arguments)
                    }
                })
            }

            function hh(e, t) {
                if (!e.RTCPeerConnection) return;
                if ("chrome" === t.browser && t.version >= 71) return;
                if ("safari" === t.browser && t.version >= 605) return;
                const r = e.RTCPeerConnection.prototype.setRemoteDescription;
                e.RTCPeerConnection.prototype.setRemoteDescription = function (t) {
                    if (t && t.sdp && -1 !== t.sdp.indexOf("\na=extmap-allow-mixed")) {
                        const r = t.sdp.split("\n").filter(e => "a=extmap-allow-mixed" !== nh(e).call(e)).join("\n");
                        e.RTCSessionDescription && t instanceof e.RTCSessionDescription ? arguments[0] = new e.RTCSessionDescription({
                            type: t.type,
                            sdp: r
                        }) : t.sdp = r
                    }
                    return r.apply(this, arguments)
                }
            }

            function ph(e, t) {
                if (!e.RTCPeerConnection || !e.RTCPeerConnection.prototype) return;
                const r = e.RTCPeerConnection.prototype.addIceCandidate;
                r && 0 !== r.length && (e.RTCPeerConnection.prototype.addIceCandidate = function () {
                    return arguments[0] ? ("chrome" === t.browser && t.version < 78 || "firefox" === t.browser && t.version < 68 || "safari" === t.browser) && arguments[0] && "" === arguments[0].candidate ? sl.resolve() : r.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), sl.resolve())
                })
            }

            function fh(e, t) {
                if (!e.RTCPeerConnection || !e.RTCPeerConnection.prototype) return;
                const r = e.RTCPeerConnection.prototype.setLocalDescription;
                r && 0 !== r.length && (e.RTCPeerConnection.prototype.setLocalDescription = function () {
                    let e = arguments[0] || {};
                    if ("object" != typeof e || e.type && e.sdp) return r.apply(this, arguments);
                    if (!(e = {type: e.type, sdp: e.sdp}).type) switch (this.signalingState) {
                        case"stable":
                        case"have-local-offer":
                        case"have-remote-pranswer":
                            e.type = "offer";
                            break;
                        default:
                            e.type = "answer"
                    }
                    if (e.sdp || "offer" !== e.type && "answer" !== e.type) return r.apply(this, [e]);
                    const t = "offer" === e.type ? this.createOffer : this.createAnswer;
                    return t.apply(this).then(e => r.apply(this, [e]))
                })
            }

            var mh = Object.freeze({
                __proto__: null,
                shimRTCIceCandidate: ah,
                shimRTCIceCandidateRelayProtocol: ch,
                shimMaxMessageSize: uh,
                shimSendThrowTypeError: dh,
                shimConnectionState: lh,
                removeExtmapAllowMixed: hh,
                shimAddIceCandidateNullOrEmpty: ph,
                shimParameterlessSetLocalDescription: fh
            });
            let _h, vh;
            !function () {
                let {window: e} = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                    t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {
                        shimChrome: !0,
                        shimFirefox: !0,
                        shimSafari: !0
                    };
                const r = Zr, n = function (e) {
                    const t = {browser: null, version: null};
                    if (void 0 === e || !e.navigator) return t.browser = "Not a browser.", t;
                    const {navigator: r} = e;
                    if (r.mozGetUserMedia) t.browser = "firefox", t.version = Jr(r.userAgent, /Firefox\/(\d+)\./, 1); else if (r.webkitGetUserMedia || !1 === e.isSecureContext && e.webkitRTCPeerConnection) t.browser = "chrome", t.version = Jr(r.userAgent, /Chrom(e|ium)\/(\d+)\./, 2); else {
                        if (!e.RTCPeerConnection || !r.userAgent.match(/AppleWebKit\/(\d+)\./)) return t.browser = "Not a supported browser.", t;
                        t.browser = "safari", t.version = Jr(r.userAgent, /AppleWebKit\/(\d+)\./, 1), t.supportsUnifiedPlan = e.RTCRtpTransceiver && "currentDirection" in e.RTCRtpTransceiver.prototype
                    }
                    return t
                }(e), i = {
                    browserDetails: n,
                    commonShim: mh,
                    extractVersion: Jr,
                    disableLog: Qr,
                    disableWarnings: $r,
                    sdp: sh
                };
                switch (n.browser) {
                    case"chrome":
                        if (!gl || !_l || !t.shimChrome) return r("Chrome shim is not included in this adapter release."), i;
                        if (null === n.version) return r("Chrome shim can not determine version, not shimming."), i;
                        r("adapter.js shimming chrome."), i.browserShim = gl, ph(e, n), fh(e), cl(e, n), ul(e), _l(e, n), dl(e), ml(e, n), ll(e), hl(e), pl(e), vl(e, n), ah(e), ch(e), lh(e), uh(e, n), dh(e), hh(e, n);
                        break;
                    case"firefox":
                        if (!Nl || !Sl || !t.shimFirefox) return r("Firefox shim is not included in this adapter release."), i;
                        r("adapter.js shimming firefox."), i.browserShim = Nl, ph(e, n), fh(e), El(e, n), Sl(e, n), yl(e), Rl(e), bl(e), Tl(e), Il(e), wl(e), Cl(e), Al(e), Ol(e), ah(e), lh(e), uh(e, n), dh(e);
                        break;
                    case"safari":
                        if (!Fl || !t.shimSafari) return r("Safari shim is not included in this adapter release."), i;
                        r("adapter.js shimming safari."), i.browserShim = Fl, ph(e, n), fh(e), Ml(e), jl(e), kl(e), Pl(e), Dl(e), Ul(e), Ll(e), Vl(e), ah(e), ch(e), uh(e, n), dh(e), hh(e, n);
                        break;
                    default:
                        r("Unsupported browser!")
                }
            }({window: "undefined" == typeof window ? void 0 : window}), function (e) {
                e.WIN_10 = "Windows 10", e.WIN_81 = "Windows 8.1", e.WIN_8 = "Windows 8", e.WIN_7 = "Windows 7", e.WIN_VISTA = "Windows Vista", e.WIN_SERVER_2003 = "Windows Server 2003", e.WIN_XP = "Windows XP", e.WIN_2000 = "Windows 2000", e.ANDROID = "Android", e.OPEN_BSD = "Open BSD", e.SUN_OS = "Sun OS", e.LINUX = "Linux", e.IOS = "iOS", e.MAC_OS = "Mac OS", e.QNX = "QNX", e.UNIX = "UNIX", e.BEOS = "BeOS", e.OS_2 = "OS/2", e.SEARCH_BOT = "Search Bot"
            }(_h || (_h = {})), function (e) {
                e.CHROME = "Chrome", e.SAFARI = "Safari", e.EDGE = "Edge", e.FIREFOX = "Firefox", e.OPERA = "OPR", e.QQ = "QQBrowser", e.WECHAT = "MicroMessenger"
            }(vh || (vh = {}));
            var gh = {exports: {}};
            !function (t, r) {
                !function (e, n) {
                    var i = "function", o = "undefined", s = "object", a = "string", c = "model", u = "name",
                        d = "type", l = "vendor", h = "version", p = "architecture", f = "console", m = "mobile",
                        _ = "tablet", v = "smarttv", g = "wearable", E = "embedded", y = "Amazon", S = "Apple",
                        b = "ASUS", T = "BlackBerry", R = "Google", I = "Huawei", w = "LG", C = "Microsoft",
                        A = "Motorola", O = "Samsung", N = "Sharp", P = "Sony", D = "Xiaomi", k = "Zebra",
                        L = "Facebook", x = function (e) {
                            for (var t = {}, r = 0; r < e.length; r++) t[e[r].toUpperCase()] = e[r];
                            return t
                        }, M = function (e, t) {
                            return typeof e === a && -1 !== U(t).indexOf(U(e))
                        }, U = function (e) {
                            return e.toLowerCase()
                        }, j = function (e, t) {
                            if (typeof e === a) return e = e.replace(/^\s\s*/, "").replace(/\s\s*$/, ""), typeof t === o ? e : e.substring(0, 350)
                        }, V = function (e, t) {
                            for (var r, o, a, c, u, d, l = 0; l < t.length && !u;) {
                                var h = t[l], p = t[l + 1];
                                for (r = o = 0; r < h.length && !u;) if (u = h[r++].exec(e)) for (a = 0; a < p.length; a++) d = u[++o], typeof (c = p[a]) === s && c.length > 0 ? 2 === c.length ? typeof c[1] == i ? this[c[0]] = c[1].call(this, d) : this[c[0]] = c[1] : 3 === c.length ? typeof c[1] !== i || c[1].exec && c[1].test ? this[c[0]] = d ? d.replace(c[1], c[2]) : n : this[c[0]] = d ? c[1].call(this, d, c[2]) : n : 4 === c.length && (this[c[0]] = d ? c[3].call(this, d.replace(c[1], c[2])) : n) : this[c] = d || n;
                                l += 2
                            }
                        }, F = function (e, t) {
                            for (var r in t) if (typeof t[r] === s && t[r].length > 0) {
                                for (var i = 0; i < t[r].length; i++) if (M(t[r][i], e)) return "?" === r ? n : r
                            } else if (M(t[r], e)) return "?" === r ? n : r;
                            return e
                        }, B = {
                            ME: "4.90",
                            "NT 3.11": "NT3.51",
                            "NT 4.0": "NT4.0",
                            2000: "NT 5.0",
                            XP: ["NT 5.1", "NT 5.2"],
                            Vista: "NT 6.0",
                            7: "NT 6.1",
                            8: "NT 6.2",
                            8.1: "NT 6.3",
                            10: ["NT 6.4", "NT 10.0"],
                            RT: "ARM"
                        }, W = {
                            browser: [[/\b(?:crmo|crios)\/([\w\.]+)/i], [h, [u, "Chrome"]], [/edg(?:e|ios|a)?\/([\w\.]+)/i], [h, [u, "Edge"]], [/(opera mini)\/([-\w\.]+)/i, /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i, /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i], [u, h], [/opios[\/ ]+([\w\.]+)/i], [h, [u, "Opera Mini"]], [/\bopr\/([\w\.]+)/i], [h, [u, "Opera"]], [/(kindle)\/([\w\.]+)/i, /(lunascape|maxthon|netfront|jasmine|blazer)[\/ ]?([\w\.]*)/i, /(avant |iemobile|slim)(?:browser)?[\/ ]?([\w\.]*)/i, /(ba?idubrowser)[\/ ]?([\w\.]+)/i, /(?:ms|\()(ie) ([\w\.]+)/i, /(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale|qqbrowserlite|qq|duckduckgo)\/([-\w\.]+)/i, /(weibo)__([\d\.]+)/i], [u, h], [/(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i], [h, [u, "UCBrowser"]], [/microm.+\bqbcore\/([\w\.]+)/i, /\bqbcore\/([\w\.]+).+microm/i], [h, [u, "WeChat(Win) Desktop"]], [/micromessenger\/([\w\.]+)/i], [h, [u, "WeChat"]], [/konqueror\/([\w\.]+)/i], [h, [u, "Konqueror"]], [/trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i], [h, [u, "IE"]], [/yabrowser\/([\w\.]+)/i], [h, [u, "Yandex"]], [/(avast|avg)\/([\w\.]+)/i], [[u, /(.+)/, "$1 Secure Browser"], h], [/\bfocus\/([\w\.]+)/i], [h, [u, "Firefox Focus"]], [/\bopt\/([\w\.]+)/i], [h, [u, "Opera Touch"]], [/coc_coc\w+\/([\w\.]+)/i], [h, [u, "Coc Coc"]], [/dolfin\/([\w\.]+)/i], [h, [u, "Dolphin"]], [/coast\/([\w\.]+)/i], [h, [u, "Opera Coast"]], [/miuibrowser\/([\w\.]+)/i], [h, [u, "MIUI Browser"]], [/fxios\/([-\w\.]+)/i], [h, [u, "Firefox"]], [/\bqihu|(qi?ho?o?|360)browser/i], [[u, "360 Browser"]], [/(oculus|samsung|sailfish|huawei)browser\/([\w\.]+)/i], [[u, /(.+)/, "$1 Browser"], h], [/(comodo_dragon)\/([\w\.]+)/i], [[u, /_/g, " "], h], [/(electron)\/([\w\.]+) safari/i, /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i, /m?(qqbrowser|baiduboxapp|2345Explorer)[\/ ]?([\w\.]+)/i], [u, h], [/(metasr)[\/ ]?([\w\.]+)/i, /(lbbrowser)/i, /\[(linkedin)app\]/i], [u], [/((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i], [[u, L], h], [/safari (line)\/([\w\.]+)/i, /\b(line)\/([\w\.]+)\/iab/i, /(chromium|instagram)[\/ ]([-\w\.]+)/i], [u, h], [/\bgsa\/([\w\.]+) .*safari\//i], [h, [u, "GSA"]], [/headlesschrome(?:\/([\w\.]+)| )/i], [h, [u, "Chrome Headless"]], [/ wv\).+(chrome)\/([\w\.]+)/i], [[u, "Chrome WebView"], h], [/droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i], [h, [u, "Android Browser"]], [/(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i], [u, h], [/version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i], [h, [u, "Mobile Safari"]], [/version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i], [h, u], [/webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i], [u, [h, F, {
                                "1.0": "/8",
                                1.2: "/1",
                                1.3: "/3",
                                "2.0": "/412",
                                "2.0.2": "/416",
                                "2.0.3": "/417",
                                "2.0.4": "/419",
                                "?": "/"
                            }]], [/(webkit|khtml)\/([\w\.]+)/i], [u, h], [/(navigator|netscape\d?)\/([-\w\.]+)/i], [[u, "Netscape"], h], [/mobile vr; rv:([\w\.]+)\).+firefox/i], [h, [u, "Firefox Reality"]], [/ekiohf.+(flow)\/([\w\.]+)/i, /(swiftfox)/i, /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\/ ]?([\w\.\+]+)/i, /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i, /(firefox)\/([\w\.]+)/i, /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i, /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i, /(links) \(([\w\.]+)/i], [u, h]],
                            cpu: [[/(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i], [[p, "amd64"]], [/(ia32(?=;))/i], [[p, U]], [/((?:i[346]|x)86)[;\)]/i], [[p, "ia32"]], [/\b(aarch64|arm(v?8e?l?|_?64))\b/i], [[p, "arm64"]], [/\b(arm(?:v[67])?ht?n?[fl]p?)\b/i], [[p, "armhf"]], [/windows (ce|mobile); ppc;/i], [[p, "arm"]], [/((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i], [[p, /ower/, "", U]], [/(sun4\w)[;\)]/i], [[p, "sparc"]], [/((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i], [[p, U]]],
                            device: [[/\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i], [c, [l, O], [d, _]], [/\b((?:s[cgp]h|gt|sm)-\w+|galaxy nexus)/i, /samsung[- ]([-\w]+)/i, /sec-(sgh\w+)/i], [c, [l, O], [d, m]], [/\((ip(?:hone|od)[\w ]*);/i], [c, [l, S], [d, m]], [/\((ipad);[-\w\),; ]+apple/i, /applecoremedia\/[\w\.]+ \((ipad)/i, /\b(ipad)\d\d?,\d\d?[;\]].+ios/i], [c, [l, S], [d, _]], [/\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i], [c, [l, I], [d, _]], [/(?:huawei|honor)([-\w ]+)[;\)]/i, /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i], [c, [l, I], [d, m]], [/\b(poco[\w ]+)(?: bui|\))/i, /\b; (\w+) build\/hm\1/i, /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i, /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i, /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\))/i], [[c, /_/g, " "], [l, D], [d, m]], [/\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i], [[c, /_/g, " "], [l, D], [d, _]], [/; (\w+) bui.+ oppo/i, /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i], [c, [l, "OPPO"], [d, m]], [/vivo (\w+)(?: bui|\))/i, /\b(v[12]\d{3}\w?[at])(?: bui|;)/i], [c, [l, "Vivo"], [d, m]], [/\b(rmx[12]\d{3})(?: bui|;|\))/i], [c, [l, "Realme"], [d, m]], [/\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i, /\bmot(?:orola)?[- ](\w*)/i, /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i], [c, [l, A], [d, m]], [/\b(mz60\d|xoom[2 ]{0,2}) build\//i], [c, [l, A], [d, _]], [/((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i], [c, [l, w], [d, _]], [/(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i, /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i, /\blg-?([\d\w]+) bui/i], [c, [l, w], [d, m]], [/(ideatab[-\w ]+)/i, /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i], [c, [l, "Lenovo"], [d, _]], [/(?:maemo|nokia).*(n900|lumia \d+)/i, /nokia[-_ ]?([-\w\.]*)/i], [[c, /_/g, " "], [l, "Nokia"], [d, m]], [/(pixel c)\b/i], [c, [l, R], [d, _]], [/droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i], [c, [l, R], [d, m]], [/droid.+ (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i], [c, [l, P], [d, m]], [/sony tablet [ps]/i, /\b(?:sony)?sgp\w+(?: bui|\))/i], [[c, "Xperia Tablet"], [l, P], [d, _]], [/ (kb2005|in20[12]5|be20[12][59])\b/i, /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i], [c, [l, "OnePlus"], [d, m]], [/(alexa)webm/i, /(kf[a-z]{2}wi)( bui|\))/i, /(kf[a-z]+)( bui|\)).+silk\//i], [c, [l, y], [d, _]], [/((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i], [[c, /(.+)/g, "Fire Phone $1"], [l, y], [d, m]], [/(playbook);[-\w\),; ]+(rim)/i], [c, l, [d, _]], [/\b((?:bb[a-f]|st[hv])100-\d)/i, /\(bb10; (\w+)/i], [c, [l, T], [d, m]], [/(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i], [c, [l, b], [d, _]], [/ (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i], [c, [l, b], [d, m]], [/(nexus 9)/i], [c, [l, "HTC"], [d, _]], [/(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i, /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i, /(alcatel|geeksphone|nexian|panasonic|sony(?!-bra))[-_ ]?([-\w]*)/i], [l, [c, /_/g, " "], [d, m]], [/droid.+; ([ab][1-7]-?[0178a]\d\d?)/i], [c, [l, "Acer"], [d, _]], [/droid.+; (m[1-5] note) bui/i, /\bmz-([-\w]{2,})/i], [c, [l, "Meizu"], [d, m]], [/\b(sh-?[altvz]?\d\d[a-ekm]?)/i], [c, [l, N], [d, m]], [/(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[-_ ]?([-\w]*)/i, /(hp) ([\w ]+\w)/i, /(asus)-?(\w+)/i, /(microsoft); (lumia[\w ]+)/i, /(lenovo)[-_ ]?([-\w]+)/i, /(jolla)/i, /(oppo) ?([\w ]+) bui/i], [l, c, [d, m]], [/(archos) (gamepad2?)/i, /(hp).+(touchpad(?!.+tablet)|tablet)/i, /(kindle)\/([\w\.]+)/i, /(nook)[\w ]+build\/(\w+)/i, /(dell) (strea[kpr\d ]*[\dko])/i, /(le[- ]+pan)[- ]+(\w{1,9}) bui/i, /(trinity)[- ]*(t\d{3}) bui/i, /(gigaset)[- ]+(q\w{1,9}) bui/i, /(vodafone) ([\w ]+)(?:\)| bui)/i], [l, c, [d, _]], [/(surface duo)/i], [c, [l, C], [d, _]], [/droid [\d\.]+; (fp\du?)(?: b|\))/i], [c, [l, "Fairphone"], [d, m]], [/(u304aa)/i], [c, [l, "AT&T"], [d, m]], [/\bsie-(\w*)/i], [c, [l, "Siemens"], [d, m]], [/\b(rct\w+) b/i], [c, [l, "RCA"], [d, _]], [/\b(venue[\d ]{2,7}) b/i], [c, [l, "Dell"], [d, _]], [/\b(q(?:mv|ta)\w+) b/i], [c, [l, "Verizon"], [d, _]], [/\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i], [c, [l, "Barnes & Noble"], [d, _]], [/\b(tm\d{3}\w+) b/i], [c, [l, "NuVision"], [d, _]], [/\b(k88) b/i], [c, [l, "ZTE"], [d, _]], [/\b(nx\d{3}j) b/i], [c, [l, "ZTE"], [d, m]], [/\b(gen\d{3}) b.+49h/i], [c, [l, "Swiss"], [d, m]], [/\b(zur\d{3}) b/i], [c, [l, "Swiss"], [d, _]], [/\b((zeki)?tb.*\b) b/i], [c, [l, "Zeki"], [d, _]], [/\b([yr]\d{2}) b/i, /\b(dragon[- ]+touch |dt)(\w{5}) b/i], [[l, "Dragon Touch"], c, [d, _]], [/\b(ns-?\w{0,9}) b/i], [c, [l, "Insignia"], [d, _]], [/\b((nxa|next)-?\w{0,9}) b/i], [c, [l, "NextBook"], [d, _]], [/\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i], [[l, "Voice"], c, [d, m]], [/\b(lvtel\-)?(v1[12]) b/i], [[l, "LvTel"], c, [d, m]], [/\b(ph-1) /i], [c, [l, "Essential"], [d, m]], [/\b(v(100md|700na|7011|917g).*\b) b/i], [c, [l, "Envizen"], [d, _]], [/\b(trio[-\w\. ]+) b/i], [c, [l, "MachSpeed"], [d, _]], [/\btu_(1491) b/i], [c, [l, "Rotor"], [d, _]], [/(shield[\w ]+) b/i], [c, [l, "Nvidia"], [d, _]], [/(sprint) (\w+)/i], [l, c, [d, m]], [/(kin\.[onetw]{3})/i], [[c, /\./g, " "], [l, C], [d, m]], [/droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i], [c, [l, k], [d, _]], [/droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i], [c, [l, k], [d, m]], [/(ouya)/i, /(nintendo) ([wids3utch]+)/i], [l, c, [d, f]], [/droid.+; (shield) bui/i], [c, [l, "Nvidia"], [d, f]], [/(playstation [345portablevi]+)/i], [c, [l, P], [d, f]], [/\b(xbox(?: one)?(?!; xbox))[\); ]/i], [c, [l, C], [d, f]], [/smart-tv.+(samsung)/i], [l, [d, v]], [/hbbtv.+maple;(\d+)/i], [[c, /^/, "SmartTV"], [l, O], [d, v]], [/(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i], [[l, w], [d, v]], [/(apple) ?tv/i], [l, [c, "Apple TV"], [d, v]], [/crkey/i], [[c, "Chromecast"], [l, R], [d, v]], [/droid.+aft(\w)( bui|\))/i], [c, [l, y], [d, v]], [/\(dtv[\);].+(aquos)/i, /(aquos-tv[\w ]+)\)/i], [c, [l, N], [d, v]], [/(bravia[\w ]+)( bui|\))/i], [c, [l, P], [d, v]], [/(mitv-\w{5}) bui/i], [c, [l, D], [d, v]], [/\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i, /hbbtv\/\d+\.\d+\.\d+ +\([\w ]*; *(\w[^;]*);([^;]*)/i], [[l, j], [c, j], [d, v]], [/\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i], [[d, v]], [/((pebble))app/i], [l, c, [d, g]], [/droid.+; (glass) \d/i], [c, [l, R], [d, g]], [/droid.+; (wt63?0{2,3})\)/i], [c, [l, k], [d, g]], [/(quest( 2)?)/i], [c, [l, L], [d, g]], [/(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i], [l, [d, E]], [/droid .+?; ([^;]+?)(?: bui|\) applew).+? mobile safari/i], [c, [d, m]], [/droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i], [c, [d, _]], [/\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i], [[d, _]], [/(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i], [[d, m]], [/(android[-\w\. ]{0,9});.+buil/i], [c, [l, "Generic"]]],
                            engine: [[/windows.+ edge\/([\w\.]+)/i], [h, [u, "EdgeHTML"]], [/webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i], [h, [u, "Blink"]], [/(presto)\/([\w\.]+)/i, /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i, /ekioh(flow)\/([\w\.]+)/i, /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i, /(icab)[\/ ]([23]\.[\d\.]+)/i], [u, h], [/rv\:([\w\.]{1,9})\b.+(gecko)/i], [h, u]],
                            os: [[/microsoft (windows) (vista|xp)/i], [u, h], [/(windows) nt 6\.2; (arm)/i, /(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i, /(windows)[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i], [u, [h, F, B]], [/(win(?=3|9|n)|win 9x )([nt\d\.]+)/i], [[u, "Windows"], [h, F, B]], [/ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i, /cfnetwork\/.+darwin/i], [[h, /_/g, "."], [u, "iOS"]], [/(mac os x) ?([\w\. ]*)/i, /(macintosh|mac_powerpc\b)(?!.+haiku)/i], [[u, "Mac OS"], [h, /_/g, "."]], [/droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i], [h, u], [/(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\/ ]?([\w\.]*)/i, /(blackberry)\w*\/([\w\.]*)/i, /(tizen|kaios)[\/ ]([\w\.]+)/i, /\((series40);/i], [u, h], [/\(bb(10);/i], [h, [u, T]], [/(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i], [h, [u, "Symbian"]], [/mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i], [h, [u, "Firefox OS"]], [/web0s;.+rt(tv)/i, /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i], [h, [u, "webOS"]], [/crkey\/([\d\.]+)/i], [h, [u, "Chromecast"]], [/(cros) [\w]+ ([\w\.]+\w)/i], [[u, "Chromium OS"], h], [/(nintendo|playstation) ([wids345portablevuch]+)/i, /(xbox); +xbox ([^\);]+)/i, /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i, /(mint)[\/\(\) ]?(\w*)/i, /(mageia|vectorlinux)[; ]/i, /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i, /(hurd|linux) ?([\w\.]*)/i, /(gnu) ?([\w\.]*)/i, /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i, /(haiku) (\w+)/i], [u, h], [/(sunos) ?([\w\.\d]*)/i], [[u, "Solaris"], h], [/((?:open)?solaris)[-\/ ]?([\w\.]*)/i, /(aix) ((\d)(?=\.|\)| )[\w\.])*/i, /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux)/i, /(unix) ?([\w\.]*)/i], [u, h]]
                        }, G = function (t, r) {
                            if (typeof t === s && (r = t, t = n), !(this instanceof G)) return new G(t, r).getResult();
                            var i = t || (typeof e !== o && e.navigator && e.navigator.userAgent ? e.navigator.userAgent : ""),
                                c = r ? function (e, t) {
                                    var r = {};
                                    for (var n in e) t[n] && t[n].length % 2 == 0 ? r[n] = t[n].concat(e[n]) : r[n] = e[n];
                                    return r
                                }(W, r) : W;
                            return this.getBrowser = function () {
                                var e = {};
                                return e.name = n, e.version = n, V.call(e, i, c.browser), e.major = function (e) {
                                    return typeof e === a ? e.replace(/[^\d\.]/g, "").split(".")[0] : n
                                }(e.version), e
                            }, this.getCPU = function () {
                                var e = {};
                                return e.architecture = n, V.call(e, i, c.cpu), e
                            }, this.getDevice = function () {
                                var e = {};
                                return e.vendor = n, e.model = n, e.type = n, V.call(e, i, c.device), e
                            }, this.getEngine = function () {
                                var e = {};
                                return e.name = n, e.version = n, V.call(e, i, c.engine), e
                            }, this.getOS = function () {
                                var e = {};
                                return e.name = n, e.version = n, V.call(e, i, c.os), e
                            }, this.getResult = function () {
                                return {
                                    ua: this.getUA(),
                                    browser: this.getBrowser(),
                                    engine: this.getEngine(),
                                    os: this.getOS(),
                                    device: this.getDevice(),
                                    cpu: this.getCPU()
                                }
                            }, this.getUA = function () {
                                return i
                            }, this.setUA = function (e) {
                                return i = typeof e === a && e.length > 350 ? j(e, 350) : e, this
                            }, this.setUA(i), this
                        };
                    G.VERSION = "0.7.32", G.BROWSER = x([u, h, "major"]), G.CPU = x([p]), G.DEVICE = x([c, l, d, f, m, v, _, g, E]), G.ENGINE = G.OS = x([u, h]), t.exports && (r = t.exports = G), r.UAParser = G;
                    var q = typeof e !== o && (e.jQuery || e.Zepto);
                    if (q && !q.ua) {
                        var H = new G;
                        q.ua = H.getResult(), q.ua.get = function () {
                            return H.getUA()
                        }, q.ua.set = function (e) {
                            H.setUA(e);
                            var t = H.getResult();
                            for (var r in t) q.ua[r] = t[r]
                        }
                    }
                }("object" == typeof window ? window : e)
            }(gh, gh.exports);
            const Eh = new (0, gh.exports);
            let yh = Eh.getResult();

            function Sh(e) {
                return e && Eh.setUA(e), {
                    name: function (e) {
                        if ("Blink" === e.engine.name && "WeChat" !== e.browser.name) return vh.CHROME;
                        switch (e.browser.name) {
                            case"Chrome Headless":
                            case"Chrome":
                            case"Chromium":
                                return vh.CHROME;
                            case"Safari":
                            case"Mobile Safari":
                                return vh.SAFARI;
                            case"Edge":
                                return vh.EDGE;
                            case"Firefox":
                                return vh.FIREFOX;
                            case"QQBrowser":
                                return vh.QQ;
                            case"Opera":
                                return vh.OPERA;
                            case"WeChat":
                                return vh.WECHAT;
                            default:
                                return e.browser.name || ""
                        }
                    }(yh = Eh.getResult()), version: function (e) {
                        let t;
                        return (t = "Blink" === e.engine.name ? e.engine.version || "" : e.browser.version || "").split(".")[0]
                    }(yh), os: function (e) {
                        switch (e.os.name) {
                            case"Windows":
                                return e.os.version ? e.os.name + " " + e.os.version : e.os.name;
                            default:
                                return e.os.name || ""
                        }
                    }(yh), osVersion: yh.os.version
                }
            }

            function bh() {
                return Sh().os
            }

            function Th() {
                const e = Sh();
                return !!("WebKit" === yh.engine.name && e.os === _h.MAC_OS && navigator.maxTouchPoints && navigator.maxTouchPoints > 0 && e.name !== vh.SAFARI || Ch() && e.name !== vh.SAFARI)
            }

            function Rh() {
                return Sh().name === vh.CHROME
            }

            function Ih() {
                return Sh().name === vh.SAFARI
            }

            function wh() {
                return Sh().name === vh.FIREFOX
            }

            function Ch() {
                return Sh().os === _h.IOS
            }

            function Ah() {
                const e = Sh();
                return !(e.name !== vh.CHROME || !e.osVersion) && Number(e.version) <= 90
            }

            function Oh() {
                const e = Sh();
                if (e.os !== _h.IOS || !e.osVersion) return !1;
                const t = e.osVersion.split(".");
                return 15 === Number(t[0])
            }

            function Nh() {
                const e = Sh();
                if (e.os !== _h.IOS || !e.osVersion) return !1;
                const t = e.osVersion.split(".");
                return 15 === Number(t[0]) && 0 === Number(t[1])
            }

            function Ph() {
                const e = Sh();
                if (e.os !== _h.IOS || !e.osVersion) return !1;
                const t = e.osVersion.split(".");
                return 15 === Number(t[0]) && Number(t[1]) >= 1
            }

            function Dh() {
                const e = Sh();
                if (e.os !== _h.IOS || !e.osVersion) return !1;
                const t = e.osVersion.split(".");
                return 15 === Number(t[0]) && Number(t[1]) >= 2
            }

            function kh() {
                return Ih() && navigator.maxTouchPoints > 0
            }

            function Lh() {
                return Sh().name === vh.WECHAT
            }

            function xh() {
                return window.navigator.appVersion && null !== window.navigator.appVersion.match(/Chrome\/([\w\W]*?)\./) && window.navigator.appVersion.match(/Chrome\/([\w\W]*?)\./)[1] <= 35
            }

            function Mh() {
                const e = Sh();
                return e.name !== vh.EDGE && e.name !== vh.SAFARI && !!navigator.userAgent.toLocaleLowerCase().match(/chrome\/[\d]./i)
            }

            function Uh() {
                return Sh().os === _h.ANDROID
            }

            function jh() {
                const e = Sh();
                return "Android" === e.os && ("Chrome" === e.name || e.name === vh.WECHAT || /chrome|chromium/i.test(navigator.userAgent))
            }

            var Vh = {exports: {}}, Fh = Er, Bh = b, Wh = qt.f;
            Fh({target: "Object", stat: !0, forced: Object.defineProperty !== Wh, sham: !Bh}, {defineProperty: Wh});
            var Gh = X.Object, qh = Vh.exports = function (e, t, r) {
                return Gh.defineProperty(e, t, r)
            };
            Gh.defineProperty.sham && (qh.sham = !0);
            var Hh = Vh.exports;

            function Kh(e, t, r) {
                return t in e ? Hh(e, t, {value: r, enumerable: !0, configurable: !0, writable: !0}) : e[t] = r, e
            }

            var zh, Yh = {exports: {}}, Jh = function (e, t) {
                return function () {
                    for (var r = new Array(arguments.length), n = 0; n < r.length; n++) r[n] = arguments[n];
                    return e.apply(t, r)
                }
            }, Xh = Jh, Qh = Object.prototype.toString, $h = (zh = Object.create(null), function (e) {
                var t = Qh.call(e);
                return zh[t] || (zh[t] = t.slice(8, -1).toLowerCase())
            });

            function Zh(e) {
                return e = e.toLowerCase(), function (t) {
                    return $h(t) === e
                }
            }

            function ep(e) {
                return Array.isArray(e)
            }

            function tp(e) {
                return void 0 === e
            }

            var rp = Zh("ArrayBuffer");

            function np(e) {
                return null !== e && "object" == typeof e
            }

            function ip(e) {
                if ("object" !== $h(e)) return !1;
                var t = Object.getPrototypeOf(e);
                return null === t || t === Object.prototype
            }

            var op = Zh("Date"), sp = Zh("File"), ap = Zh("Blob"), cp = Zh("FileList");

            function up(e) {
                return "[object Function]" === Qh.call(e)
            }

            var dp = Zh("URLSearchParams");

            function lp(e, t) {
                if (null != e) if ("object" != typeof e && (e = [e]), ep(e)) for (var r = 0, n = e.length; r < n; r++) t.call(null, e[r], r, e); else for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && t.call(null, e[i], i, e)
            }

            var hp, pp = (hp = "undefined" != typeof Uint8Array && Object.getPrototypeOf(Uint8Array), function (e) {
                return hp && e instanceof hp
            }), fp = {
                isArray: ep,
                isArrayBuffer: rp,
                isBuffer: function (e) {
                    return null !== e && !tp(e) && null !== e.constructor && !tp(e.constructor) && "function" == typeof e.constructor.isBuffer && e.constructor.isBuffer(e)
                },
                isFormData: function (e) {
                    var t = "[object FormData]";
                    return e && ("function" == typeof FormData && e instanceof FormData || Qh.call(e) === t || up(e.toString) && e.toString() === t)
                },
                isArrayBufferView: function (e) {
                    return "undefined" != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(e) : e && e.buffer && rp(e.buffer)
                },
                isString: function (e) {
                    return "string" == typeof e
                },
                isNumber: function (e) {
                    return "number" == typeof e
                },
                isObject: np,
                isPlainObject: ip,
                isUndefined: tp,
                isDate: op,
                isFile: sp,
                isBlob: ap,
                isFunction: up,
                isStream: function (e) {
                    return np(e) && up(e.pipe)
                },
                isURLSearchParams: dp,
                isStandardBrowserEnv: function () {
                    return ("undefined" == typeof navigator || "ReactNative" !== navigator.product && "NativeScript" !== navigator.product && "NS" !== navigator.product) && "undefined" != typeof window && "undefined" != typeof document
                },
                forEach: lp,
                merge: function e() {
                    var t = {};

                    function r(r, n) {
                        ip(t[n]) && ip(r) ? t[n] = e(t[n], r) : ip(r) ? t[n] = e({}, r) : ep(r) ? t[n] = r.slice() : t[n] = r
                    }

                    for (var n = 0, i = arguments.length; n < i; n++) lp(arguments[n], r);
                    return t
                },
                extend: function (e, t, r) {
                    return lp(t, function (t, n) {
                        e[n] = r && "function" == typeof t ? Xh(t, r) : t
                    }), e
                },
                trim: function (e) {
                    return e.trim ? e.trim() : e.replace(/^\s+|\s+$/g, "")
                },
                stripBOM: function (e) {
                    return 65279 === e.charCodeAt(0) && (e = e.slice(1)), e
                },
                inherits: function (e, t, r, n) {
                    e.prototype = Object.create(t.prototype, n), e.prototype.constructor = e, r && Object.assign(e.prototype, r)
                },
                toFlatObject: function (e, t, r) {
                    var n, i, o, s = {};
                    t = t || {};
                    do {
                        for (i = (n = Object.getOwnPropertyNames(e)).length; i-- > 0;) s[o = n[i]] || (t[o] = e[o], s[o] = !0);
                        e = Object.getPrototypeOf(e)
                    } while (e && (!r || r(e, t)) && e !== Object.prototype);
                    return t
                },
                kindOf: $h,
                kindOfTest: Zh,
                endsWith: function (e, t, r) {
                    e = String(e), (void 0 === r || r > e.length) && (r = e.length), r -= t.length;
                    var n = e.indexOf(t, r);
                    return -1 !== n && n === r
                },
                toArray: function (e) {
                    if (!e) return null;
                    var t = e.length;
                    if (tp(t)) return null;
                    for (var r = new Array(t); t-- > 0;) r[t] = e[t];
                    return r
                },
                isTypedArray: pp,
                isFileList: cp
            }, mp = fp;

            function _p(e) {
                return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]")
            }

            var vp = function (e, t, r) {
                if (!t) return e;
                var n;
                if (r) n = r(t); else if (mp.isURLSearchParams(t)) n = t.toString(); else {
                    var i = [];
                    mp.forEach(t, function (e, t) {
                        null != e && (mp.isArray(e) ? t += "[]" : e = [e], mp.forEach(e, function (e) {
                            mp.isDate(e) ? e = e.toISOString() : mp.isObject(e) && (e = JSON.stringify(e)), i.push(_p(t) + "=" + _p(e))
                        }))
                    }), n = i.join("&")
                }
                if (n) {
                    var o = e.indexOf("#");
                    -1 !== o && (e = e.slice(0, o)), e += (-1 === e.indexOf("?") ? "?" : "&") + n
                }
                return e
            }, gp = fp;

            function Ep() {
                this.handlers = []
            }

            Ep.prototype.use = function (e, t, r) {
                return this.handlers.push({
                    fulfilled: e,
                    rejected: t,
                    synchronous: !!r && r.synchronous,
                    runWhen: r ? r.runWhen : null
                }), this.handlers.length - 1
            }, Ep.prototype.eject = function (e) {
                this.handlers[e] && (this.handlers[e] = null)
            }, Ep.prototype.forEach = function (e) {
                gp.forEach(this.handlers, function (t) {
                    null !== t && e(t)
                })
            };
            var yp = Ep, Sp = fp, bp = fp;

            function Tp(e, t, r, n, i) {
                Error.call(this), this.message = e, this.name = "AxiosError", t && (this.code = t), r && (this.config = r), n && (this.request = n), i && (this.response = i)
            }

            bp.inherits(Tp, Error, {
                toJSON: function () {
                    return {
                        message: this.message,
                        name: this.name,
                        description: this.description,
                        number: this.number,
                        fileName: this.fileName,
                        lineNumber: this.lineNumber,
                        columnNumber: this.columnNumber,
                        stack: this.stack,
                        config: this.config,
                        code: this.code,
                        status: this.response && this.response.status ? this.response.status : null
                    }
                }
            });
            var Rp = Tp.prototype, Ip = {};
            ["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED"].forEach(function (e) {
                Ip[e] = {value: e}
            }), Object.defineProperties(Tp, Ip), Object.defineProperty(Rp, "isAxiosError", {value: !0}), Tp.from = function (e, t, r, n, i, o) {
                var s = Object.create(Rp);
                return bp.toFlatObject(e, s, function (e) {
                    return e !== Error.prototype
                }), Tp.call(s, e.message, t, r, n, i), s.name = e.name, o && Object.assign(s, o), s
            };
            var wp = Tp, Cp = {silentJSONParsing: !0, forcedJSONParsing: !0, clarifyTimeoutError: !1}, Ap = fp,
                Op = function (e, t) {
                    t = t || new FormData;
                    var n = [];

                    function i(e) {
                        return null === e ? "" : Ap.isDate(e) ? e.toISOString() : Ap.isArrayBuffer(e) || Ap.isTypedArray(e) ? "function" == typeof Blob ? new Blob([e]) : r.from(e) : e
                    }

                    return function e(r, o) {
                        if (Ap.isPlainObject(r) || Ap.isArray(r)) {
                            if (-1 !== n.indexOf(r)) throw Error("Circular reference detected in " + o);
                            n.push(r), Ap.forEach(r, function (r, n) {
                                if (!Ap.isUndefined(r)) {
                                    var s, a = o ? o + "." + n : n;
                                    if (r && !o && "object" == typeof r) if (Ap.endsWith(n, "{}")) r = JSON.stringify(r); else if (Ap.endsWith(n, "[]") && (s = Ap.toArray(r))) return void s.forEach(function (e) {
                                        !Ap.isUndefined(e) && t.append(a, i(e))
                                    });
                                    e(r, a)
                                }
                            }), n.pop()
                        } else t.append(o, i(r))
                    }(e), t
                }, Np = wp, Pp = fp, Dp = Pp.isStandardBrowserEnv() ? {
                    write: function (e, t, r, n, i, o) {
                        var s = [];
                        s.push(e + "=" + encodeURIComponent(t)), Pp.isNumber(r) && s.push("expires=" + new Date(r).toGMTString()), Pp.isString(n) && s.push("path=" + n), Pp.isString(i) && s.push("domain=" + i), !0 === o && s.push("secure"), document.cookie = s.join("; ")
                    }, read: function (e) {
                        var t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)"));
                        return t ? decodeURIComponent(t[3]) : null
                    }, remove: function (e) {
                        this.write(e, "", Date.now() - 864e5)
                    }
                } : {
                    write: function () {
                    }, read: function () {
                        return null
                    }, remove: function () {
                    }
                }, kp = function (e, t) {
                    return e && !function (e) {
                        return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e)
                    }(t) ? function (e, t) {
                        return t ? e.replace(/\/+$/, "") + "/" + t.replace(/^\/+/, "") : e
                    }(e, t) : t
                }, Lp = fp,
                xp = ["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"],
                Mp = fp, Up = Mp.isStandardBrowserEnv() ? function () {
                    var e, t = /(msie|trident)/i.test(navigator.userAgent), r = document.createElement("a");

                    function n(e) {
                        var n = e;
                        return t && (r.setAttribute("href", n), n = r.href), r.setAttribute("href", n), {
                            href: r.href,
                            protocol: r.protocol ? r.protocol.replace(/:$/, "") : "",
                            host: r.host,
                            search: r.search ? r.search.replace(/^\?/, "") : "",
                            hash: r.hash ? r.hash.replace(/^#/, "") : "",
                            hostname: r.hostname,
                            port: r.port,
                            pathname: "/" === r.pathname.charAt(0) ? r.pathname : "/" + r.pathname
                        }
                    }

                    return e = n(window.location.href), function (t) {
                        var r = Mp.isString(t) ? n(t) : t;
                        return r.protocol === e.protocol && r.host === e.host
                    }
                }() : function () {
                    return !0
                }, jp = wp;

            function Vp(e) {
                jp.call(this, null == e ? "canceled" : e, jp.ERR_CANCELED), this.name = "CanceledError"
            }

            fp.inherits(Vp, jp, {__CANCEL__: !0});
            var Fp = Vp, Bp = fp, Wp = function (e, t, r) {
                var n = r.config.validateStatus;
                r.status && n && !n(r.status) ? t(new Np("Request failed with status code " + r.status, [Np.ERR_BAD_REQUEST, Np.ERR_BAD_RESPONSE][Math.floor(r.status / 100) - 4], r.config, r.request, r)) : e(r)
            }, Gp = Dp, qp = vp, Hp = kp, Kp = function (e) {
                var t, r, n, i = {};
                return e ? (Lp.forEach(e.split("\n"), function (e) {
                    if (n = e.indexOf(":"), t = Lp.trim(e.substr(0, n)).toLowerCase(), r = Lp.trim(e.substr(n + 1)), t) {
                        if (i[t] && xp.indexOf(t) >= 0) return;
                        i[t] = "set-cookie" === t ? (i[t] ? i[t] : []).concat([r]) : i[t] ? i[t] + ", " + r : r
                    }
                }), i) : i
            }, zp = Up, Yp = Cp, Jp = wp, Xp = Fp, Qp = fp, $p = function (e, t) {
                Sp.forEach(e, function (r, n) {
                    n !== t && n.toUpperCase() === t.toUpperCase() && (e[t] = r, delete e[n])
                })
            }, Zp = wp, ef = Op, tf = {"Content-Type": "application/x-www-form-urlencoded"};

            function rf(e, t) {
                !Qp.isUndefined(e) && Qp.isUndefined(e["Content-Type"]) && (e["Content-Type"] = t)
            }

            var nf, of = {
                transitional: Cp,
                adapter: (("undefined" != typeof XMLHttpRequest || void 0 !== n && "[object process]" === Object.prototype.toString.call(n)) && (nf = function (e) {
                    return new Promise(function (t, r) {
                        var n, i = e.data, o = e.headers, s = e.responseType;

                        function a() {
                            e.cancelToken && e.cancelToken.unsubscribe(n), e.signal && e.signal.removeEventListener("abort", n)
                        }

                        Bp.isFormData(i) && Bp.isStandardBrowserEnv() && delete o["Content-Type"];
                        var c = new XMLHttpRequest;
                        if (e.auth) {
                            var u = e.auth.username || "",
                                d = e.auth.password ? unescape(encodeURIComponent(e.auth.password)) : "";
                            o.Authorization = "Basic " + btoa(u + ":" + d)
                        }
                        var l = Hp(e.baseURL, e.url);

                        function h() {
                            if (c) {
                                var n = "getAllResponseHeaders" in c ? Kp(c.getAllResponseHeaders()) : null, i = {
                                    data: s && "text" !== s && "json" !== s ? c.response : c.responseText,
                                    status: c.status,
                                    statusText: c.statusText,
                                    headers: n,
                                    config: e,
                                    request: c
                                };
                                Wp(function (e) {
                                    t(e), a()
                                }, function (e) {
                                    r(e), a()
                                }, i), c = null
                            }
                        }

                        if (c.open(e.method.toUpperCase(), qp(l, e.params, e.paramsSerializer), !0), c.timeout = e.timeout, "onloadend" in c ? c.onloadend = h : c.onreadystatechange = function () {
                            c && 4 === c.readyState && (0 !== c.status || c.responseURL && 0 === c.responseURL.indexOf("file:")) && setTimeout(h)
                        }, c.onabort = function () {
                            c && (r(new Jp("Request aborted", Jp.ECONNABORTED, e, c)), c = null)
                        }, c.onerror = function () {
                            r(new Jp("Network Error", Jp.ERR_NETWORK, e, c, c)), c = null
                        }, c.ontimeout = function () {
                            var t = e.timeout ? "timeout of " + e.timeout + "ms exceeded" : "timeout exceeded",
                                n = e.transitional || Yp;
                            e.timeoutErrorMessage && (t = e.timeoutErrorMessage), r(new Jp(t, n.clarifyTimeoutError ? Jp.ETIMEDOUT : Jp.ECONNABORTED, e, c)), c = null
                        }, Bp.isStandardBrowserEnv()) {
                            var p = (e.withCredentials || zp(l)) && e.xsrfCookieName ? Gp.read(e.xsrfCookieName) : void 0;
                            p && (o[e.xsrfHeaderName] = p)
                        }
                        "setRequestHeader" in c && Bp.forEach(o, function (e, t) {
                            void 0 === i && "content-type" === t.toLowerCase() ? delete o[t] : c.setRequestHeader(t, e)
                        }), Bp.isUndefined(e.withCredentials) || (c.withCredentials = !!e.withCredentials), s && "json" !== s && (c.responseType = e.responseType), "function" == typeof e.onDownloadProgress && c.addEventListener("progress", e.onDownloadProgress), "function" == typeof e.onUploadProgress && c.upload && c.upload.addEventListener("progress", e.onUploadProgress), (e.cancelToken || e.signal) && (n = function (e) {
                            c && (r(!e || e && e.type ? new Xp : e), c.abort(), c = null)
                        }, e.cancelToken && e.cancelToken.subscribe(n), e.signal && (e.signal.aborted ? n() : e.signal.addEventListener("abort", n))), i || (i = null);
                        var f = function (e) {
                            var t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
                            return t && t[1] || ""
                        }(l);
                        f && -1 === ["http", "https", "file"].indexOf(f) ? r(new Jp("Unsupported protocol " + f + ":", Jp.ERR_BAD_REQUEST, e)) : c.send(i)
                    })
                }), nf),
                transformRequest: [function (e, t) {
                    if ($p(t, "Accept"), $p(t, "Content-Type"), Qp.isFormData(e) || Qp.isArrayBuffer(e) || Qp.isBuffer(e) || Qp.isStream(e) || Qp.isFile(e) || Qp.isBlob(e)) return e;
                    if (Qp.isArrayBufferView(e)) return e.buffer;
                    if (Qp.isURLSearchParams(e)) return rf(t, "application/x-www-form-urlencoded;charset=utf-8"), e.toString();
                    var r, n = Qp.isObject(e), i = t && t["Content-Type"];
                    if ((r = Qp.isFileList(e)) || n && "multipart/form-data" === i) {
                        var o = this.env && this.env.FormData;
                        return ef(r ? {"files[]": e} : e, o && new o)
                    }
                    return n || "application/json" === i ? (rf(t, "application/json"), function (e, t, r) {
                        if (Qp.isString(e)) try {
                            return (0, JSON.parse)(e), Qp.trim(e)
                        } catch (e) {
                            if ("SyntaxError" !== e.name) throw e
                        }
                        return (0, JSON.stringify)(e)
                    }(e)) : e
                }],
                transformResponse: [function (e) {
                    var t = this.transitional || of.transitional, r = t && t.silentJSONParsing,
                        n = t && t.forcedJSONParsing, i = !r && "json" === this.responseType;
                    if (i || n && Qp.isString(e) && e.length) try {
                        return JSON.parse(e)
                    } catch (e) {
                        if (i) {
                            if ("SyntaxError" === e.name) throw Zp.from(e, Zp.ERR_BAD_RESPONSE, this, null, this.response);
                            throw e
                        }
                    }
                    return e
                }],
                timeout: 0,
                xsrfCookieName: "XSRF-TOKEN",
                xsrfHeaderName: "X-XSRF-TOKEN",
                maxContentLength: -1,
                maxBodyLength: -1,
                env: {FormData: null},
                validateStatus: function (e) {
                    return e >= 200 && e < 300
                },
                headers: {common: {Accept: "application/json, text/plain, */*"}}
            };
            Qp.forEach(["delete", "get", "head"], function (e) {
                of.headers[e] = {}
            }), Qp.forEach(["post", "put", "patch"], function (e) {
                of.headers[e] = Qp.merge(tf)
            });
            var sf = of, af = fp, cf = sf, uf = function (e) {
                return !(!e || !e.__CANCEL__)
            }, df = fp, lf = function (e, t, r) {
                var n = this || cf;
                return af.forEach(r, function (r) {
                    e = r.call(n, e, t)
                }), e
            }, hf = uf, pf = sf, ff = Fp;

            function mf(e) {
                if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted) throw new ff
            }

            var _f = fp, vf = function (e, t) {
                t = t || {};
                var r = {};

                function n(e, t) {
                    return _f.isPlainObject(e) && _f.isPlainObject(t) ? _f.merge(e, t) : _f.isPlainObject(t) ? _f.merge({}, t) : _f.isArray(t) ? t.slice() : t
                }

                function i(r) {
                    return _f.isUndefined(t[r]) ? _f.isUndefined(e[r]) ? void 0 : n(void 0, e[r]) : n(e[r], t[r])
                }

                function o(e) {
                    if (!_f.isUndefined(t[e])) return n(void 0, t[e])
                }

                function s(r) {
                    return _f.isUndefined(t[r]) ? _f.isUndefined(e[r]) ? void 0 : n(void 0, e[r]) : n(void 0, t[r])
                }

                function a(r) {
                    return r in t ? n(e[r], t[r]) : r in e ? n(void 0, e[r]) : void 0
                }

                var c = {
                    url: o,
                    method: o,
                    data: o,
                    baseURL: s,
                    transformRequest: s,
                    transformResponse: s,
                    paramsSerializer: s,
                    timeout: s,
                    timeoutMessage: s,
                    withCredentials: s,
                    adapter: s,
                    responseType: s,
                    xsrfCookieName: s,
                    xsrfHeaderName: s,
                    onUploadProgress: s,
                    onDownloadProgress: s,
                    decompress: s,
                    maxContentLength: s,
                    maxBodyLength: s,
                    beforeRedirect: s,
                    transport: s,
                    httpAgent: s,
                    httpsAgent: s,
                    cancelToken: s,
                    socketPath: s,
                    responseEncoding: s,
                    validateStatus: a
                };
                return _f.forEach(Object.keys(e).concat(Object.keys(t)), function (e) {
                    var t = c[e] || i, n = t(e);
                    _f.isUndefined(n) && t !== a || (r[e] = n)
                }), r
            }, gf = "0.27.2", Ef = wp, yf = {};
            ["object", "boolean", "number", "function", "string", "symbol"].forEach(function (e, t) {
                yf[e] = function (r) {
                    return typeof r === e || "a" + (t < 1 ? "n " : " ") + e
                }
            });
            var Sf = {};
            yf.transitional = function (e, t, r) {
                function n(e, t) {
                    return "[Axios v" + gf + "] Transitional option '" + e + "'" + t + (r ? ". " + r : "")
                }

                return function (r, i, o) {
                    if (!1 === e) throw new Ef(n(i, " has been removed" + (t ? " in " + t : "")), Ef.ERR_DEPRECATED);
                    return t && !Sf[i] && (Sf[i] = !0, console.warn(n(i, " has been deprecated since v" + t + " and will be removed in the near future"))), !e || e(r, i, o)
                }
            };
            var bf = fp, Tf = vp, Rf = yp, If = function (e) {
                return mf(e), e.headers = e.headers || {}, e.data = lf.call(e, e.data, e.headers, e.transformRequest), e.headers = df.merge(e.headers.common || {}, e.headers[e.method] || {}, e.headers), df.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function (t) {
                    delete e.headers[t]
                }), (e.adapter || pf.adapter)(e).then(function (t) {
                    return mf(e), t.data = lf.call(e, t.data, t.headers, e.transformResponse), t
                }, function (t) {
                    return hf(t) || (mf(e), t && t.response && (t.response.data = lf.call(e, t.response.data, t.response.headers, e.transformResponse))), Promise.reject(t)
                })
            }, wf = vf, Cf = kp, Af = {
                assertOptions: function (e, t, r) {
                    if ("object" != typeof e) throw new Ef("options must be an object", Ef.ERR_BAD_OPTION_VALUE);
                    for (var n = Object.keys(e), i = n.length; i-- > 0;) {
                        var o = n[i], s = t[o];
                        if (s) {
                            var a = e[o], c = void 0 === a || s(a, o, e);
                            if (!0 !== c) throw new Ef("option " + o + " must be " + c, Ef.ERR_BAD_OPTION_VALUE)
                        } else if (!0 !== r) throw new Ef("Unknown option " + o, Ef.ERR_BAD_OPTION)
                    }
                }, validators: yf
            }, Of = Af.validators;

            function Nf(e) {
                this.defaults = e, this.interceptors = {request: new Rf, response: new Rf}
            }

            Nf.prototype.request = function (e, t) {
                "string" == typeof e ? (t = t || {}).url = e : t = e || {}, (t = wf(this.defaults, t)).method ? t.method = t.method.toLowerCase() : this.defaults.method ? t.method = this.defaults.method.toLowerCase() : t.method = "get";
                var r = t.transitional;
                void 0 !== r && Af.assertOptions(r, {
                    silentJSONParsing: Of.transitional(Of.boolean),
                    forcedJSONParsing: Of.transitional(Of.boolean),
                    clarifyTimeoutError: Of.transitional(Of.boolean)
                }, !1);
                var n = [], i = !0;
                this.interceptors.request.forEach(function (e) {
                    "function" == typeof e.runWhen && !1 === e.runWhen(t) || (i = i && e.synchronous, n.unshift(e.fulfilled, e.rejected))
                });
                var o, s = [];
                if (this.interceptors.response.forEach(function (e) {
                    s.push(e.fulfilled, e.rejected)
                }), !i) {
                    var a = [If, void 0];
                    for (Array.prototype.unshift.apply(a, n), a = a.concat(s), o = Promise.resolve(t); a.length;) o = o.then(a.shift(), a.shift());
                    return o
                }
                for (var c = t; n.length;) {
                    var u = n.shift(), d = n.shift();
                    try {
                        c = u(c)
                    } catch (e) {
                        d(e);
                        break
                    }
                }
                try {
                    o = If(c)
                } catch (e) {
                    return Promise.reject(e)
                }
                for (; s.length;) o = o.then(s.shift(), s.shift());
                return o
            }, Nf.prototype.getUri = function (e) {
                e = wf(this.defaults, e);
                var t = Cf(e.baseURL, e.url);
                return Tf(t, e.params, e.paramsSerializer)
            }, bf.forEach(["delete", "get", "head", "options"], function (e) {
                Nf.prototype[e] = function (t, r) {
                    return this.request(wf(r || {}, {method: e, url: t, data: (r || {}).data}))
                }
            }), bf.forEach(["post", "put", "patch"], function (e) {
                function t(t) {
                    return function (r, n, i) {
                        return this.request(wf(i || {}, {
                            method: e,
                            headers: t ? {"Content-Type": "multipart/form-data"} : {},
                            url: r,
                            data: n
                        }))
                    }
                }

                Nf.prototype[e] = t(), Nf.prototype[e + "Form"] = t(!0)
            });
            var Pf = Nf, Df = Fp;

            function kf(e) {
                if ("function" != typeof e) throw new TypeError("executor must be a function.");
                var t;
                this.promise = new Promise(function (e) {
                    t = e
                });
                var r = this;
                this.promise.then(function (e) {
                    if (r._listeners) {
                        var t, n = r._listeners.length;
                        for (t = 0; t < n; t++) r._listeners[t](e);
                        r._listeners = null
                    }
                }), this.promise.then = function (e) {
                    var t, n = new Promise(function (e) {
                        r.subscribe(e), t = e
                    }).then(e);
                    return n.cancel = function () {
                        r.unsubscribe(t)
                    }, n
                }, e(function (e) {
                    r.reason || (r.reason = new Df(e), t(r.reason))
                })
            }

            kf.prototype.throwIfRequested = function () {
                if (this.reason) throw this.reason
            }, kf.prototype.subscribe = function (e) {
                this.reason ? e(this.reason) : this._listeners ? this._listeners.push(e) : this._listeners = [e]
            }, kf.prototype.unsubscribe = function (e) {
                if (this._listeners) {
                    var t = this._listeners.indexOf(e);
                    -1 !== t && this._listeners.splice(t, 1)
                }
            }, kf.source = function () {
                var e;
                return {
                    token: new kf(function (t) {
                        e = t
                    }), cancel: e
                }
            };
            var Lf = kf, xf = fp, Mf = fp, Uf = Jh, jf = Pf, Vf = vf, Ff = function e(t) {
                var r = new jf(t), n = Uf(jf.prototype.request, r);
                return Mf.extend(n, jf.prototype, r), Mf.extend(n, r), n.create = function (r) {
                    return e(Vf(t, r))
                }, n
            }(sf);
            Ff.Axios = jf, Ff.CanceledError = Fp, Ff.CancelToken = Lf, Ff.isCancel = uf, Ff.VERSION = "0.27.2", Ff.toFormData = Op, Ff.AxiosError = wp, Ff.Cancel = Ff.CanceledError, Ff.all = function (e) {
                return Promise.all(e)
            }, Ff.spread = function (e) {
                return function (t) {
                    return e.apply(null, t)
                }
            }, Ff.isAxiosError = function (e) {
                return xf.isObject(e) && !0 === e.isAxiosError
            }, Yh.exports = Ff, Yh.exports.default = Ff;
            var Bf = Yh.exports;

            class Wf {
                constructor() {
                    Kh(this, "_events", {}), Kh(this, "addListener", this.on)
                }

                getListeners(e) {
                    return this._events[e] ? this._events[e].map(e => e.listener) : []
                }

                on(e, t) {
                    this._events[e] || (this._events[e] = []);
                    const r = this._events[e];
                    -1 === this._indexOfListener(r, t) && r.push({listener: t, once: !1})
                }

                once(e, t) {
                    this._events[e] || (this._events[e] = []);
                    const r = this._events[e];
                    -1 === this._indexOfListener(r, t) && r.push({listener: t, once: !0})
                }

                off(e, t) {
                    if (!this._events[e]) return;
                    const r = this._events[e], n = this._indexOfListener(r, t);
                    -1 !== n && r.splice(n, 1), 0 === this._events[e].length && delete this._events[e]
                }

                removeAllListeners(e) {
                    e ? delete this._events[e] : this._events = {}
                }

                emit(e) {
                    this._events[e] || (this._events[e] = []);
                    const t = this._events[e].map(e => e);
                    for (var r = arguments.length, n = new Array(r > 1 ? r - 1 : 0), i = 1; i < r; i++) n[i - 1] = arguments[i];
                    for (let r = 0; r < t.length; r += 1) {
                        const i = t[r];
                        i.once && this.off(e, i.listener), i.listener.apply(this, n || [])
                    }
                }

                _indexOfListener(e, t) {
                    let r = e.length;
                    for (; r--;) if (e[r].listener === t) return r;
                    return -1
                }
            }

            const Gf = new class extends Wf {
                reportLogUploadError(e) {
                    this.emit("REPORT_LOG_UPLOAD", e)
                }
            };
            let qf;
            !function (e) {
                e.UNEXPECTED_ERROR = "UNEXPECTED_ERROR", e.UNEXPECTED_RESPONSE = "UNEXPECTED_RESPONSE", e.TIMEOUT = "TIMEOUT", e.INVALID_PARAMS = "INVALID_PARAMS", e.NOT_READABLE = "NOT_READABLE", e.NOT_SUPPORTED = "NOT_SUPPORTED", e.INVALID_OPERATION = "INVALID_OPERATION", e.OPERATION_ABORTED = "OPERATION_ABORTED", e.WEB_SECURITY_RESTRICT = "WEB_SECURITY_RESTRICT", e.EXCHANGE_SDP_FAILED = "EXCHANGE_SDP_FAILED", e.NETWORK_ERROR = "NETWORK_ERROR", e.NETWORK_TIMEOUT = "NETWORK_TIMEOUT", e.NETWORK_RESPONSE_ERROR = "NETWORK_RESPONSE_ERROR", e.API_INVOKE_TIMEOUT = "API_INVOKE_TIMEOUT", e.ENUMERATE_DEVICES_FAILED = "ENUMERATE_DEVICES_FAILED", e.DEVICE_NOT_FOUND = "DEVICE_NOT_FOUND", e.ELECTRON_IS_NULL = "ELECTRON_IS_NULL", e.ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR = "ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR", e.CHROME_PLUGIN_NO_RESPONSE = "CHROME_PLUGIN_NO_RESPONSE", e.CHROME_PLUGIN_NOT_INSTALL = "CHROME_PLUGIN_NOT_INSTALL", e.MEDIA_OPTION_INVALID = "MEDIA_OPTION_INVALID", e.PERMISSION_DENIED = "PERMISSION_DENIED", e.CONSTRAINT_NOT_SATISFIED = "CONSTRAINT_NOT_SATISFIED", e.TRACK_IS_DISABLED = "TRACK_IS_DISABLED", e.GET_VIDEO_ELEMENT_VISIBLE_ERROR = "GET_VIDEO_ELEMENT_VISIBLE_ERROR", e.SHARE_AUDIO_NOT_ALLOWED = "SHARE_AUDIO_NOT_ALLOWED", e.LOW_STREAM_ENCODING_ERROR = "LOW_STREAM_ENCODING_ERROR", e.SET_ENCODING_PARAMETER_ERROR = "SET_ENCODING_PARAMETER_ERROR", e.TRACK_STATE_UNREACHABLE = "TRACK_STATE_UNREACHABLE", e.INVALID_UINT_UID_FROM_STRING_UID = "INVALID_UINT_UID_FROM_STRING_UID", e.CAN_NOT_GET_PROXY_SERVER = "CAN_NOT_GET_PROXY_SERVER", e.CAN_NOT_GET_GATEWAY_SERVER = "CAN_NOT_GET_GATEWAY_SERVER", e.VOID_GATEWAY_ADDRESS = "VOID_GATEWAY_ADDRESS", e.UID_CONFLICT = "UID_CONFLICT", e.MULTI_UNILBS_RESPONSE_ERROR = "MULTI_UNILBS_RESPONSE_ERROR", e.UPDATE_TICKET_FAILED = "UPDATE_TICKET_FAILED", e.INVALID_LOCAL_TRACK = "INVALID_LOCAL_TRACK", e.INVALID_TRACK = "INVALID_TRACK", e.SENDER_NOT_FOUND = "SENDER_NOT_FOUND", e.CREATE_OFFER_FAILED = "CREATE_OFFER_FAILED", e.SET_ANSWER_FAILED = "SET_ANSWER_FAILED", e.ICE_FAILED = "ICE_FAILED", e.PC_CLOSED = "PC_CLOSED", e.SENDER_REPLACE_FAILED = "SENDER_REPLACE_FAILED", e.GET_LOCAL_CAPABILITIES_FAILED = "GET_LOCAL_CAPABILITIES_FAILED", e.GET_LOCAL_CONNECTION_PARAMS_FAILED = "GET_LOCAL_CONNECTION_PARAMS_FAILED", e.SUBSCRIBE_FAILED = "SUBSCRIBE_FAILED", e.UNSUBSCRIBE_FAILED = "UNSUBSCRIBE_FAILED", e.GATEWAY_P2P_LOST = "GATEWAY_P2P_LOST", e.NO_ICE_CANDIDATE = "NO_ICE_CANDIDATE", e.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS = "CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS", e.EXIST_DISABLED_VIDEO_TRACK = "EXIST_DISABLED_VIDEO_TRACK", e.INVALID_REMOTE_USER = "INVALID_REMOTE_USER", e.REMOTE_USER_IS_NOT_PUBLISHED = "REMOTE_USER_IS_NOT_PUBLISHED", e.CUSTOM_REPORT_SEND_FAILED = "CUSTOM_REPORT_SEND_FAILED", e.CUSTOM_REPORT_FREQUENCY_TOO_HIGH = "CUSTOM_REPORT_FREQUENCY_TOO_HIGH", e.FETCH_AUDIO_FILE_FAILED = "FETCH_AUDIO_FILE_FAILED", e.READ_LOCAL_AUDIO_FILE_ERROR = "READ_LOCAL_AUDIO_FILE_ERROR", e.DECODE_AUDIO_FILE_FAILED = "DECODE_AUDIO_FILE_FAILED", e.WS_ABORT = "WS_ABORT", e.WS_DISCONNECT = "WS_DISCONNECT", e.WS_ERR = "WS_ERR", e.LIVE_STREAMING_TASK_CONFLICT = "LIVE_STREAMING_TASK_CONFLICT", e.LIVE_STREAMING_INVALID_ARGUMENT = "LIVE_STREAMING_INVALID_ARGUMENT", e.LIVE_STREAMING_INTERNAL_SERVER_ERROR = "LIVE_STREAMING_INTERNAL_SERVER_ERROR", e.LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED = "LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED", e.LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED = "LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED", e.LIVE_STREAMING_CDN_ERROR = "LIVE_STREAMING_CDN_ERROR", e.LIVE_STREAMING_INVALID_RAW_STREAM = "LIVE_STREAMING_INVALID_RAW_STREAM", e.LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT = "LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT", e.LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE = "LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE", e.LIVE_STREAMING_WARN_FREQUENT_REQUEST = "LIVE_STREAMING_WARN_FREQUENT_REQUEST", e.WEBGL_INTERNAL_ERROR = "WEBGL_INTERNAL_ERROR", e.BEAUTY_PROCESSOR_INTERNAL_ERROR = "BEAUTY_PROCESSOR_INTERNAL_ERROR", e.CROSS_CHANNEL_WAIT_STATUS_ERROR = "CROSS_CHANNEL_WAIT_STATUS_ERROR", e.CROSS_CHANNEL_FAILED_JOIN_SRC = "CROSS_CHANNEL_FAILED_JOIN_SEC", e.CROSS_CHANNEL_FAILED_JOIN_DEST = "CROSS_CHANNEL_FAILED_JOIN_DEST", e.CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST = "CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST", e.CROSS_CHANNEL_SERVER_ERROR_RESPONSE = "CROSS_CHANNEL_SERVER_ERROR_RESPONSE", e.METADATA_OUT_OF_RANGE = "METADATA_OUT_OF_RANGE", e.LOCAL_AEC_ERROR = "LOCAL_AEC_ERROR", e.INVALID_PLUGIN = "INVALID_PLUGIN", e.DISCONNECT_P2P = "DISCONNECT_P2P", e.INIT_WEBSOCKET_TIMEOUT = "INIT_WEBSOCKET_TIMEOUT", e.CONVERTING_IMAGEDATA_TO_BLOB_FAILED = "CONVERTING_IMAGEDATA_TO_BLOB_FAILED", e.CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED = "CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED", e.INIT_DATACHANNEL_TIMEOUT = "INIT_DATACHANNEL_TIMEOUT", e.DATACHANNEL_CONNECTION_TIMEOUT = "DATACHANNEL_CONNECTION_TIMEOUT"
            }(qf || (qf = {}));

            class Hf extends Error {
                constructor(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "",
                        r = arguments.length > 2 ? arguments[2] : void 0;
                    super(t), Kh(this, "code", void 0), Kh(this, "message", void 0), Kh(this, "data", void 0), Kh(this, "name", "AgoraRTCException"), this.code = e, this.message = "AgoraRTCError ".concat(this.code, ": ").concat(t), this.data = r
                }

                toString() {
                    return this.data ? "data: ".concat(JSON.stringify(this.data), "\n").concat(this.stack) : "".concat(this.stack)
                }

                print() {
                    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "error";
                    return "error" === e && em.error(this.toString()), "warning" === e && em.warning(this.toString()), this
                }

                throw() {
                    throw this.print(), this
                }
            }

            const Kf = {timeout: 500, timeoutFactor: 1.5, maxRetryCount: 1 / 0, maxRetryTimeout: 1e4};

            function zf(e, t) {
                const r = Math.floor(t.timeout * Math.pow(t.timeoutFactor, e));
                return Math.min(t.maxRetryTimeout, r)
            }

            function Yf(e, t, r, n) {
                const i = Object.assign({}, Kf, n);
                let o = i.timeout;
                const s = async () => {
                    await function (e) {
                        return new sl(t => {
                            window.setTimeout(t, e)
                        })
                    }(o), o *= i.timeoutFactor, o = Math.min(i.maxRetryTimeout, o)
                };
                let a = !1;
                const c = new sl(async (n, o) => {
                    t = t || (() => !1), r = r || (() => !0);
                    for (let r = 0; r < i.maxRetryCount; r += 1) {
                        if (a) return o(new Hf(qf.OPERATION_ABORTED));
                        try {
                            const a = await e();
                            if (!t(a, r)) return n(a);
                            if (r + 1 === i.maxRetryCount) return n(a);
                            await s()
                        } catch (e) {
                            if (!a(e, r)) return o(e);
                            if (r + 1 === i.maxRetryCount) return o(e);
                            await s()
                        }
                    }
                });
                return c.cancel = (() => a = !0), c
            }

            function Jf() {
                const e = new Date;
                return e.toTimeString().split(" ")[0] + ":" + e.getMilliseconds()
            }

            function Xf() {
                const e = new Date, t = /((\d+:){2}\d+)/.exec((new Date).toUTCString());
                return t ? (null == t ? void 0 : t[0]) + ":" + e.getUTCMilliseconds() : e.toTimeString().split(" ")[0] + ":" + e.getMilliseconds()
            }

            const Qf = {DEBUG: 0, INFO: 1, WARNING: 2, ERROR: 3, NONE: 4}, $f = Date.now(), Zf = e => {
                for (const t in Qf) if (Object.prototype.hasOwnProperty.call(Qf, t) && Qf[t] === e) return t;
                return "DEFAULT"
            }, em = new class {
                constructor() {
                    Kh(this, "proxyServerURL", void 0), Kh(this, "logLevel", Qf.DEBUG), Kh(this, "uploadState", "collecting"), Kh(this, "uploadLogWaitingList", []), Kh(this, "uploadLogUploadingList", []), Kh(this, "uploadErrorCount", 0), Kh(this, "currentLogID", 0), Kh(this, "url", void 0), Kh(this, "extLog", (e, t) => {
                        this.appendLogToWaitingList(e, ...t)
                    })
                }

                debug() {
                    for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];
                    const n = [Qf.DEBUG].concat(t);
                    this.log.apply(this, n)
                }

                info() {
                    for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];
                    const n = [Qf.INFO].concat(t);
                    this.log.apply(this, n)
                }

                warning() {
                    for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];
                    const n = [Qf.WARNING].concat(t);
                    this.log.apply(this, n)
                }

                error() {
                    for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];
                    const n = [Qf.ERROR].concat(t);
                    this.log.apply(this, n)
                }

                upload() {
                    for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];
                    const n = [Qf.DEBUG].concat(t);
                    this.uploadLog.apply(this, n)
                }

                setLogLevel(e) {
                    e = Math.min(Math.max(0, e), 4), this.logLevel = e
                }

                enableLogUpload() {
                    pm("UPLOAD_LOG", !0)
                }

                disableLogUpload() {
                    pm("UPLOAD_LOG", !1), this.uploadLogUploadingList = [], this.uploadLogWaitingList = []
                }

                setProxyServer(e) {
                    this.proxyServerURL = e
                }

                prefix(e) {
                    return new class {
                        constructor(e) {
                            Kh(this, "logger", void 0), Kh(this, "prefixLists", []), this.logger = e
                        }

                        debug() {
                            for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];
                            this.logger.debug(...this.prefixLists, ...t)
                        }

                        info() {
                            for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];
                            this.logger.info(...this.prefixLists, ...t)
                        }

                        warning() {
                            for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];
                            this.logger.warning(...this.prefixLists, ...t)
                        }

                        error() {
                            for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];
                            this.logger.error(...this.prefixLists, ...t)
                        }

                        prefix(e) {
                            return this.prefixLists.push(e), this
                        }

                        popPrefix() {
                            return this.prefixLists.pop(), this
                        }
                    }(this).prefix(e)
                }

                log() {
                    for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];
                    if (Date.now() - $f < 100) return void setTimeout(() => {
                        this.log(...t)
                    }, Date.now() - $f);
                    const n = Math.max(0, Math.min(4, t[0]));
                    if (t[0] = Jf() + " Agora-SDK [".concat(Zf(n), "]:"), this.appendLogToWaitingList(n, ...t), n < this.logLevel) return;
                    const i = Jf() + " %cAgora-SDK [".concat(Zf(n), "]:");
                    let o = [];
                    if (!fm("USE_NEW_LOG")) switch (n) {
                        case Qf.DEBUG:
                            o = [i, "color: #64B5F6;"].concat(t.slice(1)), console.log.apply(console, o);
                            break;
                        case Qf.INFO:
                            o = [i, "color: #1E88E5; font-weight: bold;"].concat(t.slice(1)), console.log.apply(console, o);
                            break;
                        case Qf.WARNING:
                            o = [i, "color: #FB8C00; font-weight: bold;"].concat(t.slice(1)), console.warn.apply(console, o);
                            break;
                        case Qf.ERROR:
                            o = [i, "color: #B00020; font-weight: bold;"].concat(t.slice(1)), console.error.apply(console, o)
                    }
                }

                uploadLog() {
                    for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];
                    if (Date.now() - $f < 100) return void setTimeout(() => {
                        this.uploadLog(...t)
                    }, Date.now() - $f);
                    const n = Math.max(0, Math.min(4, t[0]));
                    t[0] = Jf() + " Agora-SDK [".concat(Zf(n), "]:"), this.appendLogToWaitingList(n, ...t)
                }

                appendLogToWaitingList(e) {
                    if (!fm("UPLOAD_LOG")) return;
                    for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++) r[n - 1] = arguments[n];
                    Array.isArray(r[0]) ? r[0][0] = Xf() + " Agora-SDK [".concat(Zf(e), "]:") : r[0] = Xf() + " Agora-SDK [".concat(Zf(e), "]:");
                    let i = "";
                    r.forEach(e => {
                        "object" == typeof e && (e = JSON.stringify(e)), i += "".concat(e, " ")
                    }), this.uploadLogWaitingList.push({
                        payload_str: i,
                        log_level: e,
                        log_item_id: this.currentLogID++
                    }), "uploading" === this.uploadState && 0 === this.uploadLogUploadingList.length && this.uploadLogInterval()
                }

                startUpload() {
                    this.uploadState = "uploading", 0 === this.uploadLogUploadingList.length && this.uploadLogInterval()
                }

                async uploadLogs() {
                    const e = this.uploadLogUploadingList,
                        t = {sdk_version: rm, process_id: fm("PROCESS_ID"), payload: JSON.stringify(e)};
                    return Yf(async () => {
                        const e = await Bf.post(this.url || (this.proxyServerURL ? "https://".concat(this.proxyServerURL, "/ls/?h=").concat(fm("LOG_UPLOAD_SERVER"), "&p=443&d=upload/v1") : "https://".concat(fm("LOG_UPLOAD_SERVER"), "/upload/v1")), t, {responseType: "text"});
                        if ("OK" !== e.data) {
                            const t = new Error("unexpected upload log response");
                            throw t.response = e, t
                        }
                    }, () => (this.uploadLogUploadingList = [], !1), e => (e.response ? Gf.reportLogUploadError({
                        status: e.response.status,
                        data: e.response.data,
                        headers: e.response.headers,
                        message: e.message
                    }) : e.request ? Gf.reportLogUploadError({
                        status: e.request.status,
                        message: e.message
                    }) : Gf.reportLogUploadError({
                        status: -1,
                        message: e.message
                    }), !0), {
                        timeout: fm("UPLOAD_LOG_REQUEST_RETRY_INTERVAL"),
                        maxRetryTimeout: fm("UPLOAD_LOG_REQUEST_MAX_RETRY_INTERVAL")
                    })
                }

                uploadLogInterval() {
                    0 === this.uploadLogUploadingList.length && 0 === this.uploadLogWaitingList.length || (0 === this.uploadLogUploadingList.length && (this.uploadLogUploadingList = this.uploadLogWaitingList.splice(0, fm("UPLOAD_LOG_LENGTH_EACH_TIME"))), this.uploadLogs().then(() => {
                        this.uploadErrorCount = 0, this.uploadLogWaitingList.length > 0 && window.setTimeout(() => this.uploadLogInterval(), fm("UPLOAD_LOG_INTERVAL"))
                    }).catch(e => {
                        this.uploadErrorCount += 1, this.uploadErrorCount < 2 ? window.setTimeout(() => this.uploadLogInterval(), fm("UPLOAD_LOG_TWICE_RETRY_INTERVAL_V1")) : window.setTimeout(() => this.uploadLogInterval(), fm("UPLOAD_LOG_RETRY_INTERVAL_V1"))
                    }))
                }
            }, tm = "v4.16.0-0-g1b0d4ed6-dirty(1/5/2023, 2:12:28 PM)", rm = function (e) {
                if (e.match(/[0-9]+\.[0-9]+\.[0-9]+$/)) return e;
                const t = e.match(/([0-9]+\.[0-9]+\.[0-9]+)\-alpha\.([0-9]+)/);
                if (t && t[1] && t[2]) {
                    const e = t[1], r = t[2];
                    return "".concat(e, ".").concat(r)
                }
                const r = e.match(/([0-9]+\.[0-9]+\.[0-9]+)\-special\.([0-9]+)/);
                if (r && r[1] && r[2]) {
                    const e = r[1], t = r[2];
                    return "".concat(e, ".").concat(100 * (Number(t) + 1))
                }
                return "4.0.0.999"
            }("4.16.0"), nm = function () {
                try {
                    return !0 === JSON.parse("true")
                } catch (e) {
                    return !0
                }
            }(), im = function () {
                const e = "us".concat("erna", "me"), t = "pa".concat("sswo", "rd"), r = ["t", "s", "t"];
                r.splice(1, 0, "e");
                const n = r.join(""), i = [];
                for (let e = 0; e < 6; e++) i.push("1");
                const o = i.join(""), s = {};
                return s[e] = n, s[t] = o, Object.assign(s, {
                    turnServerURL: "",
                    tcpport: 3433,
                    udpport: 3478,
                    forceturn: !1
                })
            }();
            window.DEFAULT_TURN_CONFIG = im;
            const om = {
                "90p": gm(160, 90),
                "90p_1": gm(160, 90),
                "120p": gm(160, 120, 15, 30, 65),
                "120p_1": gm(160, 120, 15, 30, 65),
                "120p_3": gm(120, 120, 15, 30, 50),
                "120p_4": gm(212, 120),
                "180p": gm(320, 180, 15, 30, 140),
                "180p_1": gm(320, 180, 15, 30, 140),
                "180p_3": gm(180, 180, 15, 30, 100),
                "180p_4": gm(240, 180, 15, 30, 120),
                "240p": gm(320, 240, 15, 40, 200),
                "240p_1": gm(320, 240, 15, 40, 200),
                "240p_3": gm(240, 240, 15, 40, 140),
                "240p_4": gm(424, 240, 15, 40, 220),
                "360p": gm(640, 360, 15, 80, 400),
                "360p_1": gm(640, 360, 15, 80, 400),
                "360p_3": gm(360, 360, 15, 80, 260),
                "360p_4": gm(640, 360, 30, 80, 600),
                "360p_6": gm(360, 360, 30, 80, 400),
                "360p_7": gm(480, 360, 15, 80, 320),
                "360p_8": gm(480, 360, 30, 80, 490),
                "360p_9": gm(640, 360, 15, 80, 800),
                "360p_10": gm(640, 360, 24, 80, 800),
                "360p_11": gm(640, 360, 24, 80, 1e3),
                "480p": gm(640, 480, 15, 100, 500),
                "480p_1": gm(640, 480, 15, 100, 500),
                "480p_2": gm(640, 480, 30, 100, 1e3),
                "480p_3": gm(480, 480, 15, 100, 400),
                "480p_4": gm(640, 480, 30, 100, 750),
                "480p_6": gm(480, 480, 30, 100, 600),
                "480p_8": gm(848, 480, 15, 100, 610),
                "480p_9": gm(848, 480, 30, 100, 930),
                "480p_10": gm(640, 480, 10, 100, 400),
                "720p": gm(1280, 720, 15, 120, 1130),
                "720p_1": gm(1280, 720, 15, 120, 1130),
                "720p_2": gm(1280, 720, 30, 120, 2e3),
                "720p_3": gm(1280, 720, 30, 120, 1710),
                "720p_5": gm(960, 720, 15, 120, 910),
                "720p_6": gm(960, 720, 30, 120, 1380),
                "1080p": gm(1920, 1080, 15, 120, 2080),
                "1080p_1": gm(1920, 1080, 15, 120, 2080),
                "1080p_2": gm(1920, 1080, 30, 120, 3e3),
                "1080p_3": gm(1920, 1080, 30, 120, 3150),
                "1080p_5": gm(1920, 1080, 60, 120, 4780),
                "1440p": gm(2560, 1440, 30, 120, 4850),
                "1440p_1": gm(2560, 1440, 30, 120, 4850),
                "1440p_2": gm(2560, 1440, 60, 120, 7350),
                "4k": gm(3840, 2160, 30, 120, 8910),
                "4k_1": gm(3840, 2160, 30, 120, 8910),
                "4k_3": gm(3840, 2160, 60, 120, 13500)
            }, sm = {
                "480p": Em(640, 480, 5),
                "480p_1": Em(640, 480, 5),
                "480p_2": Em(640, 480, 30),
                "480p_3": Em(640, 480, 15),
                "720p": Em(1280, 720, 5),
                "720p_1": Em(1280, 720, 5),
                "720p_2": Em(1280, 720, 30),
                "720p_3": Em(1280, 720, 15),
                "1080p": Em(1920, 1080, 5),
                "1080p_1": Em(1920, 1080, 5),
                "1080p_2": Em(1920, 1080, 30),
                "1080p_3": Em(1920, 1080, 15)
            }, am = {"1SL1TL": ym(1, 1), "3SL3TL": ym(3, 3), "2SL3TL": ym(2, 3)};

            function cm(e) {
                return "string" == typeof e ? Object.assign({}, om[e]) : e
            }

            function um(e) {
                return "string" == typeof e ? Object.assign({}, sm[e]) : e
            }

            function dm(e) {
                return "string" == typeof e ? Object.assign({}, am[e]) : e
            }

            const lm = {
                speech_low_quality: vm(16e3, !1),
                speech_standard: vm(32e3, !1, 18),
                music_standard: vm(48e3, !1),
                standard_stereo: vm(48e3, !0, 56),
                high_quality: vm(48e3, !1, 128),
                high_quality_stereo: vm(48e3, !0, 192)
            };

            function hm(e) {
                return "string" == typeof e ? Object.assign({}, lm[e]) : e
            }

            function pm(e, t, r) {
                Object.keys(mm).includes(e) && (!r && Object.keys(_m).includes(e) || (mm[e] = t))
            }

            function fm(e) {
                return mm[e]
            }

            const mm = {
                PROCESS_ID: "",
                ENCRYPT_AES: !0,
                AREAS: ["CHINA", "GLOBAL"],
                WEBCS_DOMAIN: ["webrtc2-ap-web-1.agora.io", "webrtc2-2.ap.sd-rtn.com"],
                WEBCS_DOMAIN_BACKUP_LIST: ["webrtc2-ap-web-3.agora.io", "webrtc2-4.ap.sd-rtn.com"],
                PROXY_CS: ["ap-proxy-1.agora.io", "ap-proxy-2.agora.io"],
                CDS_AP: ["cds-ap-web-1.agora.io", "cds-web-2.ap.sd-rtn.com", "cds-ap-web-3.agora.io", "cds-web-4.ap.sd-rtn.com"],
                ACCOUNT_REGISTER: ["sua-ap-web-1.agora.io", "sua-web-2.ap.sd-rtn.com", "sua-ap-web-3.agora.io", "sua-web-4.ap.sd-rtn.com"],
                UAP_AP: ["uap-ap-web-1.agora.io", "uap-web-2.ap.sd-rtn.com", "uap-ap-web-3.agora.io", "uap-web-4.ap.sd-rtn.com"],
                LOG_UPLOAD_SERVER: "logservice.agora.io",
                EVENT_REPORT_DOMAIN: "statscollector-1.agora.io",
                EVENT_REPORT_BACKUP_DOMAIN: "web-2.statscollector.sd-rtn.com",
                ENABLE_EVENT_REPORT: !0,
                GATEWAY_ADDRESS: [],
                GATEWAY_WSS_ADDRESS: "",
                LIVE_STREAMING_ADDRESS: "",
                HTTP_CONNECT_TIMEOUT: 5e3,
                SIGNAL_REQUEST_TIMEOUT: 1e4,
                REPORT_STATS: !0,
                UPLOAD_LOG: !1,
                NOT_REPORT_EVENT: [],
                SUBSCRIBE_TCC: !0,
                PUBLISH_TCC: !1,
                PING_PONG_TIME_OUT: 10,
                WEBSOCKET_TIMEOUT_MIN: 1e4,
                EVENT_REPORT_SEND_INTERVAL: 3e3,
                CONFIG_DISTRIBUTE_INTERVAL: 3e5,
                ENABLE_CONFIG_DISTRIBUTE: !0,
                CANDIDATE_TIMEOUT: 5e3,
                SHOW_REPORT_INVOKER_LOG: !1,
                JOIN_EXTEND: "",
                PUB_EXTEND: "",
                SUB_EXTEND: "",
                FORCE_TURN: !1,
                TURN_ENABLE_TCP: !0,
                TURN_ENABLE_UDP: !0,
                MAX_UPLOAD_CACHE: 50,
                UPLOAD_CACHE_INTERVAL: 2e3,
                AJAX_REQUEST_CONCURRENT: 3,
                REPORT_APP_SCENARIO: void 0,
                GATEWAY_DOMAINS: ["edge.agora.io", "edge.sd-rtn.com"],
                WORKER_DOMAIN: "edge.agora.io",
                TURN_DOMAIN: "edge.agora.io",
                EVENT_REPORT_RETRY: !0,
                CHROME_FORCE_PLAN_B: !1,
                AUDIO_SOURCE_VOLUME_UPDATE_INTERVAL: 400,
                AUDIO_SOURCE_AVG_VOLUME_DURATION: 3e3,
                AUDIO_VOLUME_INDICATION_INTERVAL: 2e3,
                VOLUME_VOICE_WEIGHT: 10,
                GET_VOLUME_OF_MUTED_AUDIO_TRACK: !1,
                NORMAL_EVENT_QUEUE_CAPACITY: 100,
                CUSTOM_REPORT: !0,
                CUSTOM_REPORT_LIMIT: 20,
                PROXY_SERVER_TYPE2: "webnginx-proxy.agora.io",
                PROXY_SERVER_TYPE3: ["webrtc-cloud-proxy.sd-rtn.com", "webrtc-cloud-proxy.agora.io"],
                CUSTOM_PUB_ANSWER_MODIFIER: null,
                CUSTOM_SUB_ANSWER_MODIFIER: null,
                CUSTOM_PUB_OFFER_MODIFIER: null,
                CUSTOM_SUB_OFFER_MODIFIER: null,
                DSCP_TYPE: "high",
                REMOVE_NEW_CODECS: !0,
                FRAGEMENT_LENGTH: 3,
                WEBSOCKET_COMPRESS: !1,
                SIMULCAST: !1,
                PRELOAD_MEDIA_COUNT: 0,
                USE_RTX: !1,
                CHECK_VIDEO_VISIBLE_INTERVAL: 3e4,
                ENUMERATE_DEVICES_INTERVAL: !1,
                ENUMERATE_DEVICES_INTERVAL_TIME: 1e4,
                USE_NEW_TOKEN: !1,
                CLOSE_AFB_FOR_LOCAL_AP: !0,
                JOIN_WITH_FALLBACK_SIGNAL_PROXY: !0,
                JOIN_WITH_FALLBACK_MEDIA_PROXY: !0,
                JOIN_WITH_FALLBACK_MEDIA_PROXY_FORCE: !1,
                JOIN_WITH_FALLBACK_PROXY_PENDING_DURATION: 2e3,
                USE_TURN_SERVER_OF_GATEWAY: !1,
                H264_PROFILE_LEVEL_ID: "",
                USE_NEW_LOG: !1,
                LOG_VERSION: 3,
                MEDIA_DEVICE_CONSTRAINTS: null,
                ENCRYPT_PROXY_USERNAME_AND_PSW: !0,
                SDP_LOGGING: !1,
                CSP_DETECTED_HOSTNAME_LIST: ["agora.io", "sd-rtn.com"],
                REMOTE_AUDIO_TRACK_USES_WEB_AUDIO: !1,
                LOCAL_AUDIO_TRACK_USES_WEB_AUDIO: !0,
                BITRATE_ADAPTER_TYPE: "STANDARD_BITRATE",
                AI_DENOISER_PARAMETERS: {},
                ADJUST_3A_FROM_PLUGINS: !0,
                RAISE_H264_BASELINE_PRIORITY: !0,
                FILTER_SEND_H264_BASELINE: !1,
                ENABLE_PUBLISHED_USER_LIST: !0,
                MAX_SUBSCRIPTION: 50,
                X_GOOGLE_START_BITRATE: void 0,
                NEW_REPORT_SERVER: !1,
                NEW_REPORT_SERVER_DOMAINS: ["data-reporting.agora.io", "data-reporting.agora.io"],
                VIDEO_INSPECT_WORKER_MESSAGE_LENGTH_LIMIT: 3e5,
                VIDEO_INSPECT_INTERVAL_MINIMUM: 1e3,
                VIDEO_INSPECT_QUALITY_RATIO: .9,
                VIDEO_INSPECT_WORKER_MANAGER_HOST: "edge.agora.io",
                VIDEO_INSPECT_WORKER_MANAGER_PORT: "",
                VIDEO_INSPECT_WORKER_PORT: "",
                SHOW_VIDEO_INSPECT_WORKER_MESSAGE: !1,
                STATS_COLLECTOR_PORT: 443,
                FORCE_TURN_TCP: !1,
                SUBSCRIBE_AUDIO_FILTER_TOPN: void 0,
                ENABLE_PUBLISH_AUDIO_FILTER: void 0,
                WEBAUDIO_INIT_OPTIONS: void 0,
                FILTER_VIDEO_FEC: !0,
                FILTER_AUDIO_FEC: !1,
                CHROME_DUAL_STREAM_USE_ENCODING: !0,
                EXTENSION_USAGE_UPLOAD_INTERVAL: 1e4,
                ICE_RESTART: !0,
                ENABLE_USER_LICENSE_CHECK: !0,
                SIGNAL_CHANNEL: 0,
                TRANSMITTER_INITIAL_RTT: 30,
                TRANSMITTER_INITIAL_RTO: 30,
                TRANSMITTER_MAX_BATCH_ACK_COUNT: 2,
                TRANSMITTER_MAX_RTO: 500,
                DATACHANNEL_COMPRESS: !1,
                FINGERPRINT: null,
                DC_JOIN_WITH_FAILBACK: 5e3,
                ENABLE_VIDEO_FRAME_CALLBACK: !0,
                VIDEO_FREEZE_DURATION: 500,
                SPATIALIZER_PARAMETERS: {},
                UPLOAD_LOG_INTERVAL: 3e3,
                UPLOAD_LOG_REQUEST_RETRY_INTERVAL: 2e3,
                UPLOAD_LOG_REQUEST_MAX_RETRY_INTERVAL: 2e4,
                UPLOAD_LOG_TRY_INTERVAL_WHILE_OFF: 5e3,
                UPLOAD_LOG_RETRY_INTERVAL_V1: 1e4,
                UPLOAD_LOG_TWICE_RETRY_INTERVAL_V1: 200,
                UPLOAD_LOG_LENGTH_EACH_TIME: 10,
                APP_TYPE: 0,
                DISABLE_WEBAUDIO: !1,
                CHANNEL_MEDIA_RELAY_SERVERS: void 0,
                ACCOUNT_REGISTER_RETRY_TIMEOUT: 1,
                ACCOUNT_REGISTER_RETRY_RATIO: 2,
                ACCOUNT_REGISTER_RETRY_TIMEOUT_MAX: 6e4,
                ACCOUNT_REGISTER_RETRY_COUNT_MAX: 1e5,
                AUDIO_CONTEXT: null,
                WEBCS_BACKUP_CONNECT_TIMEOUT: 6e3,
                PLAYER_STATE_DEFER: 2e3,
                SIGNAL_REQUEST_WATCH_INTERVAL: 1e3,
                FILEPATH_LENMAX: 255,
                DUALSTREAM_OPERATION_CHECK: !0,
                MEDIA_ELEMENT_EXISTS_DEPTH: 3,
                SHIM_CANDIDATE: !1,
                LEAVE_MSG_TIMEOUT: 2e3,
                STATS_FILTER: {transportId: !0, googTrackId: !0}
            }, _m = {};

            function vm(e, t, r) {
                return {sampleRate: e, stereo: t, bitrate: r}
            }

            function gm(e, t, r, n, i) {
                return {width: e, height: t, frameRate: r, bitrateMin: n, bitrateMax: i}
            }

            function Em(e, t, r, n, i) {
                return {width: {max: e}, height: {max: t}, frameRate: r, bitrateMin: n, bitrateMax: i}
            }

            function ym(e, t) {
                return {numSpatialLayers: e, numTemporalLayers: t}
            }

            nm || (mm.WEBCS_DOMAIN = ["ap-web-1-oversea.agora.io", "ap-web-1-north-america.agora.io"], mm.WEBCS_DOMAIN_BACKUP_LIST = ["ap-web-2-oversea.agora.io", "ap-web-2-north-america.agora.io"], mm.PROXY_CS = ["proxy-ap-web-oversea.agora.io", "proxy-ap-web-america.agora.io"], mm.CDS_AP = ["cds-ap-web-oversea.agora.io", "cds-ap-web-america.agora.io", "cds-ap-web-america2.agora.io"], mm.ACCOUNT_REGISTER = ["sua-ap-web-oversea.agora.io", "sua-ap-web-america.agora.io", "sua-ap-web-america2.agora.io"], mm.UAP_AP = ["uap-ap-web-oversea.agora.io", "uap-ap-web-america.agora.io", "uap-ap-web-america2.agora.io"], mm.LOG_UPLOAD_SERVER = "logservice-oversea.agora.io", mm.EVENT_REPORT_DOMAIN = "statscollector-1-oversea.agora.io", mm.EVENT_REPORT_BACKUP_DOMAIN = "statscollector-2-oversea.agora.io", mm.PROXY_SERVER_TYPE3 = "webrtc-cloud-proxy.agora.io", mm.AREAS = ["NORTH_AMERICA", "OVERSEA"]);
            const Sm = [[0, 1, 2, 3, 4, 5, 5], [0, 2, 2, 3, 4, 5, 5], [0, 3, 3, 3, 4, 5, 5], [0, 4, 4, 4, 4, 5, 5], [0, 5, 5, 5, 5, 5, 5]],
                bm = [], Tm = [];
            var Rm = mt, Im = qt, wm = D, Cm = function (e, t, r) {
                    var n = Rm(t);
                    n in e ? Im.f(e, n, wm(0, r)) : e[n] = r
                }, Am = On, Om = Ir, Nm = Cm, Pm = f.Array, Dm = Math.max, km = function (e, t, r) {
                    for (var n = Om(e), i = Am(t, n), o = Am(void 0 === r ? n : r, n), s = Pm(Dm(o - i, 0)), a = 0; i < o; i++, a++) Nm(s, a, e[i]);
                    return s.length = a, s
                }, Lm = km, xm = Math.floor, Mm = function (e, t) {
                    var r = e.length, n = xm(r / 2);
                    return r < 8 ? Um(e, t) : jm(e, Mm(Lm(e, 0, n), t), Mm(Lm(e, n), t), t)
                }, Um = function (e, t) {
                    for (var r, n, i = e.length, o = 1; o < i;) {
                        for (n = o, r = e[o]; n && t(e[n - 1], r) > 0;) e[n] = e[--n];
                        n !== o++ && (e[n] = r)
                    }
                    return e
                }, jm = function (e, t, r, n) {
                    for (var i = t.length, o = r.length, s = 0, a = 0; s < i || a < o;) e[s + a] = s < i && a < o ? n(t[s], r[a]) <= 0 ? t[s++] : r[a++] : s < i ? t[s++] : r[a++];
                    return e
                }, Vm = Mm, Fm = re.match(/firefox\/(\d+)/i), Bm = !!Fm && +Fm[1], Wm = /MSIE|Trident/.test(re),
                Gm = re.match(/AppleWebKit\/(\d+)\./), qm = !!Gm && +Gm[1], Hm = Er, Km = l, zm = Ie, Ym = Fe, Jm = Ir,
                Xm = wo, Qm = i, $m = Vm, Zm = Lr, e_ = Bm, t_ = Wm, r_ = ue, n_ = qm, i_ = [], o_ = Km(i_.sort),
                s_ = Km(i_.push), a_ = Qm(function () {
                    i_.sort(void 0)
                }), c_ = Qm(function () {
                    i_.sort(null)
                }), u_ = Zm("sort"), d_ = !Qm(function () {
                    if (r_) return r_ < 70;
                    if (!(e_ && e_ > 3)) {
                        if (t_) return !0;
                        if (n_) return n_ < 603;
                        var e, t, r, n, i = "";
                        for (e = 65; e < 76; e++) {
                            switch (t = String.fromCharCode(e), e) {
                                case 66:
                                case 69:
                                case 70:
                                case 72:
                                    r = 3;
                                    break;
                                case 68:
                                case 71:
                                    r = 4;
                                    break;
                                default:
                                    r = 2
                            }
                            for (n = 0; n < 47; n++) i_.push({k: t + n, v: r})
                        }
                        for (i_.sort(function (e, t) {
                            return t.v - e.v
                        }), n = 0; n < i_.length; n++) t = i_[n].k.charAt(0), i.charAt(i.length - 1) !== t && (i += t);
                        return "DGBEFHACIJK" !== i
                    }
                });
            Hm({target: "Array", proto: !0, forced: a_ || !c_ || !u_ || !d_}, {
                sort: function (e) {
                    void 0 !== e && zm(e);
                    var t = Ym(this);
                    if (d_) return void 0 === e ? o_(t) : o_(t, e);
                    var r, n, i = [], o = Jm(t);
                    for (n = 0; n < o; n++) n in t && s_(i, t[n]);
                    for ($m(i, function (e) {
                        return function (t, r) {
                            return void 0 === r ? -1 : void 0 === t ? 1 : void 0 !== e ? +e(t, r) || 0 : Xm(t) > Xm(r) ? 1 : -1
                        }
                    }(e)), r = i.length, n = 0; n < r;) t[n] = i[n++];
                    for (; n < o;) delete t[n++];
                    return t
                }
            });
            var l_ = Fr("Array").sort, h_ = h, p_ = l_, f_ = Array.prototype, m_ = function (e) {
                var t = e.sort;
                return e === f_ || h_(f_, e) && t === f_.sort ? p_ : t
            };

            function __(e, t) {
                if ("boolean" != typeof e) throw new Hf(qf.INVALID_PARAMS, "Invalid ".concat(t, ": The value is of the boolean type."))
            }

            function v_(e, t, r) {
                if (!r.includes(e)) throw new Hf(qf.INVALID_PARAMS, "".concat(t, " can only be set as ").concat(JSON.stringify(r)))
            }

            function g_(e, t) {
                let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
                    n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1e4,
                    i = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4];
                if (e < r || e > n || i && !function (e) {
                    return "number" == typeof e && e % 1 == 0
                }(e)) throw new Hf(qf.INVALID_PARAMS, "invalid ".concat(t, ": the value range is [").concat(r, ", ").concat(n, "]. integer only"))
            }

            function E_(e, t) {
                if ("number" != typeof e) {
                    if (!(e.min || e.max || e.ideal || e.exact)) throw new Hf(qf.INVALID_PARAMS, "".concat(t, " is not a valid ConstrainLong"));
                    void 0 !== e.min && g_(e.min, "".concat(t, ".min"), 0, 1 / 0), void 0 !== e.max && g_(e.max, "".concat(t, ".max"), 1, 1 / 0), void 0 !== e.exact && g_(e.exact, "".concat(t, ".exact"), 1, 1 / 0), void 0 !== e.ideal && g_(e.ideal, "".concat(t, ".ideal"), 1, 1 / 0)
                } else g_(e, t, 1, 1 / 0)
            }

            function y_(e, t) {
                let r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
                    n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 255,
                    i = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4];
                if (null == e) throw new Hf(qf.INVALID_PARAMS, "".concat(t || "param", " cannot be empty"));
                if (!I_(e, r, n, i)) throw new Hf(qf.INVALID_PARAMS, "Invalid ".concat(t || "string param", ": Length of the string: [").concat(r, ",").concat(n, "].").concat(i ? " ASCII characters only." : ""))
            }

            function S_(e, t) {
                if (!Array.isArray(e)) throw new Hf(qf.INVALID_PARAMS, "".concat(t, " should be an array"))
            }

            function b_(e) {
                if ("string" != typeof e || !/^[a-zA-Z0-9 \!\#\$\%\&\(\)\+\-\:\;\<\=\.\>\?\@\[\]\^\_\{\}\|\~\,]{1,64}$/.test(e)) throw em.error("Invalid Channel Name ".concat(e)), new Hf(qf.INVALID_PARAMS, "The length must be within 64 bytes. The supported characters: a-z,A-Z,0-9,space,!, #, $, %, &, (, ), +, -, :, ;, <, =, ., >, ?, @, [, ], ^, _,  {, }, |, ~, ,")
            }

            function T_(e) {
                if (!("number" == typeof (t = e) && Math.floor(t) === t && 0 <= t && t <= 4294967295 || I_(e, 1, 255))) throw em.error("Invalid UID ".concat(e, " ").concat(typeof e)), new Hf(qf.INVALID_PARAMS, "[String uid] Length of the string: [1,255]. ASCII characters only. [Number uid] The value range is [0,10000]");
                var t;
                "string" == typeof e && em.warning("You input a string as the user ID, to ensure better end-user experience, Agora highly suggests not using a string as the user ID.")
            }

            function R_(e) {
                return null == e
            }

            function I_(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
                    r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 255,
                    n = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];
                return "string" == typeof e && e.length <= r && e.length >= t && (!n || function (e) {
                    if ("string" != typeof e) return !1;
                    for (let t = 0; t < e.length; t += 1) {
                        const r = e.charCodeAt(t);
                        if (r < 0 || r > 255) return !1
                    }
                    return !0
                }(e))
            }

            let w_, C_, A_;
            !function (e) {
                e.FREE = "free", e.UPLOADING = "uploading"
            }(w_ || (w_ = {})), function (e) {
                e[e.MISC = 0] = "MISC", e[e.INTERNAL_EVENT = 1] = "INTERNAL_EVENT", e[e.PUBLIC_EVENT = 2] = "PUBLIC_EVENT", e[e.WEB_EVENT = 3] = "WEB_EVENT", e[e.INTERNAL_API = 4] = "INTERNAL_API", e[e.WEB_API = 5] = "WEB_API", e[e.PUBLIC_API = 6] = "PUBLIC_API"
            }(C_ || (C_ = {})), function (e) {
                e.NONE = "none", e.INIT = "init", e.CANPLAY = "canplay", e.PLAYING = "playing", e.PAUSED = "paused", e.SUSPEND = "suspend", e.STALLED = "stalled", e.WAITING = "waiting", e.ERROR = "error", e.DESTROYED = "destroyed", e.ABORT = "abort", e.ENDED = "ended", e.EMPTIED = "emptied", e.LOADEDDATA = "loadeddata"
            }(A_ || (A_ = {}));
            const O_ = {
                uninit: 100,
                none: 110,
                init: 120,
                loadeddata: 130,
                canplay: 200,
                playing: 210,
                paused: 220,
                suspend: 300,
                stalled: 310,
                waiting: 320,
                error: 330,
                destroyed: 340,
                abort: 350,
                ended: 360,
                emptied: 370
            };

            function N_(e) {
                return y_(e.reportId, "params.reportId", 0, 100, !1), y_(e.category, "params.category", 0, 100, !1), y_(e.event, "params.event", 0, 100, !1), y_(e.label, "params.label", 0, 100, !1), g_(e.value, "params.value", Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, !1), !0
            }

            const P_ = {
                sid: "",
                lts: 0,
                success: null,
                cname: null,
                uid: null,
                peer: null,
                cid: null,
                elapse: null,
                extend: null,
                vid: 0
            };
            let D_, k_, L_, x_, M_, U_, j_, V_, F_, B_, W_, G_, q_, H_, K_, z_, Y_, J_, X_, Q_, $_, Z_, ev, tv;

            function rv(e) {
                return g_(e.timeout, "config.timeout", 0, 1e5), g_(e.timeoutFactor, "config.timeoutFactor", 0, 100, !1), g_(e.maxRetryCount, "config.maxRetryConfig", 0, 1 / 0), g_(e.maxRetryTimeout, "config.maxRetryTimeout", 0, 1 / 0), !0
            }

            function nv(e) {
                if (!Array.isArray(e) || e.length < 1) return !1;
                try {
                    e.forEach(e => {
                        if (!e.urls) throw Error()
                    })
                } catch (e) {
                    return !1
                }
                return !0
            }

            function iv(e) {
                return y_(e.turnServerURL, "turnServerURL"), y_(e.username, "username"), y_(e.password, "password"), e.udpport && g_(e.udpport, "udpport", 1, 99999, !0), e.forceturn && __(e.forceturn, "forceturn"), e.security && __(e.security, "security"), e.tcpport && g_(e.tcpport, "tcpport", 1, 99999, !0), !0
            }

            function ov(e) {
                return void 0 !== e.level && v_(e.level, "level", [1, 2, 3]), !0
            }

            !function (e) {
                e.PUBLISH = "publish", e.SUBSCRIBE = "subscribe", e.WS_COMPRESSOR_INIT = "ws_compressor_init", e.SESSION_INIT = "session_init", e.JOIN_CHOOSE_SERVER = "join_choose_server", e.REQ_USER_ACCOUNT = "req_user_account", e.JOIN_GATEWAY = "join_gateway", e.REJOIN_GATEWAY = "rejoin_gateway", e.STREAM_SWITCH = "stream_switch", e.REQUEST_PROXY_WORKER_MANAGER = "request_proxy_worker_manager", e.REQUEST_PROXY_APPCENTER = "request_proxy_appcenter", e.FIRST_VIDEO_RECEIVED = "first_video_received", e.FIRST_AUDIO_RECEIVED = "first_audio_received", e.FIRST_VIDEO_DECODE = "first_video_decode", e.FIRST_AUDIO_DECODE = "first_audio_decode", e.ON_ADD_AUDIO_STREAM = "on_add_audio_stream", e.ON_ADD_VIDEO_STREAM = "on_add_video_stream", e.ON_UPDATE_STREAM = "on_update_stream", e.ON_REMOVE_STREAM = "on_remove_stream", e.USER_ANALYTICS = "req_user_analytics"
            }(D_ || (D_ = {})), function (e) {
                e.SESSION = "io.agora.pb.Wrtc.Session", e.JOIN_CHOOSE_SERVER = "io.agora.pb.Wrtc.JoinChooseServer", e.REQ_USER_ACCOUNT = "io.agora.pb.Wrtc.ReqUserAccount", e.JOIN_GATEWAY = "io.agora.pb.Wrtc.JoinGateway", e.RE_JOIN_GATEWAY = "io.agora.pb.Wrtc.ReJoinGateway", e.PUBLISH = "io.agora.pb.Wrtc.Publish", e.SUBSCRIBE = "io.agora.pb.Wrtc.Subscribe", e.WS_COMPRESSOR_INIT = "io.agora.pb.Wrtc.WsCompressorInit", e.STREAM_SWITCH = "io.agora.pb.Wrtc.StreamSwitch", e.AUDIO_SENDING_STOPPED = "io.agora.pb.Wrtc.AudioSendingStopped", e.VIDEO_SENDING_STOPPED = "io.agora.pb.Wrtc.VideoSendingStopped", e.REQUEST_PROXY_APPCENTER = "io.agora.pb.Wrtc.RequestProxyAppCenter", e.REQUEST_PROXY_WORKER_MANAGER = "io.agora.pb.Wrtc.RequestProxyWorkerManager", e.API_INVOKE = "io.agora.pb.Wrtc.ApiInvoke", e.FIRST_VIDEO_RECEIVED = "io.agora.pb.Wrtc.FirstVideoReceived", e.FIRST_AUDIO_RECEIVED = "io.agora.pb.Wrtc.FirstAudioReceived", e.FIRST_VIDEO_DECODE = "io.agora.pb.Wrtc.FirstVideoDecode", e.FIRST_AUDIO_DECODE = "io.agora.pb.Wrtc.FirstAudioDecode", e.ON_ADD_AUDIO_STREAM = "io.agora.pb.Wrtc.OnAddAudioStream", e.ON_ADD_VIDEO_STREAM = "io.agora.pb.Wrtc.OnAddVideoStream", e.ON_UPDATE_STREAM = "io.agora.pb.Wrtc.OnUpdateStream", e.ON_REMOVE_STREAM = "io.agora.pb.Wrtc.OnRemoveStream", e.JOIN_CHANNEL_TIMEOUT = "io.agora.pb.Wrtc.JoinChannelTimeout", e.PEER_PUBLISH_STATUS = "io.agora.pb.Wrtc.PeerPublishStatus", e.WORKER_EVENT = "io.agora.pb.Wrtc.WorkerEvent", e.AP_WORKER_EVENT = "io.agora.pb.Wrtc.APWorkerEvent", e.JOIN_WEB_PROXY_AP = "io.agora.pb.Wrtc.JoinWebProxyAP", e.WEBSOCKET_QUIT = "io.agora.pb.Wrtc.WebSocketQuit", e.USER_ANALYTICS = "io.agora.pb.Wrtc.UserAnalytics", e.AUTOPLAY_FAILED = "io.agora.pb.Wrtc.AutoplayFailed"
            }(k_ || (k_ = {})), function (e) {
                e[e.WORKER_EVENT = 156] = "WORKER_EVENT", e[e.AP_WORKER_EVENT = 160] = "AP_WORKER_EVENT"
            }(L_ || (L_ = {})), function (e) {
                e[e.SESSION = 26] = "SESSION", e[e.JOIN_CHOOSE_SERVER = 27] = "JOIN_CHOOSE_SERVER", e[e.REQ_USER_ACCOUNT = 196] = "REQ_USER_ACCOUNT", e[e.JOIN_GATEWAY = 28] = "JOIN_GATEWAY", e[e.PUBLISH = 30] = "PUBLISH", e[e.SUBSCRIBE = 29] = "SUBSCRIBE", e[e.WS_COMPRESSOR_INIT = 9430] = "WS_COMPRESSOR_INIT", e[e.STREAM_SWITCH = 32] = "STREAM_SWITCH", e[e.AUDIO_SENDING_STOPPED = 33] = "AUDIO_SENDING_STOPPED", e[e.VIDEO_SENDING_STOPPED = 34] = "VIDEO_SENDING_STOPPED", e[e.REQUEST_PROXY_APPCENTER = 35] = "REQUEST_PROXY_APPCENTER", e[e.REQUEST_PROXY_WORKER_MANAGER = 36] = "REQUEST_PROXY_WORKER_MANAGER", e[e.API_INVOKE = 41] = "API_INVOKE", e[e.FIRST_VIDEO_RECEIVED = 348] = "FIRST_VIDEO_RECEIVED", e[e.FIRST_AUDIO_RECEIVED = 349] = "FIRST_AUDIO_RECEIVED", e[e.FIRST_VIDEO_DECODE = 350] = "FIRST_VIDEO_DECODE", e[e.FIRST_AUDIO_DECODE = 351] = "FIRST_AUDIO_DECODE", e[e.ON_ADD_AUDIO_STREAM = 352] = "ON_ADD_AUDIO_STREAM", e[e.ON_ADD_VIDEO_STREAM = 353] = "ON_ADD_VIDEO_STREAM", e[e.ON_UPDATE_STREAM = 356] = "ON_UPDATE_STREAM", e[e.ON_REMOVE_STREAM = 355] = "ON_REMOVE_STREAM", e[e.JOIN_CHANNEL_TIMEOUT = 407] = "JOIN_CHANNEL_TIMEOUT", e[e.PEER_PUBLISH_STATUS = 408] = "PEER_PUBLISH_STATUS", e[e.WORKER_EVENT = 156] = "WORKER_EVENT", e[e.AP_WORKER_EVENT = 160] = "AP_WORKER_EVENT", e[e.JOIN_WEB_PROXY_AP = 700] = "JOIN_WEB_PROXY_AP", e[e.WEBSOCKET_QUIT = 671] = "WEBSOCKET_QUIT", e[e.USER_ANALYTICS = 1e4] = "USER_ANALYTICS", e[e.AUTOPLAY_FAILED = 9178] = "AUTOPLAY_FAILED"
            }(x_ || (x_ = {})), function (e) {
                e.CREATE_CLIENT = "createClient", e.CHECK_SYSTEM_REQUIREMENTS = "checkSystemRequirements", e.SET_AREA = "setArea", e.CHECK_VIDEO_TRACK_IS_ACTIVE = "checkVideoTrackIsActive", e.CHECK_AUDIO_TRACK_IS_ACTIVE = "checkAudioTrackIsActive", e.CREATE_MIC_AUDIO_TRACK = "createMicrophoneAudioTrack", e.CREATE_CUSTOM_AUDIO_TRACK = "createCustomAudioTrack", e.CREATE_BUFFER_AUDIO_TRACK = "createBufferSourceAudioTrack", e.CREATE_CAM_VIDEO_TRACK = "createCameraVideoTrack", e.CREATE_CUSTOM_VIDEO_TRACK = "createCustomVideoTrack", e.CREATE_MIC_AND_CAM_TRACKS = "createMicrophoneAndCameraTracks", e.CREATE_SCREEN_VIDEO_TRACK = "createScreenVideoTrack", e.SET_ENCRYPTION_CONFIG = "Client.setEncryptionConfig", e.START_PROXY_SERVER = "Client.startProxyServer", e.STOP_PROXY_SERVER = "Client.stopProxyServer", e.SET_PROXY_SERVER = "Client.setProxyServer", e.SET_TURN_SERVER = "Client.setTurnServer", e.SET_CLIENT_ROLE = "Client.setClientRole", e.SET_LOW_STREAM_PARAMETER = "Client.setLowStreamParameter", e.ENABLE_DUAL_STREAM = "Client.enableDualStream", e.DISABLE_DUAL_STREAM = "Client.disableDualStream", e.JOIN = "Client.join", e.LEAVE = "Client.leave", e.PUBLISH = "Client.publish", e.UNPUBLISH = "Client.unpublish", e.SUBSCRIBE = "Client.subscribe", e.MASS_SUBSCRIBE = "Client.massSubscribe", e.MASS_UNSUBSCRIBE = "Client.massUnsubscribe", e.UNSUBSCRIBE = "Client.unsubscribe", e.RENEW_TOKEN = "Client.renewToken", e.SET_REMOTE_VIDEO_STREAM_TYPE = "Client.setRemoteVideoStreamType", e.SET_STREAM_FALLBACK_OPTION = "Client.setStreamFallbackOption", e.ENABLE_AUDIO_VOLUME_INDICATOR = "Client.enableAudioVolumeIndicator", e.SEND_CUSTOM_REPORT_MESSAGE = "Client.sendCustomReportMessage", e.INSPECT_VIDEO_CONTENT = "Client.inspectVideoContent", e.STOP_INSPECT_VIDEO_CONTENT = "Client.stopInspectVideoContent", e.JOIN_FALLBACK_TO_PROXY = "Client._joinFallbackToProxy", e.DATACHANNEL_FAILBACK = "Client._datachannelFailback", e.ON_LIVE_STREAM_WARNING = "Client.onLiveStreamWarning", e.ON_LIVE_STREAM_ERROR = "Client.onLiveStreamingError", e.START_LIVE_STREAMING = "Client.startLiveStreaming", e.SET_LIVE_TRANSCODING = "Client.setLiveTranscoding", e.STOP_LIVE_STREAMING = "Client.stopLiveStreaming", e.ADD_INJECT_STREAM_URL = "Client.addInjectStreamUrl", e.REMOVE_INJECT_STREAM_URL = "Client.removeInjectStreamUrl", e.START_CHANNEL_MEDIA_RELAY = "Client.startChannelMediaRelay", e.UPDATE_CHANNEL_MEDIA_RELAY = "Client.updateChannelMediaRelay", e.STOP_CHANNEL_MEDIA_RELAY = "Client.stopChannelMediaRelay", e.REQUEST_CONFIG_DISTRIBUTE = "_config-distribute-request", e.SET_CONFIG_DISTRIBUTE = "_configDistribute", e.LOCAL_TRACK_SET_MUTED = "LocalTrack.setMute", e.LOCAL_AUDIO_TRACK_PLAY = "LocalAudioTrack.play", e.LOCAL_AUDIO_TRACK_PLAY_IN_ELEMENT = "LocalAudioTrack.playInElement", e.LOCAL_AUDIO_TRACK_STOP = "LocalAudioTrack.stop", e.LOCAL_AUDIO_TRACK_SET_VOLUME = "LocalAudioTrack.setVolume", e.MIC_AUDIO_TRACK_SET_DEVICE = "MicrophoneAudioTrack.setDevice", e.BUFFER_AUDIO_TRACK_START = "BufferSourceAudioTrack.startProcessAudioBuffer", e.BUFFER_AUDIO_TRACK_STOP = "BufferSourceAudioTrack.stopProcessAudioBuffer", e.BUFFER_AUDIO_TRACK_PAUSE = "BufferSourceAudioTrack.pauseProcessAudioBuffer", e.BUFFER_AUDIO_TRACK_RESUME = "BufferSourceAudioTrack.resumeProcessAudioBuffer", e.BUFFER_AUDIO_TRACK_SEEK = "BufferSourceAudioTrack.seekAudioBuffer", e.LOCAL_VIDEO_TRACK_PLAY = "LocalVideoTrack.play", e.LOCAL_VIDEO_TRACK_STOP = "LocalVideoTrack.stop", e.LOCAL_VIDEO_TRACK_GET_VIDEO_VISIBLE = "LocalVideoTrack.getVideoElementVisibleStatus", e.LOCAL_VIDEO_TRACK_BEAUTY = "LocalVideoTrack.setBeautyEffect", e.CAM_VIDEO_TRACK_SET_DEVICE = "CameraVideoTrack.setDevice", e.CAM_VIDEO_TRACK_SET_ENCODER_CONFIG = "CameraVideoTrack.setEncoderConfiguration", e.REMOTE_VIDEO_TRACK_PLAY = "RemoteVideoTrack.play", e.REMOTE_VIDEO_TRACK_STOP = "RemoteVideoTrack.stop", e.REMOTE_VIDEO_TRACK_GET_VIDEO_VISIBLE = "RemoteVideoTrack.getVideoElementVisibleStatus", e.REMOTE_AUDIO_TRACK_PLAY = "RemoteAudioTrack.play", e.REMOTE_AUDIO_TRACK_STOP = "RemoteAudioTrack.stop", e.REMOTE_AUDIO_SET_VOLUME = "RemoteAudioTrack.setVolume", e.REMOTE_AUDIO_SET_OUTPUT_DEVICE = "RemoteAudioTrack.setOutputDevice", e.GET_MEDIA_STREAM_TRACK = "Track.getMediaStreamTrack", e.STREAM_TYPE_CHANGE = "streamTypeChange", e.CONNECTION_STATE_CHANGE = "connectionStateChange", e.LOAD_CONFIG_FROM_LOCALSTORAGE = "loadConfigFromLocalStorage"
            }(M_ || (M_ = {})), function (e) {
                e.TRACER = "tracer"
            }(U_ || (U_ = {})), function (e) {
                e.IDLE = "IDLE", e.INITING = "INITING", e.INITEND = "INITEND"
            }(j_ || (j_ = {})), function (e) {
                e.STATE_CHANGE = "state_change", e.RECORDING_DEVICE_CHANGED = "recordingDeviceChanged", e.PLAYOUT_DEVICE_CHANGED = "playoutDeviceChanged", e.CAMERA_DEVICE_CHANGED = "cameraDeviceChanged"
            }(V_ || (V_ = {})), function (e) {
                e[e.ACCESS_POINT = 101] = "ACCESS_POINT", e[e.UNILBS = 201] = "UNILBS", e[e.STRING_UID_ALLOCATOR = 901] = "STRING_UID_ALLOCATOR"
            }(F_ || (F_ = {})), function (e) {
                e[e.IIIEGAL_APPID = 1] = "IIIEGAL_APPID", e[e.IIIEGAL_UID = 2] = "IIIEGAL_UID", e[e.INTERNAL_ERROR = 3] = "INTERNAL_ERROR"
            }(B_ || (B_ = {})), function (e) {
                e[e.INVALID_VENDOR_KEY = 5] = "INVALID_VENDOR_KEY", e[e.INVALID_CHANNEL_NAME = 7] = "INVALID_CHANNEL_NAME", e[e.INTERNAL_ERROR = 8] = "INTERNAL_ERROR", e[e.NO_AUTHORIZED = 9] = "NO_AUTHORIZED", e[e.DYNAMIC_KEY_TIMEOUT = 10] = "DYNAMIC_KEY_TIMEOUT", e[e.NO_ACTIVE_STATUS = 11] = "NO_ACTIVE_STATUS", e[e.DYNAMIC_KEY_EXPIRED = 13] = "DYNAMIC_KEY_EXPIRED", e[e.STATIC_USE_DYNAMIC_KEY = 14] = "STATIC_USE_DYNAMIC_KEY", e[e.DYNAMIC_USE_STATIC_KEY = 15] = "DYNAMIC_USE_STATIC_KEY", e[e.USER_OVERLOAD = 16] = "USER_OVERLOAD", e[e.FORBIDDEN_REGION = 18] = "FORBIDDEN_REGION", e[e.CANNOT_MEET_AREA_DEMAND = 19] = "CANNOT_MEET_AREA_DEMAND"
            }(W_ || (W_ = {})), function (e) {
                e[e.NO_FLAG_SET = 100] = "NO_FLAG_SET", e[e.FLAG_SET_BUT_EMPTY = 101] = "FLAG_SET_BUT_EMPTY", e[e.INVALID_FALG_SET = 102] = "INVALID_FALG_SET", e[e.FLAG_SET_BUT_NO_RE = 103] = "FLAG_SET_BUT_NO_RE", e[e.INVALID_SERVICE_ID = 104] = "INVALID_SERVICE_ID", e[e.NO_SERVICE_AVAILABLE = 200] = "NO_SERVICE_AVAILABLE", e[e.NO_SERVICE_AVAILABLE_P2P = 201] = "NO_SERVICE_AVAILABLE_P2P", e[e.NO_SERVICE_AVAILABLE_VOICE = 202] = "NO_SERVICE_AVAILABLE_VOICE", e[e.NO_SERVICE_AVAILABLE_WEBRTC = 203] = "NO_SERVICE_AVAILABLE_WEBRTC", e[e.NO_SERVICE_AVAILABLE_CDS = 204] = "NO_SERVICE_AVAILABLE_CDS", e[e.NO_SERVICE_AVAILABLE_CDN = 205] = "NO_SERVICE_AVAILABLE_CDN", e[e.NO_SERVICE_AVAILABLE_TDS = 206] = "NO_SERVICE_AVAILABLE_TDS", e[e.NO_SERVICE_AVAILABLE_REPORT = 207] = "NO_SERVICE_AVAILABLE_REPORT", e[e.NO_SERVICE_AVAILABLE_APP_CENTER = 208] = "NO_SERVICE_AVAILABLE_APP_CENTER", e[e.NO_SERVICE_AVAILABLE_ENV0 = 209] = "NO_SERVICE_AVAILABLE_ENV0", e[e.NO_SERVICE_AVAILABLE_VOET = 210] = "NO_SERVICE_AVAILABLE_VOET", e[e.NO_SERVICE_AVAILABLE_STRING_UID = 211] = "NO_SERVICE_AVAILABLE_STRING_UID", e[e.NO_SERVICE_AVAILABLE_WEBRTC_UNILBS = 212] = "NO_SERVICE_AVAILABLE_WEBRTC_UNILBS", e[e.NO_SERVICE_AVAILABLE_UNILBS_FLV = 213] = "NO_SERVICE_AVAILABLE_UNILBS_FLV"
            }(G_ || (G_ = {})), function (e) {
                e[e.K_TIMESTAMP_EXPIRED = 2] = "K_TIMESTAMP_EXPIRED", e[e.K_CHANNEL_PERMISSION_INVALID = 3] = "K_CHANNEL_PERMISSION_INVALID", e[e.K_CERTIFICATE_INVALID = 4] = "K_CERTIFICATE_INVALID", e[e.K_CHANNEL_NAME_EMPTY = 5] = "K_CHANNEL_NAME_EMPTY", e[e.K_CHANNEL_NOT_FOUND = 6] = "K_CHANNEL_NOT_FOUND", e[e.K_TICKET_INVALID = 7] = "K_TICKET_INVALID", e[e.K_CHANNEL_CONFLICTED = 8] = "K_CHANNEL_CONFLICTED", e[e.K_SERVICE_NOT_READY = 9] = "K_SERVICE_NOT_READY", e[e.K_SERVICE_TOO_HEAVY = 10] = "K_SERVICE_TOO_HEAVY", e[e.K_UID_BANNED = 14] = "K_UID_BANNED", e[e.K_IP_BANNED = 15] = "K_IP_BANNED", e[e.K_CHANNEL_BANNED = 16] = "K_CHANNEL_BANNED", e[e.WARN_NO_AVAILABLE_CHANNEL = 103] = "WARN_NO_AVAILABLE_CHANNEL", e[e.WARN_LOOKUP_CHANNEL_TIMEOUT = 104] = "WARN_LOOKUP_CHANNEL_TIMEOUT", e[e.WARN_LOOKUP_CHANNEL_REJECTED = 105] = "WARN_LOOKUP_CHANNEL_REJECTED", e[e.WARN_OPEN_CHANNEL_TIMEOUT = 106] = "WARN_OPEN_CHANNEL_TIMEOUT", e[e.WARN_OPEN_CHANNEL_REJECTED = 107] = "WARN_OPEN_CHANNEL_REJECTED", e[e.WARN_REQUEST_DEFERRED = 108] = "WARN_REQUEST_DEFERRED", e[e.ERR_DYNAMIC_KEY_TIMEOUT = 109] = "ERR_DYNAMIC_KEY_TIMEOUT", e[e.ERR_NO_AUTHORIZED = 110] = "ERR_NO_AUTHORIZED", e[e.ERR_VOM_SERVICE_UNAVAILABLE = 111] = "ERR_VOM_SERVICE_UNAVAILABLE", e[e.ERR_NO_CHANNEL_AVAILABLE_CODE = 112] = "ERR_NO_CHANNEL_AVAILABLE_CODE", e[e.ERR_MASTER_VOCS_UNAVAILABLE = 114] = "ERR_MASTER_VOCS_UNAVAILABLE", e[e.ERR_INTERNAL_ERROR = 115] = "ERR_INTERNAL_ERROR", e[e.ERR_NO_ACTIVE_STATUS = 116] = "ERR_NO_ACTIVE_STATUS", e[e.ERR_INVALID_UID = 117] = "ERR_INVALID_UID", e[e.ERR_DYNAMIC_KEY_EXPIRED = 118] = "ERR_DYNAMIC_KEY_EXPIRED", e[e.ERR_STATIC_USE_DYANMIC_KE = 119] = "ERR_STATIC_USE_DYANMIC_KE", e[e.ERR_DYNAMIC_USE_STATIC_KE = 120] = "ERR_DYNAMIC_USE_STATIC_KE", e[e.ERR_NO_VOCS_AVAILABLE = 2e3] = "ERR_NO_VOCS_AVAILABLE", e[e.ERR_NO_VOS_AVAILABLE = 2001] = "ERR_NO_VOS_AVAILABLE", e[e.ERR_JOIN_CHANNEL_TIMEOUT = 2002] = "ERR_JOIN_CHANNEL_TIMEOUT", e[e.ERR_REPEAT_JOIN_CHANNEL = 2003] = "ERR_REPEAT_JOIN_CHANNEL", e[e.ERR_JOIN_BY_MULTI_IP = 2004] = "ERR_JOIN_BY_MULTI_IP", e[e.ERR_NOT_JOINED = 2011] = "ERR_NOT_JOINED", e[e.ERR_REPEAT_JOIN_REQUEST = 2012] = "ERR_REPEAT_JOIN_REQUEST", e[e.ERR_INVALID_VENDOR_KEY = 2013] = "ERR_INVALID_VENDOR_KEY", e[e.ERR_INVALID_CHANNEL_NAME = 2014] = "ERR_INVALID_CHANNEL_NAME", e[e.ERR_INVALID_STRINGUID = 2015] = "ERR_INVALID_STRINGUID", e[e.ERR_TOO_MANY_USERS = 2016] = "ERR_TOO_MANY_USERS", e[e.ERR_SET_CLIENT_ROLE_TIMEOUT = 2017] = "ERR_SET_CLIENT_ROLE_TIMEOUT", e[e.ERR_SET_CLIENT_ROLE_NO_PERMISSION = 2018] = "ERR_SET_CLIENT_ROLE_NO_PERMISSION", e[e.ERR_SET_CLIENT_ROLE_ALREADY_IN_USE = 2019] = "ERR_SET_CLIENT_ROLE_ALREADY_IN_USE", e[e.ERR_PUBLISH_REQUEST_INVALID = 2020] = "ERR_PUBLISH_REQUEST_INVALID", e[e.ERR_SUBSCRIBE_REQUEST_INVALID = 2021] = "ERR_SUBSCRIBE_REQUEST_INVALID", e[e.ERR_NOT_SUPPORTED_MESSAGE = 2022] = "ERR_NOT_SUPPORTED_MESSAGE", e[e.ERR_ILLEAGAL_PLUGIN = 2023] = "ERR_ILLEAGAL_PLUGIN", e[e.ERR_REJOIN_TOKEN_INVALID = 2024] = "ERR_REJOIN_TOKEN_INVALID", e[e.ERR_REJOIN_USER_NOT_JOINED = 2025] = "ERR_REJOIN_USER_NOT_JOINED", e[e.ERR_INVALID_OPTIONAL_INFO = 2027] = "ERR_INVALID_OPTIONAL_INFO", e[e.ILLEGAL_AES_PASSWORD = 2028] = "ILLEGAL_AES_PASSWORD", e[e.ILLEGAL_CLIENT_ROLE_LEVEL = 2029] = "ILLEGAL_CLIENT_ROLE_LEVEL", e[e.ERR_TOO_MANY_BROADCASTERS = 2031] = "ERR_TOO_MANY_BROADCASTERS", e[e.ERR_TOO_MANY_SUBSCRIBERS = 2032] = "ERR_TOO_MANY_SUBSCRIBERS", e[e.ERR_LICENSE_MISSING = 32769] = "ERR_LICENSE_MISSING", e[e.ERR_LICENSE_EXPIRED = 32771] = "ERR_LICENSE_EXPIRED", e[e.ERR_LICENSE_MINUTES_EXCEEDED = 32773] = "ERR_LICENSE_MINUTES_EXCEEDED", e[e.ERR_LICENSE_PERIOD_INVALID = 32774] = "ERR_LICENSE_PERIOD_INVALID", e[e.ERR_LICENSE_MULTIPLE_SDK_SERVICE = 32778] = "ERR_LICENSE_MULTIPLE_SDK_SERVICE", e[e.ERR_LICENSE_ILLEGAL = 32783] = "ERR_LICENSE_ILLEGAL", e[e.ERR_TEST_RECOVER = 9e3] = "ERR_TEST_RECOVER", e[e.ERR_TEST_TRYNEXT = 9001] = "ERR_TEST_TRYNEXT", e[e.ERR_TEST_RETRY = 9002] = "ERR_TEST_RETRY"
            }(q_ || (q_ = {})), function (e) {
                e[e.AUDIENCE_LEVEL_LOW_LATENCY = 1] = "AUDIENCE_LEVEL_LOW_LATENCY", e[e.AUDIENCE_LEVEL_ULTRA_LOW_LATENCY = 2] = "AUDIENCE_LEVEL_ULTRA_LOW_LATENCY", e[e.AUDIENCE_LEVEL_SYNC_LATENCY = 3] = "AUDIENCE_LEVEL_SYNC_LATENCY"
            }(H_ || (H_ = {})), function (e) {
                e.LEAVE = "LEAVE", e.NETWORK_ERROR = "NETWORK_ERROR", e.SERVER_ERROR = "SERVER_ERROR", e.UID_BANNED = "UID_BANNED", e.IP_BANNED = "IP_BANNED", e.CHANNEL_BANNED = "CHANNEL_BANNED", e.FALLBACK = "FALLBACK", e.LICENSE_MISSING = "LICENSE_MISSING", e.LICENSE_EXPIRED = "LICENSE_EXPIRED", e.LICENSE_MINUTES_EXCEEDED = "LICENSE_MINUTES_EXCEEDED", e.LICENSE_PERIOD_INVALID = "LICENSE_PERIOD_INVALID", e.LICENSE_MULTIPLE_SDK_SERVICE = "LICENSE_MULTIPLE_SDK_SERVICE", e.LICENSE_ILLEGAL = "LICENSE_ILLEGAL"
            }(K_ || (K_ = {})), function (e) {
                e.CONNECTION_STATE_CHANGE = "connection-state-change", e.MEDIA_RECONNECT_START = "media-reconnect-start", e.MEDIA_RECONNECT_END = "media-reconnect-end", e.IS_USING_CLOUD_PROXY = "is-using-cloud-proxy", e.USER_JOINED = "user-joined", e.USER_LEAVED = "user-left", e.USER_PUBLISHED = "user-published", e.USER_UNPUBLISHED = "user-unpublished", e.USER_INFO_UPDATED = "user-info-updated", e.CLIENT_BANNED = "client-banned", e.CHANNEL_MEDIA_RELAY_STATE = "channel-media-relay-state", e.CHANNEL_MEDIA_RELAY_EVENT = "channel-media-relay-event", e.VOLUME_INDICATOR = "volume-indicator", e.CRYPT_ERROR = "crypt-error", e.ON_TOKEN_PRIVILEGE_WILL_EXPIRE = "token-privilege-will-expire", e.ON_TOKEN_PRIVILEGE_DID_EXPIRE = "token-privilege-did-expire", e.NETWORK_QUALITY = "network-quality", e.STREAM_TYPE_CHANGED = "stream-type-changed", e.STREAM_FALLBACK = "stream-fallback", e.RECEIVE_METADATA = "receive-metadata", e.STREAM_MESSAGE = "stream-message", e.LIVE_STREAMING_ERROR = "live-streaming-error", e.LIVE_STREAMING_WARNING = "live-streaming-warning", e.INJECT_STREAM_STATUS = "stream-inject-status", e.EXCEPTION = "exception", e.ERROR = "error", e.P2P_LOST = "p2p_lost", e.JOIN_FALLBACK_TO_PROXY = "join-fallback-to-proxy", e.CHANNEL_FALLBACK_TO_WEBSOCKET = "channel-fallback-to-websocket", e.MEDIA_CONNECTION_TYPE_CHANGE = "media-connection-type-change", e.PUBLISHED_USER_LIST = "published-user-list", e.CONTENT_INSPECT_CONNECTION_STATE_CHANGE = "content-inspect-connection-state-change", e.CONTENT_INSPECT_ERROR = "content-inspect-error", e.CONTENT_INSPECT_RESULT = "content-inspect-result"
            }(z_ || (z_ = {})), function (e) {
                e.NETWORK_ERROR = "NETWORK_ERROR", e.SERVER_ERROR = "SERVER_ERROR", e.MULTI_IP = "MULTI_IP", e.TIMEOUT = "TIMEOUT", e.OFFLINE = "OFFLINE", e.LEAVE = "LEAVE", e.P2P_FAILED = "P2P_FAILED", e.FALLBACK = "FALLBACK"
            }(Y_ || (Y_ = {})), function (e) {
                e.CONNECTING = "connecting", e.CONNECTED = "connected", e.RECONNECTING = "reconnecting", e.CLOSED = "closed"
            }(J_ || (J_ = {})), function (e) {
                e.WS_CONNECTED = "ws_connected", e.WS_RECONNECTING = "ws_reconnecting", e.WS_CLOSED = "ws_closed", e.WS_RECONNECT_WAITTING_FINISH = "ws_reconnect_waitting_finish", e.WS_RECONNECT_CREATE_CONNECTION = "ws_reconnect_create_connection", e.ON_BINARY_DATA = "on_binary_data", e.REQUEST_RECOVER = "request_recover", e.REQUEST_JOIN_INFO = "request_join_info", e.REQUEST_REJOIN_INFO = "req_rejoin_info", e.IS_P2P_DISCONNECTED = "is_p2p_dis", e.DISCONNECT_P2P = "dis_p2p", e.ABORT_P2P_EXECUTION = "abort_p2p_execution", e.NEED_RENEW_SESSION = "need-sid", e.REPORT_JOIN_GATEWAY = "report_join_gateway", e.REQUEST_TIMEOUT = "request_timeout", e.REQUEST_SUCCESS = "request_success", e.JOIN_RESPONSE = "join_response", e.DATACHANNEL_PRECONNECT = "datachannel_preconnect", e.DATACHANNEL_CONNECTING = "datachannel_connecting", e.DATACHANNEL_FAILBACK = "datachannel_failback"
            }(X_ || (X_ = {})), function (e) {
                e.PING = "ping", e.PING_BACK = "ping_back", e.JOIN = "join_v3", e.REJOIN = "rejoin_v3", e.LEAVE = "leave", e.SET_CLIENT_ROLE = "set_client_role", e.PUBLISH = "publish", e.UNPUBLISH = "unpublish", e.SUBSCRIBE = "subscribe", e.SUBSCRIBE_STREAMS = "subscribe_streams", e.UNSUBSCRIBE = "unsubscribe", e.UNSUBSCRIBE_STREAMS = "unsubscribe_streams", e.SUBSCRIBE_CHANGE = "subscribe_change", e.TRAFFIC_STATS = "traffic_stats", e.RENEW_TOKEN = "renew_token", e.SWITCH_VIDEO_STREAM = "switch_video_stream", e.DEFAULT_VIDEO_STREAM = "default_video_stream", e.SET_FALLBACK_OPTION = "set_fallback_option", e.GATEWAY_INFO = "gateway_info", e.CONTROL = "control", e.SEND_METADATA = "send_metadata", e.DATA_STREAM = "data_stream", e.PICK_SVC_LAYER = "pick_svc_layer", e.RESTART_ICE = "restart_ice", e.CONNECT_PC = "connect_pc", e.SET_VIDEO_PROFILE = "set_video_profile", e.SET_PARAMETER = "set_parameter"
            }(Q_ || (Q_ = {})), function (e) {
                e.PUBLISH_STATS = "publish_stats", e.PUBLISH_RELATED_STATS = "publish_related_stats", e.SUBSCRIBE_STATS = "subscribe_stats", e.SUBSCRIBE_RELATED_STATS = "subscribe_related_stats", e.WS_INFLATE_DATA_LENGTH = "ws_inflate_data_length", e.DENOISER_STATS = "denoiser_stats", e.TRANSPORT_STATS = "transport_stats", e.EXTENSION_USAGE_STATS = "extension_usage_stats"
            }($_ || ($_ = {})), function (e) {
                e.ON_USER_ONLINE = "on_user_online", e.ON_USER_OFFLINE = "on_user_offline", e.ON_STREAM_FALLBACK_UPDATE = "on_stream_fallback_update", e.ON_PUBLISH_STREAM = "on_publish_stream", e.ON_UPLINK_STATS = "on_uplink_stats", e.ON_P2P_LOST = "on_p2p_lost", e.ON_REMOVE_STREAM = "on_remove_stream", e.ON_ADD_AUDIO_STREAM = "on_add_audio_stream", e.ON_ADD_VIDEO_STREAM = "on_add_video_stream", e.ON_TOKEN_PRIVILEGE_WILL_EXPIRE = "on_token_privilege_will_expire", e.ON_TOKEN_PRIVILEGE_DID_EXPIRE = "on_token_privilege_did_expire", e.ON_USER_BANNED = "on_user_banned", e.ON_USER_LICENSE_BANNED = "on_user_license_banned", e.ON_NOTIFICATION = "on_notification", e.ON_CRYPT_ERROR = "on_crypt_error", e.MUTE_AUDIO = "mute_audio", e.MUTE_VIDEO = "mute_video", e.UNMUTE_AUDIO = "unmute_audio", e.UNMUTE_VIDEO = "unmute_video", e.ON_P2P_OK = "on_p2p_ok", e.RECEIVE_METADATA = "receive_metadata", e.ON_DATA_STREAM = "on_data_stream", e.ENABLE_LOCAL_VIDEO = "enable_local_video", e.DISABLE_LOCAL_VIDEO = "disable_local_video", e.ENABLE_LOCAL_AUDIO = "enable_local_audio", e.DISABLE_LOCAL_AUDIO = "disable_local_audio", e.ON_PUBLISHED_USER_LIST = "on_published_user_list"
            }(Z_ || (Z_ = {})), function (e) {
                e.CONNECTION_STATE_CHANGE = "CONNECTION_STATE_CHANGE", e.NEED_ANSWER = "NEED_ANSWER", e.NEED_RENEGOTIATE = "NEED_RENEGOTIATE", e.P2P_LOST = "P2P_LOST", e.GATEWAY_P2P_LOST = "GATEWAY_P2P_LOST", e.NEED_UNPUB = "NEED_UNPUB", e.NEED_UNSUB = "NEED_UNSUB", e.NEED_UPLOAD = "NEED_UPLOAD", e.NEED_CONTROL = "NEED_CONTROL", e.START_RECONNECT = "START_RECONNECT", e.END_RECONNECT = "END_RECONNECT", e.NEED_SIGNAL_RTT = "NEED_SIGNAL_RTT"
            }(ev || (ev = {})), function (e) {
                e.AUDIO_SOURCE_STATE_CHANGE = "audio_source_state_change", e.RECEIVE_TRACK_BUFFER = "receive_track_buffer", e.ON_AUDIO_BUFFER = "on_audio_buffer", e.UPDATE_SOURCE = "update_source"
            }(tv || (tv = {}));
            const sv = {
                sendVolumeLevel: 0,
                sendBitrate: 0,
                sendBytes: 0,
                sendPackets: 0,
                sendPacketsLost: 0,
                currentPacketLossRate: 0
            }, av = {
                sendBytes: 0,
                sendBitrate: 0,
                sendPackets: 0,
                sendPacketsLost: 0,
                sendResolutionHeight: 0,
                sendResolutionWidth: 0,
                captureResolutionHeight: 0,
                captureResolutionWidth: 0,
                targetSendBitrate: 0,
                totalDuration: 0,
                totalFreezeTime: 0,
                currentPacketLossRate: 0
            }, cv = {
                transportDelay: 0,
                end2EndDelay: 0,
                receiveBitrate: 0,
                receiveLevel: 0,
                receiveBytes: 0,
                receiveDelay: 0,
                receivePackets: 0,
                receivePacketsLost: 0,
                totalDuration: 0,
                totalFreezeTime: 0,
                freezeRate: 0,
                packetLossRate: 0,
                currentPacketLossRate: 0,
                publishDuration: -1
            }, uv = {uplinkNetworkQuality: 0, downlinkNetworkQuality: 0}, dv = {
                transportDelay: 0,
                end2EndDelay: 0,
                receiveBitrate: 0,
                receiveBytes: 0,
                receiveDelay: 0,
                receivePackets: 0,
                receivePacketsLost: 0,
                receiveResolutionHeight: 0,
                receiveResolutionWidth: 0,
                totalDuration: 0,
                totalFreezeTime: 0,
                freezeRate: 0,
                packetLossRate: 0,
                currentPacketLossRate: 0,
                publishDuration: -1
            };
            let lv, hv, pv;
            !function (e) {
                e.CONNECTED = "websocket:connected", e.RECONNECTING = "websocket:reconnecting", e.WILL_RECONNECT = "websocket:will_reconnect", e.CLOSED = "websocket:closed", e.FAILED = "websocket:failed", e.ON_MESSAGE = "websocket:on_message", e.REQUEST_NEW_URLS = "websocket:request_new_urls", e.RECONNECT_WAITTING_FINISH = "websocket:reconnect_waitting_finish", e.RECONNECT_CREATE_CONNECTION = "websocket:reconnect_create_connection", e.ON_TOKEN_PRIVILEGE_DID_EXPIRE = "websocket:on_token_privilege_did_expire"
            }(lv || (lv = {})), function (e) {
                e.TRANSCODE = "mix_streaming", e.RAW = "raw_streaming", e.INJECT = "inject_streaming"
            }(hv || (hv = {})), function (e) {
                e[e.INJECT_STREAM_STATUS_START_SUCCESS = 0] = "INJECT_STREAM_STATUS_START_SUCCESS", e[e.INJECT_STREAM_STATUS_START_ALREADY_EXISTS = 1] = "INJECT_STREAM_STATUS_START_ALREADY_EXISTS", e[e.INJECT_STREAM_STATUS_START_UNAUTHORIZED = 2] = "INJECT_STREAM_STATUS_START_UNAUTHORIZED", e[e.INJECT_STREAM_STATUS_START_TIMEOUT = 3] = "INJECT_STREAM_STATUS_START_TIMEOUT", e[e.INJECT_STREAM_STATUS_START_FAILED = 4] = "INJECT_STREAM_STATUS_START_FAILED", e[e.INJECT_STREAM_STATUS_STOP_SUCCESS = 5] = "INJECT_STREAM_STATUS_STOP_SUCCESS", e[e.INJECT_STREAM_STATUS_STOP_NOT_FOUND = 6] = "INJECT_STREAM_STATUS_STOP_NOT_FOUND", e[e.INJECT_STREAM_STATUS_STOP_UNAUTHORIZED = 7] = "INJECT_STREAM_STATUS_STOP_UNAUTHORIZED", e[e.INJECT_STREAM_STATUS_STOP_TIMEOUT = 8] = "INJECT_STREAM_STATUS_STOP_TIMEOUT", e[e.INJECT_STREAM_STATUS_STOP_FAILED = 9] = "INJECT_STREAM_STATUS_STOP_FAILED", e[e.INJECT_STREAM_STATUS_BROKEN = 10] = "INJECT_STREAM_STATUS_BROKEN"
            }(pv || (pv = {}));
            const fv = {alpha: 1, height: 640, width: 360, x: 0, y: 0, zOrder: 0, audioChannel: 0},
                mv = {x: 0, y: 0, width: 160, height: 160, zOrder: 255, alpha: 1};

            function _v(e, t) {
                y_(e.url, "".concat(t, ".url"), 1, 1e3, !1), R_(e.x) || g_(e.x, "".concat(t, ".x"), 0, 1e4), R_(e.y) || g_(e.y, "".concat(t, ".y"), 0, 1e4), R_(e.width) || g_(e.width, "".concat(t, ".width"), 0, 1e4), R_(e.height) || g_(e.height, "".concat(t, ".height"), 0, 1e4), R_(e.zOrder) || g_(e.zOrder, "".concat(t, ".zOrder"), 0, 255), R_(e.alpha) || g_(e.alpha, "".concat(t, ".alpha"), 0, 1, !1)
            }

            const vv = {
                audioBitrate: 48,
                audioChannels: 1,
                audioSampleRate: 48e3,
                backgroundColor: 0,
                height: 360,
                lowLatency: !1,
                videoBitrate: 400,
                videoCodecProfile: 100,
                videoCodecType: 1,
                videoFrameRate: 15,
                videoGop: 30,
                width: 640,
                images: [],
                userConfigs: [],
                userConfigExtraInfo: ""
            }, gv = {
                audioBitrate: 48,
                audioChannels: 2,
                audioVolume: 100,
                audioSampleRate: 48e3,
                height: 0,
                width: 0,
                videoBitrate: 400,
                videoFramerate: 15,
                videoGop: 30
            };
            let Ev, yv, Sv, bv, Tv, Rv, Iv, wv, Cv, Av, Ov, Nv, Pv, Dv, kv, Lv, xv, Mv;

            function Uv(e) {
                if (!e.channelName) throw new Hf(qf.INVALID_PARAMS, "invalid channelName in info");
                if ("number" != typeof e.uid) throw new Hf(qf.INVALID_PARAMS, "invalid uid in info, uid must be a number");
                return e.token && y_(e.token, "info.token", 1, 2047), T_(e.uid), b_(e.channelName), !0
            }

            function jv(e) {
                return v_(e, "mediaSource", ["screen", "window", "application"]), !0
            }

            !function (e) {
                e.WARNING = "@live_uap-warning", e.ERROR = "@line_uap-error", e.PUBLISH_STREAM_STATUS = "@live_uap-publish-status", e.INJECT_STREAM_STATUS = "@live_uap-inject-status", e.WORKER_STATUS = "@live_uap-worker-status", e.REQUEST_NEW_ADDRESS = "@live_uap-request-address"
            }(Ev || (Ev = {})), function (e) {
                e.REQUEST_WORKER_MANAGER_LIST = "@live_req_worker_manager"
            }(yv || (yv = {})), function (e) {
                e[e.LIVE_STREAM_RESPONSE_SUCCEED = 200] = "LIVE_STREAM_RESPONSE_SUCCEED", e[e.LIVE_STREAM_RESPONSE_ALREADY_EXISTS_STREAM = 454] = "LIVE_STREAM_RESPONSE_ALREADY_EXISTS_STREAM", e[e.LIVE_STREAM_RESPONSE_TRANSCODING_PARAMETER_ERROR = 450] = "LIVE_STREAM_RESPONSE_TRANSCODING_PARAMETER_ERROR", e[e.LIVE_STREAM_RESPONSE_BAD_STREAM = 451] = "LIVE_STREAM_RESPONSE_BAD_STREAM", e[e.LIVE_STREAM_RESPONSE_WM_PARAMETER_ERROR = 400] = "LIVE_STREAM_RESPONSE_WM_PARAMETER_ERROR", e[e.LIVE_STREAM_RESPONSE_WM_WORKER_NOT_EXIST = 404] = "LIVE_STREAM_RESPONSE_WM_WORKER_NOT_EXIST", e[e.LIVE_STREAM_RESPONSE_NOT_AUTHORIZED = 456] = "LIVE_STREAM_RESPONSE_NOT_AUTHORIZED", e[e.LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE = 457] = "LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE", e[e.LIVE_STREAM_RESPONSE_REQUEST_TOO_OFTEN = 429] = "LIVE_STREAM_RESPONSE_REQUEST_TOO_OFTEN", e[e.LIVE_STREAM_RESPONSE_NOT_FOUND_PUBLISH = 452] = "LIVE_STREAM_RESPONSE_NOT_FOUND_PUBLISH", e[e.LIVE_STREAM_RESPONSE_NOT_SUPPORTED = 453] = "LIVE_STREAM_RESPONSE_NOT_SUPPORTED", e[e.LIVE_STREAM_RESPONSE_MAX_STREAM_NUM = 455] = "LIVE_STREAM_RESPONSE_MAX_STREAM_NUM", e[e.LIVE_STREAM_RESPONSE_INTERNAL_SERVER_ERROR = 500] = "LIVE_STREAM_RESPONSE_INTERNAL_SERVER_ERROR", e[e.LIVE_STREAM_RESPONSE_WORKER_LOST = 501] = "LIVE_STREAM_RESPONSE_WORKER_LOST", e[e.LIVE_STREAM_RESPONSE_RESOURCE_LIMIT = 502] = "LIVE_STREAM_RESPONSE_RESOURCE_LIMIT", e[e.LIVE_STREAM_RESPONSE_WORKER_QUIT = 503] = "LIVE_STREAM_RESPONSE_WORKER_QUIT", e[e.ERROR_FAIL_SEND_MESSAGE = 504] = "ERROR_FAIL_SEND_MESSAGE", e[e.PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE = 30] = "PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE", e[e.PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT = 31] = "PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT", e[e.PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH = 32] = "PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH", e[e.PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN = 33] = "PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN"
            }(Sv || (Sv = {})), function (e) {
                e.CONNECT_FAILED = "connect failed", e.CONNECT_TIMEOUT = "connect timeout", e.WS_DISCONNECTED = "websocket disconnected", e.REQUEST_TIMEOUT = "request timeout", e.REQUEST_FAILED = "request failed", e.WAIT_STATUS_TIMEOUT = "wait status timeout", e.WAIT_STATUS_ERROR = "wait status error", e.BAD_STATE = "bad state", e.WS_ABORT = "ws abort", e.AP_REQUEST_TIMEOUT = "AP request timeout", e.AP_JSON_PARSE_ERROR = "AP json parse error", e.AP_REQUEST_ERROR = "AP request error", e.AP_REQUEST_ABORT = "AP request abort"
            }(bv || (bv = {})), function (e) {
                e[e.SetSdkProfile = 0] = "SetSdkProfile", e[e.SetSourceChannel = 1] = "SetSourceChannel", e[e.SetSourceUserId = 2] = "SetSourceUserId", e[e.SetDestChannel = 3] = "SetDestChannel", e[e.StartPacketTransfer = 4] = "StartPacketTransfer", e[e.StopPacketTransfer = 5] = "StopPacketTransfer", e[e.UpdateDestChannel = 6] = "UpdateDestChannel", e[e.Reconnect = 7] = "Reconnect", e[e.SetVideoProfile = 8] = "SetVideoProfile"
            }(Tv || (Tv = {})), function (e) {
                e.NETWORK_DISCONNECTED = "NETWORK_DISCONNECTED", e.NETWORK_CONNECTED = "NETWORK_CONNECTED", e.PACKET_JOINED_SRC_CHANNEL = "PACKET_JOINED_SRC_CHANNEL", e.PACKET_JOINED_DEST_CHANNEL = "PACKET_JOINED_DEST_CHANNEL", e.PACKET_SENT_TO_DEST_CHANNEL = "PACKET_SENT_TO_DEST_CHANNEL", e.PACKET_RECEIVED_VIDEO_FROM_SRC = "PACKET_RECEIVED_VIDEO_FROM_SRC", e.PACKET_RECEIVED_AUDIO_FROM_SRC = "PACKET_RECEIVED_AUDIO_FROM_SRC", e.PACKET_UPDATE_DEST_CHANNEL = "PACKET_UPDATE_DEST_CHANNEL", e.PACKET_UPDATE_DEST_CHANNEL_REFUSED = "PACKET_UPDATE_DEST_CHANNEL_REFUSED", e.PACKET_UPDATE_DEST_CHANNEL_NOT_CHANGE = "PACKET_UPDATE_DEST_CHANNEL_NOT_CHANGE"
            }(Rv || (Rv = {})), function (e) {
                e.RELAY_STATE_IDLE = "RELAY_STATE_IDLE", e.RELAY_STATE_CONNECTING = "RELAY_STATE_CONNECTING", e.RELAY_STATE_RUNNING = "RELAY_STATE_RUNNING", e.RELAY_STATE_FAILURE = "RELAY_STATE_FAILURE"
            }(Iv || (Iv = {})), function (e) {
                e.RELAY_OK = "RELAY_OK", e.SERVER_CONNECTION_LOST = "SERVER_CONNECTION_LOST", e.SRC_TOKEN_EXPIRED = "SRC_TOKEN_EXPIRED", e.DEST_TOKEN_EXPIRED = "DEST_TOKEN_EXPIRED"
            }(wv || (wv = {})), function (e) {
                e.High = "high", e.Low = "low", e.Audio = "audio", e.Screen = "screen", e.ScreenLow = "screen_low"
            }(Cv || (Cv = {})), function (e) {
                e.DISCONNECT = "disconnect", e.CONNECTION_STATE_CHANGE = "connection-state-change", e.NETWORK_QUALITY = "network-quality", e.STREAM_TYPE_CHANGE = "stream-type-change", e.IS_P2P_DISCONNECTED = "is-p2p-dis", e.DISCONNECT_P2P = "dis-p2p", e.REQUEST_NEW_GATEWAY_LIST = "req-gate-url", e.NEED_RENEW_SESSION = "need-sid", e.REQUEST_P2P_CONNECTION_PARAMS = "request-p2p-connection-params", e.JOIN_RESPONSE = "join-response", e.REQUEST_DC_CONNECTION_PARAMS = "request-dc-connection-params", e.RESET_CONNECTION_EVENTS = "reset-connection-events", e.DATACHANNEL_PRECONNECT = "datachannel_preconnect", e.DATACHANNEL_FAILBACK = "datachannel_failback"
            }(Av || (Av = {})), function (e) {
                e[e.Nothing = 0] = "Nothing", e[e.Audio = 1] = "Audio", e[e.LwoVideo = 2] = "LwoVideo", e[e.Video = 4] = "Video", e[e.Data = 8] = "Data"
            }(Ov || (Ov = {})), function (e) {
                e.NEED_RENEGOTIATE = "@need_renegotiate", e.NEED_REPLACE_TRACK = "@need_replace_track", e.NEED_CLOSE = "@need_close", e.NEED_ENABLE_TRACK = "@need_enable_track", e.NEED_DISABLE_TRACK = "@need_disable_track", e.NEED_SESSION_ID = "@need_sid", e.SET_OPTIMIZATION_MODE = "@set_optimization_mode", e.GET_STATS = "@get_stats", e.GET_LOW_VIDEO_TRACK = "@get_low_video_track", e.NEED_RESET_REMOTE_SDP = "@need_reset_remote_sdp", e.NEED_UPDATE_VIDEO_ENCODER = "@need_update_video_encoder", e.NEED_MUTE_TRACK = "@need_mute_track", e.NEED_UNMUTE_TRACK = "@need_unmute_track"
            }(Nv || (Nv = {})), function (e) {
                e.SCREEN_TRACK = "screen_track", e.LOW_STREAM = "low_stream"
            }(Pv || (Pv = {})), function (e) {
                e[e.HIGH_STREAM = 0] = "HIGH_STREAM", e[e.LOW_STREAM = 1] = "LOW_STREAM"
            }(Dv || (Dv = {})), function (e) {
                e[e.DISABLE = 0] = "DISABLE", e[e.LOW_STREAM = 1] = "LOW_STREAM", e[e.AUDIO_ONLY = 2] = "AUDIO_ONLY"
            }(kv || (kv = {})), function (e) {
                e.SOURCE_STATE_CHANGE = "source-state-change", e.TRACK_ENDED = "track-ended", e.BEAUTY_EFFECT_OVERLOAD = "beauty-effect-overload", e.VIDEO_ELEMENT_VISIBLE_STATUS = "video-element-visible-status", e.CLOSED = "closed"
            }(Lv || (Lv = {})), function (e) {
                e.FIRST_FRAME_DECODED = "first-frame-decoded", e.VIDEO_ELEMENT_VISIBLE_STATUS = "video-element-visible-status"
            }(xv || (xv = {})), function (e) {
                e.CHINA = "CHINA", e.ASIA = "ASIA", e.NORTH_AMERICA = "NORTH_AMERICA", e.EUROPE = "EUROPE", e.JAPAN = "JAPAN", e.INDIA = "INDIA", e.KOREA = "KOREA", e.HKMC = "HKMC", e.US = "US", e.OCEANIA = "OCEANIA", e.SOUTH_AMERICA = "SOUTH_AMERICA", e.AFRICA = "AFRICA", e.OVERSEA = "OVERSEA", e.GLOBAL = "GLOBAL"
            }(Mv || (Mv = {}));
            const Vv = [Mv.AFRICA, Mv.ASIA, Mv.CHINA, Mv.EUROPE, Mv.GLOBAL, Mv.INDIA, Mv.JAPAN, Mv.NORTH_AMERICA, Mv.OCEANIA, Mv.OVERSEA, Mv.SOUTH_AMERICA];
            let Fv;
            !function (e) {
                e.CHINA = "CN", e.ASIA = "AS", e.NORTH_AMERICA = "NA", e.EUROPE = "EU", e.JAPAN = "JP", e.INDIA = "IN", e.KOREA = "KR", e.HKMC = "HK", e.US = "US", e.OCEANIA = "OC", e.SOUTH_AMERICA = "SA", e.AFRICA = "AF", e.OVERSEA = "OVERSEA", e.GLOBAL = "GLOBAL"
            }(Fv || (Fv = {}));
            const Bv = {
                CHINA: {},
                ASIA: {
                    CODE: Fv.ASIA,
                    WEBCS_DOMAIN: ["ap-web-1-asia.agora.io"],
                    WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-asia.agora.io"],
                    PROXY_CS: ["proxy-ap-web-asia.agora.io"],
                    CDS_AP: ["cds-ap-web-asia.agora.io", "cds-ap-web-asia2.agora.io"],
                    ACCOUNT_REGISTER: ["sua-ap-web-asia.agora.io", "sua-ap-web-asia2.agora.io"],
                    UAP_AP: ["uap-ap-web-asia.agora.io", "uap-ap-web-asia2.agora.io"],
                    EVENT_REPORT_DOMAIN: ["statscollector-1-asia.agora.io"],
                    EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-asia.agora.io"],
                    LOG_UPLOAD_SERVER: ["logservice-asia.agora.io"],
                    PROXY_SERVER_TYPE3: ["southeast-asia.webrtc-cloud-proxy.sd-rtn.com"]
                },
                NORTH_AMERICA: {
                    CODE: Fv.NORTH_AMERICA,
                    WEBCS_DOMAIN: ["ap-web-1-north-america.agora.io"],
                    WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-north-america.agora.io"],
                    PROXY_CS: ["proxy-ap-web-america.agora.io"],
                    CDS_AP: ["cds-ap-web-america.agora.io", "cds-ap-web-america2.agora.io"],
                    ACCOUNT_REGISTER: ["sua-ap-web-america.agora.io", "sua-ap-web-america2.agora.io"],
                    UAP_AP: ["uap-ap-web-america.agora.io", "uap-ap-web-america2.agora.io"],
                    EVENT_REPORT_DOMAIN: ["statscollector-1-north-america.agora.io"],
                    EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-north-america.agora.io"],
                    LOG_UPLOAD_SERVER: ["logservice-north-america.agora.io"],
                    PROXY_SERVER_TYPE3: ["east-usa.webrtc-cloud-proxy.sd-rtn.com"]
                },
                EUROPE: {
                    CODE: Fv.EUROPE,
                    WEBCS_DOMAIN: ["ap-web-1-europe.agora.io"],
                    WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-europe.agora.io"],
                    PROXY_CS: ["proxy-ap-web-europe.agora.io"],
                    CDS_AP: ["cds-ap-web-europe.agora.io", "cds-ap-web-europe2.agora.io"],
                    ACCOUNT_REGISTER: ["sua-ap-web-europe.agora.io", "sua-ap-web-europe.agora.io"],
                    UAP_AP: ["uap-ap-web-europe.agora.io", "uap-ap-web-europe2.agora.io"],
                    EVENT_REPORT_DOMAIN: ["statscollector-1-europe.agora.io"],
                    EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-europe.agora.io"],
                    LOG_UPLOAD_SERVER: ["logservice-europe.agora.io"],
                    PROXY_SERVER_TYPE3: ["europe.webrtc-cloud-proxy.sd-rtn.com"]
                },
                JAPAN: {
                    CODE: Fv.JAPAN,
                    WEBCS_DOMAIN: ["ap-web-1-japan.agora.io"],
                    WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-japan.agora.io"],
                    PROXY_CS: ["proxy-ap-web-japan.agora.io"],
                    CDS_AP: ["cds-ap-web-japan.agora.io", "cds-ap-web-japan2.agora.io"],
                    ACCOUNT_REGISTER: ["sua-ap-web-japan.agora.io", "sua-ap-web-japan2.agora.io"],
                    UAP_AP: ["uap-ap-web-japan.agora.io", "\tuap-ap-web-japan2.agora.io"],
                    EVENT_REPORT_DOMAIN: ["statscollector-1-japan.agora.io"],
                    EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-japan.agora.io"],
                    LOG_UPLOAD_SERVER: ["logservice-japan.agora.io"],
                    PROXY_SERVER_TYPE3: ["japan.webrtc-cloud-proxy.sd-rtn.com"]
                },
                INDIA: {
                    CODE: Fv.INDIA,
                    WEBCS_DOMAIN: ["ap-web-1-india.agora.io"],
                    WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-india.agora.io"],
                    PROXY_CS: ["proxy-ap-web-india.agora.io"],
                    CDS_AP: ["cds-ap-web-india.agora.io", "cds-ap-web-india2.agora.io"],
                    ACCOUNT_REGISTER: ["sua-ap-web-india.agora.io", "sua-ap-web-india2.agora.io"],
                    UAP_AP: ["uap-ap-web-india.agora.io", "uap-ap-web-india2.agora.io"],
                    EVENT_REPORT_DOMAIN: ["statscollector-1-india.agora.io"],
                    EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-india.agora.io"],
                    LOG_UPLOAD_SERVER: ["logservice-india.agora.io"],
                    PROXY_SERVER_TYPE3: ["india.webrtc-cloud-proxy.sd-rtn.com"]
                },
                KOREA: {
                    CODE: Fv.KOREA,
                    WEBCS_DOMAIN: ["ap-web-1-korea.agora.io"],
                    WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-korea.agora.io"],
                    PROXY_CS: ["proxy-ap-web-korea.agora.io"],
                    CDS_AP: ["cds-ap-web-korea.agora.io", "cds-ap-web-korea2.agora.io"],
                    ACCOUNT_REGISTER: ["sua-ap-web-korea.agora.io", "sua-ap-web-korea2.agora.io"],
                    UAP_AP: ["uap-ap-web-korea.agora.io", "uap-ap-web-korea2.agora.io"],
                    EVENT_REPORT_DOMAIN: ["statscollector-1-korea.agora.io"],
                    EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-korea.agora.io"],
                    LOG_UPLOAD_SERVER: ["logservice-korea.agora.io"],
                    PROXY_SERVER_TYPE3: ["korea.webrtc-cloud-proxy.sd-rtn.com"]
                },
                HKMC: {
                    CODE: Fv.HKMC,
                    WEBCS_DOMAIN: ["ap-web-1-hkmc.agora.io"],
                    WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-hkmc.agora.io"],
                    PROXY_CS: ["proxy-ap-web-hkmc.agora.io"],
                    CDS_AP: ["cds-ap-web-hkmc.agora.io", "cds-ap-web-hkmc2.agora.io"],
                    ACCOUNT_REGISTER: ["sua-ap-web-hkmc.agora.io", "sua-ap-web-hkmc2.agora.io"],
                    UAP_AP: ["uap-ap-web-hkmc.agora.io", "uap-ap-web-hkmc2.agora.io"],
                    EVENT_REPORT_DOMAIN: ["statscollector-1-hkmc.agora.io"],
                    EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-hkmc.agora.io"],
                    LOG_UPLOAD_SERVER: ["logservice-hkmc.agora.io"],
                    PROXY_SERVER_TYPE3: ["hkmc.webrtc-cloud-proxy.sd-rtn.com"]
                },
                US: {
                    CODE: Fv.US,
                    WEBCS_DOMAIN: ["ap-web-1-us.agora.io"],
                    WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-us.agora.io"],
                    PROXY_CS: ["proxy-ap-web-us.agora.io"],
                    CDS_AP: ["cds-ap-web-us.agora.io", "cds-ap-web-us2.agora.io"],
                    ACCOUNT_REGISTER: ["sua-ap-web-us.agora.io", "sua-ap-web-us2.agora.io"],
                    UAP_AP: ["uap-ap-web-us.agora.io", "uap-ap-web-us2.agora.io"],
                    EVENT_REPORT_DOMAIN: ["statscollector-1-us.agora.io"],
                    EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-us.agora.io"],
                    LOG_UPLOAD_SERVER: ["logservice-us.agora.io"],
                    PROXY_SERVER_TYPE3: ["us.webrtc-cloud-proxy.sd-rtn.com"]
                },
                OVERSEA: {
                    CODE: Fv.OVERSEA,
                    WEBCS_DOMAIN: ["ap-web-1-oversea.agora.io"],
                    WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-oversea.agora.io"],
                    PROXY_CS: ["proxy-ap-web-oversea.agora.io"],
                    CDS_AP: ["cds-ap-web-oversea.agora.io"],
                    ACCOUNT_REGISTER: ["sua-ap-web-oversea.agora.io"],
                    UAP_AP: ["uap-ap-web-oversea.agora.io"],
                    EVENT_REPORT_DOMAIN: ["statscollector-1-oversea.agora.io"],
                    EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-oversea.agora.io"],
                    LOG_UPLOAD_SERVER: ["logservice-oversea.agora.io"],
                    PROXY_SERVER_TYPE3: ["webrtc-cloud-proxy.agora.io"]
                },
                GLOBAL: {
                    CODE: Fv.GLOBAL,
                    WEBCS_DOMAIN: ["webrtc2-ap-web-1.agora.io"],
                    WEBCS_DOMAIN_BACKUP_LIST: ["webrtc2-ap-web-3.agora.io"],
                    PROXY_CS: ["ap-proxy-1.agora.io", "ap-proxy-2.agora.io"],
                    CDS_AP: ["cds-ap-web-1.agora.io", "cds-ap-web-3.agora.io"],
                    ACCOUNT_REGISTER: ["sua-ap-web-1.agora.io", "sua-ap-web-3.agora.io"],
                    UAP_AP: ["uap-ap-web-1.agora.io", "uap-ap-web-3.agora.io"],
                    EVENT_REPORT_DOMAIN: ["statscollector-1.agora.io"],
                    EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2.agora.io"],
                    LOG_UPLOAD_SERVER: ["logservice.agora.io"],
                    PROXY_SERVER_TYPE3: ["webrtc-cloud-proxy.sd-rtn.com"]
                },
                OCEANIA: {
                    CODE: Fv.OCEANIA,
                    WEBCS_DOMAIN: ["ap-web-1-oceania.agora.io"],
                    WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-oceania.agora.io"],
                    PROXY_CS: ["proxy-ap-web-oceania.agora.io"],
                    CDS_AP: ["cds-ap-web-oceania.agora.io", "cds-ap-web-oceania2.agora.io"],
                    ACCOUNT_REGISTER: ["sua-ap-web-oceania.agora.io", "sua-ap-web-oceania2.agora.io"],
                    UAP_AP: ["uap-ap-web-oceania.agora.io", "uap-ap-web-oceania2.agora.io"],
                    EVENT_REPORT_DOMAIN: ["statscollector-1-oceania.agora.io"],
                    EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-oceania.agora.io"],
                    LOG_UPLOAD_SERVER: ["logservice-oceania.agora.io"],
                    PROXY_SERVER_TYPE3: ["oceania.webrtc-cloud-proxy.sd-rtn.com"]
                },
                SOUTH_AMERICA: {
                    CODE: Fv.SOUTH_AMERICA,
                    WEBCS_DOMAIN: ["ap-web-1-south-america.agora.io"],
                    WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-south-america.agora.io"],
                    PROXY_CS: ["proxy-ap-web-south-america.agora.io"],
                    CDS_AP: ["cds-ap-web-south-america.agora.io", "cds-ap-web-south-america2.agora.io"],
                    ACCOUNT_REGISTER: ["sua-ap-web-south-america.agora.io", "sua-ap-web-south-america2.agora.io"],
                    UAP_AP: ["uap-ap-web-south-america.agora.io", "uap-ap-web-south-america2.agora.io"],
                    EVENT_REPORT_DOMAIN: ["statscollector-1-south-america.agora.io"],
                    EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-south-america.agora.io"],
                    LOG_UPLOAD_SERVER: ["logservice-south-america.agora.io"],
                    PROXY_SERVER_TYPE3: ["south-america.webrtc-cloud-proxy.sd-rtn.com"]
                },
                AFRICA: {
                    CODE: Fv.AFRICA,
                    WEBCS_DOMAIN: ["ap-web-1-africa.agora.io"],
                    WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-2-africa.agora.io"],
                    PROXY_CS: ["proxy-ap-web-africa.agora.io"],
                    CDS_AP: ["cds-ap-web-africa.agora.io", "cds-ap-web-africa2.agora.io"],
                    ACCOUNT_REGISTER: ["sua-ap-web-africa.agora.io", "sua-ap-web-africa2.agora.io"],
                    UAP_AP: ["uap-ap-web-africa.agora.io", "uap-ap-web-africa2.agora.io"],
                    EVENT_REPORT_DOMAIN: ["statscollector-1-africa.agora.io"],
                    EVENT_REPORT_BACKUP_DOMAIN: ["statscollector-2-africa.agora.io"],
                    LOG_UPLOAD_SERVER: ["logservice-south-africa.agora.io"],
                    PROXY_SERVER_TYPE3: ["africa.webrtc-cloud-proxy.sd-rtn.com"]
                }
            };
            let Wv, Gv, qv, Hv, Kv, zv, Yv, Jv, Xv, Qv, $v, Zv, eg, tg, rg;
            nm && (Bv.CHINA = {
                CODE: Fv.CHINA,
                WEBCS_DOMAIN: ["webrtc2-2.ap.sd-rtn.com"],
                WEBCS_DOMAIN_BACKUP_LIST: ["webrtc2-4.ap.sd-rtn.com"],
                PROXY_CS: ["proxy-web.ap.sd-rtn.com"],
                CDS_AP: ["cds-web-2.ap.sd-rtn.com", "cds-web-4.ap.sd-rtn.com"],
                ACCOUNT_REGISTER: ["sua-web-2.ap.sd-rtn.com", "sua-web-4.ap.sd-rtn.com"],
                UAP_AP: ["uap-web-2.ap.sd-rtn.com", "uap-web-4.ap.sd-rtn.com"],
                EVENT_REPORT_DOMAIN: ["web-3.statscollector.sd-rtn.com"],
                EVENT_REPORT_BACKUP_DOMAIN: ["web-4.statscollector.sd-rtn.com"],
                LOG_UPLOAD_SERVER: ["logservice-china.agora.io"],
                PROXY_SERVER_TYPE3: ["east-cn.webrtc-cloud-proxy.sd-rtn.com"]
            }), function (e) {
                e.UPDATE_BITRATE_LIMIT = "update_bitrate_limit"
            }(Wv || (Wv = {}));

            class ng extends Wf {
                constructor(e, t) {
                    super(), Kh(this, "onICEConnectionStateChange", void 0), Kh(this, "onConnectionStateChange", void 0), Kh(this, "onDTLSTransportStateChange", void 0), Kh(this, "onDTLSTransportError", void 0), Kh(this, "onICETransportStateChange", void 0), Kh(this, "onFirstAudioReceived", void 0), Kh(this, "onFirstVideoReceived", void 0), Kh(this, "onFirstAudioDecoded", void 0), Kh(this, "onFirstVideoDecoded", void 0), Kh(this, "onFirstVideoDecodedTimeout", void 0), Kh(this, "onSelectedLocalCandidateChanged", void 0), Kh(this, "onSelectedRemoteCandidateChanged", void 0)
                }
            }

            !function (e) {
                e.SEND = "sendonly", e.RECV = "recvonly", e.SENDRECV = "sendrecv", e.INACTIVE = "inactive"
            }(Gv || (Gv = {})), function (e) {
                e.VIDEO = "video", e.AUDIO = "audio"
            }(qv || (qv = {})), function (e) {
                e.LocalVideoTrack = "videoTrack", e.LocalAudioTrack = "audioTrack", e.LocalVideoLowTrack = "videoLowTrack"
            }(Hv || (Hv = {})), function (e) {
                e.New = "new", e.Connected = "connected", e.Reconnecting = "reconnecting", e.Disconnected = "disconnected"
            }(Kv || (Kv = {})), function (e) {
                e.StateChange = "stateChange", e.IceConnectionStateChange = "iceConnectionStateChange", e.RequestMuteLocal = "requestMuteLocal", e.RequestUnmuteLocal = "requestUnmuteLocal", e.RequestRePublish = "requestRePublish", e.RequestReSubscribe = "requestReSubscribe", e.RequestUploadStats = "requestUploadStats", e.MediaReconnectStart = "MediaReconnectStart", e.MediaReconnectEnd = "MediaReconnectEnd", e.NeedSignalRTT = "NeedSignalRTT", e.RequestRestartICE = "RequestRestartIce", e.PeerConnectionStateChange = "PeerConnectionStateChange", e.RequestReconnect = "RequestReconnect", e.RequestReconnectPC = "RequestReconnectPC", e.RequestUnpublishForReconnectPC = "RequestUnpublishForReconnectPC", e.P2PLost = "P2PLost", e.UpdateVideoEncoder = "UpdateVideoEncoder", e.ConnectionTypeChange = "ConnectionTypeChange", e.RequestLowStreamParameter = "RequestLowStreamParameter", e.QueryClientConnectionState = "QueryClientConnectionState"
            }(zv || (zv = {})), function (e) {
                e.ONLINE = "ONLINE", e.OFFLINE = "OFFLINE"
            }(Yv || (Yv = {})), function (e) {
                e.NETWORK_STATE_CHANGE = "NETWORK_STATE_CHANGE", e.ONLINE = "ONLINE", e.OFFLINE = "OFFLINE"
            }(Jv || (Jv = {})), function (e) {
                e.ON_TRACK = "on_track", e.ON_NODE = "on_node"
            }(Xv || (Xv = {})), function (e) {
                e.REQUEST_UPDATE_CONSTRAINTS = "request_update_constraints", e.REQUEST_CONSTRAINTS = "request_constraints"
            }(Qv || (Qv = {})), function (e) {
                e.CONNECTING = "CONNECTING", e.RECONNECTING = "RECONNECTING", e.CONNECTED = "CONNECTED", e.CLOSED = "CLOSED"
            }($v || ($v = {})), function (e) {
                e[e.CONNECT_AP = 0] = "CONNECT_AP", e[e.AP_CONNECTED = 1] = "AP_CONNECTED", e[e.CONNECT_WORKER_MANAGER = 2] = "CONNECT_WORKER_MANAGER", e[e.WORKER_MANAGER_CONNECTED = 3] = "WORKER_MANAGER_CONNECTED", e[e.GET_WORKER_MANAGER_RESPONSE = 4] = "GET_WORKER_MANAGER_RESPONSE", e[e.CONNECT_WORKER = 5] = "CONNECT_WORKER", e[e.WORKER_CONNECTED = 6] = "WORKER_CONNECTED", e[e.CLOSED = 7] = "CLOSED"
            }(Zv || (Zv = {})), function (e) {
                e.CONNECTION_STATE_CHANGE = "connection-state-change", e.STATE_CHANGE = "state-change", e.INSPECT_RESULT = "inspect-result", e.CLIENT_LOCAL_VIDEO_TRACK = "client-local-video-track", e.REQUEST_NEW_WORKER_URL = "request-new-worker-url"
            }(eg || (eg = {})), function (e) {
                e.NETWORK_ERROR = "NETWORK_ERROR", e.SERVER_ERROR = "SERVER_ERROR", e.MULTI_IP = "MULTI_IP", e.TIMEOUT = "TIMEOUT", e.OFFLINE = "OFFLINE", e.LEAVE = "LEAVE", e.P2P_FAILED = "P2P_FAILED", e.FALLBACK = "FALLBACK"
            }(tg || (tg = {})), function (e) {
                e.CONNECTED = "transmitter:connected", e.RECONNECTING = "transmitter:reconnecting", e.WILL_RECONNECT = "transmitter:will_reconnect", e.CLOSED = "transmitter:closed", e.FAILED = "transmitter:failed", e.ON_MESSAGE = "transmitter:on_message", e.REQUEST_NEW_URLS = "transmitter:request_new_urls", e.RECONNECT_WAITTING_FINISH = "transmitter:reconnect_waitting_finish", e.RECONNECT_CREATE_CONNECTION = "transmitter:reconnect_create_connection", e.ON_TOKEN_PRIVILEGE_DID_EXPIRE = "transmitter:on_token_privilege_did_expire", e.TO_CONNECT_DATACHANNEL = "transmitter:to_connect_datachannel", e.FAILBACK = "transmitter:failback"
            }(rg || (rg = {}));
            const ig = {
                getDisplayMedia: !1,
                getStreamFromExtension: !1,
                supportUnifiedPlan: !1,
                supportMinBitrate: !1,
                supportSetRtpSenderParameters: !1,
                supportDualStream: !0,
                webAudioMediaStreamDest: !1,
                supportReplaceTrack: !1,
                supportWebGL: !1,
                webAudioWithAEC: !1,
                supportRequestFrame: !1,
                supportShareAudio: !1,
                supportDualStreamEncoding: !1,
                supportDataChannel: !1
            };

            function og() {
                return ig
            }

            let sg;
            !function (e) {
                e[e.CHOOSE_SERVER = 11] = "CHOOSE_SERVER", e[e.CLOUD_PROXY = 18] = "CLOUD_PROXY", e[e.CLOUD_PROXY_5 = 20] = "CLOUD_PROXY_5", e[e.CLOUD_PROXY_FALLBACK = 26] = "CLOUD_PROXY_FALLBACK"
            }(sg || (sg = {}));
            var ag = M, cg = Array.isArray || function (e) {
                return "Array" == ag(e)
            }, ug = f, dg = cg, lg = Za, hg = J, pg = ot("species"), fg = ug.Array, mg = function (e, t) {
                return new (function (e) {
                    var t;
                    return dg(e) && (t = e.constructor, (lg(t) && (t === fg || dg(t.prototype)) || hg(t) && null === (t = t[pg])) && (t = void 0)), void 0 === t ? fg : t
                }(e))(0 === t ? 0 : t)
            }, _g = Gt, vg = W, gg = Fe, Eg = Ir, yg = mg, Sg = l([].push), bg = function (e) {
                var t = 1 == e, r = 2 == e, n = 3 == e, i = 4 == e, o = 6 == e, s = 7 == e, a = 5 == e || o;
                return function (c, u, d, l) {
                    for (var h, p, f = gg(c), m = vg(f), _ = _g(u, d), v = Eg(m), g = 0, E = l || yg, y = t ? E(c, v) : r || s ? E(c, 0) : void 0; v > g; g++) if ((a || g in m) && (p = _(h = m[g], g, f), e)) if (t) y[g] = p; else if (p) switch (e) {
                        case 3:
                            return !0;
                        case 5:
                            return h;
                        case 6:
                            return g;
                        case 2:
                            Sg(y, h)
                    } else switch (e) {
                        case 4:
                            return !1;
                        case 7:
                            Sg(y, h)
                    }
                    return o ? -1 : n || i ? i : y
                }
            }, Tg = {
                forEach: bg(0),
                map: bg(1),
                filter: bg(2),
                some: bg(3),
                every: bg(4),
                find: bg(5),
                findIndex: bg(6),
                filterReject: bg(7)
            }, Rg = Tg.forEach, Ig = Lr("forEach") ? [].forEach : function (e) {
                return Rg(this, e, arguments.length > 1 ? arguments[1] : void 0)
            };
            Er({target: "Array", proto: !0, forced: [].forEach != Ig}, {forEach: Ig});
            var wg = Fr("Array").forEach, Cg = Ki, Ag = Ge, Og = h, Ng = wg, Pg = Array.prototype,
                Dg = {DOMTokenList: !0, NodeList: !0}, kg = function (e) {
                    var t = e.forEach;
                    return e === Pg || Og(Pg, e) && t === Pg.forEach || Ag(Dg, Cg(e)) ? Ng : t
                }, Lg = Fe, xg = oi;
            Er({
                target: "Object", stat: !0, forced: i(function () {
                    xg(1)
                })
            }, {
                keys: function (e) {
                    return xg(Lg(e))
                }
            });
            var Mg = X.Object.keys, Ug = Hr, jg = Er, Vg = cg, Fg = l([].reverse), Bg = [1, 2];
            jg({target: "Array", proto: !0, forced: String(Bg) === String(Bg.reverse())}, {
                reverse: function () {
                    return Vg(this) && (this.length = this.length), Fg(this)
                }
            });
            var Wg = Fr("Array").reverse, Gg = h, qg = Wg, Hg = Array.prototype, Kg = function (e) {
                    var t = e.reverse;
                    return e === Hg || Gg(Hg, e) && t === Hg.reverse ? qg : t
                }, zg = i, Yg = ue, Jg = ot("species"), Xg = function (e) {
                    return Yg >= 51 || !zg(function () {
                        var t = [];
                        return (t.constructor = {})[Jg] = function () {
                            return {foo: 1}
                        }, 1 !== t[e](Boolean).foo
                    })
                }, Qg = Er, $g = f, Zg = cg, eE = Za, tE = J, rE = On, nE = Ir, iE = z, oE = Cm, sE = ot, aE = sc,
                cE = Xg("slice"), uE = sE("species"), dE = $g.Array, lE = Math.max;
            Qg({target: "Array", proto: !0, forced: !cE}, {
                slice: function (e, t) {
                    var r, n, i, o = iE(this), s = nE(o), a = rE(e, s), c = rE(void 0 === t ? s : t, s);
                    if (Zg(o) && (r = o.constructor, (eE(r) && (r === dE || Zg(r.prototype)) || tE(r) && null === (r = r[uE])) && (r = void 0), r === dE || void 0 === r)) return aE(o, a, c);
                    for (n = new (void 0 === r ? dE : r)(lE(c - a, 0)), i = 0; a < c; a++, i++) a in o && oE(n, i, o[a]);
                    return n.length = i, n
                }
            });
            var hE = Fr("Array").slice, pE = h, fE = hE, mE = Array.prototype, _E = function (e) {
                var t = e.slice;
                return e === mE || pE(mE, e) && t === mE.slice ? fE : t
            };

            function vE(e, t, r, n, i) {
                var o, s, a, c = {};
                return kg(o = Mg(n)).call(o, function (e) {
                    c[e] = n[e]
                }), c.enumerable = !!c.enumerable, c.configurable = !!c.configurable, ("value" in c || c.initializer) && (c.writable = !0), c = Ug(s = Kg(a = _E(r).call(r)).call(a)).call(s, function (r, n) {
                    return n(e, t, r) || r
                }, c), i && void 0 !== c.initializer && (c.value = c.initializer ? c.initializer.call(i) : void 0, c.initializer = void 0), void 0 === c.initializer && (Hh(e, t, c), c = null), c
            }

            var gE = Fr("Array").keys, EE = Ki, yE = Ge, SE = h, bE = gE, TE = Array.prototype,
                RE = {DOMTokenList: !0, NodeList: !0}, IE = function (e) {
                    var t = e.keys;
                    return e === TE || SE(TE, e) && t === TE.keys || yE(RE, EE(e)) ? bE : t
                };

            function wE(e, t) {
                var r = Object.keys(e);
                if (Object.getOwnPropertySymbols) {
                    var n = Object.getOwnPropertySymbols(e);
                    t && (n = n.filter(function (t) {
                        return Object.getOwnPropertyDescriptor(e, t).enumerable
                    })), r.push.apply(r, n)
                }
                return r
            }

            function CE(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var r = null != arguments[t] ? arguments[t] : {};
                    t % 2 ? wE(Object(r), !0).forEach(function (t) {
                        Kh(e, t, r[t])
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : wE(Object(r)).forEach(function (t) {
                        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t))
                    })
                }
                return e
            }

            let AE = 0, OE = 0;

            function NE(e, t, r, n) {
                return new sl((i, o) => {
                    t.timeout = t.timeout || fm("HTTP_CONNECT_TIMEOUT"), t.responseType = t.responseType || "json", t.data && !r ? (t.data = JSON.stringify(t.data), AE += KS(t.data)) : r && (t.data.size ? AE += t.data.size : t.data instanceof FormData ? AE += function (e) {
                        let t = 0;
                        return /DingTalk/i.test(navigator.userAgent) && e.realFormData && (e = e.realFormData), e.forEach(e => {
                            t += "string" == typeof e ? KS(e) : e.size
                        }), t + 138
                    }(t.data) : AE += KS(JSON.stringify(t.data))), t.headers = t.headers || {}, t.headers["Content-Type"] = t.headers["Content-Type"] || "application/json", t.method = "POST", t.url = e, Bf.request(t).then(e => {
                        "string" == typeof e.data ? OE += KS(e.data) : e.data instanceof ArrayBuffer || e.data instanceof Uint8Array ? OE += e.data.byteLength : OE += KS(JSON.stringify(e.data)), n && i({
                            data: e.data,
                            headers: e.headers
                        }), i(e.data)
                    }).catch(e => {
                        Bf.isCancel(e) ? o(new Hf(qf.OPERATION_ABORTED, "cancel token canceled")) : "ECONNABORTED" === e.code ? o(new Hf(qf.NETWORK_TIMEOUT, e.message)) : e.response ? o(new Hf(qf.NETWORK_RESPONSE_ERROR, e.response.status)) : o(new Hf(qf.NETWORK_ERROR, e.message))
                    })
                })
            }

            async function PE(e, t) {
                const r = new Blob([t.data], {type: "buffer"});
                return await NE(e, CE(CE({}, t), {}, {
                    data: r,
                    headers: {"Content-Type": "application/octet-stream"}
                }), !0)
            }

            const DE = new class extends Wf {
                set networkState(e) {
                    em.info("[".concat(this._moduleName, "]") + "network state changed, " + this._networkState + " -> " + e), this.emit(Jv.NETWORK_STATE_CHANGE, e, this._networkState), e === Yv.ONLINE ? this.emit(Jv.ONLINE) : e === Yv.OFFLINE && (this.onlineWaiter = new sl(e => {
                        this.once(Jv.ONLINE, () => {
                            this.onlineWaiter = void 0, e(Yv.ONLINE)
                        })
                    }), this.emit(Jv.OFFLINE)), this._networkState = e
                }

                get networkState() {
                    return this._networkState
                }

                constructor() {
                    super(), Kh(this, "_moduleName", "network-indicator"), Kh(this, "_networkState", Yv.ONLINE), Kh(this, "onlineWaiter", void 0), window.addEventListener("online", () => {
                        this.networkState = Yv.ONLINE
                    }), window.addEventListener("offline", () => {
                        this.networkState = Yv.OFFLINE
                    })
                }
            };
            let kE = !1;
            const LE = new class extends Wf {
                constructor() {
                    super(...arguments), Kh(this, "onAutoplayFailed", void 0), Kh(this, "onAudioAutoplayFailed", void 0)
                }
            };

            function xE() {
                if (Sh(), !kE) {
                    const e = t => {
                        t.preventDefault(), kE = !1, jh() ? document.body.removeEventListener("click", e, !0) : (document.body.removeEventListener("touchstart", e, !0), document.body.removeEventListener("mousedown", e, !0))
                    };
                    kE = !0, jh() ? document.body.addEventListener("click", e, !0) : (document.body.addEventListener("touchstart", e, !0), document.body.addEventListener("mousedown", e, !0)), em.info("detect media autoplay failed, document: https://docs.agora.io/cn/Voice/autoplay_policy_web_ng?platform=Web"), LE.onAutoplayFailed ? LE.onAutoplayFailed() : LE.onAudioAutoplayFailed ? em.warning("AgoraRTC.onAudioAutoplayFailed has been deprecated in favor of AgoraRTC.onAutoplayFailed.\n\n  Please refer to the Agora document to migrate the newer API, https://docs.agora.io/en/Voice/autoplay_policy_web_ng?platform=Web .") : em.warning("We have detected a media autoplay failed event, and found out that you haven't implemented AgoraRTC.onAutoplayFailed callback yet.\n\n  It will cause audio/video element not playing automatically on some browsers without user interaction, possibly hurting user experiences.\n\n  Please refer to the Agora document to properly handle autoplay failed event, https://docs.agora.io/en/Voice/autoplay_policy_web_ng?platform=Web ."), LE.emit("autoplay-failed")
                }
            }

            function ME(e) {
                return (new TextEncoder).encode(e)
            }

            const UE = function (e, t) {
                const r = new Uint8Array(e.byteLength + t.byteLength);
                return r.set(new Uint8Array(e), 0), r.set(new Uint8Array(t), e.byteLength), r
            }, jE = async e => (function (e, t) {
                let r = "";
                return new Uint8Array(e).forEach(e => {
                    r += e.toString(16).padStart(2, "0")
                }), r
            })(await crypto.subtle.digest("SHA-256", ME(e)));

            function VE(e, t) {
                var r = Object.keys(e);
                if (Object.getOwnPropertySymbols) {
                    var n = Object.getOwnPropertySymbols(e);
                    t && (n = n.filter(function (t) {
                        return Object.getOwnPropertyDescriptor(e, t).enumerable
                    })), r.push.apply(r, n)
                }
                return r
            }

            function FE(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var r = null != arguments[t] ? arguments[t] : {};
                    t % 2 ? VE(Object(r), !0).forEach(function (t) {
                        Kh(e, t, r[t])
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : VE(Object(r)).forEach(function (t) {
                        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t))
                    })
                }
                return e
            }

            function BE() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                return function (t, r, n) {
                    const i = n.value;
                    if ("function" == typeof i) {
                        const o = e.className || t.__className__ || ("AgoraRTCClient" === t.constructor.name ? "Client" : t.constructor.name);
                        n.value = function () {
                            for (var t = arguments.length, n = new Array(t), s = 0; s < t; s++) n[s] = arguments[s];
                            let a = n;
                            if (e.argsMap) try {
                                a = e.argsMap(this, ...n)
                            } catch (e) {
                                em.warning(e), a = []
                            }
                            try {
                                JSON.stringify(a)
                            } catch (e) {
                                em.warning("arguments for method ".concat(o, ".").concat(r, " not serializable for apiInvoke.")), a = []
                            }
                            const c = (e.report || WE).reportApiInvoke(this._sessionId || null, {
                                name: "".concat(o, ".").concat(r),
                                options: a,
                                tag: U_.TRACER,
                                reportResult: e.reportResult
                            }, e.throttleTime);
                            try {
                                const t = i.apply(this, n);
                                return t instanceof sl ? t.then(t => (c.onSuccess(e.reportResult && t), t)).catch(e => {
                                    throw c.onError(e), e
                                }) : (c.onSuccess(e.reportResult && t), t)
                            } catch (e) {
                                throw c.onError(e), e
                            }
                        }
                    }
                    return n
                }
            }

            const WE = new class {
                constructor() {
                    Kh(this, "baseInfoMap", new Map), Kh(this, "proxyServer", void 0), Kh(this, "clientList", bm), Kh(this, "eventUploadTimer", void 0), Kh(this, "setSessionIdTimer", void 0), Kh(this, "url", void 0), Kh(this, "backupUrl", void 0), Kh(this, "_appId", void 0), Kh(this, "keyEventUploadPendingItems", []), Kh(this, "normalEventUploadPendingItems", []), Kh(this, "apiInvokeUploadPendingItems", []), Kh(this, "apiInvokeCount", 0), Kh(this, "ltsList", []), Kh(this, "lastSendNormalEventTime", Date.now()), Kh(this, "customReportCounterTimer", void 0), Kh(this, "customReportCount", 0), Kh(this, "extApiInvoke", async e => {
                        for (const t of e) {
                            const e = FE(FE({}, t), {}, {sid: null, invokeId: ++this.apiInvokeCount, tag: U_.TRACER});
                            this.sendApiInvoke(e)
                        }
                    }), this.eventUploadTimer = window.setInterval(this.doSend.bind(this), fm("EVENT_REPORT_SEND_INTERVAL")), this.setSessionIdTimer = window.setInterval(this.appendSessionId.bind(this), fm("EVENT_REPORT_SEND_INTERVAL"))
                }

                adjustSessionStartTime(e) {
                    if (!this.baseInfoMap.has(e) && !this.baseInfoMap.get(e)) return void em.error("adjust session ".concat(e, " start time, sid is not exist or info is undefined"));
                    const t = this.baseInfoMap.get(e), r = Date.now(), n = t.startTime;
                    t.startTime = r, em.debug("rewrite session ".concat(e, " startTime: ").concat(r, " , ").concat(r - n, "ms")), this.baseInfoMap.set(e, t)
                }

                setAppId(e) {
                    this._appId = e
                }

                reportApiInvoke(e, t, r) {
                    t.timeout = t.timeout || 6e4, t.reportResult = void 0 === t.reportResult || t.reportResult;
                    const n = Date.now();
                    this.apiInvokeCount += 1;
                    const i = this.apiInvokeCount, o = () => ({
                        tag: t.tag,
                        invokeId: i,
                        sid: e,
                        name: t.name,
                        apiInvokeTime: n,
                        options: t.options,
                        states: t.states || null
                    }), s = !!fm("SHOW_REPORT_INVOKER_LOG");
                    s && em.info("".concat(t.name, " start"), t.options);
                    let a = !1;
                    zS(t.timeout).then(() => {
                        a || (this.sendApiInvoke(FE(FE({}, o()), {}, {
                            error: qf.API_INVOKE_TIMEOUT,
                            success: !1
                        })), em.debug("".concat(t.name, " timeout")))
                    });
                    const c = new Hf(qf.UNEXPECTED_ERROR, "".concat(t.name, ": this api invoke is end"));
                    return {
                        onSuccess: e => {
                            const n = () => {
                                if (a) throw c;
                                return a = !0, this.sendApiInvoke(FE(FE({}, o()), {}, {success: !0}, t.reportResult && {result: e})), s && em.info("".concat(t.name, " onSuccess")), e
                            };
                            return r ? hb(n, t.name + "Success", r, () => a = !0) : n()
                        }, onError: e => {
                            const n = () => {
                                if (a) throw e;
                                a = !0, this.sendApiInvoke(FE(FE({}, o()), {}, {
                                    success: !1,
                                    error: e
                                })), s && em.info("".concat(t.name, " onFailure"), e.toString())
                            };
                            return r ? hb(n, t.name + "Error", r, () => a = !0) : n()
                        }
                    }
                }

                sessionInit(e, t) {
                    if (this.baseInfoMap.has(e)) return;
                    const r = Date.now(), n = this.createBaseInfo(e, r);
                    n.cname = t.cname;
                    const i = Object.assign({}, {
                        willUploadConsoleLog: fm("UPLOAD_LOG"),
                        maxTouchPoints: navigator.maxTouchPoints,
                        areaVersion: nm ? "global" : "oversea",
                        areas: fm("AREAS") && fm("AREAS").join(",")
                    }, t.extend), o = Date.now(), s = FE(FE({}, n), {}, {
                        eventType: D_.SESSION_INIT,
                        appid: t.appid,
                        browser: navigator.userAgent,
                        build: tm,
                        lts: o,
                        elapse: o - r,
                        extend: JSON.stringify(i),
                        mode: t.mode,
                        process: fm("PROCESS_ID"),
                        appType: fm("APP_TYPE"),
                        success: !0,
                        version: rm
                    });
                    this.send({type: k_.SESSION, data: s}, !0)
                }

                joinChooseServer(e, t) {
                    const r = this.baseInfoMap.get(e);
                    if (!r) return;
                    const n = r.info, i = Date.now(), o = FE(FE({}, n), {}, {
                        eventType: D_.JOIN_CHOOSE_SERVER,
                        lts: i,
                        eventElapse: i - t.lts,
                        chooseServerAddr: t.csAddr,
                        errorCode: t.ec,
                        elapse: i - r.startTime,
                        success: t.succ,
                        chooseServerAddrList: JSON.stringify(t.serverList),
                        uid: t.uid ? parseInt(t.uid) : null,
                        cid: t.cid ? parseInt(t.cid) : null,
                        chooseServerIp: t.csIp || "",
                        opid: t.opid,
                        unilbsServerIds: t.unilbsServerIds,
                        extend: t.extend || void 0,
                        isHttp3: t.isHttp3
                    });
                    this.send({type: k_.JOIN_CHOOSE_SERVER, data: o}, !0)
                }

                reqUserAccount(e, t) {
                    const r = this.baseInfoMap.get(e);
                    if (!r) return;
                    const n = r.info, i = Date.now(), o = FE(FE({}, n), {}, {
                        eventType: D_.REQ_USER_ACCOUNT,
                        lts: i,
                        success: t.success,
                        serverAddress: t.serverAddr,
                        stringUid: t.stringUid,
                        uid: t.uid,
                        errorCode: t.errorCode,
                        elapse: i - r.startTime,
                        eventElapse: i - t.lts,
                        extend: JSON.stringify(t.extend)
                    });
                    this.send({type: k_.REQ_USER_ACCOUNT, data: o}, !0)
                }

                joinGateway(e, t) {
                    const r = this.baseInfoMap.get(e);
                    if (!r) return;
                    const n = r.info;
                    t.vid && (n.vid = t.vid), n.uid = t.uid, n.cid = t.cid;
                    const i = Date.now(), {firstSuccess: o, avoidJoinStartTime: s, isProxy: a, addr: c} = t,
                        u = i - (o && s ? s : r.startTime), d = FE(FE({}, n), {}, {
                            eventType: D_.JOIN_GATEWAY,
                            lts: i,
                            gatewayAddr: t.addr,
                            success: t.succ,
                            errorCode: t.ec,
                            elapse: u,
                            eventElapse: i - t.lts,
                            firstSuccess: o,
                            signalChannel: t.signalChannel
                        }), l = d.success ? 1 : 0;
                    if (t.succ && (r.lastJoinSuccessTime = i), o) this.send({
                        type: k_.JOIN_GATEWAY,
                        data: d
                    }, !0); else {
                        let e;
                        if (c) if (a) {
                            const t = c.match(/h=(\d{1,3}-){3}\d{1,3}/g), r = c.match(/p=[0-9]{1,6}/g);
                            e = {
                                isSuccess: l,
                                gatewayIp: t && t.length ? t[0].split("=")[1].replace(/-/g, ".") : "",
                                port: r && r.length ? r[0].split("=")[1] : "",
                                isProxy: a ? 1 : 0
                            }
                        } else {
                            const t = c.match(/wss:\/\/(\d{1,3}-){3}\d{1,3}/g), r = c.match(/:[0-9]{1,6}/g);
                            e = {
                                isSuccess: l,
                                gatewayIp: t && t.length ? t[0].split("//")[1].replace(/-/g, ".") : "",
                                port: r && r.length ? r[0].split(":")[1] : "",
                                isProxy: a ? 1 : 0
                            }
                        } else e = {isSuccess: l, gatewayIp: "", port: "", isProxy: a ? 1 : 0};
                        delete d.success, delete d.eventType, delete d.firstSuccess, d.vid = Number(d.vid);
                        const t = Object.assign({}, d, e, {eventType: D_.REJOIN_GATEWAY});
                        this.send({type: k_.RE_JOIN_GATEWAY, data: t}, !0)
                    }
                }

                joinChannelTimeout(e, t) {
                    const r = this.baseInfoMap.get(e);
                    if (!r) return;
                    const n = Date.now(), i = FE(FE({}, r.info), {}, {lts: n, timeout: t, elapse: n - r.startTime});
                    this.send({type: k_.JOIN_CHANNEL_TIMEOUT, data: i}, !0)
                }

                publish(e, t) {
                    const r = this.baseInfoMap.get(e);
                    if (!r) return;
                    const n = r.info, i = Date.now(), o = FE(FE({}, n), {}, {
                        eventType: D_.PUBLISH,
                        lts: i,
                        eventElapse: t.eventElapse,
                        elapse: i - r.startTime,
                        success: t.succ,
                        errorCode: t.ec,
                        videoName: t.videoName,
                        audioName: t.audioName,
                        screenName: t.screenName,
                        screenshare: t.screenshare,
                        audio: t.audio,
                        video: t.video,
                        p2pid: t.p2pid,
                        publishRequestid: t.publishRequestid
                    });
                    this.send({type: k_.PUBLISH, data: o}, !0)
                }

                subscribe(e, t, r) {
                    const n = this.baseInfoMap.get(e);
                    if (!n) return;
                    const i = n.info, o = Date.now(), s = FE(FE({}, i), {}, {
                        eventType: D_.SUBSCRIBE,
                        lts: o,
                        eventElapse: t.eventElapse,
                        elapse: o - n.startTime,
                        success: t.succ,
                        errorCode: t.ec,
                        video: t.video,
                        audio: t.audio,
                        subscribeRequestid: t.subscribeRequestid,
                        p2pid: t.p2pid
                    }, r && {extend: JSON.stringify({isMassSubscribe: !0})});
                    "string" == typeof t.peerid ? s.peerSuid = t.peerid : s.peer = t.peerid, this.send({
                        type: k_.SUBSCRIBE,
                        data: s
                    }, !0)
                }

                wsCompressorInit(e) {
                    var t;
                    const r = [...IE(t = this.baseInfoMap).call(t)], n = r.length ? r[0] : "UnableToGetSid",
                        i = this.baseInfoMap.get(n);
                    if (!i) return;
                    const o = i.info, s = Date.now(), a = FE(FE({}, o), {}, {
                        eventType: D_.WS_COMPRESSOR_INIT,
                        lts: s,
                        eventElapse: e.eventElapse,
                        elapse: s - i.startTime,
                        status: e.status ? 1 : 2
                    });
                    this.send({type: k_.WS_COMPRESSOR_INIT, data: a}, !0)
                }

                firstRemoteVideoDecode(e, t, r, n) {
                    const i = this.baseInfoMap.get(e);
                    if (!i) return;
                    const o = i.info, s = Date.now(), a = FE(FE(FE({}, o), n), {}, {
                        elapse: s - i.startTime,
                        eventType: t,
                        lts: s,
                        firstDecodeFrame: Math.max(s - i.startTime, 0),
                        apEnd: Math.max(n.apEnd - i.startTime, 0),
                        apStart: Math.max(n.apStart - i.startTime, 0),
                        joinGwEnd: Math.max(n.joinGwEnd - i.startTime, 0),
                        joinGwStart: Math.max(n.joinGwStart - i.startTime, 0),
                        pcEnd: Math.max(n.pcEnd - i.startTime, 0),
                        pcStart: Math.max(n.pcStart - i.startTime, 0),
                        subscriberEnd: Math.max(n.subscriberEnd - i.startTime, 0),
                        subscriberStart: Math.max(n.subscriberStart - i.startTime, 0),
                        videoAddNotify: Math.max(n.videoAddNotify - i.startTime, 0)
                    });
                    this.send({type: r, data: a}, !0)
                }

                firstRemoteFrame(e, t, r, n) {
                    const i = this.baseInfoMap.get(e);
                    if (!i) return;
                    const o = i.info, s = Date.now(),
                        a = FE(FE(FE({}, o), n), {}, {elapse: s - i.startTime, eventType: t, lts: s});
                    this.send({type: r, data: a}, !0)
                }

                onGatewayStream(e, t, r, n) {
                    const i = this.baseInfoMap.get(e);
                    if (!i) return;
                    const o = i.info, s = Date.now(), a = FE(FE(FE({}, o), n), {}, {eventType: t, lts: s});
                    this.send({type: r, data: a}, !0)
                }

                streamSwitch(e, t) {
                    const r = this.baseInfoMap.get(e);
                    if (!r) return;
                    const n = r.info, i = Date.now(), o = FE(FE({}, n), {}, {
                        eventType: D_.STREAM_SWITCH,
                        lts: i,
                        isDual: t.isdual,
                        elapse: i - r.startTime,
                        success: t.succ
                    });
                    this.send({type: k_.STREAM_SWITCH, data: o}, !0)
                }

                requestProxyAppCenter(e, t) {
                    const r = this.baseInfoMap.get(e);
                    if (!r) return;
                    const n = r.info, i = Date.now(), o = FE(FE({}, n), {}, {
                        eventType: D_.REQUEST_PROXY_APPCENTER,
                        lts: i,
                        eventElapse: i - t.lts,
                        elapse: i - r.startTime,
                        APAddr: t.APAddr,
                        workerManagerList: t.workerManagerList,
                        response: t.response,
                        errorCode: t.ec,
                        success: t.succ
                    });
                    this.send({type: k_.REQUEST_PROXY_APPCENTER, data: o}, !0)
                }

                requestProxyWorkerManager(e, t) {
                    const r = this.baseInfoMap.get(e);
                    if (!r) return;
                    const n = r.info, i = Date.now(), o = FE(FE({}, n), {}, {
                        eventType: D_.REQUEST_PROXY_WORKER_MANAGER,
                        lts: i,
                        eventElapse: i - t.lts,
                        elapse: i - r.startTime,
                        workerManagerAddr: t.workerManagerAddr,
                        response: t.response,
                        errorCode: t.ec,
                        success: t.succ
                    });
                    this.send({type: k_.REQUEST_PROXY_WORKER_MANAGER, data: o}, !0)
                }

                setProxyServer(e) {
                    this.proxyServer = e, e ? em.debug("reportProxyServerurl: ".concat(e)) : em.debug("disable reportProxyServerurl: ".concat(e))
                }

                peerPublishStatus(e, t) {
                    const r = this.baseInfoMap.get(e);
                    if (!r) return;
                    const n = r.info, i = Date.now(), o = FE(FE({}, n), {}, {
                        subscribeElapse: t.subscribeElapse,
                        peer: t.peer,
                        peerPublishDuration: Math.max(t.audioPublishDuration, t.videoPublishDuration),
                        audiotag: t.audioPublishDuration > 0 ? 1 : -1,
                        videotag: t.videoPublishDuration > 0 ? 1 : -1,
                        lts: i,
                        elapse: i - r.startTime,
                        joinChannelSuccessElapse: i - (r.lastJoinSuccessTime || i),
                        peerPublishDurationVideo: t.videoPublishDuration,
                        peerPublishDurationAudio: t.audioPublishDuration
                    });
                    this.send({type: k_.PEER_PUBLISH_STATUS, data: o}, !0)
                }

                workerEvent(e, t) {
                    const r = this.baseInfoMap.get(e);
                    if (!r) return;
                    const n = r.info, i = Date.now();
                    (function (e, t, r) {
                        const n = e[t];
                        if (!n || "string" != typeof n) return [e];
                        e[t] = "";
                        const i = KS(JSON.stringify(e));
                        let o = 0;
                        const s = [];
                        let a = 0;
                        for (let r = 0; r < n.length; r++) (a += n.charCodeAt(r) <= 127 ? 1 : 3) <= 1300 - i || (s[s.length] = HS(HS({}, e), {}, {[t]: n.substring(o, r)}), o = r, a = n.charCodeAt(r) <= 127 ? 1 : 3);
                        return o !== n.length - 1 && (s[s.length] = HS(HS({}, e), {}, {[t]: n.substring(o)})), s
                    })(FE(FE(FE({}, n), t), {}, {
                        elapse: i - r.startTime,
                        lts: i,
                        productType: "WebRTC"
                    }), "payload").forEach(e => this.send({type: k_.WORKER_EVENT, data: e}, !0))
                }

                apworkerEvent(e, t) {
                    const r = this.baseInfoMap.get(e);
                    if (!r) return;
                    const n = r.info, i = Date.now(), o = FE(FE(FE({}, n), t), {}, {elapse: i - r.startTime, lts: i});
                    this.send({type: k_.AP_WORKER_EVENT, data: o}, !0)
                }

                joinWebProxyAP(e, t) {
                    const r = this.baseInfoMap.get(e);
                    if (!r) return;
                    const n = r.info, i = Date.now(),
                        o = FE(FE(FE({}, n), t), {}, {elapse: i - r.startTime, lts: i, extend: t.extend || void 0});
                    this.send({type: k_.JOIN_WEB_PROXY_AP, data: o}, !0)
                }

                WebSocketQuit(e, t) {
                    const r = this.baseInfoMap.get(e);
                    if (!r) return;
                    const n = r.info, i = Date.now(), o = FE(FE(FE({}, n), t), {}, {elapse: i - r.startTime, lts: i});
                    this.send({type: k_.WEBSOCKET_QUIT, data: o}, !0)
                }

                async sendCustomReportMessage(e, t) {
                    if (this.customReportCount += t.length, this.customReportCount > fm("CUSTOM_REPORT_LIMIT")) throw new Hf(qf.CUSTOM_REPORT_FREQUENCY_TOO_HIGH);
                    this.customReportCounterTimer || (this.customReportCounterTimer = window.setInterval(() => {
                        this.customReportCount = 0
                    }, 5e3));
                    const r = t.map(t => ({type: k_.USER_ANALYTICS, data: FE({sid: e}, t)}));
                    try {
                        fm("NEW_REPORT_SERVER") ? await this.postDataToStatsCollector2(r) : await this.postDataToStatsCollector(r)
                    } catch (e) {
                        throw em.error("send custom report message failed", e.toString()), new Hf(qf.CUSTOM_REPORT_SEND_FAILED, e.message)
                    }
                }

                autoplayFailed(e, t, r, n) {
                    if (!e) return;
                    const i = this.baseInfoMap.get(e);
                    if (!i) return;
                    const o = i.info, s = Date.now(), a = FE(FE({}, o), {}, {
                        vid: void 0 === o.vid ? 0 : Number(o.vid),
                        lts: s,
                        elapse: s - i.startTime,
                        cbRegistered: LE.onAutoplayFailed || LE.onAudioAutoplayFailed ? 1 : -1,
                        errorMsg: r,
                        mediaType: t,
                        trackId: n,
                        extend: void 0
                    });
                    this.send({type: k_.AUTOPLAY_FAILED, data: a}, !0)
                }

                sendApiInvoke(e) {
                    const t = fm("NOT_REPORT_EVENT");
                    if (e.tag && t.includes && t.includes(e.tag)) return !1;
                    if (null === e.sid) return this.apiInvokeUploadPendingItems.push(e), !1;
                    const r = this.baseInfoMap.get(e.sid);
                    if (!r) return this.apiInvokeUploadPendingItems.push(e), !1;
                    const {cname: n, uid: i, cid: o} = r.info;
                    e.lts = e.lts || Date.now();
                    let s = void 0;
                    if (e.error) if (e.error instanceof Hf) {
                        const {code: t, message: r} = e.error;
                        s = t || r || e.error.toString()
                    } else s = e.error.toString();
                    const a = {
                        invokeId: e.invokeId,
                        sid: e.sid,
                        cname: n,
                        cid: o,
                        uid: i,
                        lts: e.lts,
                        success: e.success,
                        elapse: e.lts - r.startTime,
                        execElapse: e.lts - e.apiInvokeTime,
                        apiName: e.name,
                        options: e.options ? JSON.stringify(e.options) : void 0,
                        execStates: e.states ? JSON.stringify(e.states) : void 0,
                        execResult: e.result ? JSON.stringify(e.result) : void 0,
                        errorCode: e.error ? s : void 0,
                        errorMsg: e.error ? JSON.stringify(e.error) : void 0
                    };
                    return this.send({type: k_.API_INVOKE, data: a}, !1), !0
                }

                appendSessionId() {
                    this.clientList.forEach(e => {
                        if (e._sessionId) {
                            const t = this.apiInvokeUploadPendingItems.length;
                            for (let r = 0; r < t; r++) {
                                const t = this.apiInvokeUploadPendingItems.shift();
                                t && (t.sid = e._sessionId, this.sendApiInvoke(Object.assign({}, t)))
                            }
                        }
                    })
                }

                send(e, t) {
                    if (t) return this.keyEventUploadPendingItems.push(e), void this.sendItems(this.keyEventUploadPendingItems, !0);
                    this.normalEventUploadPendingItems.push(e), this.normalEventUploadPendingItems.length > fm("NORMAL_EVENT_QUEUE_CAPACITY") && this.normalEventUploadPendingItems.splice(0, 1), this.normalEventUploadPendingItems.length >= 10 && this.sendItems(this.normalEventUploadPendingItems, !1)
                }

                doSend() {
                    this.keyEventUploadPendingItems.length > 0 && this.sendItems(this.keyEventUploadPendingItems, !0), this.normalEventUploadPendingItems.length > 0 && Date.now() - this.lastSendNormalEventTime >= 5e3 && this.sendItems(this.normalEventUploadPendingItems, !1)
                }

                sendItems(e, t) {
                    const r = [], n = [];
                    for (; e.length;) {
                        const t = e.shift();
                        r.length < 20 ? r.push(t) : n.push(t)
                    }
                    e.push(...n);
                    for (const e of [...r]) {
                        var i;
                        -1 !== this.ltsList.indexOf(e.data.lts) ? (e.data.lts = this.ltsList[this.ltsList.length - 1] + 1, this.ltsList.push(e.data.lts)) : (this.ltsList.push(e.data.lts), m_(i = this.ltsList).call(i, (e, t) => e - t))
                    }
                    return t || (this.lastSendNormalEventTime = Date.now()), fm("ENABLE_EVENT_REPORT") ? (r.length && (fm("NEW_REPORT_SERVER") ? this.postDataToStatsCollector2(r) : this.postDataToStatsCollector(r)).catch((e => r => {
                        fm("EVENT_REPORT_RETRY") && (t ? this.keyEventUploadPendingItems = this.keyEventUploadPendingItems.concat(e) : (this.normalEventUploadPendingItems = this.normalEventUploadPendingItems.concat(e), this.normalEventUploadPendingItems.length > fm("NORMAL_EVENT_QUEUE_CAPACITY") && (this.normalEventUploadPendingItems.splice(0, this.normalEventUploadPendingItems.length - fm("NORMAL_EVENT_QUEUE_CAPACITY")), em.warning("report: drop normal events"))))
                    })(r)), e) : e
                }

                async postDataToStatsCollector2(e) {
                    DE.networkState === Yv.OFFLINE && await sl.race([DE.onlineWaiter, zS(2 * Kf.maxRetryTimeout)]);
                    const t = e => {
                        let t = new Uint8Array;
                        return e.forEach(e => {
                            const r = ME(JSON.stringify(e.data)), n = new ArrayBuffer(5), i = (e => {
                                let t = 0;
                                return Object.entries(k_).forEach(r => {
                                    let [n, i] = r;
                                    i === e.type && (t = x_[n])
                                }), t
                            })(e), o = new DataView(n);
                            o.setUint16(0, r.byteLength, !0), o.setUint8(2, 255 & i), o.setUint8(3, i >>> 8 & 255), o.setUint8(4, i >>> 16 & 255), t = UE(t, new Uint8Array(n)), t = UE(t, r)
                        }), t
                    }, r = "event";
                    let n = this.proxyServer ? "https://".concat(this.proxyServer, "/rs/?h=").concat(fm("NEW_REPORT_SERVER_DOMAINS")[0], "&p=443&d=").concat(r) : "https://".concat(fm("NEW_REPORT_SERVER_DOMAINS")[0], "/").concat(r);
                    for (let i = 0; i < 2; i += 1) {
                        1 === i && (n = this.proxyServer ? "https://".concat(this.proxyServer, "/rs/?h=").concat(fm("NEW_REPORT_SERVER_DOMAINS")[1], "&p=443&d=").concat(r) : "https://".concat(fm("NEW_REPORT_SERVER_DOMAINS")[1], "/").concat(r));
                        try {
                            await NE(n, {
                                timeout: 1e4,
                                data: t(e),
                                headers: FE(FE({
                                    token: "32f24ab2ddb74f508aa9286c356cec84",
                                    biz: "webrtc",
                                    sendts: Math.round(Date.now() / 1e3),
                                    debug: "false"
                                }, this._appId && {appid: this._appId}), {}, {"Content-Type": "application/octet-stream"})
                            }, !0)
                        } catch (e) {
                            if (1 === i) throw e;
                            continue
                        }
                        return
                    }
                }

                async postDataToStatsCollector(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                    const r = {
                        msgType: "EventMessages",
                        sentTs: Math.round(Date.now() / 1e3),
                        payloads: e.map(e => JSON.stringify(e)),
                        vid: (e => {
                            const t = e && e.data.sid && this.baseInfoMap.get(e.data.sid);
                            return t && t.info.vid && +t.info.vid || 0
                        })(e[0])
                    };
                    DE.networkState === Yv.OFFLINE && await sl.race([DE.onlineWaiter, zS(2 * Kf.maxRetryTimeout)]);
                    const n = t ? "/events/proto-raws" : "/events/messages";
                    let i = this.url || (this.proxyServer ? "https://".concat(this.proxyServer, "/rs/?h=").concat(fm("EVENT_REPORT_DOMAIN"), "&p=").concat(fm("STATS_COLLECTOR_PORT"), "&d=").concat(n) : "https://".concat(fm("EVENT_REPORT_DOMAIN"), ":").concat(fm("STATS_COLLECTOR_PORT")).concat(n));
                    for (let e = 0; e < 2; e += 1) {
                        1 === e && (i = this.backupUrl || (this.proxyServer ? "https://".concat(this.proxyServer, "/rs/?h=").concat(fm("EVENT_REPORT_BACKUP_DOMAIN"), "&p=").concat(fm("STATS_COLLECTOR_PORT"), "&d=").concat(n) : "https://".concat(fm("EVENT_REPORT_BACKUP_DOMAIN"), ":").concat(fm("STATS_COLLECTOR_PORT")).concat(n)));
                        try {
                            t ? await PE(i, {timeout: 1e4, data: r}) : await NE(i, {timeout: 1e4, data: r})
                        } catch (t) {
                            if (1 === e) throw t;
                            continue
                        }
                        return
                    }
                }

                createBaseInfo(e, t) {
                    const r = Object.assign({}, P_);
                    return r.sid = e, this.baseInfoMap.set(e, {info: r, startTime: t}), r
                }

                reportResourceTiming(e, t) {
                    const r = performance.getEntriesByName(e), n = r[r.length - 1];
                    n && this.reportApiInvoke(t, {
                        name: "Client.resourceTiming",
                        options: n,
                        tag: U_.TRACER
                    }).onSuccess()
                }
            };
            Gf.on("REPORT_LOG_UPLOAD", e => {
                e.networkState = DE.networkState, WE.reportApiInvoke(null, {
                    name: "logUploadError",
                    options: e,
                    tag: U_.TRACER
                })
            });

            class GE extends Wf {
                constructor(e, t) {
                    super(), Kh(this, "trackMediaType", void 0), Kh(this, "_ID", void 0), Kh(this, "_hints", []), Kh(this, "_isClosed", !1), Kh(this, "_originMediaStreamTrack", void 0), Kh(this, "_mediaStreamTrack", void 0), Kh(this, "_external", {}), this._ID = t || YS(8, "track-"), this._originMediaStreamTrack = e, this._mediaStreamTrack = e, function (e) {
                        Tm.includes(e) || Tm.push(e)
                    }(this)
                }

                toString() {
                    return this._ID
                }

                getTrackId() {
                    return this._ID
                }

                getMediaStreamTrack(e) {
                    if (!e) {
                        const e = WE.reportApiInvoke(null, {
                            name: M_.GET_MEDIA_STREAM_TRACK,
                            options: [],
                            tag: U_.TRACER
                        });
                        this._mediaStreamTrack && "string" == typeof this._mediaStreamTrack.label ? e.onSuccess(this._mediaStreamTrack.label) : e.onSuccess("")
                    }
                    return this._mediaStreamTrack
                }

                getMediaStreamTrackSettings() {
                    return this.getMediaStreamTrack(!0).getSettings()
                }

                close() {
                    this._isClosed = !0, function (e) {
                        const t = Tm.indexOf(e);
                        -1 !== t && Tm.splice(t, 1)
                    }(this), this.emit(Lv.CLOSED)
                }
            }

            let qE, HE = 1;

            class KE {
                constructor(e) {
                    Kh(this, "lockingPromise", sl.resolve()), Kh(this, "locks", 0), Kh(this, "name", ""), Kh(this, "lockId", void 0), this.lockId = HE++, e && (this.name = e), em.debug("[lock-".concat(this.name, "-").concat(this.lockId, "] is created."))
                }

                get isLocked() {
                    return this.locks > 0
                }

                lock(e) {
                    let t;
                    this.locks += 1, em.debug("[lock-".concat(this.name, "-").concat(this.lockId, "] is locked, current queue ").concat(this.locks, ". ").concat("string" == typeof e ? e : ""));
                    const r = new sl(r => {
                        t = (() => {
                            this.locks -= 1, em.debug("[lock-".concat(this.name, "-").concat(this.lockId, "] is not locked, current queue ").concat(this.locks, ". ").concat("string" == typeof e ? e : "")), r()
                        })
                    }), n = this.lockingPromise.then(() => t);
                    return this.lockingPromise = this.lockingPromise.then(() => r), n
                }
            }

            function zE(e, t) {
                return function (r, n, i) {
                    const o = i.value;
                    if ("function" != typeof o) throw new Error("Cannot use mutex on object property.");
                    return i.value = async function () {
                        const r = this[t];
                        if (!r) throw new Error("mutex property key ".concat(t, " doesn't exist on ").concat(e));
                        const i = await r.lock("From ".concat(e, ".").concat(n));
                        try {
                            for (var s = arguments.length, a = new Array(s), c = 0; c < s; c++) a[c] = arguments[c];
                            return await o.apply(this, a)
                        } finally {
                            i()
                        }
                    }, i
                }
            }

            class YE extends GE {
                get muted() {
                    return this._muted
                }

                get enabled() {
                    return this._enabled
                }

                constructor(e, t) {
                    super(e, t), Kh(this, "_enabled", !0), Kh(this, "_muted", !1), Kh(this, "_isClosed", !1), Kh(this, "_enabledMutex", void 0), Kh(this, "processor", void 0), Kh(this, "processorContext", void 0), Kh(this, "_handleTrackEnded", () => {
                        this.onTrackEnded()
                    }), this._enabledMutex = new KE("".concat(t)), e.addEventListener("ended", this._handleTrackEnded)
                }

                getTrackLabel() {
                    return this._originMediaStreamTrack.label
                }

                close() {
                    this._isClosed || (this.stop(), this._originMediaStreamTrack.stop(), this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack.stop(), this._mediaStreamTrack = null), this._originMediaStreamTrack = null, this._enabledMutex = null, em.debug("[".concat(this.getTrackId(), "] close")), this.emit(Nv.NEED_CLOSE), super.close())
                }

                async _updateOriginMediaStreamTrack(e, t) {
                    e !== this._originMediaStreamTrack && (this._originMediaStreamTrack.removeEventListener("ended", this._handleTrackEnded), t && this._originMediaStreamTrack.stop(), e.addEventListener("ended", this._handleTrackEnded), this._originMediaStreamTrack = e, this._muted && (this._originMediaStreamTrack.enabled = !1), this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource(), await eb(this, Nv.NEED_REPLACE_TRACK, this), this.processor && this.processor.updateInput({
                        track: this._originMediaStreamTrack,
                        context: this.processorContext
                    }))
                }

                _getDefaultPlayerConfig() {
                    return {}
                }

                onTrackEnded() {
                    em.debug("[".concat(this.getTrackId(), "] track ended")), this.emit(Lv.TRACK_ENDED)
                }

                stateCheck(e, t) {
                    if (em.debug("check track state, [muted: ".concat(this._muted, ", enabled: ").concat(this._enabled, "] to [").concat(e, ": ").concat(t, "]")), __(t, e), this._enabled && this._muted && "enabled" === e && !1 === t) throw new Hf(qf.TRACK_STATE_UNREACHABLE, "cannot set enabled while the track is muted").print();
                    if (!this._enabled && !this._muted && "muted" === e && !0 === t) throw new Hf(qf.TRACK_STATE_UNREACHABLE, "cannot set muted while the track is disabled").print()
                }

                getProcessorStats() {
                    return this.processorContext.gatherStats()
                }

                getProcessorUsage() {
                    return this.processorContext.gatherUsage()
                }
            }

            function JE(e, t) {
                var r = Object.keys(e);
                if (Object.getOwnPropertySymbols) {
                    var n = Object.getOwnPropertySymbols(e);
                    t && (n = n.filter(function (t) {
                        return Object.getOwnPropertyDescriptor(e, t).enumerable
                    })), r.push.apply(r, n)
                }
                return r
            }

            !function (e) {
                e.IOS_15_INTERRUPTION_START = "ios15-interruption-start", e.IOS_15_INTERRUPTION_END = "ios15-interruption-end", e.IOS_INTERRUPTION_START = "ios-interruption-start", e.IOS_INTERRUPTION_END = "ios-interruption-end", e.STATE_CHANGE = "state-change"
            }(qE || (qE = {}));
            const XE = window.AudioContext || window.webkitAudioContext;
            let QE = null;
            const $E = new class extends Wf {
                constructor() {
                    super(...arguments), Kh(this, "prevState", void 0), Kh(this, "curState", void 0), Kh(this, "currentTime", void 0), Kh(this, "currentTimeStuckAt", void 0), Kh(this, "interruptDetectorTrack", void 0), Kh(this, "onLocalAudioTrackMute", () => {
                        em.info("ios15-interruption-start"), this.emit(qE.IOS_15_INTERRUPTION_START)
                    }), Kh(this, "onLocalAudioTrackUnmute", async () => {
                        em.info("ios15-interruption-end"), "running" !== this.curState || this.duringInterruption ? em.info("ios15-interruption-end-canceled") : (QE && await QE.suspend(), this.emit(qE.IOS_15_INTERRUPTION_END))
                    })
                }

                get duringInterruption() {
                    return "running" === this.prevState && "interrupted" === this.curState
                }

                bindInterruptDetectorTrack(e) {
                    em.debug("webaudio bindInterruptDetectorTrack ".concat(e.getTrackId())), this.interruptDetectorTrack || (this.interruptDetectorTrack = e, this.interruptDetectorTrack._mediaStreamTrack.onmute = this.onLocalAudioTrackMute, this.interruptDetectorTrack._mediaStreamTrack.onunmute = this.onLocalAudioTrackUnmute)
                }

                unbindInterruptDetectorTrack(e) {
                    em.debug("webaudio unbindInterruptDetectorTrack ".concat(e.getTrackId())), this.interruptDetectorTrack && this.interruptDetectorTrack === e && (this.interruptDetectorTrack._mediaStreamTrack && (this.interruptDetectorTrack._mediaStreamTrack.onmute = null, this.interruptDetectorTrack._mediaStreamTrack.onunmute = null), this.interruptDetectorTrack = void 0)
                }
            };

            function ZE() {
                if (!QE) {
                    if (function () {
                        if (!XE) return void em.error("your browser is not support web audio");
                        em.info("create audio context");
                        const e = function (e) {
                            for (var t = 1; t < arguments.length; t++) {
                                var r = null != arguments[t] ? arguments[t] : {};
                                t % 2 ? JE(Object(r), !0).forEach(function (t) {
                                    Kh(e, t, r[t])
                                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : JE(Object(r)).forEach(function (t) {
                                    Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t))
                                })
                            }
                            return e
                        }({}, fm("WEBAUDIO_INIT_OPTIONS"));
                        em.debug("audio context init option:", JSON.stringify(e)), QE = new XE(e), $E.curState = QE.state, QE.onstatechange = (() => {
                            $E.prevState = $E.curState, $E.curState = QE ? QE.state : void 0, (Ch() || kh()) && "running" === $E.prevState && "interrupted" === $E.curState && (em.info("ios-interruption-start"), $E.emit(qE.IOS_INTERRUPTION_START)), (Ch() || kh()) && "interrupted" === $E.prevState && "running" === $E.curState && (em.info("ios-interruption-end"), $E.emit(qE.IOS_INTERRUPTION_END)), $E.prevState !== $E.curState && (em.debug("AudioContext State Change", "".concat($E.prevState, "=>").concat($E.curState)), $E.emit(qE.STATE_CHANGE))
                        }), setInterval(() => {
                            var e;
                            const t = null === (e = QE) || void 0 === e ? void 0 : e.currentTime;
                            $E.currentTime !== t ? ($E.currentTimeStuckAt && (em.debug("AudioContext current time resume at ".concat(t)), $E.currentTimeStuckAt = void 0), $E.currentTime = t) : (t !== $E.currentTimeStuckAt && (WE.reportApiInvoke(null, {
                                name: "WEB_AUDIO_CURRENT_TIME_STUCK",
                                options: {currentTime: t},
                                tag: U_.TRACER
                            }).onSuccess(), em.warning("AudioContext current time stuck at ".concat(t))), $E.currentTimeStuckAt = t)
                        }, 5e3), async function (e) {
                            const t = ["click", "contextmenu", "auxclick", "dblclick", "mousedown", "mouseup", "touchend", "keydown", "keyup"];
                            let r, n = !1, i = !1, o = !1;

                            function s(t) {
                                "running" === e.state ? a(!1) : Ch() || kh() ? "suspended" === e.state && (a(!0), t && e.resume().then(c, c)) : "closed" !== e.state && (a(!0), t && e.resume().then(c, c))
                            }

                            function a(e) {
                                if (n !== e) {
                                    n = e;
                                    for (let r = 0, n = t; r < n.length; r += 1) {
                                        const t = n[r];
                                        e ? window.addEventListener(t, u, {
                                            capture: !0,
                                            passive: !0
                                        }) : window.removeEventListener(t, u, {capture: !0, passive: !0})
                                    }
                                }
                            }

                            function c() {
                                s(!1)
                            }

                            function u() {
                                s(!0)
                            }

                            function d(e) {
                                if (!o) if (r.paused) if (e) {
                                    l(!1), o = !0;
                                    let t = void 0;
                                    try {
                                        (t = r.play()) ? t.then(h, h) : (r.addEventListener("playing", h), r.addEventListener("abort", h), r.addEventListener("error", h))
                                    } catch (e) {
                                        h()
                                    }
                                } else l(!0); else l(!1)
                            }

                            function l(e) {
                                if (i !== e) {
                                    i = e;
                                    for (let r = 0, n = t; r < n.length; r++) {
                                        const t = n[r];
                                        e ? window.addEventListener(t, p, {
                                            capture: !0,
                                            passive: !0
                                        }) : window.removeEventListener(t, p, {capture: !0, passive: !0})
                                    }
                                }
                            }

                            function h() {
                                r.removeEventListener("playing", h), r.removeEventListener("abort", h), r.removeEventListener("error", h), o = !1, d(!1)
                            }

                            function p() {
                                d(!0)
                            }

                            if (Ch()) {
                                const t = e.createMediaStreamDestination(), n = document.createElement("div");
                                n.innerHTML = "<audio x-webkit-airplay='deny'></audio>", (r = n.children.item(0)).controls = !1, r.disableRemotePlayback = !0, r.preload = "auto", r.srcObject = t.stream, d(!0)
                            }
                            $E.on(qE.STATE_CHANGE, function () {
                                s(!0)
                            }), s(!1)
                        }(QE)
                    }(), !QE) throw new Hf(qf.NOT_SUPPORTED, "can not create audio context");
                    return QE
                }
                return QE
            }

            function ey(e) {
                if (function () {
                    if (null !== ty) return ty;
                    const e = ZE(), t = e.createBufferSource(), r = e.createGain(), n = e.createGain();
                    t.connect(r), t.connect(n), t.disconnect(r);
                    let i = !1;
                    try {
                        t.disconnect(r)
                    } catch (e) {
                        i = !0
                    }
                    return t.disconnect(), ty = i, i
                }()) return;
                const t = e.connect, r = e.disconnect;
                e.connect = ((r, n, i) => (e._inputNodes || (e._inputNodes = []), e._inputNodes.includes(r) || (r instanceof AudioNode ? (e._inputNodes.push(r), t.call(e, r, n, i)) : t.call(e, r, n)), e)), e.disconnect = ((n, i, o) => {
                    r.call(e), n ? nb(e._inputNodes, n) : e._inputNodes = [];
                    for (const r of e._inputNodes) t.call(e, r)
                })
            }

            let ty = null;

            function ry(e, t) {
                let r = !1;
                const n = 1 / t;
                if (fm("DISABLE_WEBAUDIO")) {
                    const t = window.setInterval(() => {
                        r ? window.clearInterval(t) : e(performance.now() / 1e3)
                    }, 1e3 * n)
                } else {
                    const t = ZE();
                    let i = t.createGain();
                    i.gain.value = 0, i.connect(t.destination);
                    const o = () => {
                        if (r) return void (i = null);
                        const s = t.createOscillator();
                        s.onended = o, s.connect(i), s.start(0), s.stop(t.currentTime + n), e(t.currentTime)
                    };
                    o()
                }
                return () => {
                    r = !0
                }
            }

            const ny = em.prefix("[inject-node]");

            class iy {
                constructor() {
                    Kh(this, "nodeLists", []), Kh(this, "prevNode", void 0), Kh(this, "nextNode", void 0)
                }

                get firstNode() {
                    return this.nodeLists[0]
                }

                get lastNode() {
                    return this.nodeLists[this.nodeLists.length - 1]
                }

                get isActive() {
                    return !!this.nodeLists.length
                }

                get isConnected() {
                    return !(!this.prevNode || !this.nextNode)
                }

                connect(e, t) {
                    ny.debug("connect audio node, current list:" + this.nodeLists.length), this.nodeLists.length ? (this.prevNode && this.prevNode.disconnect(), e.connect(this.firstNode), this.nextNode && this.lastNode && this.lastNode.disconnect(), this.lastNode.connect(t), this.nodeLists.forEach((e, t) => {
                        const r = this.nodeLists[t + 1];
                        r && e.connect(r)
                    })) : e.connect(t), this.nextNode = t, this.prevNode = e
                }

                disconnect() {
                    var e;
                    ny.debug("disconnect audio node, current list:" + this.nodeLists.length), this.nodeLists.forEach(e => {
                        e.disconnect()
                    }), null === (e = this.prevNode) || void 0 === e || e.disconnect(), this.prevNode = void 0, this.nextNode = void 0
                }

                addNode(e) {
                    ny.debug("add node in inject node, current list:", this.nodeLists.length), this.prevNode && this.nextNode ? (this.firstNode || (ny.debug("new node is the first node"), this.prevNode.disconnect(), this.prevNode.connect(e), e.connect(this.nextNode)), this.nextNode && this.lastNode && (this.lastNode.disconnect(this.nextNode), this.lastNode.connect(e), e.connect(this.nextNode)), this.nodeLists.push(e)) : ny.debug("add node is called before inject node connected")
                }

                removeNode(e) {
                    ny.debug("remove node in inject node, current list:", this.nodeLists.length);
                    const t = this.nodeLists.indexOf(e);
                    if (-1 === t) return void ny.debug("$[inject-node] cannot find the node to be removed");
                    const r = this.nodeLists[t + 1], n = this.nodeLists[t - 1];
                    0 === t && this.prevNode && this.nextNode && (this.prevNode.disconnect(e), r ? this.prevNode.connect(r) : this.prevNode.connect(this.nextNode)), t === this.nodeLists.length - 1 && this.nextNode && n && (n.disconnect(e), n.connect(this.nextNode)), 0 !== t && t !== this.nodeLists.length - 1 && (n.disconnect(e), n.connect(r)), ny.debug("remove node in inject node success, current list:", this.nodeLists.length)
                }
            }

            class oy {
                constructor() {
                    Kh(this, "context", void 0), Kh(this, "analyserNode", void 0), Kh(this, "sourceNode", void 0), this.context = ZE(), this.analyserNode = this.context.createAnalyser(), this.analyserNode.fftSize = 2048, this.analyserNode.smoothingTimeConstant = .4
                }

                updateSource(e) {
                    if (e !== this.sourceNode) {
                        if (this.sourceNode) try {
                            this.sourceNode.disconnect(this.analyserNode)
                        } catch (e) {
                        }
                        this.sourceNode = e, null == e || e.connect(this.analyserNode)
                    }
                }

                getVolumeLevel() {
                    if (!this.sourceNode) return 0;
                    if (!this.context || Ch() || kh() || "running" !== this.context.state && this.context.resume(), !this.analyserNode) return 0;
                    const e = new Float32Array(this.analyserNode.fftSize);
                    if (this.analyserNode.getFloatTimeDomainData) this.analyserNode.getFloatTimeDomainData(e); else {
                        const t = new Uint8Array(this.analyserNode.fftSize);
                        this.analyserNode.getByteTimeDomainData(t);
                        for (let r = 0; r < e.length; ++r) e[r] = t[r] / 128 - 1
                    }
                    const t = Kr(e).call(e, (e, t) => e + t * t, 0) / e.length;
                    return Math.max(10 * Math.log10(t) + 100, 0) / 100
                }

                getAnalyserNode() {
                    return this.analyserNode
                }

                rebuildAnalyser() {
                    try {
                        var e, t;
                        null === (e = this.sourceNode) || void 0 === e || e.disconnect(this.analyserNode), this.analyserNode = this.context.createAnalyser(), this.analyserNode.fftSize = 2048, this.analyserNode.smoothingTimeConstant = .4, null === (t = this.sourceNode) || void 0 === t || t.connect(this.analyserNode)
                    } catch (e) {
                        em.warning("rebuild analyser node failed.")
                    }
                }

                destroy() {
                    this.updateSource(void 0)
                }
            }

            class sy extends Wf {
                get processSourceNode() {
                    return this.sourceNode
                }

                set processedNode(e) {
                    var t;
                    if (!this.isDestroyed && this._processedNode !== e) {
                        try {
                            var r;
                            null === (r = this.sourceNode) || void 0 === r || r.disconnect(this.outputNode)
                        } catch (e) {
                        }
                        null === (t = this._processedNode) || void 0 === t || t.disconnect(), this._processedNode = e, this.connect()
                    }
                }

                get processedNode() {
                    return this._processedNode
                }

                constructor() {
                    super(), Kh(this, "outputNode", void 0), Kh(this, "outputTrack", void 0), Kh(this, "isPlayed", !1), Kh(this, "sourceNode", void 0), Kh(this, "context", void 0), Kh(this, "audioBufferNode", void 0), Kh(this, "destNode", void 0), Kh(this, "injectNode", void 0), Kh(this, "audioOutputLevel", 0), Kh(this, "volumeLevelAnalyser", void 0), Kh(this, "_processedNode", void 0), Kh(this, "playNode", void 0), Kh(this, "isDestroyed", !1), Kh(this, "onNoAudioInput", void 0), Kh(this, "isNoAudioInput", !1), Kh(this, "_noAudioInputCount", 0), this.context = ZE(), this.playNode = this.context.destination, this.outputNode = this.context.createGain(), ey(this.outputNode), this.injectNode = new iy, this.volumeLevelAnalyser = new oy
                }

                startGetAudioBuffer(e) {
                    this.audioBufferNode || (this.audioBufferNode = this.context.createScriptProcessor(e), this.outputNode.connect(this.audioBufferNode), this.audioBufferNode.connect(this.context.destination), this.audioBufferNode.onaudioprocess = (e => {
                        this.emit(tv.ON_AUDIO_BUFFER, function (e) {
                            for (let t = 0; t < e.outputBuffer.numberOfChannels; t += 1) {
                                const r = e.outputBuffer.getChannelData(t);
                                for (let e = 0; e < r.length; e += 1) r[e] = 0
                            }
                            return e.inputBuffer
                        }(e))
                    }))
                }

                stopGetAudioBuffer() {
                    this.audioBufferNode && (this.audioBufferNode.onaudioprocess = null, this.outputNode.disconnect(this.audioBufferNode), this.audioBufferNode = void 0)
                }

                createOutputTrack() {
                    if (!og().webAudioMediaStreamDest) throw new Hf(qf.NOT_SUPPORTED, "your browser is not support audio processor");
                    return this.destNode && this.outputTrack || (this.destNode = this.context.createMediaStreamDestination(), this.outputNode.connect(this.destNode), this.outputTrack = this.destNode.stream.getAudioTracks()[0]), this.outputTrack
                }

                play(e) {
                    "running" !== this.context.state && ob(() => {
                        $E.emit("autoplay-failed")
                    }), this.isPlayed = !0, this.playNode = e || this.context.destination, this.outputNode.connect(this.playNode)
                }

                stop() {
                    if (this.isPlayed) try {
                        this.outputNode.disconnect(this.playNode)
                    } catch (e) {
                    }
                    this.isPlayed = !1
                }

                getAccurateVolumeLevel() {
                    return this.volumeLevelAnalyser.getVolumeLevel()
                }

                async checkHasAudioInput() {
                    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
                    if (e > 5) return this.isNoAudioInput = !0, this.onNoAudioInput && this.onNoAudioInput(), !1;
                    Ch() || kh() ? "suspended" === this.context.state && this.context.resume() : "running" !== this.context.state && this.context.resume();
                    const t = this.volumeLevelAnalyser.getAnalyserNode();
                    let r;
                    t.getFloatTimeDomainData ? (r = new Float32Array(t.fftSize), t.getFloatTimeDomainData(r)) : (r = new Uint8Array(t.fftSize), t.getByteTimeDomainData(r));
                    let n = !1;
                    for (let e = 0; e < r.length; e++) 0 !== r[e] && (n = !0);
                    return n ? (this.isNoAudioInput = !1, !0) : (await zS(200), await this.checkHasAudioInput(e ? e + 1 : 1) && n)
                }

                getAudioVolume() {
                    return this.outputNode.gain.value
                }

                setVolume(e) {
                    this.outputNode.gain.setValueAtTime(e, this.context.currentTime)
                }

                destroy() {
                    this.disconnect(), this.stop(), this.isDestroyed = !0, this.onNoAudioInput = void 0
                }

                injectAudioNode(e) {
                    this.injectNode.addNode(e)
                }

                removeAudioNode(e) {
                    this.injectNode.removeNode(e)
                }

                disconnect() {
                    var e, t;
                    null === (e = this.processedNode) || void 0 === e || e.disconnect(), null === (t = this.sourceNode) || void 0 === t || t.disconnect(), this.outputNode && this.outputNode.disconnect()
                }

                connect() {
                    var e;
                    this.processedNode ? null === (e = this.processedNode) || void 0 === e || e.connect(this.outputNode) : this.sourceNode && this.sourceNode.connect(this.outputNode), this.volumeLevelAnalyser.updateSource(this.outputNode)
                }
            }

            class ay extends sy {
                get isFreeze() {
                    return !1
                }

                constructor(e, t, r) {
                    var n;
                    if (super(), Kh(this, "sourceNode", void 0), Kh(this, "track", void 0), Kh(this, "clonedTrack", void 0), Kh(this, "audioElement", void 0), Kh(this, "isCurrentTrackCloned", !1), Kh(this, "isRemoteTrack", !1), Kh(this, "originVolumeLevelAnalyser", void 0), Kh(this, "rebuildWebAudio", async () => {
                        if (em.debug("ready to rebuild web audio, state:", this.context.state), this.isNoAudioInput && await this.checkHasAudioInput(), !this.isNoAudioInput || this.isDestroyed) return document.body.removeEventListener("click", this.rebuildWebAudio, !0), void em.debug("rebuild web audio success, current volume status", this.getAccurateVolumeLevel());
                        this.context.resume().then(() => em.info("resume success")), em.debug("rebuild web audio because of ios 12 bugs"), this.disconnect();
                        const e = this.track;
                        this.track = this.track.clone(), this.isCurrentTrackCloned ? e.stop() : this.isCurrentTrackCloned = !0;
                        const t = new MediaStream([this.track]);
                        this.sourceNode = this.context.createMediaStreamSource(t), ey(this.sourceNode), this.volumeLevelAnalyser.rebuildAnalyser();
                        const r = this.outputNode.gain.value;
                        this.outputNode = this.context.createGain(), this.outputNode.gain.setValueAtTime(r, this.context.currentTime), ey(this.outputNode), this.emit(tv.UPDATE_SOURCE), this.connect(), this.audioElement.srcObject = t, this.isPlayed && this.play(this.playNode), this.checkHasAudioInput()
                    }), "audio" !== e.kind) throw new Hf(qf.UNEXPECTED_ERROR);
                    this.track = e;
                    const i = new MediaStream([this.track]);
                    if (this.isRemoteTrack = !!t, this.sourceNode = this.context.createMediaStreamSource(i), ey(this.sourceNode), r) {
                        const e = r.clone();
                        e.enabled = !0, this.clonedTrack = e, em.debug("create an unmuted track ".concat(e.id, " from the original track ").concat(r.id, " to get the volume"));
                        const t = this.context.createMediaStreamSource(new MediaStream([e]));
                        ey(t), this.originVolumeLevelAnalyser = new oy, this.originVolumeLevelAnalyser.updateSource(t)
                    }
                    this.connect(), this.audioElement = document.createElement("audio"), this.audioElement.srcObject = i;
                    const o = Sh();
                    t && o.os === _h.IOS && Number(null === (n = o.osVersion) || void 0 === n ? void 0 : n.split(".")[0]) < 15 && ($E.on(qE.STATE_CHANGE, () => {
                        "suspended" === this.context.state ? document.body.addEventListener("click", this.rebuildWebAudio, !0) : "running" === this.context.state && this.rebuildWebAudio()
                    }), this.checkHasAudioInput().then(e => {
                        e || document.body.addEventListener("click", this.rebuildWebAudio, !0)
                    }))
                }

                updateTrack(e) {
                    this.sourceNode.disconnect(), this.track = e, this.isCurrentTrackCloned = !1;
                    const t = new MediaStream([e]);
                    this.sourceNode = this.context.createMediaStreamSource(t), ey(this.sourceNode), this.processedNode || this.sourceNode.connect(this.outputNode), this.emit(tv.UPDATE_SOURCE), this.audioElement.srcObject = t
                }

                destroy() {
                    var e;
                    this.audioElement.srcObject = null, this.audioElement.remove(), $E.off("state-change", this.rebuildWebAudio), null === (e = this.originVolumeLevelAnalyser) || void 0 === e || e.destroy(), this.clonedTrack = void 0, super.destroy()
                }

                createMediaStreamSourceNode(e) {
                    return this.context.createMediaStreamSource(new MediaStream([e]))
                }

                updateOriginTrack(e) {
                    const t = e.clone();
                    t.enabled = !0, this.clonedTrack && (this.clonedTrack.stop(), this.clonedTrack = t), em.debug("create an unmuted track ".concat(t.id, " from the original track ").concat(e.id, " to get the volume"));
                    const r = this.context.createMediaStreamSource(new MediaStream([t]));
                    ey(r), this.originVolumeLevelAnalyser && this.originVolumeLevelAnalyser.updateSource(r)
                }

                getOriginVolumeLevel() {
                    return this.originVolumeLevelAnalyser ? this.originVolumeLevelAnalyser.getVolumeLevel() : this.getAccurateVolumeLevel()
                }
            }

            async function cy(e, t) {
                const r = (e, t) => e ? "number" != typeof e ? e.max || e.exact || e.ideal || e.min || t : e : t, n = {
                    audio: !1,
                    video: {
                        mandatory: {
                            chromeMediaSource: "desktop",
                            chromeMediaSourceId: e,
                            maxHeight: r(t.height, 1080),
                            maxWidth: r(t.width, 1920)
                        }
                    }
                };
                return t.frameRate && "number" != typeof t.frameRate ? (n.video.mandatory.maxFrameRate = t.frameRate.max, n.video.mandatory.minFrameRate = t.frameRate.min) : "number" == typeof t.frameRate && (n.video.mandatory.maxFrameRate = t.frameRate), await navigator.mediaDevices.getUserMedia(n)
            }

            async function uy(e) {
                let t = ["window", "screen"];
                "application" !== e && "window" !== e || (t = ["window"]), "screen" === e && (t = ["screen"]);
                const r = ly();
                if (!r) throw new Hf(qf.ELECTRON_IS_NULL);
                let n = null;
                try {
                    var i;
                    n = (null === (i = r.desktopCapturer) || void 0 === i ? void 0 : i.getSources({types: t})) || r.ipcRenderer.invoke("DESKTOP_CAPTURER_GET_SOURCES", {types: t})
                } catch (e) {
                    n = null
                }
                n && n.then || (n = new sl((e, n) => {
                    r.desktopCapturer.getSources({types: t}, (t, r) => {
                        t ? n(t) : e(r)
                    })
                }));
                try {
                    return await n
                } catch (e) {
                    throw new Hf(qf.ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR, e.toString())
                }
            }

            let dy = null;

            function ly() {
                if (dy) return dy;
                try {
                    return dy = window.require("electron")
                } catch (e) {
                    return null
                }
            }

            const hy = new KE("safari");
            let py = !1, fy = !1;

            async function my(e, t) {
                let r = 0, n = null;
                for (; r < 2;) try {
                    n = await _y(e, t, r > 0);
                    break
                } catch (e) {
                    if (e instanceof Hf) throw em.error("[".concat(t, "] ").concat(e.toString())), e;
                    const n = vy(e.name || e.code || e, e.message);
                    if (n.code === qf.MEDIA_OPTION_INVALID) {
                        em.debug("[".concat(t, "] detect media option invalid, retry")), r += 1, await zS(500);
                        continue
                    }
                    throw em.error("[".concat(t, "] ").concat(n.toString())), n
                }
                if (!n) throw new Hf(qf.UNEXPECTED_ERROR, "can not find stream after getUserMedia");
                return n
            }

            async function _y(e, t, r) {
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) throw new Hf(qf.NOT_SUPPORTED, "can not find getUserMedia");
                r && (e.video && (delete e.video.width, delete e.video.height), e.screen && (delete e.screen.width, delete e.screen.height));
                const n = og(), i = new MediaStream;
                if (e.audioSource && i.addTrack(e.audioSource), e.videoSource && i.addTrack(e.videoSource), !e.audio && !e.video && !e.screen) return em.debug("Using Video Source/ Audio Source"), i;
                if (e.screen) if (ly()) e.screen.sourceId ? gy(i, await cy(e.screen.sourceId, e.screen)) : gy(i, await async function (e) {
                    const t = await uy(e.mediaSource), r = await function (e) {
                        return new sl((t, r) => {
                            const n = document.createElement("div");
                            n.innerText = "share screen", n.setAttribute("style", "text-align: center; height: 25px; line-height: 25px; border-radius: 4px 4px 0 0; background: #D4D2D4; border-bottom:  solid 1px #B9B8B9;");
                            const i = document.createElement("div");
                            i.setAttribute("style", "width: 100%; height: 500px; padding: 15px 25px ; box-sizing: border-box;");
                            const o = document.createElement("div");
                            o.innerText = "Agora Web Screensharing wants to share the contents of your screen with webdemo.agorabeckon.com. Choose what you'd like to share.", o.setAttribute("style", "height: 12%;");
                            const s = document.createElement("div");
                            s.setAttribute("style", "width: 100%; height: 80%; background: #FFF; border:  solid 1px #CBCBCB; display: flex; flex-wrap: wrap; justify-content: space-around; overflow-y: scroll; padding: 0 15px; box-sizing: border-box;");
                            const a = document.createElement("div");
                            a.setAttribute("style", "text-align: right; padding: 16px 0;");
                            const c = document.createElement("button");
                            c.innerHTML = "cancel", c.setAttribute("style", "width: 85px;"), c.onclick = (() => {
                                document.body.removeChild(u);
                                const e = new Error("NotAllowedError");
                                e.name = "NotAllowedError", r(e)
                            }), a.appendChild(c), i.appendChild(o), i.appendChild(s), i.appendChild(a);
                            const u = document.createElement("div");
                            u.setAttribute("style", "position: fixed; z-index: 99999999; top: 50%; left: 50%; width: 620px; height: 525px; background: #ECECEC; border-radius: 4px; -webkit-transform: translate(-50%,-50%); transform: translate(-50%,-50%);"), u.appendChild(n), u.appendChild(i), document.body.appendChild(u), e.map(e => {
                                if (e.id) {
                                    const r = document.createElement("div");
                                    r.setAttribute("style", "width: 30%; height: 160px; padding: 20px 0; text-align: center;box-sizing: content-box;");
                                    let n = e.thumbnail;
                                    const {width: i} = n.getSize();
                                    i > 1920 && (n = n.resize({width: 1920})), r.innerHTML = '<div style="height: 120px; display: table-cell; vertical-align: middle;"><img style="width: 100%; background: #333333; box-shadow: 1px 1px 1px 1px rgba(0, 0, 0, 0.2);" src=' + n.toDataURL() + ' /></div><span style="\theight: 40px; line-height: 40px; display: inline-block; width: 70%; word-break: keep-all; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">' + e.name.replace(/[\u00A0-\u9999<>\&]/g, function (e) {
                                        return "&#" + e.charCodeAt(0) + ";"
                                    }) + "</span>", r.onclick = (() => {
                                        document.body.removeChild(u), t(e.id)
                                    }), s.appendChild(r)
                                }
                            })
                        })
                    }(t);
                    return await cy(r, e)
                }(e.screen)); else if (Rh() && e.screen.extensionId && e.screen.mandatory) {
                    if (!n.getStreamFromExtension) throw new Hf(qf.NOT_SUPPORTED, "This browser does not support screen sharing");
                    em.debug("[".concat(t, '] Screen access on chrome stable, looking for extension"'));
                    const r = await (o = e.screen.extensionId, s = t, new sl((e, t) => {
                        try {
                            chrome.runtime.sendMessage(o, {getStream: !0}, r => {
                                if (!r || !r.streamId) return em.error("[".concat(s, "] No response from Chrome Plugin. Plugin not installed properly"), r), void t(new Hf(qf.CHROME_PLUGIN_NO_RESPONSE, "No response from Chrome Plugin. Plugin not installed properly"));
                                e(r.streamId)
                            })
                        } catch (e) {
                            em.error("[".concat(s, "] AgoraRTC screensharing plugin is not accessible(").concat(o, ")"), e.toString()), t(new Hf(qf.CHROME_PLUGIN_NOT_INSTALL))
                        }
                    }));
                    e.screen.mandatory.chromeMediaSourceId = r, gy(i, await navigator.mediaDevices.getUserMedia({video: {mandatory: e.screen.mandatory}}))
                } else if (n.getDisplayMedia) {
                    e.screen.mediaSource && jv(e.screen.mediaSource);
                    const r = {
                        width: e.screen.width,
                        height: e.screen.height,
                        frameRate: e.screen.frameRate,
                        displaySurface: "screen" === e.screen.mediaSource ? "monitor" : e.screen.mediaSource
                    };
                    em.debug("[".concat(t, "] getDisplayMedia:"), JSON.stringify({
                        video: r,
                        audio: !!e.screenAudio
                    })), gy(i, await navigator.mediaDevices.getDisplayMedia({video: r, audio: !!e.screenAudio}))
                } else {
                    if (!wh()) throw em.error("[".concat(t, "] This browser does not support screenSharing")), new Hf(qf.NOT_SUPPORTED, "This browser does not support screen sharing");
                    {
                        e.screen.mediaSource && jv(e.screen.mediaSource);
                        const r = {
                            video: {
                                mediaSource: e.screen.mediaSource,
                                width: e.screen.width,
                                height: e.screen.height,
                                frameRate: e.screen.frameRate
                            }
                        };
                        em.debug("[".concat(t, "] getUserMedia: ").concat(JSON.stringify(r))), gy(i, await navigator.mediaDevices.getUserMedia(r))
                    }
                }
                var o, s;
                if (!e.video && !e.audio) return i;
                let a = {video: e.video, audio: e.audio}, c = fm("MEDIA_DEVICE_CONSTRAINTS");
                if (c) try {
                    "string" == typeof c && (c = JSON.parse(c)), a = function e(t, r) {
                        if (!fb(t) || !fb(r)) return r;
                        if (Array.isArray(t) && !Array.isArray(r) || !Array.isArray(t) && Array.isArray(r)) return r;
                        if (Array.isArray(r) && Array.isArray(t)) {
                            const n = [...t];
                            for (let i = 0; i < r.length; i++) n[i] = e(t[i], r[i]);
                            return n
                        }
                        {
                            const n = HS({}, t);
                            for (const i in r) Object.prototype.hasOwnProperty.call(r, i) && (Object.prototype.hasOwnProperty.call(t, i) ? n[i] = e(t[i], r[i]) : n[i] = r[i]);
                            return n
                        }
                    }(a, c)
                } catch (e) {
                }
                em.debug("[".concat(t, "] GetUserMedia"), JSON.stringify(a)), Sh();
                let u, d = null;
                (Ih() || Ch() || Th()) && (d = await hy.lock());
                try {
                    u = await navigator.mediaDevices.getUserMedia(a)
                } catch (e) {
                    throw d && d(), e
                }
                return a.audio && (py = !0), a.video && (fy = !0), gy(i, u), d && d(), i
            }

            function vy(e, t) {
                switch (e) {
                    case"Starting video failed":
                    case"OverconstrainedError":
                    case"TrackStartError":
                        return new Hf(qf.MEDIA_OPTION_INVALID, "".concat(e, ": ").concat(t));
                    case"NotFoundError":
                    case"DevicesNotFoundError":
                        return new Hf(qf.DEVICE_NOT_FOUND, "".concat(e, ": ").concat(t));
                    case"NotSupportedError":
                        return new Hf(qf.NOT_SUPPORTED, "".concat(e, ": ").concat(t));
                    case"NotReadableError":
                        return new Hf(qf.NOT_READABLE, "".concat(e, ": ").concat(t));
                    case"InvalidStateError":
                    case"NotAllowedError":
                    case"PERMISSION_DENIED":
                    case"PermissionDeniedError":
                        return new Hf(qf.PERMISSION_DENIED, "".concat(e, ": ").concat(t));
                    case"ConstraintNotSatisfiedError":
                        return new Hf(qf.CONSTRAINT_NOT_SATISFIED, "".concat(e, ": ").concat(t));
                    default:
                        return em.error("getUserMedia unexpected error", e), new Hf(qf.UNEXPECTED_ERROR, "".concat(e, ": ").concat(t))
                }
            }

            function gy(e, t) {
                const r = e.getVideoTracks()[0], n = e.getAudioTracks()[0], i = t.getVideoTracks()[0],
                    o = t.getAudioTracks()[0];
                o && (n && e.removeTrack(n), e.addTrack(o)), i && (r && e.removeTrack(r), e.addTrack(i))
            }

            const Ey = new class extends Wf {
                    get state() {
                        return this._state
                    }

                    set state(e) {
                        e !== this._state && (this.emit(V_.STATE_CHANGE, e), this._state = e)
                    }

                    constructor() {
                        super(), Kh(this, "_state", j_.IDLE), Kh(this, "isAccessMicrophonePermission", !1), Kh(this, "isAccessCameraPermission", !1), Kh(this, "lastAccessMicrophonePermission", !1), Kh(this, "lastAccessCameraPermission", !1), Kh(this, "checkdeviceMatched", !1), Kh(this, "deviceInfoMap", new Map), this.init().then(() => {
                            navigator.mediaDevices.addEventListener && navigator.mediaDevices.addEventListener("devicechange", this.updateDevicesInfo.bind(this)), window.setInterval(() => {
                                (fm("ENUMERATE_DEVICES_INTERVAL") || Uh() && Mh()) && this.updateDevicesInfo()
                            }, fm("ENUMERATE_DEVICES_INTERVAL_TIME"))
                        }).catch(e => em.error(e.toString()))
                    }

                    async enumerateDevices(e, t) {
                        let r = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                        if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) return new Hf(qf.NOT_SUPPORTED, "enumerateDevices() not supported.").throw();
                        const n = await navigator.mediaDevices.enumerateDevices(), i = this.checkMediaDeviceInfoIsOk(n);
                        let o = !this.isAccessMicrophonePermission && e, s = !this.isAccessCameraPermission && t;
                        i.audio && (o = !1), i.video && (s = !1);
                        let a = null, c = null, u = null;
                        if (!r && (o || s)) {
                            if (hy.isLocked && (em.debug("[device manager] wait GUM lock"), (await hy.lock())(), em.debug("[device manager] GUM unlock")), py && (o = !1, this.isAccessMicrophonePermission = !0), fy && (s = !1, this.isAccessCameraPermission = !0), em.debug("[device manager] check media device permissions", e, t, o, s), o && s) {
                                try {
                                    u = await navigator.mediaDevices.getUserMedia({audio: !0, video: !0})
                                } catch (e) {
                                    const t = vy(e.name || e.code || e, e.message);
                                    if (t.code === qf.PERMISSION_DENIED) throw t;
                                    em.warning("getUserMedia failed in getDevices", t)
                                }
                                this.isAccessCameraPermission = !0, this.isAccessMicrophonePermission = !0
                            } else if (o) {
                                try {
                                    a = await navigator.mediaDevices.getUserMedia({audio: e})
                                } catch (e) {
                                    const t = vy(e.name || e.code || e, e.message);
                                    if (t.code === qf.PERMISSION_DENIED) throw t;
                                    em.warning("getUserMedia failed in getDevices", t)
                                }
                                this.isAccessMicrophonePermission = !0
                            } else if (s) {
                                try {
                                    c = await navigator.mediaDevices.getUserMedia({video: t})
                                } catch (e) {
                                    const t = vy(e.name || e.code || e, e.message);
                                    if (t.code === qf.PERMISSION_DENIED) throw t;
                                    em.warning("getUserMedia failed in getDevices", t)
                                }
                                this.isAccessCameraPermission = !0
                            }
                            em.debug("[device manager] mic permission", e, "cam permission", t)
                        }
                        try {
                            const t = await navigator.mediaDevices.enumerateDevices();
                            return a && a.getTracks().forEach(e => e.stop()), c && c.getTracks().forEach(e => e.stop()), u && u.getTracks().forEach(e => e.stop()), a = null, c = null, u = null, t
                        } catch (e) {
                            return a && a.getTracks().forEach(e => e.stop()), c && c.getTracks().forEach(e => e.stop()), u && u.getTracks().forEach(e => e.stop()), a = null, c = null, u = null, new Hf(qf.ENUMERATE_DEVICES_FAILED, e.toString()).throw()
                        }
                    }

                    async getRecordingDevices() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                        return (await this.enumerateDevices(!0, !1, e)).filter(e => "audioinput" === e.kind)
                    }

                    async getCamerasDevices() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                        return (await this.enumerateDevices(!1, !0, e)).filter(e => "videoinput" === e.kind)
                    }

                    async getSpeakers() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                        return (await this.enumerateDevices(!0, !1, e)).filter(e => "audiooutput" === e.kind)
                    }

                    searchDeviceIdByName(e) {
                        let t = null;
                        return this.deviceInfoMap.forEach(r => {
                            r.device.label === e && (t = r.device.deviceId)
                        }), t
                    }

                    async getDeviceById(e) {
                        const t = (await this.enumerateDevices(!0, !0, !0)).find(t => t.deviceId === e);
                        if (!t) throw new Hf(qf.DEVICE_NOT_FOUND, "deviceId: ".concat(e));
                        return t
                    }

                    async init() {
                        this.state = j_.INITING;
                        try {
                            await this.updateDevicesInfo(), this.state = j_.INITEND
                        } catch (e) {
                            throw em.warning("Device Detection functionality cannot start properly.", e.toString()), this.state = j_.IDLE, ("boolean" == typeof isSecureContext ? isSecureContext : "https:" === location.protocol || "file:" === location.protocol || "localhost" === location.hostname || "127.0.0.1" === location.hostname || "::1" === location.hostname) || new Hf(qf.WEB_SECURITY_RESTRICT, "Your context is limited by web security, please try using https protocol or localhost.").throw(), e
                        }
                    }

                    async updateDevicesInfo() {
                        const e = await this.enumerateDevices(!0, !0, !0), t = Date.now(), r = [];
                        if (e[0] && e[0].label && !1 === this.checkdeviceMatched) {
                            this.checkdeviceMatched = !0;
                            const t = e.find(e => "audioinput" === e.kind && "default" === e.deviceId),
                                r = e.find(e => "audiooutput" === e.kind && "default" === e.deviceId);
                            t && r ? r.groupId === t.groupId ? em.debug("[device-check] default input ".concat(t.label, " and output ").concat(r.label, " is the same group")) : em.warning("[device-check] default input ".concat(t.label, " and output ").concat(r.label, " is not the same group")) : em.debug("[device-check] default input or output not found")
                        }
                        const n = this.checkMediaDeviceInfoIsOk(e);
                        if (e.forEach(e => {
                            if (!e.deviceId) return;
                            const n = this.deviceInfoMap.get("".concat(e.kind, "_").concat(e.deviceId));
                            if ("ACTIVE" !== (n ? n.state : "INACTIVE")) {
                                const n = {initAt: t, updateAt: t, device: e, state: "ACTIVE"};
                                this.deviceInfoMap.set("".concat(e.kind, "_").concat(e.deviceId), n), r.push(n)
                            }
                            n && (n.updateAt = t)
                        }), this.deviceInfoMap.forEach((e, n) => {
                            "ACTIVE" === e.state && e.updateAt !== t && (e.state = "INACTIVE", r.push(e))
                        }), this.state !== j_.INITEND) return n.audio && (this.lastAccessMicrophonePermission = !0, this.isAccessMicrophonePermission = !0), void (n.video && (this.lastAccessCameraPermission = !0, this.isAccessCameraPermission = !0));
                        r.forEach(e => {
                            switch (e.device.kind) {
                                case"audioinput":
                                    this.lastAccessMicrophonePermission && this.isAccessMicrophonePermission && this.emit(V_.RECORDING_DEVICE_CHANGED, e);
                                    break;
                                case"videoinput":
                                    this.lastAccessCameraPermission && this.isAccessCameraPermission && this.emit(V_.CAMERA_DEVICE_CHANGED, e);
                                    break;
                                case"audiooutput":
                                    this.lastAccessMicrophonePermission && this.isAccessMicrophonePermission && this.emit(V_.PLAYOUT_DEVICE_CHANGED, e)
                            }
                        }), n.audio && (this.lastAccessMicrophonePermission = !0, this.isAccessMicrophonePermission = !0), n.video && (this.lastAccessCameraPermission = !0, this.isAccessCameraPermission = !0)
                    }

                    checkMediaDeviceInfoIsOk(e) {
                        const t = e.filter(e => "audioinput" === e.kind), r = e.filter(e => "videoinput" === e.kind),
                            n = {audio: !1, video: !1};
                        for (const e of t) if (e.label && e.deviceId) {
                            n.audio = !0;
                            break
                        }
                        for (const e of r) if (e.label && e.deviceId) {
                            n.video = !0;
                            break
                        }
                        return n
                    }
                },
                yy = ["play", "playing", "loadeddata", "canplay", "pause", "stalled", "suspend", "waiting", "abort", "emptied", "ended", "error"],
                Sy = new class {
                    constructor() {
                        Kh(this, "onAutoplayFailed", void 0), Kh(this, "elementMap", new Map), Kh(this, "elementStateMap", new Map), Kh(this, "elementsNeedToResume", []), Kh(this, "sinkIdMap", new Map), Kh(this, "autoResumeAfterInterruption", () => {
                            Array.from(this.elementMap.entries()).forEach(e => {
                                let [t, r] = e;
                                const n = this.elementStateMap.get(t), i = r.srcObject.getAudioTracks()[0];
                                Oh() ? i && "live" === i.readyState && "running" === $E.curState && (em.debug("auto resume after interruption for iOS 15"), r.pause(), r.play()) : n && "paused" === n && i && "live" === i.readyState && "running" === $E.curState && (em.debug("auto resume after interruption for iOS"), r.play())
                            })
                        }), Kh(this, "autoResumeAfterInterruptionOnIOS15", () => {
                            Array.from(this.elementMap.entries()).forEach(e => {
                                let [t, r] = e;
                                const n = r.srcObject.getAudioTracks()[0];
                                n && "live" === n.readyState && (em.debug("auto resume after interruption inside autoResumeAfterInterruptionOnIOS15"), r.pause(), r.play())
                            })
                        }), this.autoResumeAudioElement(), $E.on(qE.IOS_INTERRUPTION_END, this.autoResumeAfterInterruption), $E.on(qE.IOS_15_INTERRUPTION_END, this.autoResumeAfterInterruptionOnIOS15), $E.on(qE.STATE_CHANGE, () => {
                            Ch() && "suspended" === $E.prevState && "running" === $E.curState && this.autoResumeAfterInterruption()
                        })
                    }

                    async setSinkID(e, t) {
                        const r = this.elementMap.get(e);
                        if (this.sinkIdMap.set(e, t), r) try {
                            await r.setSinkId(t)
                        } catch (e) {
                            throw new Hf(qf.PERMISSION_DENIED, "can not set sink id: " + e.toString())
                        }
                    }

                    play(e, t, r, n) {
                        if (this.elementMap.has(t)) return;
                        const i = document.createElement("audio");
                        i.autoplay = !0, i.srcObject = new MediaStream([e]), this.bindAudioElementEvents(t, i), this.elementMap.set(t, i), this.elementStateMap.set(t, A_.INIT), this.setVolume(t, r);
                        const o = this.sinkIdMap.get(t);
                        if (o) try {
                            i.setSinkId(o).catch(e => {
                                em.warning("[".concat(t, "] set sink id failed"), e.toString())
                            })
                        } catch (e) {
                            em.warning("[".concat(t, "] set sink id failed"), e.toString())
                        }
                        const s = i.play();
                        s && s.then && s.catch(e => {
                            n && WE.autoplayFailed(n, "audio", e.message, t), em.warning("audio element play warning", e.toString()), this.elementMap.has(t) && "NotAllowedError" === e.name && (em.warning("detected audio element autoplay failed"), this.elementsNeedToResume.push(i), ob(() => {
                                this.onAutoplayFailed && this.onAutoplayFailed(), xE()
                            }))
                        })
                    }

                    updateTrack(e, t) {
                        const r = this.elementMap.get(e);
                        r && (r.srcObject = new MediaStream([t]))
                    }

                    isPlaying(e) {
                        return this.elementMap.has(e)
                    }

                    setVolume(e, t) {
                        const r = this.elementMap.get(e);
                        r && (t = Math.max(0, Math.min(100, t)), r.volume = t / 100)
                    }

                    stop(e) {
                        const t = this.elementMap.get(e);
                        if (this.sinkIdMap.delete(e), !t) return;
                        const r = this.elementsNeedToResume.indexOf(t);
                        this.elementsNeedToResume.splice(r, 1), t.srcObject = null, t.remove(), this.elementMap.delete(e), this.elementStateMap.delete(e)
                    }

                    bindAudioElementEvents(e, t) {
                        yy.forEach(r => {
                            t.addEventListener(r, r => {
                                const n = this.elementStateMap.get(e), i = "pause" === r.type ? "paused" : r.type;
                                if (em.debug("[".concat(e, "] audio-element-status change ").concat(n, " => ").concat(i)), "error" === r.type) {
                                    const r = null == t ? void 0 : t.error;
                                    r && em.error("[".concat(e, "] media error, code: ").concat(r.code, ", message: ").concat(r.message))
                                }
                                this.elementStateMap.set(e, i)
                            })
                        })
                    }

                    getPlayerState(e) {
                        return this.elementStateMap.get(e) || "uninit"
                    }

                    autoResumeAudioElement() {
                        const e = () => {
                            this.elementsNeedToResume.forEach(e => {
                                e.play().then(e => {
                                    em.debug("Auto resume audio element success")
                                }).catch(e => {
                                    em.warning("Auto resume audio element failed!", e)
                                })
                            }), this.elementsNeedToResume = []
                        };
                        new sl(e => {
                            document.body ? e() : window.addEventListener("load", () => e())
                        }).then(() => {
                            jh() ? document.body.addEventListener("click", e, !0) : (document.body.addEventListener("touchstart", e, !0), document.body.addEventListener("mousedown", e, !0))
                        })
                    }
                };

            function by() {
                return function (e, t, r) {
                    const n = r.value;
                    return "function" == typeof n && (r.value = function () {
                        this._isClosed && new Hf(qf.INVALID_OPERATION, "[".concat(this.getTrackId(), "] cannot operate a closed track")).print("warning");
                        for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];
                        const i = n.apply(this, t);
                        return i instanceof sl ? new sl((e, t) => {
                            i.then(e).catch(t)
                        }) : i
                    }), r
                }
            }

            var Ty, Ry, Iy, wy, Cy, Ay, Oy, Ny, Py, Dy, ky, Ly, xy, My, Uy, jy, Vy, Fy, By, Wy, Gy, qy, Hy, Ky, zy, Yy,
                Jy, Xy, Qy, $y, Zy, eS, tS, rS, nS, iS, oS, sS = Fr("Array").values, aS = Ki, cS = Ge, uS = h, dS = sS,
                lS = Array.prototype, hS = {DOMTokenList: !0, NodeList: !0}, pS = function (e) {
                    var t = e.values;
                    return e === lS || uS(lS, e) && t === lS.values || cS(hS, aS(e)) ? dS : t
                };

            function fS(e, t) {
                var r = Object.keys(e);
                if (Object.getOwnPropertySymbols) {
                    var n = Object.getOwnPropertySymbols(e);
                    t && (n = n.filter(function (t) {
                        return Object.getOwnPropertyDescriptor(e, t).enumerable
                    })), r.push.apply(r, n)
                }
                return r
            }

            function mS(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var r = null != arguments[t] ? arguments[t] : {};
                    t % 2 ? fS(Object(r), !0).forEach(function (t) {
                        Kh(e, t, r[t])
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : fS(Object(r)).forEach(function (t) {
                        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t))
                    })
                }
                return e
            }

            class _S extends Wf {
                constructor(e) {
                    super(), Kh(this, "name", "VideoProcessorDestination"), Kh(this, "ID", "0"), Kh(this, "_source", void 0), Kh(this, "videoContext", void 0), Kh(this, "inputTrack", void 0), this.videoContext = e
                }

                get kind() {
                    return "video"
                }

                get enabled() {
                    return !0
                }

                pipe() {
                    throw new Hf(qf.NOT_SUPPORTED, "VideoProcessor cannot pipe to any other Processor")
                }

                unpipe() {
                    throw new Hf(qf.NOT_SUPPORTED, "VideoProcessor cannot unpipe to any other Processor")
                }

                enable() {
                }

                disable() {
                }

                updateInput(e) {
                    if (e.context !== this.videoContext) throw new Error("ProcessorContext passed to VideoTrack.processorDestination doesn't match it's belonging VideoTrack's context.\nProbably you are making pipeline like this:\nvideoTrack1.pipe(processor).pipe(videoTrack2.processorDestination).");
                    e.track && e.track !== this.inputTrack && (this.videoContext.chained = !0, this.inputTrack = e.track, this.emit(Xv.ON_TRACK, e.track))
                }

                reset() {
                    this.inputTrack = void 0, this.videoContext.chained = !1, this.emit(Xv.ON_TRACK, void 0)
                }
            }

            class vS extends Wf {
                set chained(e) {
                    this._chained = e
                }

                get chained() {
                    return this._chained
                }

                constructor(e, t) {
                    super(), Kh(this, "constraintsMap", new Map), Kh(this, "statsRegistry", []), Kh(this, "usageRegistry", []), Kh(this, "trackId", void 0), Kh(this, "direction", void 0), Kh(this, "_chained", !1), this.trackId = e, this.direction = t
                }

                async getConstraints() {
                    return await ZS(this, Qv.REQUEST_CONSTRAINTS)
                }

                async requestApplyConstraints(e, t) {
                    var r;
                    return em.info("processor ".concat(t.name, " requestApplyConstraints for ").concat(this.trackId)), e && this.constraintsMap.set(t, e), eb(this, Qv.REQUEST_UPDATE_CONSTRAINTS, Array.from(pS(r = this.constraintsMap).call(r)))
                }

                async requestRevertConstraints(e) {
                    var t;
                    if (this.constraintsMap.has(e)) return em.info("processor ".concat(e.name, " requestRevertConstraints for ").concat(this.trackId)), this.constraintsMap.delete(e), eb(this, Qv.REQUEST_UPDATE_CONSTRAINTS, Array.from(pS(t = this.constraintsMap).call(t)))
                }

                registerStats(e, t, r) {
                    this.statsRegistry.find(r => r.processorID === e.ID && r.processorName === e.name && r.type === t) || this.statsRegistry.push({
                        processorName: e.name,
                        processorID: e.ID,
                        type: t,
                        cb: r
                    })
                }

                unregisterStats(e, t) {
                    const r = this.statsRegistry.findIndex(r => r.processorID === e.ID && r.processorName === e.name && r.type === t);
                    -1 !== r && this.statsRegistry.splice(r, 1)
                }

                gatherStats() {
                    const e = [];
                    for (const {processorID: t, processorName: r, type: n, cb: i} of this.statsRegistry) try {
                        const o = i();
                        e.push({processorID: t, processorName: r, type: n, stats: o})
                    } catch (e) {
                        em.error(new Hf(qf.UNEXPECTED_ERROR, e.message))
                    }
                    return e
                }

                registerUsage(e, t) {
                    this.usageRegistry.find(t => t.processorID === e.ID && t.processorName === e.name) || this.usageRegistry.push({
                        processorID: e.ID,
                        processorName: e.name,
                        cb: t
                    })
                }

                unregisterUsage(e) {
                    const t = this.usageRegistry.findIndex(t => t.processorID === e.ID && t.processorName === e.name);
                    -1 !== t && this.usageRegistry.splice(t, 1)
                }

                async gatherUsage() {
                    const e = [];
                    if (!this.chained) return [];
                    for (const {cb: t} of this.usageRegistry) try {
                        let r = t();
                        r instanceof sl && (r = await r), e.push(mS(mS({}, r), {}, {direction: this.direction}))
                    } catch (e) {
                        em.error("gather extension usage error", e)
                    }
                    return e
                }

                getDirection() {
                    return this.direction
                }
            }

            class gS extends Wf {
                constructor(e) {
                    super(), Kh(this, "name", "AudioProcessorDestination"), Kh(this, "ID", "0"), Kh(this, "inputTrack", void 0), Kh(this, "inputNode", void 0), Kh(this, "audioProcessorContext", void 0), Kh(this, "_source", void 0), this.audioProcessorContext = e
                }

                get kind() {
                    return "audio"
                }

                get enabled() {
                    return !0
                }

                pipe() {
                    throw new Hf(qf.NOT_SUPPORTED, "AudioProcessorDestination cannot pipe to any other Processor")
                }

                unpipe() {
                    throw new Hf(qf.NOT_SUPPORTED, "AudioProcessor cannot unpipe to any other Processor")
                }

                enable() {
                }

                disable() {
                }

                reset() {
                    this.inputTrack = void 0, this.inputNode = void 0, this.audioProcessorContext.chained = !1, this.emit(Xv.ON_TRACK, void 0), this.emit(Xv.ON_NODE, void 0)
                }

                updateInput(e) {
                    if (e.context !== this.audioProcessorContext) throw new Error("ProcessorContext passed to AudioTrack.processorDestination doesn't match it's belonging AudioTrack's context.\n        Probably you are making pipeline like this: audioTrack1.pipe(processor).pipe(audioTrack2.processorDestination).");
                    e.track && this.inputTrack !== e.track && (this.audioProcessorContext.chained = !0, this.inputTrack = e.track, this.emit(Xv.ON_TRACK, this.inputTrack)), e.node && this.inputNode !== e.node && (this.audioProcessorContext.chained = !0, this.inputNode = e.node, this.emit(Xv.ON_NODE, this.inputNode))
                }
            }

            class ES extends Wf {
                set chained(e) {
                    this._chained = e
                }

                get chained() {
                    return this._chained
                }

                constructor(e, t, r) {
                    super(), Kh(this, "constraintsMap", new Map), Kh(this, "statsRegistry", []), Kh(this, "audioContext", void 0), Kh(this, "trackId", void 0), Kh(this, "direction", void 0), Kh(this, "usageRegistry", []), Kh(this, "_chained", !1), this.audioContext = e, this.trackId = t, this.direction = r
                }

                async getConstraints() {
                    return ZS(this, Qv.REQUEST_CONSTRAINTS)
                }

                getAudioContext() {
                    return this.audioContext
                }

                async requestApplyConstraints(e, t) {
                    var r;
                    return em.info("processor ".concat(t.name, " requestApplyConstraints for ").concat(this.trackId)), e && this.constraintsMap.set(t, e), eb(this, Qv.REQUEST_UPDATE_CONSTRAINTS, Array.from(pS(r = this.constraintsMap).call(r)))
                }

                async requestRevertConstraints(e) {
                    var t;
                    if (this.constraintsMap.has(e)) return this.constraintsMap.delete(e), eb(this, Qv.REQUEST_UPDATE_CONSTRAINTS, Array.from(pS(t = this.constraintsMap).call(t)))
                }

                registerStats(e, t, r) {
                    this.statsRegistry.find(r => r.processorID === e.ID && r.processorName === e.name && r.type === t) || this.statsRegistry.push({
                        processorName: e.name,
                        processorID: e.ID,
                        type: t,
                        cb: r
                    })
                }

                unregisterStats(e, t) {
                    const r = this.statsRegistry.findIndex(r => r.processorID === e.ID && r.processorName === e.name && r.type === t);
                    -1 !== r && this.statsRegistry.splice(r, 1)
                }

                gatherStats() {
                    const e = [];
                    for (const {processorID: t, processorName: r, type: n, cb: i} of this.statsRegistry) try {
                        const o = i();
                        e.push({processorID: t, processorName: r, type: n, stats: o})
                    } catch (e) {
                        em.error(new Hf(qf.UNEXPECTED_ERROR, e.message))
                    }
                    return e
                }

                registerUsage(e, t) {
                    this.usageRegistry.find(t => t.processorID === e.ID && t.processorName === e.name) || this.usageRegistry.push({
                        processorID: e.ID,
                        processorName: e.name,
                        cb: t
                    })
                }

                unregisterUsage(e) {
                    const t = this.usageRegistry.findIndex(t => t.processorID === e.ID && t.processorName === e.name);
                    -1 !== t && this.usageRegistry.splice(t, 1)
                }

                async gatherUsage() {
                    const e = [];
                    if (!this.chained) return [];
                    for (const {cb: t} of this.usageRegistry) try {
                        let r = t();
                        r instanceof sl && (r = await r), e.push(mS(mS({}, r), {}, {direction: this.direction}))
                    } catch (e) {
                        em.error("gather extension usage error", e)
                    }
                    return e
                }

                getDirection() {
                    return this.direction
                }
            }

            class yS extends Wf {
                get isPlayed() {
                    return !0
                }

                get isFreeze() {
                    return !1
                }

                constructor() {
                    super(), Kh(this, "context", void 0), Kh(this, "processSourceNode", void 0), Kh(this, "outputTrack", void 0), Kh(this, "processedNode", void 0), Kh(this, "clonedTrack", void 0), Kh(this, "outputNode", void 0), this.outputNode = new SS
                }

                setVolume() {
                }

                createOutputTrack() {
                    throw new Hf(qf.NOT_SUPPORTED, "can not create output MediaStreamTrack when WebAudio disabled")
                }

                getOriginVolumeLevel() {
                    return 0
                }

                getAccurateVolumeLevel() {
                    return 0
                }

                stopGetAudioBuffer() {
                }

                startGetAudioBuffer() {
                }

                play() {
                }

                stop() {
                }

                destroy() {
                }

                updateTrack() {
                }

                updateOriginTrack() {
                }

                createMediaStreamSourceNode() {
                }
            }

            class SS {
                disconnect() {
                }

                connect() {
                }
            }

            function bS(e, t) {
                var r = Object.keys(e);
                if (Object.getOwnPropertySymbols) {
                    var n = Object.getOwnPropertySymbols(e);
                    t && (n = n.filter(function (t) {
                        return Object.getOwnPropertyDescriptor(e, t).enumerable
                    })), r.push.apply(r, n)
                }
                return r
            }

            function TS(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var r = null != arguments[t] ? arguments[t] : {};
                    t % 2 ? bS(Object(r), !0).forEach(function (t) {
                        Kh(e, t, r[t])
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : bS(Object(r)).forEach(function (t) {
                        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t))
                    })
                }
                return e
            }

            let RS = (Ty = BE({
                    argsMap: (e, t) => [e.getTrackId(), t],
                    throttleTime: 300
                }), Ry = BE({argsMap: (e, t) => [e.getTrackId(), t]}), Iy = by(), wy = zE("LocalAudioTrack", "_enabledMutex"), Cy = BE({argsMap: (e, t) => [e.getTrackId(), t]}), Ay = by(), Oy = zE("LocalAudioTrack", "_enabledMutex"), Ny = BE({argsMap: (e, t) => [e.getTrackId(), t]}), Py = by(), Dy = by(), ky = by(), Ly = BE({argsMap: e => [e.getTrackId()]}), xy = by(), My = BE({argsMap: e => [e.getTrackId()]}), Uy = by(), jy = BE({argsMap: e => [e.getTrackId()]}), Vy = BE({argsMap: (e, t) => [e.getTrackId(), t.name]}), Fy = BE({argsMap: e => [e.getTrackId()]}), vE((By = class extends YE {
                    get isPlaying() {
                        return this._useAudioElement ? Sy.isPlaying(this.getTrackId()) : this._source.isPlayed
                    }

                    get __className__() {
                        return "LocalAudioTrack"
                    }

                    constructor(e, t, r, n) {
                        super(e, r), Kh(this, "trackMediaType", "audio"), Kh(this, "_encoderConfig", void 0), Kh(this, "_source", void 0), Kh(this, "_enabled", !0), Kh(this, "_volume", 100), Kh(this, "_useAudioElement", !1), Kh(this, "_bypassWebAudio", !1), Kh(this, "processor", void 0), Kh(this, "processorContext", void 0), Kh(this, "processorDestination", void 0), Kh(this, "_getOriginVolumeLevel", void 0), this._encoderConfig = t, this._getOriginVolumeLevel = !!n, fm("DISABLE_WEBAUDIO") ? (this._source = new yS, this._useAudioElement = !0, this._bypassWebAudio = !0) : (this._source = new ay(e, !1, this._getOriginVolumeLevel ? e : void 0), fm("LOCAL_AUDIO_TRACK_USES_WEB_AUDIO") || (this._useAudioElement = !0)), this.processorContext = new ES(this._source.context, this.getTrackId(), "local"), this.processorDestination = new gS(this.processorContext), this.bindProcessorDestinationEvents(), this._source.on(tv.UPDATE_SOURCE, () => {
                            this.processor && this.processor.updateInput({
                                node: this._source.processSourceNode,
                                context: this.processorContext
                            })
                        })
                    }

                    setVolume(e) {
                        g_(e, "volume", 0, 1e3), this._volume = e, this._source.setVolume(e / 100), this._useAudioElement && Sy.setVolume(this.getTrackId(), e);
                        try {
                            if (this._bypassWebAudio) return void em.debug("[".concat(this.getTrackId(), "] setVolume returned because no pass through WebAudio."));
                            const t = this._source.createOutputTrack();
                            this._mediaStreamTrack !== t && (this._mediaStreamTrack = t, eb(this, Nv.NEED_REPLACE_TRACK, this).then(() => {
                                em.debug("[".concat(this.getTrackId(), "] replace web audio track success"))
                            }).catch(e => {
                                em.warning("[".concat(this.getTrackId(), "] replace web audio track failed"), e)
                            }))
                        } catch (e) {
                        }
                    }

                    getVolumeLevel() {
                        return this._muted && this.enabled && this._getOriginVolumeLevel ? this._source.getOriginVolumeLevel() : this._source.getAccurateVolumeLevel()
                    }

                    async setPlaybackDevice(e) {
                        if (!this._useAudioElement) throw new Hf(qf.NOT_SUPPORTED, "your browser does not support setting the audio output device");
                        await Sy.setSinkID(this.getTrackId(), e)
                    }

                    async setEnabled(e, t, r) {
                        return this._setEnabled(e, t, r)
                    }

                    async _setEnabled(e, t, r) {
                        if (!r) {
                            if (e === this._enabled) return;
                            this.stateCheck("enabled", e)
                        }
                        if (em.info("[".concat(this.getTrackId(), "] start setEnabled"), e), e) {
                            this._originMediaStreamTrack.enabled = !0;
                            try {
                                r || (this._enabled = !0), await eb(this, Nv.NEED_ENABLE_TRACK, this), em.info("[".concat(this.getTrackId(), "] setEnabled to ").concat(e, " success"))
                            } catch (e) {
                                throw r || (this._enabled = !1), em.error("[".concat(this.getTrackId(), "] setEnabled to true error"), e.toString()), e
                            }
                        } else {
                            this._originMediaStreamTrack.enabled = !1, r || (this._enabled = !1);
                            try {
                                await eb(this, Nv.NEED_DISABLE_TRACK, this)
                            } catch (e) {
                                throw r || (this._enabled = !0), em.error("[".concat(this.getTrackId(), "] setEnabled to false error"), e.toString()), e
                            }
                        }
                    }

                    async setMuted(e) {
                        e !== this._muted && (this.stateCheck("muted", e), this._muted = e, this._originMediaStreamTrack.enabled = !e, em.debug("[".concat(this.getTrackId(), "] start set muted: ").concat(e)), e ? await eb(this, Nv.NEED_MUTE_TRACK, this) : await eb(this, Nv.NEED_UNMUTE_TRACK, this))
                    }

                    getStats() {
                        cb(() => {
                            em.warning("[deprecated] LocalAudioTrack.getStats will be removed in the future, use AgoraRTCClient.getLocalAudioStats instead")
                        }, "localAudioTrackGetStatsWarning");
                        const e = tb(this, Nv.GET_STATS);
                        return e || TS({}, sv)
                    }

                    setAudioFrameCallback(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 4096;
                        if (!e) return this._source.removeAllListeners(tv.ON_AUDIO_BUFFER), void this._source.stopGetAudioBuffer();
                        this._source.startGetAudioBuffer(t), this._source.removeAllListeners(tv.ON_AUDIO_BUFFER), this._source.on(tv.ON_AUDIO_BUFFER, t => e(t))
                    }

                    play() {
                        em.debug("[".concat(this.getTrackId(), "] start audio playback")), this._useAudioElement ? (em.debug("[".concat(this.getTrackId(), "] start audio playback in element")), Sy.play(this._mediaStreamTrack, this.getTrackId(), this._volume)) : this._source.play()
                    }

                    stop() {
                        em.debug("[".concat(this.getTrackId(), "] stop audio playback")), this._useAudioElement ? Sy.stop(this.getTrackId()) : this._source.stop()
                    }

                    close() {
                        super.close(), this.unbindProcessorDestinationEvents(), this.unbindProcessorContextEvents(), this.unpipe(), this.processorDestination._source && this.processorDestination._source.unpipe(), this._source.destroy()
                    }

                    _updatePlayerSource() {
                        let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                        em.debug("[".concat(this.getTrackId(), "] update player source track")), e && this._source.updateTrack(this._mediaStreamTrack), this._useAudioElement && Sy.updateTrack(this.getTrackId(), this._mediaStreamTrack)
                    }

                    async _updateOriginMediaStreamTrack(e, t) {
                        this._originMediaStreamTrack !== e && (this._originMediaStreamTrack.removeEventListener("ended", this._handleTrackEnded), e.addEventListener("ended", this._handleTrackEnded), t && this._originMediaStreamTrack.stop(), this._originMediaStreamTrack = e, this._muted && (this._originMediaStreamTrack.enabled = !1), this.processor && this.processor.updateInput({
                            track: e,
                            context: this.processorContext
                        }), this._mediaStreamTrack !== this._source.outputTrack ? (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource(), await eb(this, Nv.NEED_REPLACE_TRACK, this)) : this._source.updateTrack(this._originMediaStreamTrack), this._getOriginVolumeLevel && this._source.updateOriginTrack(e))
                    }

                    renewMediaStreamTrack(e) {
                        return sl.resolve(void 0)
                    }

                    pipe(e) {
                        if (this._bypassWebAudio) throw new Hf(qf.INVALID_OPERATION, "Can not process AudioTrack when bypassWebAudio set to true.");
                        if (this.processor === e) return e;
                        if (e._source) throw new Hf(qf.INVALID_OPERATION, "Processor ".concat(e.name, " already piped, please call unpipe beforehand."));
                        return this.unpipe(), this.processor = e, this.processor._source = this, e.updateInput({
                            track: this._originMediaStreamTrack,
                            node: this._source.processSourceNode,
                            context: this.processorContext
                        }), e
                    }

                    unpipe() {
                        var e;
                        if (!this.processor) return;
                        const t = this.processor;
                        null === (e = this._source.processSourceNode) || void 0 === e || e.disconnect(), this.processor._source = !1, this.processor = void 0, t.reset()
                    }

                    bindProcessorDestinationEvents() {
                        this.processorDestination.on(Xv.ON_TRACK, async e => {
                            e ? e !== this._mediaStreamTrack && (this._mediaStreamTrack = e, this._updatePlayerSource(!1), this._source.processedNode = this._source.createMediaStreamSourceNode(e), await eb(this, Nv.NEED_REPLACE_TRACK, this)) : this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource(), await eb(this, Nv.NEED_REPLACE_TRACK, this))
                        }), this.processorDestination.on(Xv.ON_NODE, e => {
                            this._source.processedNode = e
                        })
                    }

                    unbindProcessorDestinationEvents() {
                        this.processorDestination.removeAllListeners(Xv.ON_TRACK), this.processorDestination.removeAllListeners(Xv.ON_NODE)
                    }

                    unbindProcessorContextEvents() {
                        this.processorContext.removeAllListeners(Qv.REQUEST_UPDATE_CONSTRAINTS), this.processorContext.removeAllListeners(Qv.REQUEST_CONSTRAINTS)
                    }
                }).prototype, "setVolume", [Ty], Object.getOwnPropertyDescriptor(By.prototype, "setVolume"), By.prototype), vE(By.prototype, "setPlaybackDevice", [Ry, Iy], Object.getOwnPropertyDescriptor(By.prototype, "setPlaybackDevice"), By.prototype), vE(By.prototype, "setEnabled", [wy, Cy, Ay], Object.getOwnPropertyDescriptor(By.prototype, "setEnabled"), By.prototype), vE(By.prototype, "setMuted", [Oy, Ny, Py], Object.getOwnPropertyDescriptor(By.prototype, "setMuted"), By.prototype), vE(By.prototype, "getStats", [Dy], Object.getOwnPropertyDescriptor(By.prototype, "getStats"), By.prototype), vE(By.prototype, "setAudioFrameCallback", [ky], Object.getOwnPropertyDescriptor(By.prototype, "setAudioFrameCallback"), By.prototype), vE(By.prototype, "play", [Ly, xy], Object.getOwnPropertyDescriptor(By.prototype, "play"), By.prototype), vE(By.prototype, "stop", [My, Uy], Object.getOwnPropertyDescriptor(By.prototype, "stop"), By.prototype), vE(By.prototype, "close", [jy], Object.getOwnPropertyDescriptor(By.prototype, "close"), By.prototype), vE(By.prototype, "pipe", [Vy], Object.getOwnPropertyDescriptor(By.prototype, "pipe"), By.prototype), vE(By.prototype, "unpipe", [Fy], Object.getOwnPropertyDescriptor(By.prototype, "unpipe"), By.prototype), By),
                IS = (Wy = BE({argsMap: (e, t) => [e.getTrackId(), t]}), Gy = by(), qy = zE("MicrophoneAudioTrack", "_enabledMutex"), Hy = BE({argsMap: (e, t, r) => [e.getTrackId(), t, r]}), Ky = by(), zy = BE({argsMap: e => [e.getTrackId()]}), vE((Yy = class extends RS {
                    get __className__() {
                        return "MicrophoneAudioTrack"
                    }

                    constructor(e, t, r, n) {
                        super(e, t.encoderConfig ? hm(t.encoderConfig) : {}, n, fm("GET_VOLUME_OF_MUTED_AUDIO_TRACK")), Kh(this, "_config", void 0), Kh(this, "_deviceName", "default"), Kh(this, "_constraints", void 0), Kh(this, "_originalConstraints", void 0), Kh(this, "_enabled", !0), this._config = t, this._constraints = r, this._originalConstraints = r, this._deviceName = e.label, "boolean" == typeof t.bypassWebAudio && (this._bypassWebAudio = t.bypassWebAudio), Oh() && $E.bindInterruptDetectorTrack(this), this.bindProcessorContextEvents()
                    }

                    async setDevice(e) {
                        if (em.info("[".concat(this.getTrackId(), "] start set device to ").concat(e)), this._enabled) try {
                            const t = await Ey.getDeviceById(e), r = {};
                            r.audio = TS({}, this._constraints), r.audio.deviceId = {exact: e}, this._originMediaStreamTrack.stop();
                            let n = null;
                            try {
                                n = await my(r, this.getTrackId())
                            } catch (e) {
                                throw em.error("[".concat(this.getTrackId(), "] setDevice failed"), e.toString()), n = await my({video: this._constraints}, this.getTrackId()), await this._updateOriginMediaStreamTrack(n.getAudioTracks()[0], !1), e
                            }
                            await this._updateOriginMediaStreamTrack(n.getAudioTracks()[0], !1), this._deviceName = t.label, this._config.microphoneId = e, this._constraints.deviceId = {exact: e}
                        } catch (e) {
                            throw em.error("[".concat(this.getTrackId(), "] setDevice error"), e.toString()), e
                        } else try {
                            const t = await Ey.getDeviceById(e);
                            this._deviceName = t.label, this._config.microphoneId = e, this._constraints.deviceId = {exact: e}
                        } catch (e) {
                            throw em.error("[".concat(this.getTrackId(), "] setDevice error"), e.toString()), e
                        }
                        em.info("[".concat(this.getTrackId(), "] set device to ").concat(e, " success"))
                    }

                    async setEnabled(e, t, r) {
                        if (t) return em.debug("[".concat(this.getTrackId(), "] setEnabled false (do not close microphone)")), await super._setEnabled(e);
                        if (!r) {
                            if (e === this._enabled) return;
                            this.stateCheck("enabled", e)
                        }
                        if (em.info("[".concat(this.getTrackId(), "] start setEnabled"), e), !e) {
                            var n;
                            this._originMediaStreamTrack.onended = null, this._originMediaStreamTrack.stop(), null === (n = this._source.clonedTrack) || void 0 === n || n.stop(), r || (this._enabled = !1);
                            try {
                                await eb(this, Nv.NEED_DISABLE_TRACK, this)
                            } catch (e) {
                                throw em.error("[".concat(this.getTrackId(), "] setEnabled false failed"), e.toString()), e
                            }
                            return
                        }
                        const i = TS({}, this._constraints), o = Ey.searchDeviceIdByName(this._deviceName);
                        o && !i.deviceId && (i.deviceId = o);
                        try {
                            r || (this._enabled = !0);
                            const t = await my({audio: this._constraints}, this.getTrackId());
                            await this._updateOriginMediaStreamTrack(t.getAudioTracks()[0], !1), await eb(this, Nv.NEED_ENABLE_TRACK, this)
                        } catch (e) {
                            throw r || (this._enabled = !1), em.error("[".concat(this.getTrackId(), "] setEnabled true failed"), e.toString()), e
                        }
                        em.info("[".concat(this.getTrackId(), "] setEnabled success"))
                    }

                    close() {
                        super.close(), Oh() && $E.unbindInterruptDetectorTrack(this)
                    }

                    onTrackEnded() {
                        if ((Ch() || kh()) && this._enabled && !this._isClosed && $E.duringInterruption) {
                            const e = async () => {
                                $E.off(qE.IOS_INTERRUPTION_END, e), this._enabled && !this._isClosed && (em.debug("[".concat(this.getTrackId(), "] try capture microphone media device for interrupted iOS device.")), await this.setEnabled(!1), await this.setEnabled(!0))
                            };
                            $E.on(qE.IOS_INTERRUPTION_END, e)
                        } else em.debug("[".concat(this.getTrackId(), "] track ended")), this.emit(Lv.TRACK_ENDED)
                    }

                    async renewMediaStreamTrack(e) {
                        const t = e || this._constraints, r = Ey.searchDeviceIdByName(this._deviceName);
                        if (r && !t.deviceId && (t.deviceId = r), this._constraints = t, this._enabled) {
                            this._originMediaStreamTrack.stop();
                            const e = await my({audio: this._constraints}, this.getTrackId());
                            await this._updateOriginMediaStreamTrack(e.getAudioTracks()[0], !0)
                        }
                    }

                    bindProcessorContextEvents() {
                        this.processorContext.on(Qv.REQUEST_UPDATE_CONSTRAINTS, async (e, t, r) => {
                            try {
                                const r = Object.assign({}, this._originalConstraints, ...e);
                                await this.renewMediaStreamTrack(r), t()
                            } catch (e) {
                                r(e)
                            }
                        }), this.processorContext.on(Qv.REQUEST_CONSTRAINTS, async e => {
                            e(this._originMediaStreamTrack.getSettings())
                        })
                    }
                }).prototype, "setDevice", [Wy, Gy], Object.getOwnPropertyDescriptor(Yy.prototype, "setDevice"), Yy.prototype), vE(Yy.prototype, "setEnabled", [qy, Hy, Ky], Object.getOwnPropertyDescriptor(Yy.prototype, "setEnabled"), Yy.prototype), vE(Yy.prototype, "close", [zy], Object.getOwnPropertyDescriptor(Yy.prototype, "close"), Yy.prototype), Yy),
                wS = (Jy = BE({argsMap: (e, t) => [e.getTrackId(), t, e.duration]}), Xy = by(), Qy = BE({argsMap: e => [e.getTrackId()]}), $y = by(), Zy = BE({argsMap: e => [e.getTrackId()]}), eS = by(), tS = BE({argsMap: e => [e.getTrackId()]}), rS = by(), nS = BE({argsMap: e => [e.getTrackId()]}), iS = by(), vE((oS = class extends RS {
                    get __className__() {
                        return "BufferSourceAudioTrack"
                    }

                    constructor(e, t, r, n) {
                        super(t.createOutputTrack(), r, n), Kh(this, "source", void 0), Kh(this, "_bufferSource", void 0), this.source = e, this._bufferSource = t, this._bufferSource.on(tv.AUDIO_SOURCE_STATE_CHANGE, e => {
                            this.emit(Lv.SOURCE_STATE_CHANGE, e)
                        });
                        try {
                            this._mediaStreamTrack = this._source.createOutputTrack()
                        } catch (e) {
                        }
                    }

                    get currentState() {
                        return this._bufferSource.currentState
                    }

                    get duration() {
                        return this._bufferSource.duration
                    }

                    getCurrentTime() {
                        return this._bufferSource.currentTime
                    }

                    startProcessAudioBuffer(e) {
                        e && this._bufferSource.updateOptions(e), this._bufferSource.startProcessAudioBuffer()
                    }

                    pauseProcessAudioBuffer() {
                        this._bufferSource.pauseProcessAudioBuffer()
                    }

                    seekAudioBuffer(e) {
                        this._bufferSource.seekAudioBuffer(e)
                    }

                    resumeProcessAudioBuffer() {
                        this._bufferSource.resumeProcessAudioBuffer()
                    }

                    stopProcessAudioBuffer() {
                        this._bufferSource.stopProcessAudioBuffer()
                    }
                }).prototype, "startProcessAudioBuffer", [Jy, Xy], Object.getOwnPropertyDescriptor(oS.prototype, "startProcessAudioBuffer"), oS.prototype), vE(oS.prototype, "pauseProcessAudioBuffer", [Qy, $y], Object.getOwnPropertyDescriptor(oS.prototype, "pauseProcessAudioBuffer"), oS.prototype), vE(oS.prototype, "seekAudioBuffer", [Zy, eS], Object.getOwnPropertyDescriptor(oS.prototype, "seekAudioBuffer"), oS.prototype), vE(oS.prototype, "resumeProcessAudioBuffer", [tS, rS], Object.getOwnPropertyDescriptor(oS.prototype, "resumeProcessAudioBuffer"), oS.prototype), vE(oS.prototype, "stopProcessAudioBuffer", [nS, iS], Object.getOwnPropertyDescriptor(oS.prototype, "stopProcessAudioBuffer"), oS.prototype), oS);

            class CS extends RS {
                get __className__() {
                    return "MixingAudioTrack"
                }

                get isActive() {
                    for (const e of this.trackList) if (e._enabled && !e._isClosed && !e.muted) return !0;
                    return !1
                }

                constructor() {
                    const e = ZE().createMediaStreamDestination();
                    super(e.stream.getAudioTracks()[0], void 0, YS(8, "track-mix-")), Kh(this, "trackList", void 0), Kh(this, "destNode", void 0);
                    try {
                        this._mediaStreamTrack = this._source.createOutputTrack()
                    } catch (e) {
                    }
                    this.destNode = e, this.trackList = []
                }

                hasAudioTrack(e) {
                    return -1 !== this.trackList.indexOf(e)
                }

                addAudioTrack(e) {
                    -1 === this.trackList.indexOf(e) ? (em.debug("add ".concat(e.getTrackId(), " to mixing track")), e._source.outputNode.connect(this.destNode), this.trackList.push(e), this.updateEncoderConfig()) : em.debug("track ".concat(e.getTrackId(), " is already added"))
                }

                removeAudioTrack(e) {
                    if (-1 !== this.trackList.indexOf(e)) {
                        em.debug("remove ".concat(e.getTrackId(), " from mixing track"));
                        try {
                            e._source.outputNode.disconnect(this.destNode)
                        } catch (e) {
                        }
                        nb(this.trackList, e), this.updateEncoderConfig()
                    }
                }

                updateEncoderConfig() {
                    const e = {};
                    this.trackList.forEach(t => {
                        t._encoderConfig && ((t._encoderConfig.bitrate || 0) > (e.bitrate || 0) && (e.bitrate = t._encoderConfig.bitrate), (t._encoderConfig.sampleRate || 0) > (e.sampleRate || 0) && (e.sampleRate = t._encoderConfig.sampleRate), (t._encoderConfig.sampleSize || 0) > (e.sampleSize || 0) && (e.sampleSize = t._encoderConfig.sampleSize), t._encoderConfig.stereo && (e.stereo = !0))
                    }), this._encoderConfig = e
                }
            }

            class AS extends Wf {
                constructor() {
                    super(...arguments), Kh(this, "resultStorage", new Map)
                }

                setLocalAudioStats(e, t, r) {
                    this.record("AUDIO_INPUT_LEVEL_TOO_LOW", e, this.checkAudioInputLevel(r, t)), this.record("SEND_AUDIO_BITRATE_TOO_LOW", e, this.checkSendAudioBitrate(r, t))
                }

                setLocalVideoStats(e, t, r) {
                    this.record("SEND_VIDEO_BITRATE_TOO_LOW", e, this.checkSendVideoBitrate(r, t)), this.record("FRAMERATE_INPUT_TOO_LOW", e, this.checkFramerateInput(r, t)), this.record("FRAMERATE_SENT_TOO_LOW", e, this.checkFramerateSent(r))
                }

                setRemoteAudioStats(e, t) {
                    const r = e.getUserId();
                    this.record("AUDIO_OUTPUT_LEVEL_TOO_LOW", r, this.checkAudioOutputLevel(t))
                }

                setRemoteVideoStats(e, t) {
                    const r = e.getUserId();
                    this.record("RECV_VIDEO_DECODE_FAILED", r, this.checkVideoDecode(t))
                }

                record(e, t, r) {
                    this.resultStorage.has(e) || this.resultStorage.set(e, {result: [], isPrevNormal: !0});
                    const n = this.resultStorage.get(e);
                    if (n && (n.result.push(r), n.result.length >= 5)) {
                        const r = n.result.includes(!0);
                        n.isPrevNormal && !r && this.emit("exception", OS[e], e, t), !n.isPrevNormal && r && this.emit("exception", OS[e] + 2e3, e + "_RECOVER", t), n.isPrevNormal = r, n.result = []
                    }
                }

                checkAudioOutputLevel(e) {
                    return !(e.receiveBitrate > 0 && 0 === e.receiveLevel)
                }

                checkAudioInputLevel(e, t) {
                    return t instanceof CS && !t.isActive || !!t.muted || 0 !== e.sendVolumeLevel
                }

                checkFramerateInput(e, t) {
                    let r = null;
                    t._encoderConfig && t._encoderConfig.frameRate && (r = jS(t._encoderConfig.frameRate));
                    const n = e.captureFrameRate;
                    return !r || !n || !(r > 10 && n < 5 || r < 10 && r >= 5 && n <= 1)
                }

                checkFramerateSent(e) {
                    return !(e.captureFrameRate && e.sendFrameRate && e.captureFrameRate > 5 && e.sendFrameRate <= 1)
                }

                checkSendVideoBitrate(e, t) {
                    return !!t.muted || 0 !== e.sendBitrate
                }

                checkSendAudioBitrate(e, t) {
                    return t instanceof CS && !t.isActive || !!t.muted || 0 !== e.sendBitrate
                }

                checkVideoDecode(e) {
                    return 0 === e.receiveBitrate || 0 !== e.decodeFrameRate
                }
            }

            const OS = {
                FRAMERATE_INPUT_TOO_LOW: 1001,
                FRAMERATE_SENT_TOO_LOW: 1002,
                SEND_VIDEO_BITRATE_TOO_LOW: 1003,
                RECV_VIDEO_DECODE_FAILED: 1005,
                AUDIO_INPUT_LEVEL_TOO_LOW: 2001,
                AUDIO_OUTPUT_LEVEL_TOO_LOW: 2002,
                SEND_AUDIO_BITRATE_TOO_LOW: 2003
            }, NS = new class {
                markSubscribeStart(e, t) {
                    performance.mark("agora-web-sdk/".concat(e, "/subscribe-").concat(t))
                }

                markPublishStart(e, t) {
                    performance.mark("agora-web-sdk/".concat(e, "/publish-").concat(t))
                }

                measureFromSubscribeStart(e, t) {
                    const r = performance.getEntriesByName("agora-web-sdk/".concat(e, "/subscribe-").concat(t));
                    if (r.length > 0) {
                        const e = r[r.length - 1];
                        return Math.round(performance.now() - e.startTime)
                    }
                    return 0
                }

                measureFromPublishStart(e, t) {
                    const r = performance.getEntriesByName("agora-web-sdk/".concat(e, "/publish-").concat(t));
                    if (r.length > 0) {
                        const e = r[r.length - 1];
                        return Math.round(performance.now() - e.startTime)
                    }
                    return 0
                }
            };

            function PS(e, t) {
                var r = Object.keys(e);
                if (Object.getOwnPropertySymbols) {
                    var n = Object.getOwnPropertySymbols(e);
                    t && (n = n.filter(function (t) {
                        return Object.getOwnPropertyDescriptor(e, t).enumerable
                    })), r.push.apply(r, n)
                }
                return r
            }

            function DS(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var r = null != arguments[t] ? arguments[t] : {};
                    t % 2 ? PS(Object(r), !0).forEach(function (t) {
                        Kh(e, t, r[t])
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : PS(Object(r)).forEach(function (t) {
                        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t))
                    })
                }
                return e
            }

            class kS {
                constructor(e) {
                    Kh(this, "store", void 0), Kh(this, "onStatsException", void 0), Kh(this, "onUploadPublishDuration", void 0), Kh(this, "localStats", new Map), Kh(this, "remoteStats", new Map), Kh(this, "updateStatsInterval", void 0), Kh(this, "trafficStats", void 0), Kh(this, "trafficStatsPeerList", []), Kh(this, "uplinkStats", void 0), Kh(this, "exceptionMonitor", void 0), Kh(this, "p2pChannel", void 0), Kh(this, "updateStats", () => {
                        this.p2pChannel && (this.updateRemoteStats(this.p2pChannel), this.updateLocalStats(this.p2pChannel))
                    }), this.store = e, this.updateStatsInterval = window.setInterval(this.updateStats, 1e3), this.exceptionMonitor = new AS, this.exceptionMonitor.on("exception", (e, t, r) => {
                        this.onStatsException && this.onStatsException(e, t, r)
                    })
                }

                reset() {
                    this.localStats = new Map, this.remoteStats = new Map, this.trafficStats = void 0, this.trafficStatsPeerList = [], this.uplinkStats = void 0
                }

                getLocalAudioTrackStats() {
                    return this.localStats.get(Hv.LocalAudioTrack) || DS({}, sv)
                }

                getLocalVideoTrackStats() {
                    return this.localStats.get(Hv.LocalVideoTrack) || DS({}, av)
                }

                getRemoteAudioTrackStats(e) {
                    const t = (e, t) => {
                        if (!this.trafficStats) return t;
                        const r = this.trafficStats.peer_delay.find(t => t.peer_uid === e);
                        return r && (t.publishDuration = r.B_ppad + (Date.now() - this.trafficStats.timestamp)), t
                    }, r = {};
                    if (e) {
                        var n;
                        const i = null === (n = this.remoteStats.get(e)) || void 0 === n ? void 0 : n.audioStats;
                        i && (r[e] = t(e, i))
                    } else Array.from(this.remoteStats.entries()).forEach(e => {
                        let [n, {audioStats: i}] = e;
                        i && (r[n] = t(n, i))
                    });
                    return r
                }

                getRemoteNetworkQualityStats(e) {
                    const t = {};
                    if (e) {
                        var r;
                        const n = null === (r = this.remoteStats.get(e)) || void 0 === r ? void 0 : r.networkStats;
                        n && (t[e] = n)
                    } else Array.from(this.remoteStats.entries()).forEach(e => {
                        let [r, {networkStats: n}] = e;
                        n && (t[r] = n)
                    });
                    return t
                }

                getRemoteVideoTrackStats(e) {
                    const t = (e, t) => {
                        if (!this.trafficStats) return t;
                        const r = this.trafficStats.peer_delay.find(t => t.peer_uid === e);
                        return r && (t.publishDuration = r.B_ppvd + (Date.now() - this.trafficStats.timestamp)), t
                    }, r = {};
                    if (e) {
                        var n;
                        const i = null === (n = this.remoteStats.get(e)) || void 0 === n ? void 0 : n.videoStats;
                        i && (r[e] = t(e, i))
                    } else Array.from(this.remoteStats.entries()).forEach(e => {
                        let [n, {videoStats: i}] = e;
                        i && (r[n] = t(n, i))
                    });
                    return r
                }

                getRTCStats() {
                    let e = 0, t = 0, r = 0, n = 0;
                    const i = this.localStats.get(Hv.LocalAudioTrack);
                    i && (e += i.sendBytes, t += i.sendBitrate);
                    const o = this.localStats.get(Hv.LocalVideoTrack);
                    o && (e += o.sendBytes, t += o.sendBitrate);
                    const s = this.localStats.get(Hv.LocalVideoLowTrack);
                    s && (e += s.sendBytes, t += s.sendBitrate), this.remoteStats.forEach(e => {
                        let {audioStats: t, videoStats: i} = e;
                        t && (r += t.receiveBytes, n += t.receiveBitrate), i && (r += i.receiveBytes, n += i.receiveBitrate)
                    });
                    let a = 1;
                    return this.trafficStats && (a += this.trafficStats.peer_delay.length), {
                        Duration: 0,
                        UserCount: a,
                        SendBitrate: t,
                        SendBytes: e,
                        RecvBytes: r,
                        RecvBitrate: n,
                        OutgoingAvailableBandwidth: this.uplinkStats ? this.uplinkStats.B_uab / 1e3 : 0,
                        RTT: this.trafficStats ? 2 * this.trafficStats.B_acd : 0
                    }
                }

                addLocalStats(e) {
                    this.localStats.set(e, void 0)
                }

                removeLocalStats(e) {
                    e ? this.localStats.delete(e) : this.localStats.clear()
                }

                addRemoteStats(e) {
                    this.remoteStats.set(e, {})
                }

                removeRemoteStats(e) {
                    e ? this.remoteStats.delete(e) : this.remoteStats.clear()
                }

                addP2PChannel(e) {
                    this.p2pChannel = e
                }

                updateTrafficStats(e) {
                    e.peer_delay = e.peer_delay.filter(e => void 0 !== e.B_ppad || void 0 !== e.B_ppvd), e.peer_delay.filter(e => -1 === this.trafficStatsPeerList.indexOf(e.peer_uid)).forEach(e => {
                        var t;
                        const r = null === (t = this.p2pChannel) || void 0 === t ? void 0 : t.getRemoteMedia(e.peer_uid),
                            n = null != r && r.videoSSRC ? NS.measureFromSubscribeStart(this.store.clientId, r.videoSSRC) : 0,
                            i = null != r && r.audioSSRC ? NS.measureFromSubscribeStart(this.store.clientId, r.audioSSRC) : 0;
                        void 0 !== e.B_ppad && void 0 !== e.B_ppvd && (this.onUploadPublishDuration && this.onUploadPublishDuration(e.peer_uid, e.B_ppad, e.B_ppvd, n > i ? n : i), this.trafficStatsPeerList.push(e.peer_uid))
                    }), this.trafficStats = e
                }

                updateUplinkStats(e) {
                    this.uplinkStats && this.uplinkStats.B_fir !== e.B_fir && em.debug("[".concat(this.store.clientId, "]: Period fir changes to ").concat(e.B_fir)), this.uplinkStats = e
                }

                static isRemoteVideoFreeze(e, t, r) {
                    if (!e) return !1;
                    const n = !!r && t.framesDecodeFreezeTime > r.framesDecodeFreezeTime,
                        i = !r || t.framesDecodeCount > r.framesDecodeCount;
                    return n || !i
                }

                static isRemoteAudioFreeze(e) {
                    return !!e && e._isFreeze()
                }

                isLocalVideoFreeze(e) {
                    return !(!e.inputFrame || !e.sentFrame) && e.inputFrame.frameRate > 5 && e.sentFrame.frameRate < 3
                }

                updateLocalStats(e) {
                    Array.from(this.localStats.entries()).forEach(t => {
                        let [r, n] = t;
                        switch (r) {
                            case Hv.LocalVideoTrack:
                            case Hv.LocalVideoLowTrack: {
                                const t = n, i = DS({}, av), o = e.getStats(), s = e.getLocalMedia(r);
                                if (o) {
                                    const r = o.videoSend.find(e => e.ssrc === (null == s ? void 0 : s.ssrcs[0].ssrcId));
                                    if (r) {
                                        const n = e.getLocalVideoSize(), o = e.getEncoderConfig(Hv.LocalVideoTrack);
                                        "H264" !== r.codec && "VP8" !== r.codec && "VP9" !== r.codec && "AV1X" !== r.codec && "AV1" !== r.codec || (i.codecType = r.codec), i.sendBytes = r.bytes, i.sendBitrate = t ? 8 * Math.max(0, i.sendBytes - t.sendBytes) : 0, r.inputFrame ? (i.captureFrameRate = r.inputFrame.frameRate, i.captureResolutionHeight = r.inputFrame.height, i.captureResolutionWidth = r.inputFrame.width) : n && (i.captureResolutionWidth = n.width, i.captureResolutionHeight = n.height), r.sentFrame ? (i.sendFrameRate = r.sentFrame.frameRate, i.sendResolutionHeight = r.sentFrame.height, i.sendResolutionWidth = r.sentFrame.width) : n && (i.sendResolutionWidth = n.width, i.sendResolutionHeight = n.height), r.avgEncodeMs && (i.encodeDelay = r.avgEncodeMs), o && o.bitrateMax && (i.targetSendBitrate = 1e3 * o.bitrateMax), i.sendPackets = r.packets, i.sendPacketsLost = r.packetsLost, i.totalDuration = t ? t.totalDuration + 1 : 1, i.totalFreezeTime = t ? t.totalFreezeTime : 0, this.isLocalVideoFreeze(r) && (i.totalFreezeTime += 1)
                                    }
                                    this.trafficStats && (i.sendPacketsLost = this.trafficStats.B_pvlr4 / 100)
                                }
                                this.localStats.set(r, i), i && s && this.exceptionMonitor.setLocalVideoStats(this.store.uid, s.track, i);
                                break
                            }
                            case Hv.LocalAudioTrack: {
                                const t = n, i = DS({}, sv), o = e.getStats(), s = e.getLocalMedia(r);
                                if (o) {
                                    const r = o.audioSend.find(e => e.ssrc === (null == s ? void 0 : s.ssrcs[0].ssrcId));
                                    if (r) {
                                        if ("opus" !== r.codec && "aac" !== r.codec && "PCMU" !== r.codec && "PCMA" !== r.codec && "G722" !== r.codec || (i.codecType = r.codec), r.inputLevel) i.sendVolumeLevel = Math.round(32767 * r.inputLevel); else {
                                            const t = e.getLocalAudioVolume();
                                            t && (i.sendVolumeLevel = Math.round(32767 * t))
                                        }
                                        i.sendBytes = r.bytes, i.sendPackets = r.packets, i.sendPacketsLost = r.packetsLost, i.sendBitrate = t ? 8 * Math.max(0, i.sendBytes - t.sendBytes) : 0
                                    }
                                }
                                this.trafficStats && (i.sendPacketsLost = this.trafficStats.B_pvlr4 / 100), this.localStats.set(Hv.LocalAudioTrack, i), i && s && this.exceptionMonitor.setLocalAudioStats(this.store.uid, s.track, i);
                                break
                            }
                        }
                    })
                }

                updateRemoteStats(e) {
                    Array.from(this.remoteStats.entries()).forEach(t => {
                        let [r, {videoStats: n, audioStats: i, videoPcStats: o}] = t;
                        const s = i, a = n, c = o, u = DS({}, cv), d = DS({}, dv), l = DS({}, uv), {
                                audioTrack: h,
                                videoTrack: p,
                                audioSSRC: f,
                                videoSSRC: m
                            } = e.getRemoteMedia(r), _ = e.getStats(),
                            v = null == _ ? void 0 : _.audioRecv.find(e => e.ssrc === f),
                            g = null == _ ? void 0 : _.videoRecv.find(e => e.ssrc === m),
                            E = this.trafficStats && this.trafficStats.peer_delay.find(e => e.peer_uid === r);
                        if (v && ("opus" !== v.codec && "aac" !== v.codec && "PCMU" !== v.codec && "PCMA" !== v.codec && "G722" !== v.codec || (u.codecType = v.codec), v.outputLevel ? u.receiveLevel = Math.round(32767 * v.outputLevel) : h && (u.receiveLevel = Math.round(32767 * h.getVolumeLevel())), u.receiveBytes = v.bytes, u.receivePackets = v.packets, u.receivePacketsLost = v.packetsLost, u.packetLossRate = u.receivePacketsLost / (u.receivePackets + u.receivePacketsLost), u.receiveBitrate = s ? 8 * Math.max(0, u.receiveBytes - s.receiveBytes) : 0, u.totalDuration = s ? s.totalDuration + 1 : 1, u.totalFreezeTime = s ? s.totalFreezeTime : 0, u.freezeRate = u.totalFreezeTime / u.totalDuration, u.receiveDelay = v.jitterBufferMs, u.totalDuration > 10 && kS.isRemoteAudioFreeze(h) && (u.totalFreezeTime += 1)), g) {
                            "H264" !== g.codec && "VP8" !== g.codec && "VP9" !== g.codec && "AV1X" !== g.codec && "AV1" !== g.codec || (d.codecType = g.codec), d.receiveBytes = g.bytes, d.receiveBitrate = a ? 8 * Math.max(0, d.receiveBytes - a.receiveBytes) : 0, d.decodeFrameRate = g.decodeFrameRate < 0 ? 0 : g.decodeFrameRate, d.renderFrameRate = g.decodeFrameRate < 0 ? 0 : g.decodeFrameRate, g.outputFrame && (d.renderFrameRate = g.outputFrame.frameRate), g.receivedFrame ? (d.receiveFrameRate = g.receivedFrame.frameRate, d.receiveResolutionHeight = g.receivedFrame.height, d.receiveResolutionWidth = g.receivedFrame.width) : p && (d.receiveResolutionHeight = p._videoHeight || 0, d.receiveResolutionWidth = p._videoWidth || 0), void 0 !== g.framesRateFirefox && (d.receiveFrameRate = Math.round(g.framesRateFirefox)), d.receivePackets = g.packets, d.receivePacketsLost = g.packetsLost, d.packetLossRate = d.receivePacketsLost / (d.receivePackets + d.receivePacketsLost), d.totalDuration = a ? a.totalDuration + 1 : 1, d.totalFreezeTime = a ? a.totalFreezeTime : 0, d.receiveDelay = g.jitterBufferMs || 0;
                            const t = !!m && e.getRemoteVideoIsReady(m);
                            p && t && kS.isRemoteVideoFreeze(p, g, c) && (d.totalFreezeTime += 1), d.freezeRate = d.totalFreezeTime / d.totalDuration
                        }
                        E && (u.end2EndDelay = E.B_ad, d.end2EndDelay = E.B_vd, u.transportDelay = E.B_ed, d.transportDelay = E.B_ed, u.currentPacketLossRate = E.B_ealr4 / 100, d.currentPacketLossRate = E.B_evlr4 / 100, l.uplinkNetworkQuality = E.B_punq ? E.B_punq : 0, l.downlinkNetworkQuality = E.B_pdnq ? E.B_pdnq : 0), this.remoteStats.set(r, {
                            audioStats: u,
                            videoStats: d,
                            videoPcStats: g,
                            networkStats: l
                        }), h && this.exceptionMonitor.setRemoteAudioStats(h, u), p && this.exceptionMonitor.setRemoteVideoStats(p, d)
                    })
                }
            }

            function LS(e, t) {
                var r = Object.keys(e);
                if (Object.getOwnPropertySymbols) {
                    var n = Object.getOwnPropertySymbols(e);
                    t && (n = n.filter(function (t) {
                        return Object.getOwnPropertyDescriptor(e, t).enumerable
                    })), r.push.apply(r, n)
                }
                return r
            }

            function xS(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var r = null != arguments[t] ? arguments[t] : {};
                    t % 2 ? LS(Object(r), !0).forEach(function (t) {
                        Kh(e, t, r[t])
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : LS(Object(r)).forEach(function (t) {
                        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t))
                    })
                }
                return e
            }

            function MS(e) {
                return e.match(/^[\.\:\d]+$/) ? "".concat(e.replace(/[^\d]/g, "-"), ".").concat(fm("TURN_DOMAIN")) : (em.info("Cannot recognized as IP address ".concat(e, ". Used As Host instead")), e)
            }

            function US(e, t) {
                var r, n;
                const i = fm("GATEWAY_DOMAINS");
                let o = i[1] && -1 !== t.indexOf(i[1]) ? 1 : 0;
                e.addresses = e.addresses || [];
                const s = e.addresses.map(e => e.domain_prefix ? {address: "".concat(e.domain_prefix, ".").concat(i[o++ % i.length], ":").concat(e.port)} : e.ip.match(/^[\.\:\d]+$/) ? {
                    ip: e.ip,
                    port: e.port,
                    address: "".concat(e.ip.replace(/[^\d]/g, "-"), ".").concat(i[o++ % i.length], ":").concat(e.port)
                } : (em.info("Cannot recognized as IP address ".concat(e.ip, ". Used As Host instead")), {
                    ip: e.ip,
                    port: e.port,
                    address: "".concat(e.ip, ":").concat(e.port)
                }));
                if (null !== (r = e.detail) && void 0 !== r && r[18] && "string" == typeof (null === (n = e.detail) || void 0 === n ? void 0 : n[18])) {
                    const t = e.detail[18], r = null == t ? void 0 : t.split(";");
                    for (let e = 0; e < r.length; e++) {
                        var a;
                        const t = nh(a = r[e]).call(a);
                        s[e] && t && (s[e].ip6 = t)
                    }
                }
                return {
                    gatewayAddrs: s,
                    uid: e.uid,
                    cid: e.cid,
                    cert: e.cert,
                    vid: e.detail && e.detail[8],
                    uni_lbs_ip: e.detail && e.detail[1],
                    res: e,
                    csIp: e.detail && e.detail[502]
                }
            }

            function jS(e) {
                return "number" == typeof e ? e : e.exact || e.ideal || e.max || e.min || 0
            }

            function VS(e) {
                const t = e._encoderConfig;
                if (!t) return {};
                const r = {
                    resolution: t.width && t.height ? "".concat(jS(t.width), "x").concat(jS(t.height)) : void 0,
                    maxVideoBW: t.bitrateMax,
                    minVideoBW: t.bitrateMin
                };
                return "number" == typeof t.frameRate ? (r.maxFrameRate = t.frameRate, r.minFrameRate = t.frameRate) : t.frameRate && (r.maxFrameRate = t.frameRate.max || t.frameRate.ideal || t.frameRate.exact || t.frameRate.min, r.minFrameRate = t.frameRate.min || t.frameRate.ideal || t.frameRate.exact || t.frameRate.max), r
            }

            function FS(e, t, r) {
                var n;
                const i = t.videoSend.find(t => t.ssrc === e);
                if (!i) return null;
                const o = null == r || null === (n = r.videoSend.find(t => t.ssrc === e)) || void 0 === n ? void 0 : n.inputFrame,
                    s = {
                        id: YS(10, ""),
                        timestamp: new Date(t.timestamp).toISOString(),
                        mediaType: "video",
                        type: "ssrc",
                        ssrc: i.ssrc.toString()
                    };
                return i.inputFrame && (o && i.inputFrame.height === o.height || (s.A_fhi = i.inputFrame.height ? i.inputFrame.height.toString() : "0"), o && i.inputFrame.width === o.width || (s.A_fwi = i.inputFrame.width ? i.inputFrame.width.toString() : "0"), o && i.inputFrame.frameRate === o.frameRate || (s.A_fri = i.inputFrame.frameRate ? i.inputFrame.frameRate.toString() : "0")), s
            }

            function BS(e) {
                return e >= 0 && e < .17 ? 1 : e >= .17 && e < .36 ? 2 : e >= .36 && e < .59 ? 3 : e >= .59 && e <= 1 ? 4 : e > 1 ? 5 : 0
            }

            function WS(e, t) {
                let r, n, i = void 0;
                switch (t) {
                    case sg.CHOOSE_SERVER:
                        r = 4096, n = "choose server";
                        break;
                    case sg.CLOUD_PROXY:
                        r = 1048576, n = "proxy";
                        break;
                    case sg.CLOUD_PROXY_5:
                        r = 4194304, n = "proxy5";
                        break;
                    case sg.CLOUD_PROXY_FALLBACK:
                        r = 4194310, n = "proxy fallback";
                        break;
                    default:
                        throw new Hf(qf.UNEXPECTED_ERROR, "multi unlibs response transformer get unknown service id", {
                            csIp: e.detail && e.detail[502],
                            retry: !1
                        })
                }
                if (e.response_body.forEach(t => {
                    t.buffer && t.buffer.flag === r && (i = {
                        code: t.buffer.code,
                        addresses: (t.buffer.edges_services || []).map(e => xS(xS({}, e), {}, {ticket: t.buffer.cert})),
                        server_ts: e.enter_ts,
                        uid: t.buffer.uid,
                        cid: t.buffer.cid,
                        cname: t.buffer.cname,
                        detail: xS(xS({}, t.buffer.detail), e.detail),
                        flag: t.buffer.flag,
                        opid: e.opid,
                        cert: t.buffer.cert
                    })
                }), !i) throw new Hf(qf.MULTI_UNILBS_RESPONSE_ERROR, "cannot parse response ".concat(n, " from multi unilbs response"), {csIp: e.detail && e.detail[502]});
                return i
            }

            function GS(e) {
                let {candidateType: t, relayProtocol: r, type: n, address: i, port: o, protocol: s} = e;
                return "local-candidate" === n ? {candidateType: t, relayProtocol: r, protocol: s} : {
                    candidateType: t,
                    relayProtocol: r,
                    address: i,
                    port: o,
                    protocol: s
                }
            }

            function qS(e, t) {
                var r = Object.keys(e);
                if (Object.getOwnPropertySymbols) {
                    var n = Object.getOwnPropertySymbols(e);
                    t && (n = n.filter(function (t) {
                        return Object.getOwnPropertyDescriptor(e, t).enumerable
                    })), r.push.apply(r, n)
                }
                return r
            }

            function HS(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var r = null != arguments[t] ? arguments[t] : {};
                    t % 2 ? qS(Object(r), !0).forEach(function (t) {
                        Kh(e, t, r[t])
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : qS(Object(r)).forEach(function (t) {
                        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t))
                    })
                }
                return e
            }

            function KS(e) {
                return window.TextEncoder ? (new TextEncoder).encode(e).length : e.length
            }

            function zS(e) {
                return new sl(t => {
                    window.setTimeout(t, e)
                })
            }

            function YS() {
                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 7,
                    t = arguments.length > 1 ? arguments[1] : void 0;
                const r = Math.random().toString(16).substr(2, e).toLowerCase();
                return r.length === e ? "".concat(t).concat(r) : "".concat(t).concat(r) + YS(e - r.length, "")
            }

            function JS() {
                return YS(32, "").toUpperCase()
            }

            const XS = () => {
            };

            function QS(e) {
                return new sl((t, r) => {
                    let n = !1;
                    const i = document.createElement("video");
                    i.setAttribute("autoplay", ""), i.setAttribute("muted", ""), i.muted = !0, i.autoplay = !0, i.setAttribute("playsinline", ""), i.setAttribute("style", "position: fixed; top: 0; left: 0; width: 1px; height: 1px"), document.body.appendChild(i);
                    const o = Ch() ? "canplay" : "playing";
                    i.addEventListener(o, () => {
                        const e = i.videoWidth, r = i.videoHeight;
                        !e && wh() || (n = !0, i.srcObject = null, i.remove(), t([e, r]))
                    }), i.srcObject = new MediaStream([e]), i.play().catch(XS), setTimeout(() => {
                        n || (i.srcObject = null, i.remove(), t([i.videoWidth, i.videoHeight]))
                    }, 4e3)
                })
            }

            function $S(e) {
                return sl.all(e.map(e => e.then(e => {
                    throw e
                }, e => e))).then(e => {
                    throw e
                }, e => e)
            }

            function ZS(e, t) {
                for (var r = arguments.length, n = new Array(r > 2 ? r - 2 : 0), i = 2; i < r; i++) n[i - 2] = arguments[i];
                return 0 === e.getListeners(t).length ? sl.reject(new Hf(qf.UNEXPECTED_ERROR, "can not emit promise")) : new sl((r, i) => {
                    e.emit(t, ...n, r, i)
                })
            }

            function eb(e, t) {
                if (0 === e.getListeners(t).length) return sl.resolve();
                for (var r = arguments.length, n = new Array(r > 2 ? r - 2 : 0), i = 2; i < r; i++) n[i - 2] = arguments[i];
                return ZS(e, t, ...n)
            }

            function tb(e, t) {
                if (0 === e.getListeners(t).length) return null;
                for (var r = arguments.length, n = new Array(r > 2 ? r - 2 : 0), i = 2; i < r; i++) n[i - 2] = arguments[i];
                return rb(e, t, ...n)
            }

            function rb(e, t) {
                let r = null, n = null;
                for (var i = arguments.length, o = new Array(i > 2 ? i - 2 : 0), s = 2; s < i; s++) o[s - 2] = arguments[s];
                if (e.emit(t, ...o, e => {
                    r = e
                }, e => {
                    n = e
                }), null !== n) throw n;
                if (null === r) throw new Hf(qf.UNEXPECTED_ERROR, "handler is not sync");
                return r
            }

            function nb(e, t) {
                const r = e.indexOf(t);
                -1 !== r && e.splice(r, 1)
            }

            function ib(e) {
                const t = [];
                return e.forEach(e => {
                    -1 === t.indexOf(e) && t.push(e)
                }), t
            }

            function ob(e) {
                sl.resolve().then(e)
            }

            function sb(e) {
                return JSON.parse(JSON.stringify(e))
            }

            const ab = {};

            function cb(e, t) {
                ab[t] || (ab[t] = !0, e())
            }

            function ub(e) {
                const t = window.atob(e), r = new Uint8Array(new ArrayBuffer(t.length));
                for (let e = 0; e < t.length; e += 1) r[e] = t.charCodeAt(e);
                return r
            }

            function db(e) {
                let t = "";
                for (let r = 0; r < e.length; r += 1) t += String.fromCharCode(e[r]);
                return window.btoa(t)
            }

            const lb = new class {
                constructor() {
                    Kh(this, "fnMap", new Map)
                }

                throttleByKey(e, t, r, n) {
                    for (var i = arguments.length, o = new Array(i > 4 ? i - 4 : 0), s = 4; s < i; s++) o[s - 4] = arguments[s];
                    if (this.fnMap.has(t)) {
                        const i = this.fnMap.get(t);
                        if (i.threshold !== r) {
                            i.fn(...i.args), clearTimeout(i.timer);
                            const s = window.setTimeout(() => {
                                const e = this.fnMap.get(t);
                                e && e.fn(...e.args), this.fnMap.delete(t)
                            }, r);
                            this.fnMap.set(t, {fn: e, threshold: r, timer: s, args: o, skipFn: n})
                        } else i.skipFn && i.skipFn(...i.args), this.fnMap.set(t, HS(HS({}, i), {}, {
                            fn: e,
                            args: o,
                            skipFn: n
                        }))
                    } else {
                        const i = window.setTimeout(() => {
                            const e = this.fnMap.get(t);
                            e && e.fn(...e.args), this.fnMap.delete(t)
                        }, r);
                        this.fnMap.set(t, {fn: e, threshold: r, timer: i, args: o, skipFn: n})
                    }
                }
            }, hb = lb.throttleByKey.bind(lb), pb = async e => {
                let {
                    fragementLength: t,
                    referenceList: r,
                    asyncMapHandler: n,
                    allFailedhandler: i,
                    promisesCollector: o
                } = e, s = 0;
                const a = t;
                let c, u = 0;
                const d = async () => {
                    const e = (() => {
                        const e = s * a, t = e + a;
                        return r.slice(e, t).map(n)
                    })();
                    o && o.push(...e);
                    try {
                        c = await $S(e)
                    } catch (e) {
                        if (s++, !((u += a) >= r.length)) return void await d();
                        i(e)
                    }
                    e.forEach(e => e.cancel())
                };
                return await d(), c
            };

            function fb(e) {
                return "object" == typeof e && null !== e && !(e instanceof RegExp)
            }

            var mb = i, _b = ot("iterator"), vb = !mb(function () {
                    var e = new URL("b?a=1&b=2&c=3", "http://a"), t = e.searchParams, r = "";
                    return e.pathname = "c%20d", t.forEach(function (e, n) {
                        t.delete("b"), r += n + e
                    }), !e.toJSON || !t.sort || "http://a/c%20d?a=1&c=3" !== e.href || "3" !== t.get("c") || "a=1" !== String(new URLSearchParams("?a=1")) || !t[_b] || "a" !== new URL("https://a@b").username || "b" !== new URLSearchParams(new URLSearchParams("a=b")).get("a") || "xn--e1aybc" !== new URL("http://??").host || "#%D0%B1" !== new URL("http://a#").hash || "a1c3" !== r || "x" !== new URL("http://x", void 0).host
                }), gb = b, Eb = l, yb = I, Sb = i, bb = oi, Tb = Hn, Rb = w, Ib = Fe, wb = W, Cb = Object.assign,
                Ab = Object.defineProperty, Ob = Eb([].concat), Nb = !Cb || Sb(function () {
                    if (gb && 1 !== Cb({b: 1}, Cb(Ab({}, "a", {
                        enumerable: !0, get: function () {
                            Ab(this, "b", {value: 3, enumerable: !1})
                        }
                    }), {b: 2})).b) return !0;
                    var e = {}, t = {}, r = Symbol(), n = "abcdefghijklmnopqrst";
                    return e[r] = 7, n.split("").forEach(function (e) {
                        t[e] = e
                    }), 7 != Cb({}, e)[r] || bb(Cb({}, t)).join("") != n
                }) ? function (e, t) {
                    for (var r = Ib(e), n = arguments.length, i = 1, o = Tb.f, s = Rb.f; n > i;) for (var a, c = wb(arguments[i++]), u = o ? Ob(bb(c), o(c)) : bb(c), d = u.length, l = 0; d > l;) a = u[l++], gb && !yb(s, c, a) || (r[a] = c[a]);
                    return r
                } : Cb, Pb = Xt, Db = co, kb = Gt, Lb = I, xb = Fe, Mb = function (e, t, r, n) {
                    try {
                        return n ? t(Pb(r)[0], r[1]) : t(r)
                    } catch (t) {
                        Db(e, "throw", t)
                    }
                }, Ub = Mi, jb = Za, Vb = Ir, Fb = Cm, Bb = io, Wb = Qi, Gb = f.Array, qb = l, Hb = 2147483647,
                Kb = /[^\0-\u007E]/, zb = /[.\u3002\uFF0E\uFF61]/g,
                Yb = "Overflow: input needs wider integers to process", Jb = f.RangeError, Xb = qb(zb.exec),
                Qb = Math.floor, $b = String.fromCharCode, Zb = qb("".charCodeAt), eT = qb([].join), tT = qb([].push),
                rT = qb("".replace), nT = qb("".split), iT = qb("".toLowerCase), oT = function (e) {
                    return e + 22 + 75 * (e < 26)
                }, sT = function (e, t, r) {
                    var n = 0;
                    for (e = r ? Qb(e / 700) : e >> 1, e += Qb(e / t); e > 455;) e = Qb(e / 35), n += 36;
                    return Qb(n + 36 * e / (e + 38))
                }, aT = function (e) {
                    var t, r, n = [], i = (e = function (e) {
                        for (var t = [], r = 0, n = e.length; r < n;) {
                            var i = Zb(e, r++);
                            if (i >= 55296 && i <= 56319 && r < n) {
                                var o = Zb(e, r++);
                                56320 == (64512 & o) ? tT(t, ((1023 & i) << 10) + (1023 & o) + 65536) : (tT(t, i), r--)
                            } else tT(t, i)
                        }
                        return t
                    }(e)).length, o = 128, s = 0, a = 72;
                    for (t = 0; t < e.length; t++) (r = e[t]) < 128 && tT(n, $b(r));
                    var c = n.length, u = c;
                    for (c && tT(n, "-"); u < i;) {
                        var d = Hb;
                        for (t = 0; t < e.length; t++) (r = e[t]) >= o && r < d && (d = r);
                        var l = u + 1;
                        if (d - o > Qb((Hb - s) / l)) throw Jb(Yb);
                        for (s += (d - o) * l, o = d, t = 0; t < e.length; t++) {
                            if ((r = e[t]) < o && ++s > Hb) throw Jb(Yb);
                            if (r == o) {
                                for (var h = s, p = 36; ;) {
                                    var f = p <= a ? 1 : p >= a + 26 ? 26 : p - a;
                                    if (h < f) break;
                                    var m = h - f, _ = 36 - f;
                                    tT(n, $b(oT(f + m % _))), h = Qb(m / _), p += 36
                                }
                                tT(n, $b(oT(h))), a = sT(s, l, u == c), s = 0, u++
                            }
                        }
                        s++, o++
                    }
                    return eT(n, "")
                }, cT = f.TypeError, uT = Er, dT = f, lT = te, hT = I, pT = l, fT = vb, mT = Os, _T = Ra, vT = zs, gT = ea,
                ET = Ss, yT = Pa, ST = y, bT = Ge, TT = Gt, RT = Ki, IT = Xt, wT = J, CT = wo, AT = Ii, OT = D, NT = io,
                PT = Qi, DT = function (e, t) {
                    if (e < t) throw cT("Not enough arguments");
                    return e
                }, kT = Vm, LT = ot("iterator"), xT = "URLSearchParams", MT = "URLSearchParamsIterator", UT = ET.set,
                jT = ET.getterFor(xT), VT = ET.getterFor(MT), FT = lT("fetch"), BT = lT("Request"), WT = lT("Headers"),
                GT = BT && BT.prototype, qT = WT && WT.prototype, HT = dT.RegExp, KT = dT.TypeError,
                zT = dT.decodeURIComponent, YT = dT.encodeURIComponent, JT = pT("".charAt), XT = pT([].join),
                QT = pT([].push), $T = pT("".replace), ZT = pT([].shift), eR = pT([].splice), tR = pT("".split),
                rR = pT("".slice), nR = /\+/g, iR = Array(4), oR = function (e) {
                    return iR[e - 1] || (iR[e - 1] = HT("((?:%[\\da-f]{2}){" + e + "})", "gi"))
                }, sR = function (e) {
                    try {
                        return zT(e)
                    } catch (t) {
                        return e
                    }
                }, aR = function (e) {
                    var t = $T(e, nR, " "), r = 4;
                    try {
                        return zT(t)
                    } catch (e) {
                        for (; r;) t = $T(t, oR(r--), sR);
                        return t
                    }
                }, cR = /[!'()~]|%20/g, uR = {"!": "%21", "'": "%27", "(": "%28", ")": "%29", "~": "%7E", "%20": "+"},
                dR = function (e) {
                    return uR[e]
                }, lR = function (e) {
                    return $T(YT(e), cR, dR)
                }, hR = gT(function (e, t) {
                    UT(this, {type: MT, iterator: NT(jT(e).entries), kind: t})
                }, "Iterator", function () {
                    var e = VT(this), t = e.kind, r = e.iterator.next(), n = r.value;
                    return r.done || (r.value = "keys" === t ? n.key : "values" === t ? n.value : [n.key, n.value]), r
                }, !0), pR = function (e) {
                    this.entries = [], this.url = null, void 0 !== e && (wT(e) ? this.parseObject(e) : this.parseQuery("string" == typeof e ? "?" === JT(e, 0) ? rR(e, 1) : e : CT(e)))
                };
            pR.prototype = {
                type: xT, bindURL: function (e) {
                    this.url = e, this.update()
                }, parseObject: function (e) {
                    var t, r, n, i, o, s, a, c = PT(e);
                    if (c) for (r = (t = NT(e, c)).next; !(n = hT(r, t)).done;) {
                        if (o = (i = NT(IT(n.value))).next, (s = hT(o, i)).done || (a = hT(o, i)).done || !hT(o, i).done) throw KT("Expected sequence with length 2");
                        QT(this.entries, {key: CT(s.value), value: CT(a.value)})
                    } else for (var u in e) bT(e, u) && QT(this.entries, {key: u, value: CT(e[u])})
                }, parseQuery: function (e) {
                    if (e) for (var t, r, n = tR(e, "&"), i = 0; i < n.length;) (t = n[i++]).length && (r = tR(t, "="), QT(this.entries, {
                        key: aR(ZT(r)),
                        value: aR(XT(r, "="))
                    }))
                }, serialize: function () {
                    for (var e, t = this.entries, r = [], n = 0; n < t.length;) e = t[n++], QT(r, lR(e.key) + "=" + lR(e.value));
                    return XT(r, "&")
                }, update: function () {
                    this.entries.length = 0, this.parseQuery(this.url.query)
                }, updateURL: function () {
                    this.url && this.url.update()
                }
            };
            var fR = function () {
                yT(this, mR);
                var e = arguments.length > 0 ? arguments[0] : void 0;
                UT(this, new pR(e))
            }, mR = fR.prototype;
            if (_T(mR, {
                append: function (e, t) {
                    DT(arguments.length, 2);
                    var r = jT(this);
                    QT(r.entries, {key: CT(e), value: CT(t)}), r.updateURL()
                }, delete: function (e) {
                    DT(arguments.length, 1);
                    for (var t = jT(this), r = t.entries, n = CT(e), i = 0; i < r.length;) r[i].key === n ? eR(r, i, 1) : i++;
                    t.updateURL()
                }, get: function (e) {
                    DT(arguments.length, 1);
                    for (var t = jT(this).entries, r = CT(e), n = 0; n < t.length; n++) if (t[n].key === r) return t[n].value;
                    return null
                }, getAll: function (e) {
                    DT(arguments.length, 1);
                    for (var t = jT(this).entries, r = CT(e), n = [], i = 0; i < t.length; i++) t[i].key === r && QT(n, t[i].value);
                    return n
                }, has: function (e) {
                    DT(arguments.length, 1);
                    for (var t = jT(this).entries, r = CT(e), n = 0; n < t.length;) if (t[n++].key === r) return !0;
                    return !1
                }, set: function (e, t) {
                    DT(arguments.length, 1);
                    for (var r, n = jT(this), i = n.entries, o = !1, s = CT(e), a = CT(t), c = 0; c < i.length; c++) (r = i[c]).key === s && (o ? eR(i, c--, 1) : (o = !0, r.value = a));
                    o || QT(i, {key: s, value: a}), n.updateURL()
                }, sort: function () {
                    var e = jT(this);
                    kT(e.entries, function (e, t) {
                        return e.key > t.key ? 1 : -1
                    }), e.updateURL()
                }, forEach: function (e) {
                    for (var t, r = jT(this).entries, n = TT(e, arguments.length > 1 ? arguments[1] : void 0), i = 0; i < r.length;) n((t = r[i++]).value, t.key, this)
                }, keys: function () {
                    return new hR(this, "keys")
                }, values: function () {
                    return new hR(this, "values")
                }, entries: function () {
                    return new hR(this, "entries")
                }
            }, {enumerable: !0}), mT(mR, LT, mR.entries, {name: "entries"}), mT(mR, "toString", function () {
                return jT(this).serialize()
            }, {enumerable: !0}), vT(fR, xT), uT({global: !0, forced: !fT}, {URLSearchParams: fR}), !fT && ST(WT)) {
                var _R = pT(qT.has), vR = pT(qT.set), gR = function (e) {
                    if (wT(e)) {
                        var t, r = e.body;
                        if (RT(r) === xT) return t = e.headers ? new WT(e.headers) : new WT, _R(t, "content-type") || vR(t, "content-type", "application/x-www-form-urlencoded;charset=UTF-8"), AT(e, {
                            body: OT(0, CT(r)),
                            headers: OT(0, t)
                        })
                    }
                    return e
                };
                if (ST(FT) && uT({global: !0, enumerable: !0, forced: !0}, {
                    fetch: function (e) {
                        return FT(e, arguments.length > 1 ? gR(arguments[1]) : {})
                    }
                }), ST(BT)) {
                    var ER = function (e) {
                        return yT(this, GT), new BT(e, arguments.length > 1 ? gR(arguments[1]) : {})
                    };
                    GT.constructor = ER, ER.prototype = GT, uT({global: !0, forced: !0}, {Request: ER})
                }
            }
            var yR, SR = {URLSearchParams: fR, getState: jT}, bR = Er, TR = b, RR = vb, IR = f, wR = Gt, CR = l,
                AR = ri.f, OR = Os, NR = Pa, PR = Ge, DR = Nb, kR = function (e) {
                    var t = xb(e), r = jb(this), n = arguments.length, i = n > 1 ? arguments[1] : void 0, o = void 0 !== i;
                    o && (i = kb(i, n > 2 ? arguments[2] : void 0));
                    var s, a, c, u, d, l, h = Wb(t), p = 0;
                    if (!h || this == Gb && Ub(h)) for (s = Vb(t), a = r ? new this(s) : Gb(s); s > p; p++) l = o ? i(t[p], p) : t[p], Fb(a, p, l); else for (d = (u = Bb(t, h)).next, a = r ? new this : []; !(c = Lb(d, u)).done; p++) l = o ? Mb(u, i, [c.value, p], !0) : c.value, Fb(a, p, l);
                    return a.length = p, a
                }, LR = km, xR = Wd.codeAt, MR = wo, UR = zs, jR = SR, VR = Ss, FR = VR.set, BR = VR.getterFor("URL"),
                WR = jR.URLSearchParams, GR = jR.getState, qR = IR.URL, HR = IR.TypeError, KR = IR.parseInt,
                zR = Math.floor, YR = Math.pow, JR = CR("".charAt), XR = CR(/./.exec), QR = CR([].join),
                $R = CR(1..toString), ZR = CR([].pop), eI = CR([].push), tI = CR("".replace), rI = CR([].shift),
                nI = CR("".split), iI = CR("".slice), oI = CR("".toLowerCase), sI = CR([].unshift),
                aI = "Invalid scheme", cI = "Invalid host", uI = "Invalid port", dI = /[a-z]/i, lI = /[\d+-.a-z]/i,
                hI = /\d/, pI = /^0x/i, fI = /^[0-7]+$/, mI = /^\d+$/, _I = /^[\da-f]+$/i,
                vI = /[\0\t\n\r #%/:<>?@[\\\]^|]/, gI = /[\0\t\n\r #/:<>?@[\\\]^|]/,
                EI = /^[\u0000-\u0020]+|[\u0000-\u0020]+$/g, yI = /[\t\n\r]/g, SI = function (e) {
                    var t, r, n, i;
                    if ("number" == typeof e) {
                        for (t = [], r = 0; r < 4; r++) sI(t, e % 256), e = zR(e / 256);
                        return QR(t, ".")
                    }
                    if ("object" == typeof e) {
                        for (t = "", n = function (e) {
                            for (var t = null, r = 1, n = null, i = 0, o = 0; o < 8; o++) 0 !== e[o] ? (i > r && (t = n, r = i), n = null, i = 0) : (null === n && (n = o), ++i);
                            return i > r && (t = n, r = i), t
                        }(e), r = 0; r < 8; r++) i && 0 === e[r] || (i && (i = !1), n === r ? (t += r ? ":" : "::", i = !0) : (t += $R(e[r], 16), r < 7 && (t += ":")));
                        return "[" + t + "]"
                    }
                    return e
                }, bI = {}, TI = DR({}, bI, {" ": 1, '"': 1, "<": 1, ">": 1, "`": 1}),
                RI = DR({}, TI, {"#": 1, "?": 1, "{": 1, "}": 1}),
                II = DR({}, RI, {"/": 1, ":": 1, ";": 1, "=": 1, "@": 1, "[": 1, "\\": 1, "]": 1, "^": 1, "|": 1}),
                wI = function (e, t) {
                    var r = xR(e, 0);
                    return r > 32 && r < 127 && !PR(t, e) ? e : encodeURIComponent(e)
                }, CI = {ftp: 21, file: null, http: 80, https: 443, ws: 80, wss: 443}, AI = function (e, t) {
                    var r;
                    return 2 == e.length && XR(dI, JR(e, 0)) && (":" == (r = JR(e, 1)) || !t && "|" == r)
                }, OI = function (e) {
                    var t;
                    return e.length > 1 && AI(iI(e, 0, 2)) && (2 == e.length || "/" === (t = JR(e, 2)) || "\\" === t || "?" === t || "#" === t)
                }, NI = function (e) {
                    return "." === e || "%2e" === oI(e)
                }, PI = {}, DI = {}, kI = {}, LI = {}, xI = {}, MI = {}, UI = {}, jI = {}, VI = {}, FI = {}, BI = {},
                WI = {}, GI = {}, qI = {}, HI = {}, KI = {}, zI = {}, YI = {}, JI = {}, XI = {}, QI = {},
                $I = function (e, t, r) {
                    var n, i, o, s = MR(e);
                    if (t) {
                        if (i = this.parse(s)) throw HR(i);
                        this.searchParams = null
                    } else {
                        if (void 0 !== r && (n = new $I(r, !0)), i = this.parse(s, null, n)) throw HR(i);
                        (o = GR(new WR)).bindURL(this), this.searchParams = o
                    }
                };
            $I.prototype = {
                type: "URL", parse: function (e, t, r) {
                    var n, i, o, s, a, c = this, u = t || PI, d = 0, l = "", h = !1, p = !1, f = !1;
                    for (e = MR(e), t || (c.scheme = "", c.username = "", c.password = "", c.host = null, c.port = null, c.path = [], c.query = null, c.fragment = null, c.cannotBeABaseURL = !1, e = tI(e, EI, "")), e = tI(e, yI, ""), n = kR(e); d <= n.length;) {
                        switch (i = n[d], u) {
                            case PI:
                                if (!i || !XR(dI, i)) {
                                    if (t) return aI;
                                    u = kI;
                                    continue
                                }
                                l += oI(i), u = DI;
                                break;
                            case DI:
                                if (i && (XR(lI, i) || "+" == i || "-" == i || "." == i)) l += oI(i); else {
                                    if (":" != i) {
                                        if (t) return aI;
                                        l = "", u = kI, d = 0;
                                        continue
                                    }
                                    if (t && (c.isSpecial() != PR(CI, l) || "file" == l && (c.includesCredentials() || null !== c.port) || "file" == c.scheme && !c.host)) return;
                                    if (c.scheme = l, t) return void (c.isSpecial() && CI[c.scheme] == c.port && (c.port = null));
                                    l = "", "file" == c.scheme ? u = qI : c.isSpecial() && r && r.scheme == c.scheme ? u = LI : c.isSpecial() ? u = jI : "/" == n[d + 1] ? (u = xI, d++) : (c.cannotBeABaseURL = !0, eI(c.path, ""), u = JI)
                                }
                                break;
                            case kI:
                                if (!r || r.cannotBeABaseURL && "#" != i) return aI;
                                if (r.cannotBeABaseURL && "#" == i) {
                                    c.scheme = r.scheme, c.path = LR(r.path), c.query = r.query, c.fragment = "", c.cannotBeABaseURL = !0, u = QI;
                                    break
                                }
                                u = "file" == r.scheme ? qI : MI;
                                continue;
                            case LI:
                                if ("/" != i || "/" != n[d + 1]) {
                                    u = MI;
                                    continue
                                }
                                u = VI, d++;
                                break;
                            case xI:
                                if ("/" == i) {
                                    u = FI;
                                    break
                                }
                                u = YI;
                                continue;
                            case MI:
                                if (c.scheme = r.scheme, i == yR) c.username = r.username, c.password = r.password, c.host = r.host, c.port = r.port, c.path = LR(r.path), c.query = r.query; else if ("/" == i || "\\" == i && c.isSpecial()) u = UI; else if ("?" == i) c.username = r.username, c.password = r.password, c.host = r.host, c.port = r.port, c.path = LR(r.path), c.query = "", u = XI; else {
                                    if ("#" != i) {
                                        c.username = r.username, c.password = r.password, c.host = r.host, c.port = r.port, c.path = LR(r.path), c.path.length--, u = YI;
                                        continue
                                    }
                                    c.username = r.username, c.password = r.password, c.host = r.host, c.port = r.port, c.path = LR(r.path), c.query = r.query, c.fragment = "", u = QI
                                }
                                break;
                            case UI:
                                if (!c.isSpecial() || "/" != i && "\\" != i) {
                                    if ("/" != i) {
                                        c.username = r.username, c.password = r.password, c.host = r.host, c.port = r.port, u = YI;
                                        continue
                                    }
                                    u = FI
                                } else u = VI;
                                break;
                            case jI:
                                if (u = VI, "/" != i || "/" != JR(l, d + 1)) continue;
                                d++;
                                break;
                            case VI:
                                if ("/" != i && "\\" != i) {
                                    u = FI;
                                    continue
                                }
                                break;
                            case FI:
                                if ("@" == i) {
                                    h && (l = "%40" + l), h = !0, o = kR(l);
                                    for (var m = 0; m < o.length; m++) {
                                        var _ = o[m];
                                        if (":" != _ || f) {
                                            var v = wI(_, II);
                                            f ? c.password += v : c.username += v
                                        } else f = !0
                                    }
                                    l = ""
                                } else if (i == yR || "/" == i || "?" == i || "#" == i || "\\" == i && c.isSpecial()) {
                                    if (h && "" == l) return "Invalid authority";
                                    d -= kR(l).length + 1, l = "", u = BI
                                } else l += i;
                                break;
                            case BI:
                            case WI:
                                if (t && "file" == c.scheme) {
                                    u = KI;
                                    continue
                                }
                                if (":" != i || p) {
                                    if (i == yR || "/" == i || "?" == i || "#" == i || "\\" == i && c.isSpecial()) {
                                        if (c.isSpecial() && "" == l) return cI;
                                        if (t && "" == l && (c.includesCredentials() || null !== c.port)) return;
                                        if (s = c.parseHost(l)) return s;
                                        if (l = "", u = zI, t) return;
                                        continue
                                    }
                                    "[" == i ? p = !0 : "]" == i && (p = !1), l += i
                                } else {
                                    if ("" == l) return cI;
                                    if (s = c.parseHost(l)) return s;
                                    if (l = "", u = GI, t == WI) return
                                }
                                break;
                            case GI:
                                if (!XR(hI, i)) {
                                    if (i == yR || "/" == i || "?" == i || "#" == i || "\\" == i && c.isSpecial() || t) {
                                        if ("" != l) {
                                            var g = KR(l, 10);
                                            if (g > 65535) return uI;
                                            c.port = c.isSpecial() && g === CI[c.scheme] ? null : g, l = ""
                                        }
                                        if (t) return;
                                        u = zI;
                                        continue
                                    }
                                    return uI
                                }
                                l += i;
                                break;
                            case qI:
                                if (c.scheme = "file", "/" == i || "\\" == i) u = HI; else {
                                    if (!r || "file" != r.scheme) {
                                        u = YI;
                                        continue
                                    }
                                    if (i == yR) c.host = r.host, c.path = LR(r.path), c.query = r.query; else if ("?" == i) c.host = r.host, c.path = LR(r.path), c.query = "", u = XI; else {
                                        if ("#" != i) {
                                            OI(QR(LR(n, d), "")) || (c.host = r.host, c.path = LR(r.path), c.shortenPath()), u = YI;
                                            continue
                                        }
                                        c.host = r.host, c.path = LR(r.path), c.query = r.query, c.fragment = "", u = QI
                                    }
                                }
                                break;
                            case HI:
                                if ("/" == i || "\\" == i) {
                                    u = KI;
                                    break
                                }
                                r && "file" == r.scheme && !OI(QR(LR(n, d), "")) && (AI(r.path[0], !0) ? eI(c.path, r.path[0]) : c.host = r.host), u = YI;
                                continue;
                            case KI:
                                if (i == yR || "/" == i || "\\" == i || "?" == i || "#" == i) {
                                    if (!t && AI(l)) u = YI; else if ("" == l) {
                                        if (c.host = "", t) return;
                                        u = zI
                                    } else {
                                        if (s = c.parseHost(l)) return s;
                                        if ("localhost" == c.host && (c.host = ""), t) return;
                                        l = "", u = zI
                                    }
                                    continue
                                }
                                l += i;
                                break;
                            case zI:
                                if (c.isSpecial()) {
                                    if (u = YI, "/" != i && "\\" != i) continue
                                } else if (t || "?" != i) if (t || "#" != i) {
                                    if (i != yR && (u = YI, "/" != i)) continue
                                } else c.fragment = "", u = QI; else c.query = "", u = XI;
                                break;
                            case YI:
                                if (i == yR || "/" == i || "\\" == i && c.isSpecial() || !t && ("?" == i || "#" == i)) {
                                    if (".." === (a = oI(a = l)) || "%2e." === a || ".%2e" === a || "%2e%2e" === a ? (c.shortenPath(), "/" == i || "\\" == i && c.isSpecial() || eI(c.path, "")) : NI(l) ? "/" == i || "\\" == i && c.isSpecial() || eI(c.path, "") : ("file" == c.scheme && !c.path.length && AI(l) && (c.host && (c.host = ""), l = JR(l, 0) + ":"), eI(c.path, l)), l = "", "file" == c.scheme && (i == yR || "?" == i || "#" == i)) for (; c.path.length > 1 && "" === c.path[0];) rI(c.path);
                                    "?" == i ? (c.query = "", u = XI) : "#" == i && (c.fragment = "", u = QI)
                                } else l += wI(i, RI);
                                break;
                            case JI:
                                "?" == i ? (c.query = "", u = XI) : "#" == i ? (c.fragment = "", u = QI) : i != yR && (c.path[0] += wI(i, bI));
                                break;
                            case XI:
                                t || "#" != i ? i != yR && ("'" == i && c.isSpecial() ? c.query += "%27" : c.query += "#" == i ? "%23" : wI(i, bI)) : (c.fragment = "", u = QI);
                                break;
                            case QI:
                                i != yR && (c.fragment += wI(i, TI))
                        }
                        d++
                    }
                }, parseHost: function (e) {
                    var t, r, n;
                    if ("[" == JR(e, 0)) {
                        if ("]" != JR(e, e.length - 1)) return cI;
                        if (!(t = function (e) {
                            var t, r, n, i, o, s, a, c = [0, 0, 0, 0, 0, 0, 0, 0], u = 0, d = null, l = 0,
                                h = function () {
                                    return JR(e, l)
                                };
                            if (":" == h()) {
                                if (":" != JR(e, 1)) return;
                                l += 2, d = ++u
                            }
                            for (; h();) {
                                if (8 == u) return;
                                if (":" != h()) {
                                    for (t = r = 0; r < 4 && XR(_I, h());) t = 16 * t + KR(h(), 16), l++, r++;
                                    if ("." == h()) {
                                        if (0 == r) return;
                                        if (l -= r, u > 6) return;
                                        for (n = 0; h();) {
                                            if (i = null, n > 0) {
                                                if (!("." == h() && n < 4)) return;
                                                l++
                                            }
                                            if (!XR(hI, h())) return;
                                            for (; XR(hI, h());) {
                                                if (o = KR(h(), 10), null === i) i = o; else {
                                                    if (0 == i) return;
                                                    i = 10 * i + o
                                                }
                                                if (i > 255) return;
                                                l++
                                            }
                                            c[u] = 256 * c[u] + i, 2 != ++n && 4 != n || u++
                                        }
                                        if (4 != n) return;
                                        break
                                    }
                                    if (":" == h()) {
                                        if (l++, !h()) return
                                    } else if (h()) return;
                                    c[u++] = t
                                } else {
                                    if (null !== d) return;
                                    l++, d = ++u
                                }
                            }
                            if (null !== d) for (s = u - d, u = 7; 0 != u && s > 0;) a = c[u], c[u--] = c[d + s - 1], c[d + --s] = a; else if (8 != u) return;
                            return c
                        }(iI(e, 1, -1)))) return cI;
                        this.host = t
                    } else if (this.isSpecial()) {
                        if (e = function (e) {
                            var t, r, n = [], i = nT(rT(iT(e), zb, "."), ".");
                            for (t = 0; t < i.length; t++) r = i[t], tT(n, Xb(Kb, r) ? "xn--" + aT(r) : r);
                            return eT(n, ".")
                        }(e), XR(vI, e)) return cI;
                        if (null === (t = function (e) {
                            var t, r, n, i, o, s, a, c = nI(e, ".");
                            if (c.length && "" == c[c.length - 1] && c.length--, (t = c.length) > 4) return e;
                            for (r = [], n = 0; n < t; n++) {
                                if ("" == (i = c[n])) return e;
                                if (o = 10, i.length > 1 && "0" == JR(i, 0) && (o = XR(pI, i) ? 16 : 8, i = iI(i, 8 == o ? 1 : 2)), "" === i) s = 0; else {
                                    if (!XR(10 == o ? mI : 8 == o ? fI : _I, i)) return e;
                                    s = KR(i, o)
                                }
                                eI(r, s)
                            }
                            for (n = 0; n < t; n++) if (s = r[n], n == t - 1) {
                                if (s >= YR(256, 5 - t)) return null
                            } else if (s > 255) return null;
                            for (a = ZR(r), n = 0; n < r.length; n++) a += r[n] * YR(256, 3 - n);
                            return a
                        }(e))) return cI;
                        this.host = t
                    } else {
                        if (XR(gI, e)) return cI;
                        for (t = "", r = kR(e), n = 0; n < r.length; n++) t += wI(r[n], bI);
                        this.host = t
                    }
                }, cannotHaveUsernamePasswordPort: function () {
                    return !this.host || this.cannotBeABaseURL || "file" == this.scheme
                }, includesCredentials: function () {
                    return "" != this.username || "" != this.password
                }, isSpecial: function () {
                    return PR(CI, this.scheme)
                }, shortenPath: function () {
                    var e = this.path, t = e.length;
                    !t || "file" == this.scheme && 1 == t && AI(e[0], !0) || e.length--
                }, serialize: function () {
                    var e = this, t = e.scheme, r = e.username, n = e.password, i = e.host, o = e.port, s = e.path,
                        a = e.query, c = e.fragment, u = t + ":";
                    return null !== i ? (u += "//", e.includesCredentials() && (u += r + (n ? ":" + n : "") + "@"), u += SI(i), null !== o && (u += ":" + o)) : "file" == t && (u += "//"), u += e.cannotBeABaseURL ? s[0] : s.length ? "/" + QR(s, "/") : "", null !== a && (u += "?" + a), null !== c && (u += "#" + c), u
                }, setHref: function (e) {
                    var t = this.parse(e);
                    if (t) throw HR(t);
                    this.searchParams.update()
                }, getOrigin: function () {
                    var e = this.scheme, t = this.port;
                    if ("blob" == e) try {
                        return new ZI(e.path[0]).origin
                    } catch (e) {
                        return "null"
                    }
                    return "file" != e && this.isSpecial() ? e + "://" + SI(this.host) + (null !== t ? ":" + t : "") : "null"
                }, getProtocol: function () {
                    return this.scheme + ":"
                }, setProtocol: function (e) {
                    this.parse(MR(e) + ":", PI)
                }, getUsername: function () {
                    return this.username
                }, setUsername: function (e) {
                    var t = kR(MR(e));
                    if (!this.cannotHaveUsernamePasswordPort()) {
                        this.username = "";
                        for (var r = 0; r < t.length; r++) this.username += wI(t[r], II)
                    }
                }, getPassword: function () {
                    return this.password
                }, setPassword: function (e) {
                    var t = kR(MR(e));
                    if (!this.cannotHaveUsernamePasswordPort()) {
                        this.password = "";
                        for (var r = 0; r < t.length; r++) this.password += wI(t[r], II)
                    }
                }, getHost: function () {
                    var e = this.host, t = this.port;
                    return null === e ? "" : null === t ? SI(e) : SI(e) + ":" + t
                }, setHost: function (e) {
                    this.cannotBeABaseURL || this.parse(e, BI)
                }, getHostname: function () {
                    var e = this.host;
                    return null === e ? "" : SI(e)
                }, setHostname: function (e) {
                    this.cannotBeABaseURL || this.parse(e, WI)
                }, getPort: function () {
                    var e = this.port;
                    return null === e ? "" : MR(e)
                }, setPort: function (e) {
                    this.cannotHaveUsernamePasswordPort() || ("" == (e = MR(e)) ? this.port = null : this.parse(e, GI))
                }, getPathname: function () {
                    var e = this.path;
                    return this.cannotBeABaseURL ? e[0] : e.length ? "/" + QR(e, "/") : ""
                }, setPathname: function (e) {
                    this.cannotBeABaseURL || (this.path = [], this.parse(e, zI))
                }, getSearch: function () {
                    var e = this.query;
                    return e ? "?" + e : ""
                }, setSearch: function (e) {
                    "" == (e = MR(e)) ? this.query = null : ("?" == JR(e, 0) && (e = iI(e, 1)), this.query = "", this.parse(e, XI)), this.searchParams.update()
                }, getSearchParams: function () {
                    return this.searchParams.facade
                }, getHash: function () {
                    var e = this.fragment;
                    return e ? "#" + e : ""
                }, setHash: function (e) {
                    "" != (e = MR(e)) ? ("#" == JR(e, 0) && (e = iI(e, 1)), this.fragment = "", this.parse(e, QI)) : this.fragment = null
                }, update: function () {
                    this.query = this.searchParams.serialize() || null
                }
            };
            var ZI = function (e) {
                var t = NR(this, ew), r = arguments.length > 1 ? arguments[1] : void 0, n = FR(t, new $I(e, !1, r));
                TR || (t.href = n.serialize(), t.origin = n.getOrigin(), t.protocol = n.getProtocol(), t.username = n.getUsername(), t.password = n.getPassword(), t.host = n.getHost(), t.hostname = n.getHostname(), t.port = n.getPort(), t.pathname = n.getPathname(), t.search = n.getSearch(), t.searchParams = n.getSearchParams(), t.hash = n.getHash())
            }, ew = ZI.prototype, tw = function (e, t) {
                return {
                    get: function () {
                        return BR(this)[e]()
                    }, set: t && function (e) {
                        return BR(this)[t](e)
                    }, configurable: !0, enumerable: !0
                }
            };
            if (TR && AR(ew, {
                href: tw("serialize", "setHref"),
                origin: tw("getOrigin"),
                protocol: tw("getProtocol", "setProtocol"),
                username: tw("getUsername", "setUsername"),
                password: tw("getPassword", "setPassword"),
                host: tw("getHost", "setHost"),
                hostname: tw("getHostname", "setHostname"),
                port: tw("getPort", "setPort"),
                pathname: tw("getPathname", "setPathname"),
                search: tw("getSearch", "setSearch"),
                searchParams: tw("getSearchParams"),
                hash: tw("getHash", "setHash")
            }), OR(ew, "toJSON", function () {
                return BR(this).serialize()
            }, {enumerable: !0}), OR(ew, "toString", function () {
                return BR(this).serialize()
            }, {enumerable: !0}), qR) {
                var rw = qR.createObjectURL, nw = qR.revokeObjectURL;
                rw && OR(ZI, "createObjectURL", wR(rw, qR)), nw && OR(ZI, "revokeObjectURL", wR(nw, qR))
            }
            UR(ZI, "URL"), bR({global: !0, forced: !RR, sham: !TR}, {URL: ZI});
            var iw = X.URL;
            const ow = {
                [F_.ACCESS_POINT]: {
                    [G_.NO_FLAG_SET]: {desc: "flag is zero", retry: !1},
                    [G_.FLAG_SET_BUT_EMPTY]: {desc: "flag is empty", retry: !1},
                    [G_.INVALID_FALG_SET]: {desc: "invalid flag", retry: !1},
                    [G_.FLAG_SET_BUT_NO_RE]: {desc: "flag set unilbs but no request", retry: !1},
                    [G_.INVALID_SERVICE_ID]: {desc: "invalid service id", retry: !1},
                    [G_.NO_SERVICE_AVAILABLE]: {desc: "no service available", retry: !0},
                    [G_.NO_SERVICE_AVAILABLE_P2P]: {desc: "no unilbs p2p service available", retry: !0},
                    [G_.NO_SERVICE_AVAILABLE_VOET]: {desc: "no unilbs voice service available", retry: !0},
                    [G_.NO_SERVICE_AVAILABLE_WEBRTC]: {desc: "no unilbs webrtc service available", retry: !0},
                    [G_.NO_SERVICE_AVAILABLE_CDS]: {desc: "no cds service available", retry: !0},
                    [G_.NO_SERVICE_AVAILABLE_CDN]: {desc: "no cdn dispatcher service available", retry: !0},
                    [G_.NO_SERVICE_AVAILABLE_TDS]: {desc: "no tds service available", retry: !0},
                    [G_.NO_SERVICE_AVAILABLE_REPORT]: {desc: "no unilbs report service available", retry: !0},
                    [G_.NO_SERVICE_AVAILABLE_APP_CENTER]: {desc: "no app center service available", retry: !0},
                    [G_.NO_SERVICE_AVAILABLE_ENV0]: {desc: "no unilbs sig env0 service available", retry: !0},
                    [G_.NO_SERVICE_AVAILABLE_VOET]: {desc: "no unilbs voet service available", retry: !0},
                    [G_.NO_SERVICE_AVAILABLE_STRING_UID]: {desc: "no string uid service available", retry: !0},
                    [G_.NO_SERVICE_AVAILABLE_WEBRTC_UNILBS]: {desc: "no webrtc unilbs service available", retry: !0}
                },
                [F_.UNILBS]: {
                    [W_.INVALID_VENDOR_KEY]: {desc: "invalid vendor key, can not find appid", retry: !1},
                    [W_.INVALID_CHANNEL_NAME]: {desc: "invalid channel name", retry: !1},
                    [W_.INTERNAL_ERROR]: {desc: "unilbs internal error", retry: !1},
                    [W_.NO_AUTHORIZED]: {desc: "invalid token, authorized failed", retry: !1},
                    [W_.DYNAMIC_KEY_TIMEOUT]: {desc: "dynamic key or token timeout", retry: !1},
                    [W_.NO_ACTIVE_STATUS]: {desc: "no active status", retry: !1},
                    [W_.DYNAMIC_KEY_EXPIRED]: {desc: "dynamic key expired", retry: !1},
                    [W_.STATIC_USE_DYNAMIC_KEY]: {desc: "static use dynamic key", retry: !1},
                    [W_.DYNAMIC_USE_STATIC_KEY]: {desc: "dynamic use static key", retry: !1},
                    [W_.USER_OVERLOAD]: {desc: "amount of users over load", retry: !1},
                    [W_.FORBIDDEN_REGION]: {desc: "the request is forbidden in this area", retry: !1},
                    [W_.CANNOT_MEET_AREA_DEMAND]: {desc: "unable to allocate services in this area", retry: !1}
                },
                [F_.STRING_UID_ALLOCATOR]: {
                    [B_.IIIEGAL_APPID]: {desc: "invalid appid", retry: !1},
                    [B_.IIIEGAL_UID]: {desc: "invalid string uid", retry: !1},
                    [B_.INTERNAL_ERROR]: {desc: "string uid allocator internal error", retry: !0}
                }
            };

            function sw(e) {
                const t = ow[Math.floor(e / 1e4)];
                if (!t) return {desc: "unkonw error", retry: !1};
                const r = t[e % 1e4];
                if (!r) {
                    if (Math.floor(e / 1e4) === F_.ACCESS_POINT) {
                        const t = e % 1e4;
                        if ("1" === t.toString()[0]) return {desc: e.toString(), retry: !1};
                        if ("2" === t.toString()[0]) return {desc: e.toString(), retry: !0}
                    }
                    return {desc: "unkonw error", retry: !1}
                }
                return r
            }

            const aw = {
                [q_.K_TIMESTAMP_EXPIRED]: {desc: "K_TIMESTAMP_EXPIRED", action: "failed"},
                [q_.K_CHANNEL_PERMISSION_INVALID]: {desc: "K_CHANNEL_PERMISSION_INVALID", action: "failed"},
                [q_.K_CERTIFICATE_INVALID]: {desc: "K_CERTIFICATE_INVALID", action: "failed"},
                [q_.K_CHANNEL_NAME_EMPTY]: {desc: "K_CHANNEL_NAME_EMPTY", action: "failed"},
                [q_.K_CHANNEL_NOT_FOUND]: {desc: "K_CHANNEL_NOT_FOUND", action: "failed"},
                [q_.K_TICKET_INVALID]: {desc: "K_TICKET_INVALID", action: "failed"},
                [q_.K_CHANNEL_CONFLICTED]: {desc: "K_CHANNEL_CONFLICTED", action: "failed"},
                [q_.K_SERVICE_NOT_READY]: {desc: "K_SERVICE_NOT_READY", action: "tryNext"},
                [q_.K_SERVICE_TOO_HEAVY]: {desc: "K_SERVICE_TOO_HEAVY", action: "tryNext"},
                [q_.K_UID_BANNED]: {desc: "K_UID_BANNED", action: "failed"},
                [q_.K_IP_BANNED]: {desc: "K_IP_BANNED", action: "failed"},
                [q_.ERR_INVALID_VENDOR_KEY]: {desc: "ERR_INVALID_VENDOR_KEY", action: "failed"},
                [q_.ERR_INVALID_CHANNEL_NAME]: {desc: "ERR_INVALID_CHANNEL_NAME", action: "failed"},
                [q_.WARN_NO_AVAILABLE_CHANNEL]: {desc: "WARN_NO_AVAILABLE_CHANNEL", action: "failed"},
                [q_.WARN_LOOKUP_CHANNEL_TIMEOUT]: {desc: "WARN_LOOKUP_CHANNEL_TIMEOUT", action: "tryNext"},
                [q_.WARN_LOOKUP_CHANNEL_REJECTED]: {desc: "WARN_LOOKUP_CHANNEL_REJECTED", action: "failed"},
                [q_.WARN_OPEN_CHANNEL_TIMEOUT]: {desc: "WARN_OPEN_CHANNEL_TIMEOUT", action: "tryNext"},
                [q_.WARN_OPEN_CHANNEL_REJECTED]: {desc: "WARN_OPEN_CHANNEL_REJECTED", action: "failed"},
                [q_.WARN_REQUEST_DEFERRED]: {desc: "WARN_REQUEST_DEFERRED", action: "failed"},
                [q_.ERR_DYNAMIC_KEY_TIMEOUT]: {desc: "ERR_DYNAMIC_KEY_TIMEOUT", action: "failed"},
                [q_.ERR_NO_AUTHORIZED]: {desc: "ERR_NO_AUTHORIZED", action: "failed"},
                [q_.ERR_VOM_SERVICE_UNAVAILABLE]: {desc: "ERR_VOM_SERVICE_UNAVAILABLE", action: "tryNext"},
                [q_.ERR_NO_CHANNEL_AVAILABLE_CODE]: {desc: "ERR_NO_CHANNEL_AVAILABLE_CODE", action: "failed"},
                [q_.ERR_MASTER_VOCS_UNAVAILABLE]: {desc: "ERR_MASTER_VOCS_UNAVAILABLE", action: "tryNext"},
                [q_.ERR_INTERNAL_ERROR]: {desc: "ERR_INTERNAL_ERROR", action: "tryNext"},
                [q_.ERR_NO_ACTIVE_STATUS]: {desc: "ERR_NO_ACTIVE_STATUS", action: "failed"},
                [q_.ERR_INVALID_UID]: {desc: "ERR_INVALID_UID", action: "failed"},
                [q_.ERR_DYNAMIC_KEY_EXPIRED]: {desc: "ERR_DYNAMIC_KEY_EXPIRED", action: "failed"},
                [q_.ERR_STATIC_USE_DYANMIC_KE]: {desc: "ERR_STATIC_USE_DYANMIC_KE", action: "failed"},
                [q_.ERR_DYNAMIC_USE_STATIC_KE]: {desc: "ERR_DYNAMIC_USE_STATIC_KE", action: "failed"},
                [q_.ERR_NO_VOCS_AVAILABLE]: {desc: "ERR_NO_VOCS_AVAILABLE", action: "tryNext"},
                [q_.ERR_NO_VOS_AVAILABLE]: {desc: "ERR_NO_VOS_AVAILABLE", action: "tryNext"},
                [q_.ERR_JOIN_CHANNEL_TIMEOUT]: {desc: "ERR_JOIN_CHANNEL_TIMEOUT", action: "tryNext"},
                [q_.ERR_JOIN_BY_MULTI_IP]: {desc: "ERR_JOIN_BY_MULTI_IP", action: "recover"},
                [q_.ERR_NOT_JOINED]: {desc: "ERR_NOT_JOINED", action: "failed"},
                [q_.ERR_REPEAT_JOIN_REQUEST]: {desc: "ERR_REPEAT_JOIN_REQUEST", action: "quit"},
                [q_.ERR_REPEAT_JOIN_CHANNEL]: {desc: "ERR_REPEAT_JOIN_CHANNEL", action: "quit"},
                [q_.ERR_INVALID_VENDOR_KEY]: {desc: "ERR_INVALID_VENDOR_KEY", action: "failed"},
                [q_.ERR_INVALID_CHANNEL_NAME]: {desc: "ERR_INVALID_CHANNEL_NAME", action: "failed"},
                [q_.ERR_INVALID_STRINGUID]: {desc: "ERR_INVALID_STRINGUID", action: "failed"},
                [q_.ERR_TOO_MANY_USERS]: {desc: "ERR_TOO_MANY_USERS", action: "tryNext"},
                [q_.ERR_SET_CLIENT_ROLE_TIMEOUT]: {desc: "ERR_SET_CLIENT_ROLE_TIMEOUT", action: "failed"},
                [q_.ERR_SET_CLIENT_ROLE_NO_PERMISSION]: {desc: "ERR_SET_CLIENT_ROLE_TIMEOUT", action: "failed"},
                [q_.ERR_SET_CLIENT_ROLE_ALREADY_IN_USE]: {
                    desc: "ERR_SET_CLIENT_ROLE_ALREADY_IN_USE",
                    action: "success"
                },
                [q_.ERR_PUBLISH_REQUEST_INVALID]: {desc: "ERR_PUBLISH_REQUEST_INVALID", action: "failed"},
                [q_.ERR_SUBSCRIBE_REQUEST_INVALID]: {desc: "ERR_SUBSCRIBE_REQUEST_INVALID", action: "failed"},
                [q_.ERR_NOT_SUPPORTED_MESSAGE]: {desc: "ERR_NOT_SUPPORTED_MESSAGE", action: "failed"},
                [q_.ERR_ILLEAGAL_PLUGIN]: {desc: "ERR_ILLEAGAL_PLUGIN", action: "failed"},
                [q_.ILLEGAL_CLIENT_ROLE_LEVEL]: {desc: "ILLEGAL_CLIENT_ROLE_LEVEL", action: "failed"},
                [q_.ERR_REJOIN_TOKEN_INVALID]: {desc: "ERR_REJOIN_TOKEN_INVALID", action: "failed"},
                [q_.ERR_REJOIN_USER_NOT_JOINED]: {desc: "ERR_REJOIN_NOT_JOINED", action: "failed"},
                [q_.ERR_INVALID_OPTIONAL_INFO]: {desc: "ERR_INVALID_OPTIONAL_INFO", action: "quit"},
                [q_.ERR_TEST_RECOVER]: {desc: "ERR_TEST_RECOVER", action: "recover"},
                [q_.ERR_TEST_TRYNEXT]: {desc: "ERR_TEST_TRYNEXT", action: "recover"},
                [q_.ERR_TEST_RETRY]: {desc: "ERR_TEST_RETRY", action: "recover"},
                [q_.ILLEGAL_AES_PASSWORD]: {desc: "ERR_TEST_RETRY", action: "failed"},
                [q_.ERR_TOO_MANY_BROADCASTERS]: {desc: "ERR_TOO_MANY_BROADCASTERS", action: "failed"},
                [q_.ERR_TOO_MANY_SUBSCRIBERS]: {desc: "ERR_TOO_MANY_SUBSCRIBERS", action: "failed"},
                [q_.ERR_LICENSE_ILLEGAL]: {desc: "ERR_LICENSE_ILLEGAL", action: "quit"},
                [q_.ERR_LICENSE_MISSING]: {desc: "ERR_LICENSE_MISSING", action: "quit"},
                [q_.ERR_LICENSE_EXPIRED]: {desc: "ERR_LICENSE_EXPIRED", action: "quit"},
                [q_.ERR_LICENSE_MINUTES_EXCEEDED]: {desc: "ERR_LICENSE_MINUTES_EXCEEDED", action: "quit"},
                [q_.ERR_LICENSE_PERIOD_INVALID]: {desc: "ERR_LICENSE_PERIOD_INVALID", action: "quit"},
                [q_.ERR_LICENSE_MULTIPLE_SDK_SERVICE]: {desc: "ERR_LICENSE_MULTIPLE_SDK_SERVICE", action: "quit"}
            };

            function cw(e) {
                const t = aw[e];
                return t || {desc: "UNKNOW_ERROR_".concat(e), action: "failed"}
            }

            class uw extends Wf {
                get queue() {
                    return [...this.highPriorityQueue, ...this.lowPriorityQueue]
                }

                constructor(e) {
                    super(), Kh(this, "lowPriorityQueue", []), Kh(this, "highPriorityQueue", []), Kh(this, "AgoraWebSocketManager", void 0), this.AgoraWebSocketManager = e
                }

                reset() {
                    this.lowPriorityQueue = [], this.highPriorityQueue = []
                }

                pushMessage(e) {
                    arguments.length > 1 && void 0 !== arguments[1] && arguments[1] ? this.highPriorityQueue.push(e) : this.lowPriorityQueue.push(e), this.sendMessage()
                }

                sendMessage() {
                    const e = this.queue.length;
                    let t = 0;
                    setTimeout(() => {
                        this._sendMessage()
                    }, t = e < 5 ? 15 * e : 60 + 3 * (e - 4))
                }

                _sendMessage() {
                    if (!this.queue.length) return;
                    const e = this.AgoraWebSocketManager.getConnection();
                    if (!e || 1 !== e.readyState) return;
                    const t = this.queue.shift();
                    return this.lowPriorityQueue.includes(t) ? this.lowPriorityQueue.shift() : this.highPriorityQueue.shift(), e.send(t.compressed), t
                }
            }

            function dw(e, t) {
                var r = Object.keys(e);
                if (Object.getOwnPropertySymbols) {
                    var n = Object.getOwnPropertySymbols(e);
                    t && (n = n.filter(function (t) {
                        return Object.getOwnPropertyDescriptor(e, t).enumerable
                    })), r.push.apply(r, n)
                }
                return r
            }

            class lw extends Wf {
                get url() {
                    return this.websocket ? this.websocket.url : null
                }

                get reconnectMode() {
                    return this._reconnectMode
                }

                set reconnectMode(e) {
                    ["tryNext", "recover"].includes(e) && this.resetReconnectCount(e), this._reconnectMode = e
                }

                get state() {
                    return this._state
                }

                set state(e) {
                    e !== this._state && (this._state = e, "reconnecting" === this._state ? this.emit(lv.RECONNECTING, this.reconnectReason) : "connected" === this._state ? this.emit(lv.CONNECTED) : "closed" === this._state ? this.emit(lv.CLOSED) : "failed" === this._state && this.emit(lv.FAILED))
                }

                resetReconnectCount(e) {
                    em.debug("websocket reset reconnect count, reason: " + e), this.reconnectCount = 0
                }

                constructor(e, t) {
                    let r = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
                        n = arguments.length > 3 && void 0 !== arguments[3] && arguments[3],
                        i = arguments.length > 4 ? arguments[4] : void 0;
                    super(), Kh(this, "connectionID", 0), Kh(this, "currentURLIndex", 0), Kh(this, "urls", void 0), Kh(this, "_reconnectMode", "tryNext"), Kh(this, "reconnectReason", void 0), Kh(this, "_initMutex", new KE("websocket")), Kh(this, "name", void 0), Kh(this, "_state", "closed"), Kh(this, "reconnectInterrupter", void 0), Kh(this, "websocket", void 0), Kh(this, "retryConfig", void 0), Kh(this, "reconnectCount", 0), Kh(this, "forceCloseTimeout", 5e3), Kh(this, "onlineReconnectListener", void 0), Kh(this, "messageSender", void 0), Kh(this, "useCompress", void 0), Kh(this, "tryDoubleDomain", !1), Kh(this, "wsInflateLength", 0), Kh(this, "wsDeflateLength", 0), Kh(this, "closeEstablishingWs", () => {
                    }), Kh(this, "store", void 0), Kh(this, "joinChannelServiceRecordIndex", void 0), this.store = i, this.name = e, this.retryConfig = function (e) {
                        for (var t = 1; t < arguments.length; t++) {
                            var r = null != arguments[t] ? arguments[t] : {};
                            t % 2 ? dw(Object(r), !0).forEach(function (t) {
                                Kh(e, t, r[t])
                            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : dw(Object(r)).forEach(function (t) {
                                Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t))
                            })
                        }
                        return e
                    }({}, t), this.useCompress = r, this.tryDoubleDomain = n;
                    const {timeout: o, timeoutFactor: s} = t, a = Math.max(300, Math.floor(3 * o / 5)),
                        c = Math.max(1.2, Math.floor(8 * s) / 10);
                    Yv.ONLINE && (this.retryConfig.timeout = a, this.retryConfig.timeoutFactor = c), DE.on(Jv.NETWORK_STATE_CHANGE, (e, t) => {
                        e !== t && (this.resetReconnectCount("network state change: ".concat(t, " -> ").concat(e)), e === Yv.ONLINE ? (this.retryConfig.timeout = a, this.retryConfig.timeoutFactor = c) : (this.retryConfig.timeout = o, this.retryConfig.timeoutFactor = s))
                    })
                }

                getConnection() {
                    return this.websocket || void 0
                }

                init(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5e3;
                    this.forceCloseTimeout = t;
                    const r = (t, r) => {
                        this.urls = e;
                        const n = this.urls[this.currentURLIndex];
                        this.state = "connecting", this.messageSender = new uw(this), this.createWebSocketConnection(n).then(t).catch(r), this.once(lv.CLOSED, () => r(new Hf(qf.WS_DISCONNECT))), this.once(lv.CONNECTED, () => t())
                    };
                    return this._initMutex.lock().then(e => new sl((e, t) => {
                        r(e, t)
                    }).then(() => {
                        e()
                    }).catch(() => {
                        e()
                    }))
                }

                close(e, t) {
                    if (this.currentURLIndex = 0, this.resetReconnectCount("close"), this.reconnectInterrupter && this.reconnectInterrupter(), this.websocket) {
                        this.websocket.onclose = null, this.websocket.onopen = null, this.websocket.onmessage = null;
                        const e = this.websocket;
                        t ? setTimeout(() => e.close(), 500) : e.close(), this.websocket = void 0
                    }
                    this.state = e ? "failed" : "closed", this.closeEstablishingWs && this.closeEstablishingWs()
                }

                reconnect(e, t) {
                    if (!this.websocket) return void em.warning("[".concat(this.name, "] can not reconnect, no websocket"));
                    var r;
                    void 0 !== e && (this.reconnectMode = e), em.debug("[".concat(this.name, "] reconnect is triggered initiative")), "number" == typeof this.joinChannelServiceRecordIndex && (null === (r = this.store) || void 0 === r || r.recordJoinChannelService({
                        status: "error",
                        errors: [new Error(t)]
                    }, this.joinChannelServiceRecordIndex));
                    const n = this.websocket.onclose;
                    this.websocket.onclose = null, this.websocket.close(), n && n.bind(this.websocket)({
                        code: 9999,
                        reason: t
                    })
                }

                sendMessageWithJSON(e) {
                    const t = JSON.stringify(e);
                    return {compressed: t, compressedLength: t.length, origin: e}
                }

                sendMessageWithUint8Array(e) {
                    return {compressed: e, compressedLength: e.byteLength, origin: e}
                }

                sendMessage(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                        r = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                    if (!this.websocket || this.websocket.readyState !== WebSocket.OPEN) throw new Hf(qf.WS_ABORT, "websocket is not ready");
                    try {
                        let n = null;
                        n = r ? this.sendMessageWithUint8Array(e) : this.sendMessageWithJSON(e), t ? this.websocket.send(n.compressed) : this.messageSender.pushMessage(n)
                    } catch (e) {
                        throw new Hf(qf.WS_ERR, "send websocket message error" + e.toString())
                    }
                }

                setWsInflateData(e) {
                    this.wsDeflateLength = this.wsDeflateLength + e.originLength, this.wsInflateLength = this.wsInflateLength + e.compressedLength
                }

                getWsInflateData() {
                    const e = this.wsInflateLength, t = this.wsDeflateLength;
                    return this.clearWsInflateData(), {wsInflateLength: e, wsDeflateLength: t}
                }

                clearWsInflateData() {
                    this.wsInflateLength = 0, this.wsDeflateLength = 0
                }

                async createWebSocketConnection(e, t) {
                    return this.connectionID += 1, this.connectionID, this.joinChannelServiceRecordIndex = void 0, new sl((r, n) => {
                        var i;
                        const o = e => {
                            var t;
                            null === (t = this.store) || void 0 === t || t.signalChannelOpen(), em.debug("[".concat(this.name, "] websocket opened:"), e), this.reconnectMode = "retry", this.state = "connected", this.resetReconnectCount("opened"), r()
                        }, s = async e => {
                            if (em.debug("[".concat(this.name, "] websocket close ").concat(this.websocket && this.websocket.url, ", code: ").concat(e.code, ", reason: ").concat(e.reason, ", current mode: ").concat(this.reconnectMode)), this.reconnectCount < this.retryConfig.maxRetryCount) {
                                "connected" === this.state && (this.reconnectReason = e.reason, this.state = "reconnecting");
                                const t = tb(this, lv.WILL_RECONNECT, this.reconnectMode) || this.reconnectMode,
                                    i = await this.reconnectWithAction(t);
                                if ("closed" === this.state) return void em.debug("[".concat(this.connectionID, "] ws is closed, no need to reconnect"));
                                if (!i) return n(new Hf(qf.WS_DISCONNECT, "websocket reconnect failed: ".concat(e.code))), void this.close(!0);
                                r()
                            } else n(new Hf(qf.WS_DISCONNECT, "websocket close: ".concat(e.code))), this.close()
                        }, a = e => {
                            this.emit(lv.ON_MESSAGE, e)
                        };
                        this.websocket && (this.websocket.onclose = null, this.websocket.close()), fm("GATEWAY_WSS_ADDRESS") && this.name.startsWith("gateway") && (e = fm("GATEWAY_WSS_ADDRESS")), em.debug("[".concat(this.name, "] start connect, url: ").concat(e));
                        const c = null === (i = this.store) || void 0 === i ? void 0 : i.recordJoinChannelService({
                            startTs: Date.now(),
                            status: "pending",
                            service: "gateway"
                        });
                        this.chooseBestWebsocketConnection(e, !!t, c).then(e => {
                            var t;
                            this.websocket = e, o && o(e.url), e.onclose = s, e.onmessage = a, null === (t = this.store) || void 0 === t || t.recordJoinChannelService({
                                endTs: Date.now(),
                                status: "success"
                            }, c), this.joinChannelServiceRecordIndex = c
                        }).catch(e => {
                            var t;
                            if (null === (t = this.store) || void 0 === t || t.recordJoinChannelService({
                                endTs: Date.now(),
                                status: e instanceof Hf && e.code === qf.WS_ABORT ? "aborted" : "error",
                                errors: [e]
                            }, c), "closed" !== this.state) {
                                if (e instanceof Hf && e.code === qf.WS_ERR) {
                                    const t = new Hf(qf.WS_ERR, "init websocket failed! Error: ".concat(e.toString()));
                                    return em.error("[".concat(this.name, "]").concat(t)), void n(t)
                                }
                                s && s(e)
                            } else n(new Hf(qf.WS_DISCONNECT, "websocket is closed: ".concat(e.toString())))
                        })
                    })
                }

                async reconnectWithAction(e) {
                    let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                    if (this.reconnectCount >= this.retryConfig.maxRetryCount) return !1;
                    if (!this.urls) return !1;
                    if ("closed" === this.state) return !1;
                    this.onlineReconnectListener || DE.networkState !== Yv.OFFLINE || (this.onlineReconnectListener = DE.onlineWaiter && DE.onlineWaiter.then(() => {
                        this.onlineReconnectListener = void 0
                    }));
                    let r = !0;
                    if (this.reconnectInterrupter = (() => {
                        r = !1
                    }), t) {
                        const t = zf(this.reconnectCount, this.retryConfig);
                        em.debug("[".concat(this.name, "] wait ").concat(t, "ms to reconnect websocket, mode: ").concat(e)), await sl.race([zS(t), this.onlineReconnectListener || new sl(() => {
                        })])
                    }
                    if ("closed" === this.state || !r) return !1;
                    this.reconnectCount += 1;
                    const n = async (e, t) => {
                        this.emit(lv.RECONNECT_CREATE_CONNECTION, t), await this.createWebSocketConnection(e)
                    };
                    try {
                        if ("retry" === e) {
                            const t = this.urls[this.currentURLIndex];
                            this.emit(lv.RECONNECT_WAITTING_FINISH, e), await n(t, e)
                        } else if ("tryNext" === e) {
                            if (this.currentURLIndex += 1, this.currentURLIndex >= this.urls.length) return await this.reconnectWithAction("recover", !1);
                            em.debug("[".concat(this.name, "] websocket url length: ").concat(this.urls.length, " current index: ").concat(this.currentURLIndex));
                            const t = this.urls[this.currentURLIndex];
                            this.emit(lv.RECONNECT_WAITTING_FINISH, e), await n(t, e)
                        } else if ("recover" === e) {
                            em.debug("[".concat(this.name, "] request new urls")), this.resetReconnectCount("recover mode"), this.emit(lv.RECONNECT_WAITTING_FINISH, e), this.urls = await ZS(this, lv.REQUEST_NEW_URLS), this.currentURLIndex = 0;
                            const t = this.urls[this.currentURLIndex];
                            await n(t, e)
                        }
                        return !0
                    } catch (r) {
                        var i;
                        return em.error("[".concat(this.name, "] reconnect failed"), r.toString()), null != r && null !== (i = r.data) && void 0 !== i && i.desc && Array.isArray(r.data.desc) && r.data.desc.length && r.data.desc.includes("dynamic key expired") ? (this.emit(lv.ON_TOKEN_PRIVILEGE_DID_EXPIRE), !1) : await this.reconnectWithAction(e, t)
                    }
                }

                async chooseBestWebsocketConnection(e, t, r) {
                    return new sl((n, i) => {
                        let o = !1;
                        const s = [];
                        this.closeEstablishingWs = (() => {
                            em.debug("[choose-best-ws] close establishing websockets"), s.forEach(e => {
                                e.onclose = null, e.onopen = null, e.onmessage = null, e.close()
                            }), i(new Hf(qf.WS_ABORT, "choose best websocket aborted"))
                        });
                        const a = fm("GATEWAY_DOMAINS");
                        let c;
                        const u = e.indexOf("?h="), d = a.find(t => -1 !== u ? e.includes(t, u) : e.includes(t));
                        em.debug("[choose-best-ws] currentDomain: ", d, ", domains: ", a);
                        let l = !this.tryDoubleDomain || t || !d;
                        if (!l && d) {
                            var h;
                            const t = Date.now();
                            try {
                                a.forEach(t => {
                                    const r = -1 === u ? e.replace(d, t) : e.substr(0, u) + e.substr(u).replace(d, t),
                                        n = new WebSocket(r);
                                    n.binaryType = "arraybuffer", s.push(n), em.debug("[choose-best-ws] ws is connecting:", n.url)
                                })
                            } catch (e) {
                                for (em.debug("[choose-best-ws] ws create failed, fallback to single url"), s.forEach(e => e.close()); s.length;) s.pop();
                                l = !0
                            }
                            null === (h = this.store) || void 0 === h || h.recordJoinChannelService({
                                urls: s.map(e => e.url),
                                service: "gateway"
                            }, r), s.forEach(e => {
                                e.onopen = (() => {
                                    if (o) return;
                                    const r = Date.now() - t;
                                    em.debug("[choose-best-ws] ws open cost ".concat(r, "ms")), s.filter(t => t !== e).forEach(e => {
                                        em.debug("[choose-best-ws]close backup websocket: ".concat(e.url)), e.close()
                                    }), o = !0, n(e)
                                }), e.onclose = (e => {
                                    c = e, o || s.find(e => !(e.readyState === WebSocket.CLOSED || e.readyState === WebSocket.CLOSING)) || (em.debug("[choose-best-ws] all websocket is closed"), o = !0, i(c))
                                }), e.onmessage = (t => {
                                    em.debug("[choose-best-ws]".concat(e.url, " onmessage: ").concat(t.data))
                                })
                            }), zS(this.forceCloseTimeout).then(() => {
                                s.forEach(e => {
                                    e.readyState !== WebSocket.OPEN && e.close()
                                })
                            })
                        }
                        if (l) {
                            var p;
                            let t;
                            em.debug("[choose-best-ws] use single url: ", e), null === (p = this.store) || void 0 === p || p.recordJoinChannelService({
                                urls: [e],
                                service: "gateway"
                            }, r);
                            try {
                                t = new WebSocket(e), s.push(t), t.binaryType = "arraybuffer"
                            } catch (e) {
                                const t = new Hf(qf.WS_ERR, "init websocket failed! Error: ".concat(e.toString()));
                                return em.error("[".concat(this.name, "]").concat(t)), void i(t)
                            }
                            t.onopen = (() => {
                                n(t)
                            }), t.onclose = (e => {
                                i(e)
                            }), t.onmessage = (e => {
                                em.debug("[choose-best-ws]".concat(t.url, " onmessage: ").concat(e.data))
                            }), zS(this.forceCloseTimeout).then(() => {
                                t && t.readyState !== WebSocket.OPEN && t.close()
                            })
                        }
                    }).then(e => (this.closeEstablishingWs = void 0, e)).catch(e => {
                        throw this.closeEstablishingWs = void 0, e
                    })
                }
            }

            class hw {
                constructor(e) {
                    Kh(this, "input", []), Kh(this, "size", void 0), this.size = e
                }

                add(e) {
                    this.input.push(e), this.input.length > this.size && this.input.splice(0, 1)
                }

                mean() {
                    var e;
                    return 0 === this.input.length ? 0 : Kr(e = this.input).call(e, (e, t) => e + t) / this.input.length
                }
            }

            class pw extends Wf {
                get connectionState() {
                    return this._connectionState
                }

                set connectionState(e) {
                    e !== this._connectionState && (this._connectionState = e, e === J_.CONNECTED ? this.emit(X_.WS_CONNECTED) : e === J_.RECONNECTING ? this.emit(X_.WS_RECONNECTING, this._websocketReconnectReason) : e === J_.CLOSED && this.emit(X_.WS_CLOSED, this._disconnectedReason))
                }

                get currentURLIndex() {
                    return this.websocket.currentURLIndex
                }

                get url() {
                    return this.websocket ? this.websocket.url : null
                }

                get rtt() {
                    return this.rttRolling.mean()
                }

                constructor(e, t) {
                    super(), Kh(this, "_disconnectedReason", void 0), Kh(this, "_websocketReconnectReason", void 0), Kh(this, "_connectionState", J_.CLOSED), Kh(this, "reconnectToken", void 0), Kh(this, "websocket", void 0), Kh(this, "openConnectionTime", void 0), Kh(this, "clientId", void 0), Kh(this, "lastMsgTime", Date.now()), Kh(this, "uploadCache", []), Kh(this, "uploadCacheInterval", void 0), Kh(this, "rttRolling", new hw(5)), Kh(this, "pingpongTimer", void 0), Kh(this, "wsInflateDataTimer", void 0), Kh(this, "pingpongTimeoutCount", 0), Kh(this, "joinResponse", void 0), Kh(this, "multiIpOption", void 0), Kh(this, "initError", void 0), Kh(this, "spec", void 0), Kh(this, "store", void 0), Kh(this, "onWebsocketMessage", e => {
                        if (e.data instanceof ArrayBuffer) return void this.emit(X_.ON_BINARY_DATA, e.data);
                        const t = JSON.parse(e.data);
                        if (this.lastMsgTime = Date.now(), Object.prototype.hasOwnProperty.call(t, "_id")) {
                            const e = "res-@".concat(t._id);
                            this.emit(e, t._result, t._message)
                        } else if (Object.prototype.hasOwnProperty.call(t, "_type")) {
                            if (this.emit(t._type, t._message), t._type === Z_.ON_NOTIFICATION && this.handleNotification(t._message), t._type === Z_.ON_USER_BANNED) switch (t._message.error_code) {
                                case 14:
                                    this.close(K_.UID_BANNED);
                                    break;
                                case 15:
                                    this.close(K_.IP_BANNED);
                                    break;
                                case 16:
                                    this.close(K_.CHANNEL_BANNED)
                            }
                            if (t._type === Z_.ON_USER_LICENSE_BANNED) switch (t._message.error_code) {
                                case q_.ERR_LICENSE_MISSING:
                                    this.close(K_.LICENSE_MISSING);
                                    break;
                                case q_.ERR_LICENSE_EXPIRED:
                                    this.close(K_.LICENSE_EXPIRED);
                                    break;
                                case q_.ERR_LICENSE_MINUTES_EXCEEDED:
                                    this.close(K_.LICENSE_MINUTES_EXCEEDED);
                                    break;
                                case q_.ERR_LICENSE_PERIOD_INVALID:
                                    this.close(K_.LICENSE_PERIOD_INVALID);
                                    break;
                                case q_.ERR_LICENSE_MULTIPLE_SDK_SERVICE:
                                    this.close(K_.LICENSE_MULTIPLE_SDK_SERVICE);
                                    break;
                                case q_.ERR_LICENSE_ILLEGAL:
                                    this.close(K_.LICENSE_ILLEGAL);
                                    break;
                                default:
                                    this.close()
                            }
                        }
                    }), this.clientId = e.clientId, this.spec = e, this.store = t, this.websocket = new lw("gateway-".concat(this.clientId), this.spec.retryConfig, !0, !0, t), this.handleWebsocketEvents(), window.addEventListener("offline", () => {
                        this.connectionState === J_.CONNECTED && this.reconnect("retry", Y_.OFFLINE)
                    })
                }

                async request(e, t, r, n) {
                    const i = YS(6, ""), o = {_id: i, _type: e, _message: t}, s = this.websocket.connectionID,
                        a = () => new sl((t, r) => {
                            if (this.connectionState === J_.CONNECTED) return t();
                            const n = () => {
                                this.off(X_.WS_CLOSED, i), t()
                            }, i = () => {
                                this.off(X_.WS_CONNECTED, n), r(new Hf(qf.WS_ABORT))
                            };
                            this.once(X_.WS_CONNECTED, n), this.once(X_.WS_CLOSED, i), e !== Q_.PUBLISH && e !== Q_.SUBSCRIBE && e !== Q_.UNSUBSCRIBE && e !== Q_.UNPUBLISH && e !== Q_.CONTROL && e !== Q_.RESTART_ICE || this.once(X_.DISCONNECT_P2P, () => {
                                r(new Hf(qf.DISCONNECT_P2P))
                            }), e !== Q_.PUBLISH && e !== Q_.RESTART_ICE || this.once(X_.ABORT_P2P_EXECUTION, () => {
                                r(new Hf(qf.DISCONNECT_P2P))
                            })
                        });
                    if (this.connectionState !== J_.CONNECTING && this.connectionState !== J_.RECONNECTING || e === Q_.JOIN || e === Q_.REJOIN || await a(), this.websocket.sendMessage(o, !0), n) return;
                    const c = new sl((r, n) => {
                        let o = !1;
                        const a = (n, i) => {
                            o = !0, r({
                                isSuccess: "success" === n,
                                message: i || {}
                            }), this.off(X_.WS_CLOSED, c), this.off(X_.WS_RECONNECTING, c), this.emit(X_.REQUEST_SUCCESS, e, t)
                        };
                        this.once("res-@".concat(i), a);
                        const c = () => {
                            n(new Hf(qf.WS_ABORT, "type: ".concat(e))), this.off(X_.WS_CLOSED, c), this.off(X_.WS_RECONNECTING, c), this.off("res-@".concat(i), a)
                        };
                        this.once(X_.WS_CLOSED, c), this.once(X_.WS_RECONNECTING, c), zS(fm("SIGNAL_REQUEST_TIMEOUT")).then(() => {
                            this.websocket.connectionID !== s || o || (em.warning("ws request timeout, type: ".concat(e)), this.emit(X_.REQUEST_TIMEOUT, e, t))
                        })
                    });
                    let u = null;
                    try {
                        u = await c
                    } catch (n) {
                        if (this.connectionState === J_.CLOSED || e === Q_.LEAVE) throw new Hf(qf.WS_ABORT);
                        return !this.spec.forceWaitGatewayResponse || r ? n.throw() : e === Q_.JOIN || e === Q_.REJOIN ? null : (await a(), await this.request(e, t))
                    }
                    if (u.isSuccess) return u.message;
                    const d = Number(u.message.error_code || u.message.code), l = cw(d),
                        h = new Hf(qf.UNEXPECTED_RESPONSE, "".concat(l.desc, ": ").concat(u.message.error_str), {
                            code: d,
                            data: u.message
                        });
                    return "success" === l.action ? u.message : (em.warning("[".concat(this.websocket.connectionID, "] unexpected response from type ").concat(e, ", error_code: ").concat(d, ", message: ").concat(l.desc, ", action: ").concat(l.action)), d === q_.ERR_TOO_MANY_BROADCASTERS ? e === Q_.JOIN || e === Q_.REJOIN ? (this.initError = h, this.close(), h.throw()) : h.throw() : "failed" === l.action ? h.throw() : "quit" === l.action ? (this.initError = h, this.close(), h.throw()) : (d === q_.ERR_JOIN_BY_MULTI_IP ? (this.multiIpOption = u.message.option, em.warning("[".concat(this.clientId, "] detect multi ip, recover")), this.reconnect("recover", Y_.MULTI_IP)) : this.reconnect(l.action, Y_.SERVER_ERROR), e === Q_.JOIN || e === Q_.REJOIN ? null : await this.request(e, t)))
                }

                waitMessage(e, t) {
                    return new sl(r => {
                        const n = i => {
                            (!t || t(i)) && (this.off(e, n), r(i))
                        };
                        this.on(e, n)
                    })
                }

                upload(e, t) {
                    const r = {_type: e, _message: t};
                    try {
                        this.websocket.sendMessage(r)
                    } catch (e) {
                        const t = fm("MAX_UPLOAD_CACHE") || 50;
                        this.uploadCache.push(r), this.uploadCache.length > t && this.uploadCache.splice(0, 1), this.uploadCache.length > 0 && !this.uploadCacheInterval && (this.uploadCacheInterval = window.setInterval(() => {
                            if (this.connectionState !== J_.CONNECTED) return;
                            const e = this.uploadCache.splice(0, 1)[0];
                            0 === this.uploadCache.length && (window.clearInterval(this.uploadCacheInterval), this.uploadCacheInterval = void 0), this.upload(e._type, e._message)
                        }, fm("UPLOAD_CACHE_INTERVAL") || 2e3))
                    }
                }

                send(e, t) {
                    const r = {_type: e, _message: t};
                    this.websocket.sendMessage(r)
                }

                init(e, t) {
                    return this.initError = void 0, this.multiIpOption = void 0, this.joinResponse = void 0, this.reconnectToken = void 0, this.openConnectionTime = void 0, new sl((r, n) => {
                        this.once(X_.WS_CONNECTED, () => r(this.joinResponse)), this.once(X_.WS_CLOSED, () => n(this.initError || new Hf(qf.WS_ABORT))), this.connectionState = J_.CONNECTING, this.websocket.init(e).catch(n), this.wsInflateDataTimer && window.clearInterval(this.wsInflateDataTimer), this.wsInflateDataTimer = window.setInterval(() => {
                            this.handleWsInflateData()
                        }, 2e4), setTimeout(() => {
                            t && void 0 === this.openConnectionTime && (em.debug("[".concat(this.clientId, "] init websocket timeout while join with fallback to proxy")), n(new Hf(qf.INIT_WEBSOCKET_TIMEOUT)))
                        }, fm("JOIN_WITH_FALLBACK_PROXY_PENDING_DURATION"))
                    })
                }

                close(e) {
                    this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.wsInflateDataTimer && (this.handleWsInflateData(), window.clearInterval(this.wsInflateDataTimer), this.wsInflateDataTimer = void 0), this.reconnectToken = void 0, this.joinResponse = void 0, this._disconnectedReason = e || K_.LEAVE, this.connectionState = J_.CLOSED, em.debug("[".concat(this.clientId, "] ") + "will close websocket in signal"), this.websocket.close(), e === K_.FALLBACK && (this.websocket.removeAllListeners(), this.websocket = new lw("gateway-".concat(this.clientId), this.spec.retryConfig, !0, !0, this.store), this.handleWebsocketEvents())
                }

                async join() {
                    if (!this.joinResponse) {
                        this.emit(X_.ABORT_P2P_EXECUTION);
                        const e = await ZS(this, X_.REQUEST_JOIN_INFO), t = await this.request(Q_.JOIN, e);
                        if (!t) return this.emit(X_.REPORT_JOIN_GATEWAY, qf.TIMEOUT, this.url || ""), !1;
                        this.joinResponse = t, this.emit(X_.JOIN_RESPONSE, this.joinResponse), this.reconnectToken = this.joinResponse.rejoin_token
                    }
                    return this.connectionState = J_.CONNECTED, this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(this.handlePingPong.bind(this), 3e3), !0
                }

                async rejoin() {
                    if (!this.reconnectToken) throw new Hf(qf.UNEXPECTED_ERROR, "can not rejoin, no rejoin token");
                    const e = rb(this, X_.REQUEST_REJOIN_INFO);
                    e.token = this.reconnectToken;
                    const t = await this.request(Q_.REJOIN, e);
                    return !!t && (this.connectionState = J_.CONNECTED, this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(this.handlePingPong.bind(this), 3e3), t.peers && t.peers.forEach(e => {
                        this.emit(Z_.ON_USER_ONLINE, {uid: e.uid}), e.audio && this.emit(Z_.ON_ADD_AUDIO_STREAM, {
                            uid: e.uid,
                            uint_id: e.uint_id,
                            audio: !0,
                            ssrcId: e.audio_ssrc
                        }), e.video && this.emit(Z_.ON_ADD_VIDEO_STREAM, {
                            uid: e.uid,
                            uint_id: e.uint_id,
                            video: !0,
                            ssrcId: e.video_ssrc
                        }), e.audio_mute ? this.emit(Z_.MUTE_AUDIO, {uid: e.uid}) : this.emit(Z_.UNMUTE_AUDIO, {uid: e.uid}), e.video_mute ? this.emit(Z_.MUTE_VIDEO, {uid: e.uid}) : this.emit(Z_.UNMUTE_VIDEO, {uid: e.uid}), e.audio_enable_local ? this.emit(Z_.ENABLE_LOCAL_AUDIO, {uid: e.uid}) : this.emit(Z_.DISABLE_LOCAL_AUDIO, {uid: e.uid}), e.video_enable_local ? this.emit(Z_.ENABLE_LOCAL_VIDEO, {uid: e.uid}) : this.emit(Z_.DISABLE_LOCAL_VIDEO, {uid: e.uid}), e.audio || e.video || this.emit(Z_.ON_REMOVE_STREAM, {
                            uid: e.uid,
                            uint_id: e.uint_id
                        })
                    }), !0)
                }

                reconnect(e, t) {
                    this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.websocket.reconnect(e, t)
                }

                handleNotification(e) {
                    em.debug("[".concat(this.clientId, "] receive notification: "), e);
                    const t = cw(e.code);
                    if ("success" !== t.action) {
                        if ("failed" !== t.action) return "quit" === t.action ? ("ERR_REPEAT_JOIN_CHANNEL" === t.desc && this.close(K_.UID_BANNED), void this.close()) : void this.reconnect(t.action, Y_.SERVER_ERROR);
                        em.error("[".concat(this.clientId, "] ignore error: "), t.desc)
                    }
                }

                handlePingPong() {
                    if (!this.websocket || "connected" !== this.websocket.state) return;
                    this.pingpongTimeoutCount > 0 && this.rttRolling.add(3e3), this.pingpongTimeoutCount += 1;
                    const e = fm("PING_PONG_TIME_OUT"), t = Date.now();
                    this.pingpongTimeoutCount >= e && (em.warning("PINGPONG Timeout. Last Socket Message: ".concat(t - this.lastMsgTime, "ms")), t - this.lastMsgTime > fm("WEBSOCKET_TIMEOUT_MIN")) ? this.reconnect("retry", Y_.TIMEOUT) : this.request(Q_.PING, void 0, !0).then(() => {
                        this.pingpongTimeoutCount = 0;
                        const e = Date.now() - t;
                        this.rttRolling.add(e), fm("REPORT_STATS") && this.send(Q_.PING_BACK, {pingpongElapse: e})
                    }).catch(e => {
                    })
                }

                handleWsInflateData() {
                    const {wsInflateLength: e, wsDeflateLength: t} = this.websocket.getWsInflateData();
                    0 !== e && 0 !== t && this.upload($_.WS_INFLATE_DATA_LENGTH, {
                        ws_deflate_length: t,
                        ws_inflate_length: e
                    })
                }

                handleWebsocketEvents() {
                    this.websocket.on(lv.RECONNECT_WAITTING_FINISH, e => {
                        this.emit(X_.WS_RECONNECT_WAITTING_FINISH, e)
                    }), this.websocket.on(lv.RECONNECT_CREATE_CONNECTION, e => {
                        this.emit(X_.WS_RECONNECT_CREATE_CONNECTION, e)
                    }), this.websocket.on(lv.ON_MESSAGE, this.onWebsocketMessage), this.websocket.on(lv.CLOSED, () => {
                        this.connectionState = J_.CLOSED
                    }), this.websocket.on(lv.FAILED, () => {
                        this._disconnectedReason = K_.NETWORK_ERROR, this.connectionState = J_.CLOSED
                    }), this.websocket.on(lv.RECONNECTING, e => {
                        this._websocketReconnectReason = e, this.joinResponse = void 0, this.connectionState === J_.CONNECTED ? this.connectionState = J_.RECONNECTING : this.connectionState = J_.CONNECTING
                    }), this.websocket.on(lv.WILL_RECONNECT, (e, t) => {
                        if (rb(this, X_.IS_P2P_DISCONNECTED) && "retry" === e) return em.debug("".concat(this.clientId, " reconnect mode is retry, but p2p lost, change to tryNext")), this.reconnectToken = void 0, this.emit(X_.NEED_RENEW_SESSION), this.emit(X_.DISCONNECT_P2P), t("tryNext");
                        "retry" !== e && (em.debug("".concat(this.clientId, " websockt will_connect event, renewSession reconnectMode is ").concat(e)), this.reconnectToken = void 0, this.emit(X_.NEED_RENEW_SESSION), this.emit(X_.DISCONNECT_P2P)), t(e)
                    }), this.websocket.on(lv.CONNECTED, () => {
                        this.openConnectionTime = Date.now(), this.reconnectToken ? this.rejoin().catch(e => {
                            em.warning("[".concat(this.clientId, "] rejoin failed ").concat(e)), this.reconnect("tryNext", Y_.SERVER_ERROR)
                        }) : this.join().catch(e => {
                            if (this.emit(X_.REPORT_JOIN_GATEWAY, e.message || e.code, this.url || ""), e instanceof Hf && e.code === qf.UNEXPECTED_RESPONSE && e.data.code === q_.ERR_NO_AUTHORIZED) return em.warning("[".concat(this.clientId, "] reconnect no authorized, recover")), void this.reconnect("recover", Y_.SERVER_ERROR);
                            em.error("[".concat(this.clientId, "] join gateway request failed"), e.toString()), this.spec.forceWaitGatewayResponse ? this.reconnect("tryNext", Y_.SERVER_ERROR) : (this.initError = e, this.close())
                        })
                    }), this.websocket.on(lv.REQUEST_NEW_URLS, (e, t) => {
                        ZS(this, X_.REQUEST_RECOVER, this.multiIpOption).then(e).catch(t)
                    }), this.websocket.on(lv.ON_TOKEN_PRIVILEGE_DID_EXPIRE, () => {
                        this.emit(Z_.ON_TOKEN_PRIVILEGE_DID_EXPIRE)
                    })
                }
            }

            function fw(e, t) {
                var r = Object.keys(e);
                if (Object.getOwnPropertySymbols) {
                    var n = Object.getOwnPropertySymbols(e);
                    t && (n = n.filter(function (t) {
                        return Object.getOwnPropertyDescriptor(e, t).enumerable
                    })), r.push.apply(r, n)
                }
                return r
            }

            class mw extends Wf {
                get url() {
                    return this._url ? this._url : null
                }

                get reconnectMode() {
                    return this._reconnectMode
                }

                set reconnectMode(e) {
                    ["tryNext", "recover"].includes(e) && this.resetReconnectCount(e), this._reconnectMode = e
                }

                get state() {
                    return this._state
                }

                set state(e) {
                    e !== this._state && (this._state = e, "reconnecting" === this._state ? this.emit(rg.RECONNECTING, this.reconnectReason) : "connected" === this._state ? this.emit(rg.CONNECTED) : "closed" === this._state ? this.emit(rg.CLOSED) : "failed" === this._state && this.emit(rg.FAILED))
                }

                constructor(e, t, r, n) {
                    super(), Kh(this, "connectionID", 0), Kh(this, "currentURLIndex", 0), Kh(this, "reconnectReason", void 0), Kh(this, "_reconnectMode", "tryNext"), Kh(this, "_initMutex", void 0), Kh(this, "_name", void 0), Kh(this, "_state", "closed"), Kh(this, "_reconnectInterrupter", void 0), Kh(this, "_url", void 0), Kh(this, "_retryConfig", void 0), Kh(this, "_reconnectCount", 0), Kh(this, "_forceCloseTimeout", 5e3), Kh(this, "_onlineReconnectListener", void 0), Kh(this, "_messageSender", void 0), Kh(this, "_closeEstablishingTransmitter", () => {
                    }), Kh(this, "_store", void 0), Kh(this, "_joinChannelServiceRecordIndex", void 0), Kh(this, "_transmitter", void 0), Kh(this, "_useCompress", void 0), Kh(this, "_inflateLength", 0), Kh(this, "_deflateLength", 0), this._store = n, this._name = e, this._retryConfig = function (e) {
                        for (var t = 1; t < arguments.length; t++) {
                            var r = null != arguments[t] ? arguments[t] : {};
                            t % 2 ? fw(Object(r), !0).forEach(function (t) {
                                Kh(e, t, r[t])
                            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : fw(Object(r)).forEach(function (t) {
                                Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t))
                            })
                        }
                        return e
                    }({}, t), this._useCompress = r
                }

                resetReconnectCount(e) {
                    em.debug("".concat(this._name, " reset reconnect count, reason: ").concat(e)), this._reconnectCount = 0
                }

                close(e, t) {
                    var r;
                    if (this.currentURLIndex = 0, this.resetReconnectCount("close"), null === (r = this._messageSender) || void 0 === r || r.reset(), this._reconnectInterrupter && this._reconnectInterrupter(), this._transmitter) {
                        this._transmitter.onclose = null, this._transmitter.onopen = null, this._transmitter.onmessage = null;
                        const e = this._transmitter;
                        t ? setTimeout(() => e.close(), 500) : e.close(), this._transmitter = void 0
                    }
                    this.state = e ? "failed" : "closed", this._closeEstablishingTransmitter && this._closeEstablishingTransmitter()
                }

                reconnect(e, t) {
                    if (!this._transmitter) return void em.warning("[".concat(this._name, "] can not reconnect, no websocket"));
                    var r;
                    void 0 !== e && (this.reconnectMode = e), em.debug("[".concat(this._name, "] reconnect is triggered initiative")), "number" == typeof this._joinChannelServiceRecordIndex && (null === (r = this._store) || void 0 === r || r.recordJoinChannelService({
                        status: "error",
                        errors: [new Error(t)]
                    }, this._joinChannelServiceRecordIndex));
                    const n = this._transmitter.onclose;
                    this._transmitter.onclose = null, this._transmitter.close(), n && n.bind(this._transmitter)({
                        code: 9999,
                        reason: t
                    })
                }

                getInflateData() {
                    const e = this._inflateLength, t = this._deflateLength;
                    return this.clearInflateData(), {inflateLength: e, deflateLength: t}
                }

                setInflateData(e) {
                    this._deflateLength = this._deflateLength + e.originLength, this._inflateLength = this._inflateLength + e.compressedLength
                }

                clearInflateData() {
                    this._inflateLength = 0, this._deflateLength = 0
                }
            }

            function _w(e, t, r) {
                if ("getBigUint64" in DataView.prototype) return e.getBigUint64(t, r);
                const n = e.getUint32(t, r), i = e.getUint32(t + 4, r), o = Number(!!r), s = Number(!r);
                return BigInt(n * s + i * o) << BigInt(32) | BigInt(n * o + i * s)
            }

            function vw(e, t, r, n) {
                if ("setBigUint64" in DataView.prototype) return e.setBigUint64(t, r, n);
                const i = Number(r >> BigInt(32)), o = Number(r & BigInt(4294967295));
                n ? (e.setUint32(t + 4, i, n), e.setUint32(t, o, n)) : (e.setUint32(t, i, n), e.setUint32(t + 4, o, n))
            }

            let gw;
            !function (e) {
                e[e.Default = 0] = "Default", e[e.Ack = 1] = "Ack"
            }(gw || (gw = {}));

            class Ew {
                constructor(e, t, r) {
                    Kh(this, "version", 1), Kh(this, "initialRTO", void 0), Kh(this, "maxBatchAckCount", void 0), Kh(this, "maxRTO", void 0), Kh(this, "initialRTT", void 0), Kh(this, "ID", void 0), Kh(this, "rtt", void 0), Kh(this, "packetNumber", 1), Kh(this, "rtoRatioMap", new Map), Kh(this, "timeoutMap", new Map), Kh(this, "unorderedPacketQueue", []), Kh(this, "batchAckPacketQueue", []), Kh(this, "lastOrderedPacketNumber", 0), Kh(this, "batchAckTimer", void 0), Kh(this, "sendImpl", void 0), Kh(this, "receiveImpl", void 0), this.sendImpl = e, this.receiveImpl = t, this.ID = YS(7, "transmitter-"), this.initialRTO = void 0 !== (null == r ? void 0 : r.initialRTO) ? r.initialRTO : fm("TRANSMITTER_INITIAL_RTO"), this.initialRTT = void 0 !== (null == r ? void 0 : r.initialRTT) ? r.initialRTT : fm("TRANSMITTER_INITIAL_RTT"), this.rtt = void 0 !== (null == r ? void 0 : r.initialRTT) ? r.initialRTT : fm("TRANSMITTER_INITIAL_RTT"), this.maxBatchAckCount = void 0 !== (null == r ? void 0 : r.maxBatchAckCount) ? r.maxBatchAckCount : fm("TRANSMITTER_MAX_BATCH_ACK_COUNT"), this.maxRTO = void 0 !== (null == r ? void 0 : r.maxRTO) ? r.maxRTO : fm("TRANSMITTER_MAX_RTO")
                }

                packetize(e, t) {
                    return {type: gw.Default, version: this.version, packetNumber: t, payload: e}
                }

                serialize(e) {
                    switch (e.type) {
                        case gw.Default: {
                            let t;
                            t = "string" == typeof e.payload ? (new TextEncoder).encode(e.payload) : e.payload;
                            const r = new ArrayBuffer(t.length + 15), n = new DataView(r);
                            return n.setUint16(0, e.version), n.setUint8(2, e.type), n.setUint32(3, e.packetNumber), vw(n, 7, BigInt(e.sendTs)), new Uint8Array(n.buffer).set(t, 15), r
                        }
                        case gw.Ack: {
                            const t = new ArrayBuffer(16), r = new DataView(t);
                            return r.setUint16(0, e.version), r.setUint8(2, e.type), r.setUint32(3, e.maxAckPacketNumber), r.setUint8(7, e.shift), vw(r, 8, BigInt(e.ackSendTs)), t
                        }
                    }
                }

                deserialize(e) {
                    const t = new DataView(e), r = t.getUint16(0), n = t.getUint8(2);
                    switch (n) {
                        case gw.Default: {
                            const i = t.getUint32(3), o = _w(t, 7), s = e.slice(15), a = (new TextDecoder).decode(s);
                            return {version: r, type: n, packetNumber: i, sendTs: Number(o), payload: a}
                        }
                        case gw.Ack: {
                            const e = t.getUint32(3), i = t.getUint8(7), o = _w(t, 8);
                            return {version: r, type: n, maxAckPacketNumber: e, shift: i, ackSendTs: Number(o)}
                        }
                        default:
                            throw em.error("[".concat(this.ID, "] Unrecognized packet type ").concat(n)), new Error("Unrecognized packet type ".concat(n))
                    }
                }

                sendMessage(e) {
                    const t = this.packetize(e, this.packetNumber);
                    this.packetNumber = 4294967295 === this.packetNumber ? 1 : this.packetNumber + 1;
                    const r = this.calculateRTO(t), n = window.setTimeout(() => {
                        this.resendMessage(t)
                    }, r);
                    this.timeoutMap.set(t.packetNumber, n), this.sendPacket(t)
                }

                onData(e) {
                    const t = this.deserialize(e);
                    t.type === gw.Default ? this.ack(t) : t.type === gw.Ack && (this.updateRTT(t, Math.round(performance.now())), this.clearRTO(t))
                }

                close() {
                    this.rtt = this.initialRTT, this.packetNumber = 1, Array.from(this.timeoutMap.entries()).forEach(e => {
                        let [t, r] = e;
                        window.clearTimeout(r)
                    }), this.timeoutMap = new Map, this.rtoRatioMap = new Map, this.unorderedPacketQueue = [], this.batchAckPacketQueue = [], this.lastOrderedPacketNumber = 0, void 0 !== this.batchAckTimer && window.clearTimeout(this.batchAckTimer)
                }

                resendMessage(e) {
                    const t = this.calculateRTO(e), r = window.setTimeout(() => {
                        this.resendMessage(e)
                    }, t);
                    this.timeoutMap.set(e.packetNumber, r), this.sendPacket(e)
                }

                calculateRTO(e) {
                    const t = this.rtoRatioMap.get(e.packetNumber);
                    if (void 0 === t) return this.rtoRatioMap.set(e.packetNumber, 1), this.initialRTO;
                    {
                        const r = 9 * this.rtt / 8 * t;
                        return this.rtoRatioMap.set(e.packetNumber, t + 1), r > this.maxRTO ? this.maxRTO : r
                    }
                }

                updateRTT(e, t) {
                    const r = e.ackSendTs;
                    this.rtt = this.rtt * (7 / 8) + (t - r - this.rtt) / 8
                }

                ack(e) {
                    if (e.packetNumber === this.lastOrderedPacketNumber + 1) for (this.batchAckPacketQueue.length >= this.maxBatchAckCount && this.batchAck(), this.batchAckTimer ? this.batchAckPacketQueue.push(e) : (this.batchAckPacketQueue.push(e), this.batchAckTimer = window.setTimeout(() => {
                        this.batchAck()
                    }, this.rtt / 8)), this.lastOrderedPacketNumber += 1, this.receiveImpl(e.payload); ;) {
                        const e = this.unorderedPacketQueue[0];
                        if (!e) {
                            this.unorderedPacketQueue.shift();
                            break
                        }
                        this.batchAckTimer && this.batchAck(), this.receiveImpl(e.payload), this.unorderedPacketQueue.shift(), this.lastOrderedPacketNumber += 1
                    } else if (e.packetNumber <= this.lastOrderedPacketNumber) {
                        const t = {
                            ackSendTs: e.sendTs,
                            maxAckPacketNumber: e.packetNumber,
                            shift: 0,
                            type: gw.Ack,
                            version: this.version
                        };
                        this.sendPacket(t)
                    } else if (e.packetNumber > this.lastOrderedPacketNumber) {
                        this.unorderedPacketQueue[e.packetNumber - this.lastOrderedPacketNumber - 2] = e;
                        const t = {
                            ackSendTs: e.sendTs,
                            maxAckPacketNumber: e.packetNumber,
                            shift: 0,
                            type: gw.Ack,
                            version: this.version
                        };
                        this.sendPacket(t)
                    }
                }

                batchAck() {
                    window.clearTimeout(this.batchAckTimer), this.batchAckTimer = void 0;
                    const e = {
                        ackSendTs: this.batchAckPacketQueue[this.batchAckPacketQueue.length - 1].sendTs,
                        maxAckPacketNumber: this.batchAckPacketQueue[this.batchAckPacketQueue.length - 1].packetNumber,
                        shift: this.batchAckPacketQueue.length - 1,
                        type: gw.Ack,
                        version: this.version
                    };
                    this.sendPacket(e), this.batchAckPacketQueue = []
                }

                sendPacket(e) {
                    e.type === gw.Default && (e.sendTs = Math.round(performance.now()));
                    const t = this.serialize(e);
                    this.sendImpl(t)
                }

                clearRTO(e) {
                    for (let t = e.maxAckPacketNumber - e.shift; t <= e.maxAckPacketNumber; t++) {
                        const e = this.timeoutMap.get(t);
                        void 0 !== e && window.clearTimeout(e), this.timeoutMap.delete(t), this.rtoRatioMap.delete(t)
                    }
                }
            }

            class yw extends Wf {
                get queue() {
                    return [...this.highPriorityQueue, ...this.lowPriorityQueue]
                }

                constructor(e) {
                    super(), Kh(this, "lowPriorityQueue", []), Kh(this, "highPriorityQueue", []), Kh(this, "AgoraTransmissionManager", void 0), this.AgoraTransmissionManager = e
                }

                reset() {
                    this.lowPriorityQueue = [], this.highPriorityQueue = []
                }

                pushMessage(e) {
                    arguments.length > 1 && void 0 !== arguments[1] && arguments[1] ? this.highPriorityQueue.push(e) : this.lowPriorityQueue.push(e), this.sendMessage()
                }

                sendMessage() {
                    const e = this.queue.length;
                    let t = 0;
                    setTimeout(() => {
                        this._sendMessage()
                    }, t = e < 5 ? 15 * e : 60 + 3 * (e - 4))
                }

                _sendMessage() {
                    if (!this.queue.length) return;
                    const e = this.AgoraTransmissionManager.getConnection();
                    if (!e) return;
                    const t = this.queue.shift();
                    return this.lowPriorityQueue.includes(t) ? this.lowPriorityQueue.shift() : this.highPriorityQueue.shift(), e.sendMessage(t.compressed), t
                }
            }

            class Sw extends mw {
                constructor(e, t) {
                    super(e, t, arguments.length > 2 && void 0 !== arguments[2] && arguments[2], arguments.length > 3 ? arguments[3] : void 0), Kh(this, "_initMutex", void 0), Kh(this, "_reconnectInterrupter", void 0), Kh(this, "_url", void 0), Kh(this, "_transmitter", void 0), Kh(this, "_addresses", void 0), Kh(this, "_reliableTransmission", void 0), this._initMutex = new KE("datachannel");
                    const {timeout: r, timeoutFactor: n} = t, i = Math.max(300, Math.floor(3 * r / 5)),
                        o = Math.max(1.2, Math.floor(8 * n) / 10);
                    Yv.ONLINE && (this._retryConfig.timeout = i, this._retryConfig.timeoutFactor = o), DE.on(Jv.NETWORK_STATE_CHANGE, (e, t) => {
                        e !== t && (this.resetReconnectCount("network state change: ".concat(t, " -> ").concat(e)), e === Yv.ONLINE ? (this._retryConfig.timeout = i, this._retryConfig.timeoutFactor = o) : (this._retryConfig.timeout = r, this._retryConfig.timeoutFactor = n))
                    })
                }

                getConnection() {
                    if (this._reliableTransmission) return this._reliableTransmission
                }

                async init(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5e3;
                    this._forceCloseTimeout = t;
                    const r = (t, r) => {
                        this._addresses = e, this.currentURLIndex = this._addresses.findIndex(e => e.fingerprint || fm("FINGERPRINT"));
                        const n = this._addresses[this.currentURLIndex];
                        this.state = "connecting", this._messageSender = new yw(this), this.createTransmitterConnection(n).then(t).catch(r), this.once(rg.CLOSED, () => r(new Hf(qf.WS_DISCONNECT))), this.once(rg.CONNECTED, () => t())
                    };
                    return this._initMutex.lock().then(e => new sl((e, t) => {
                        r(e, t)
                    }).then(() => {
                        e()
                    }).catch(() => {
                        e()
                    }))
                }

                sendMessage(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                        r = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                    if (!this._transmitter || !this._reliableTransmission) throw new Hf(qf.WS_ABORT, "datachannel is not ready");
                    try {
                        let n = null;
                        n = r ? this.sendMessageWithUint8Array(e) : this.sendMessageWithJSON(e), t ? this._reliableTransmission.sendMessage(n.compressed) : this._messageSender.pushMessage(n)
                    } catch (e) {
                        throw new Hf(qf.WS_ERR, "send datachannel signal message error" + e.toString())
                    }
                }

                unbindDcCloseEventListener() {
                    this._transmitter && (this._transmitter.onclose = null)
                }

                sendMessageWithJSON(e) {
                    const t = JSON.stringify(e);
                    return {compressed: t, compressedLength: t.length, origin: e}
                }

                sendMessageWithUint8Array(e) {
                    return {compressed: e, compressedLength: e.byteLength, origin: e}
                }

                createTransmitterConnection(e) {
                    return this.connectionID += 1, this._joinChannelServiceRecordIndex = void 0, this._url = "dc://".concat(e.ip, ":").concat(e.port), new sl((t, r) => {
                        var n;
                        const i = () => {
                            em.debug("[".concat(this._name, "] datachannel opened:"), this._url), this.reconnectMode = "retry", this.state = "connected", this.resetReconnectCount("opened"), t()
                        }, o = async e => {
                            var n;
                            if (null === (n = this._closeEstablishingTransmitter) || void 0 === n || n.call(this), em.debug("[".concat(this._name, "] datachannel close ").concat(this._url, ", code: ").concat(e.code, ", reason: ").concat(e.reason, ", current mode: ").concat(this.reconnectMode)), this._reconnectCount < this._retryConfig.maxRetryCount) {
                                "connected" === this.state && (this.reconnectReason = e.reason, this.state = "reconnecting");
                                const n = tb(this, rg.WILL_RECONNECT, this.reconnectMode) || this.reconnectMode,
                                    i = await this.reconnectWithAction(n);
                                if ("closed" === this.state) return void em.debug("[".concat(this.connectionID, "] dc is closed, no need to reconnect"));
                                if (!i) return r(new Hf(qf.WS_DISCONNECT, "datachannel reconnect failed: ".concat(e.code))), void this.close(!0);
                                t()
                            } else r(new Hf(qf.WS_DISCONNECT, "datachannel close: ".concat(e.code))), this.close()
                        }, s = e => {
                            var t;
                            null === (t = this._reliableTransmission) || void 0 === t || t.onData(e.data)
                        };
                        this._transmitter && (this._transmitter.onclose = null, this._transmitter.close()), this._reliableTransmission && (this._reliableTransmission.close(), this._reliableTransmission = void 0), em.debug("[".concat(this._name, "] start connect, address: ").concat(JSON.stringify(e)));
                        const a = null === (n = this._store) || void 0 === n ? void 0 : n.recordJoinChannelService({
                            startTs: Date.now(),
                            status: "pending",
                            service: "gateway"
                        }), c = Date.now();
                        ZS(this, rg.TO_CONNECT_DATACHANNEL, e).then(e => {
                            var t, r;
                            if (!e) throw new Error("transmissonInfo not exist yet");
                            const {transmitter: n, close: u} = e;
                            this._transmitter = n, null === (t = this._store) || void 0 === t || t.signalChannelOpen();
                            const d = Date.now() - c;
                            em.debug("[choose dc] dc open cost ".concat(d, "ms")), this._reliableTransmission = new Ew(e => {
                                var t;
                                this._transmitter && "open" === this._transmitter.readyState && (null === (t = this._transmitter) || void 0 === t || t.send(e))
                            }, e => {
                                "string" == typeof e && this.emit(rg.ON_MESSAGE, e)
                            }), this._closeEstablishingTransmitter = (() => {
                                var e;
                                null === (e = this._reliableTransmission) || void 0 === e || e.close(), this._reliableTransmission = void 0, u()
                            }), i && i(), n.onclose = o, n.onmessage = s, null === (r = this._store) || void 0 === r || r.recordJoinChannelService({
                                endTs: Date.now(),
                                status: "success"
                            }, a), this._joinChannelServiceRecordIndex = a
                        }).catch(e => {
                            var t;
                            if (null === (t = this._store) || void 0 === t || t.recordJoinChannelService({
                                endTs: Date.now(),
                                status: e instanceof Hf && e.code === qf.WS_ABORT ? "aborted" : "error",
                                errors: [e]
                            }, a), "closed" !== this.state) {
                                if (e instanceof Hf && e.code === qf.WS_ERR) {
                                    const t = new Hf(qf.WS_ERR, "init datachannel failed! Error: ".concat(e.toString()));
                                    return em.error("[".concat(this._name, "]").concat(t)), void r(t)
                                }
                                o && o(e)
                            } else r(new Hf(qf.WS_DISCONNECT, "datachannel is closed: ".concat(e.toString())))
                        })
                    })
                }

                async reconnectWithAction(e) {
                    let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                    if (this._reconnectCount >= this._retryConfig.maxRetryCount) return !1;
                    if (!this._addresses) return !1;
                    if ("closed" === this.state) return !1;
                    this._onlineReconnectListener || DE.networkState !== Yv.OFFLINE || (this._onlineReconnectListener = DE.onlineWaiter && DE.onlineWaiter.then(() => {
                        this._onlineReconnectListener = void 0
                    }));
                    let r = !0;
                    if (this._reconnectInterrupter = (() => {
                        r = !1
                    }), t) {
                        const t = zf(this._reconnectCount, this._retryConfig);
                        em.debug("[".concat(this._name, "] wait ").concat(t, "ms to reconnect datachannel, mode: ").concat(e)), await sl.race([zS(t), this._onlineReconnectListener || new sl(() => {
                        })])
                    }
                    if ("closed" === this.state || !r) return !1;
                    this._reconnectCount += 1;
                    const n = async (e, t) => {
                        this.emit(rg.RECONNECT_CREATE_CONNECTION, t), await this.createTransmitterConnection(e)
                    };
                    try {
                        if ("retry" === e) {
                            const t = this._addresses[this.currentURLIndex];
                            this.emit(rg.RECONNECT_WAITTING_FINISH, e), await n(t, e)
                        } else if ("tryNext" === e) {
                            this.currentURLIndex += 1;
                            for (let e = this.currentURLIndex; e < this._addresses.length; e++) {
                                if (this._addresses[e].fingerprint || fm("FINGERPRINT")) {
                                    this.currentURLIndex = e;
                                    break
                                }
                                this.currentURLIndex += 1
                            }
                            if (this.currentURLIndex >= this._addresses.length) return em.debug("[".concat(this._name, "] the available addresses are exhausted, change to recover")), await this.reconnectWithAction("recover", !1);
                            em.debug("[".concat(this._name, "] datachannel url length: ").concat(this._addresses.length, " current index: ").concat(this.currentURLIndex));
                            const t = this._addresses[this.currentURLIndex];
                            this.emit(rg.RECONNECT_WAITTING_FINISH, e), await n(t, e)
                        } else "recover" === e && (em.debug("[".concat(this._name, "] start to failback to websocket")), this.resetReconnectCount("recover mode"), this.emit(rg.RECONNECT_WAITTING_FINISH, e), this.emit(rg.FAILBACK));
                        return !0
                    } catch (r) {
                        var i;
                        return em.error("[".concat(this._name, "] reconnect failed"), r.toString()), null != r && null !== (i = r.data) && void 0 !== i && i.desc && Array.isArray(r.data.desc) && r.data.desc.length && r.data.desc.includes("dynamic key expired") ? (this.emit(rg.ON_TOKEN_PRIVILEGE_DID_EXPIRE), !1) : await this.reconnectWithAction(e, t)
                    }
                }
            }

            class bw extends Wf {
                get connectionState() {
                    return this._connectionState
                }

                set connectionState(e) {
                    e !== this._connectionState && (this._connectionState = e, e === J_.CONNECTED ? this.emit(X_.WS_CONNECTED) : e === J_.RECONNECTING ? this.emit(X_.WS_RECONNECTING, this._websocketReconnectReason) : e === J_.CLOSED && this.emit(X_.WS_CLOSED, this._disconnectedReason))
                }

                get currentURLIndex() {
                    return this.websocket.currentURLIndex
                }

                get url() {
                    return this.websocket ? this.websocket.url : null
                }

                get rtt() {
                    return this.rttRolling.mean()
                }

                constructor(e, t) {
                    super(), Kh(this, "_disconnectedReason", void 0), Kh(this, "_websocketReconnectReason", void 0), Kh(this, "_connectionState", J_.CLOSED), Kh(this, "reconnectToken", void 0), Kh(this, "websocket", void 0), Kh(this, "openConnectionTime", void 0), Kh(this, "clientId", void 0), Kh(this, "lastMsgTime", Date.now()), Kh(this, "uploadCache", []), Kh(this, "uploadCacheInterval", void 0), Kh(this, "rttRolling", new hw(5)), Kh(this, "pingpongTimer", void 0), Kh(this, "inflateDataTimer", void 0), Kh(this, "pingpongTimeoutCount", 0), Kh(this, "joinResponse", void 0), Kh(this, "multiIpOption", void 0), Kh(this, "initError", void 0), Kh(this, "spec", void 0), Kh(this, "store", void 0), Kh(this, "onWebsocketMessage", e => {
                        if (e instanceof ArrayBuffer) return void this.emit(X_.ON_BINARY_DATA, e);
                        const t = JSON.parse(e);
                        if (this.lastMsgTime = Date.now(), Object.prototype.hasOwnProperty.call(t, "_id")) {
                            const e = "res-@".concat(t._id);
                            this.emit(e, t._result, t._message)
                        } else if (Object.prototype.hasOwnProperty.call(t, "_type") && (this.emit(t._type, t._message), t._type === Z_.ON_NOTIFICATION && this.handleNotification(t._message), t._type === Z_.ON_USER_BANNED)) switch (t._message.error_code) {
                            case 14:
                                this.close(K_.UID_BANNED);
                                break;
                            case 15:
                                this.close(K_.IP_BANNED);
                                break;
                            case 16:
                                this.close(K_.CHANNEL_BANNED)
                        }
                    }), this.clientId = e.clientId, this.spec = e, this.store = t, this.websocket = new Sw("gateway-".concat(this.clientId), this.spec.retryConfig, !0, t), this.handleWebsocketEvents(), window.addEventListener("offline", () => {
                        this.connectionState === J_.CONNECTED && this.reconnect("retry", tg.OFFLINE)
                    })
                }

                async request(e, t, r, n) {
                    const i = YS(6, ""), o = {_id: i, _type: e, _message: t}, s = this.websocket.connectionID,
                        a = () => new sl((t, r) => {
                            if (this.connectionState === J_.CONNECTED) return t();
                            const n = () => {
                                this.off(X_.WS_CLOSED, i), t()
                            }, i = () => {
                                this.off(X_.WS_CONNECTED, n), r(new Hf(qf.WS_ABORT))
                            };
                            this.once(X_.WS_CONNECTED, n), this.once(X_.WS_CLOSED, i), e !== Q_.PUBLISH && e !== Q_.SUBSCRIBE && e !== Q_.UNSUBSCRIBE && e !== Q_.UNPUBLISH && e !== Q_.CONTROL && e !== Q_.RESTART_ICE || this.once(X_.DISCONNECT_P2P, () => {
                                r(new Hf(qf.DISCONNECT_P2P))
                            }), e !== Q_.PUBLISH && e !== Q_.RESTART_ICE || this.once(X_.ABORT_P2P_EXECUTION, () => {
                                r(new Hf(qf.DISCONNECT_P2P))
                            })
                        });
                    if (this.connectionState !== J_.CONNECTING && this.connectionState !== J_.RECONNECTING || e === Q_.JOIN || e === Q_.REJOIN || await a(), e === Q_.LEAVE && (this.websocket.unbindDcCloseEventListener(), n = !0), this.websocket.sendMessage(o, !0, !1), n) return;
                    const c = new sl((r, n) => {
                        let o = !1;
                        const a = (n, i) => {
                            o = !0, r({
                                isSuccess: "success" === n,
                                message: i || {}
                            }), this.off(X_.WS_CLOSED, c), this.off(X_.WS_RECONNECTING, c), this.emit(X_.REQUEST_SUCCESS, e, t)
                        };
                        this.once("res-@".concat(i), a);
                        const c = () => {
                            n(new Hf(qf.WS_ABORT, "type: ".concat(e))), this.off(X_.WS_CLOSED, c), this.off(X_.WS_RECONNECTING, c), this.off("res-@".concat(i), a)
                        };
                        this.once(X_.WS_CLOSED, c), this.once(X_.WS_RECONNECTING, c), zS(fm("SIGNAL_REQUEST_TIMEOUT")).then(() => {
                            this.websocket.connectionID !== s || o || (em.warning("dc request timeout, type: ".concat(e)), this.emit(X_.REQUEST_TIMEOUT, e, t))
                        })
                    });
                    let u = null;
                    try {
                        u = await c
                    } catch (n) {
                        if (this.connectionState === J_.CLOSED || e === Q_.LEAVE) throw new Hf(qf.WS_ABORT);
                        return !this.spec.forceWaitGatewayResponse || r ? n.throw() : e === Q_.JOIN || e === Q_.REJOIN ? null : (await a(), await this.request(e, t))
                    }
                    if (u.isSuccess) return u.message;
                    const d = Number(u.message.error_code || u.message.code), l = cw(d),
                        h = new Hf(qf.UNEXPECTED_RESPONSE, "".concat(l.desc, ": ").concat(u.message.error_str), {
                            code: d,
                            data: u.message
                        });
                    return "success" === l.action ? u.message : (em.warning("[".concat(this.websocket.connectionID, "] unexpected response from type ").concat(e, ", error_code: ").concat(d, ", message: ").concat(l.desc, ", action: ").concat(l.action)), d === q_.ERR_TOO_MANY_BROADCASTERS ? e === Q_.JOIN || e === Q_.REJOIN ? (this.initError = h, this.close(), h.throw()) : h.throw() : "failed" === l.action ? h.throw() : "quit" === l.action ? (this.initError = h, this.close(), h.throw()) : (d === q_.ERR_JOIN_BY_MULTI_IP ? (this.multiIpOption = u.message.option, em.warning("[".concat(this.clientId, "] detect multi ip, recover")), this.reconnect("recover", tg.MULTI_IP)) : this.reconnect(l.action, tg.SERVER_ERROR), e === Q_.JOIN || e === Q_.REJOIN ? null : await this.request(e, t)))
                }

                waitMessage(e, t) {
                    return new sl(r => {
                        const n = i => {
                            (!t || t(i)) && (this.off(e, n), r(i))
                        };
                        this.on(e, n)
                    })
                }

                upload(e, t) {
                    const r = {_type: e, _message: t};
                    try {
                        this.websocket.sendMessage(r)
                    } catch (e) {
                        const t = fm("MAX_UPLOAD_CACHE") || 50;
                        this.uploadCache.push(r), this.uploadCache.length > t && this.uploadCache.splice(0, 1), this.uploadCache.length > 0 && !this.uploadCacheInterval && (this.uploadCacheInterval = window.setInterval(() => {
                            if (this.connectionState !== J_.CONNECTED) return;
                            const e = this.uploadCache.splice(0, 1)[0];
                            0 === this.uploadCache.length && (window.clearInterval(this.uploadCacheInterval), this.uploadCacheInterval = void 0), this.upload(e._type, e._message)
                        }, fm("UPLOAD_CACHE_INTERVAL") || 2e3))
                    }
                }

                send(e, t) {
                    const r = {_type: e, _message: t};
                    this.websocket.sendMessage(r)
                }

                init(e, t) {
                    return this.initError = void 0, this.multiIpOption = void 0, this.joinResponse = void 0, this.reconnectToken = void 0, this.openConnectionTime = void 0, new sl((r, n) => {
                        this.once(X_.WS_CONNECTED, () => r(this.joinResponse)), this.once(X_.WS_CLOSED, () => n(this.initError || new Hf(qf.WS_ABORT))), this.connectionState = J_.CONNECTING, this.websocket.init(e).catch(n), this.websocket.once(rg.FAILBACK, () => {
                            void 0 === this.openConnectionTime && n(new Hf(qf.INIT_DATACHANNEL_TIMEOUT))
                        }), this.inflateDataTimer && window.clearInterval(this.inflateDataTimer), this.inflateDataTimer = window.setInterval(() => {
                            this.handleInflateData()
                        }, 2e4), setTimeout(() => {
                            t && void 0 === this.openConnectionTime && (em.debug("[".concat(this.clientId, "] init datachannel timeout while join with failback to websocket")), n(new Hf(qf.INIT_DATACHANNEL_TIMEOUT)))
                        }, fm("DC_JOIN_WITH_FAILBACK"))
                    })
                }

                close(e) {
                    this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.inflateDataTimer && (this.handleInflateData(), window.clearInterval(this.inflateDataTimer), this.inflateDataTimer = void 0), this.reconnectToken = void 0, this.joinResponse = void 0, this._disconnectedReason = e || K_.LEAVE, this.connectionState = J_.CLOSED, em.debug("[".concat(this.clientId, "] ") + "will close datachannel in signal"), this.websocket.close(), e === K_.FALLBACK && (this.websocket.removeAllListeners(), this.websocket = new Sw("gateway-".concat(this.clientId), this.spec.retryConfig, !0, this.store), this.handleWebsocketEvents())
                }

                async join() {
                    if (!this.joinResponse) {
                        this.emit(X_.ABORT_P2P_EXECUTION);
                        const e = await ZS(this, X_.DATACHANNEL_CONNECTING), t = await this.request(Q_.JOIN, e);
                        if (!t) return this.emit(X_.REPORT_JOIN_GATEWAY, qf.TIMEOUT, this.url || ""), !1;
                        this.joinResponse = t, this.emit(X_.JOIN_RESPONSE, this.joinResponse), this.reconnectToken = this.joinResponse.rejoin_token
                    }
                    return this.connectionState = J_.CONNECTED, this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(this.handlePingPong.bind(this), 3e3), !0
                }

                async rejoin() {
                    if (!this.reconnectToken) throw new Hf(qf.UNEXPECTED_ERROR, "can not rejoin, no rejoin token");
                    const e = rb(this, X_.REQUEST_REJOIN_INFO);
                    e.token = this.reconnectToken;
                    const t = await this.request(Q_.REJOIN, e);
                    return !!t && (this.connectionState = J_.CONNECTED, this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(this.handlePingPong.bind(this), 3e3), t.peers && t.peers.forEach(e => {
                        this.emit(Z_.ON_USER_ONLINE, {uid: e.uid}), e.audio && this.emit(Z_.ON_ADD_AUDIO_STREAM, {
                            uid: e.uid,
                            uint_id: e.uint_id,
                            audio: !0,
                            ssrcId: e.audio_ssrc
                        }), e.video && this.emit(Z_.ON_ADD_VIDEO_STREAM, {
                            uid: e.uid,
                            uint_id: e.uint_id,
                            video: !0,
                            ssrcId: e.video_ssrc
                        }), e.audio_mute ? this.emit(Z_.MUTE_AUDIO, {uid: e.uid}) : this.emit(Z_.UNMUTE_AUDIO, {uid: e.uid}), e.video_mute ? this.emit(Z_.MUTE_VIDEO, {uid: e.uid}) : this.emit(Z_.UNMUTE_VIDEO, {uid: e.uid}), e.audio_enable_local ? this.emit(Z_.ENABLE_LOCAL_AUDIO, {uid: e.uid}) : this.emit(Z_.DISABLE_LOCAL_AUDIO, {uid: e.uid}), e.video_enable_local ? this.emit(Z_.ENABLE_LOCAL_VIDEO, {uid: e.uid}) : this.emit(Z_.DISABLE_LOCAL_VIDEO, {uid: e.uid}), e.audio || e.video || this.emit(Z_.ON_REMOVE_STREAM, {
                            uid: e.uid,
                            uint_id: e.uint_id
                        })
                    }), !0)
                }

                reconnect(e, t) {
                    this.pingpongTimer && (this.pingpongTimeoutCount = 0, window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0), this.websocket.reconnect(e, t)
                }

                handleNotification(e) {
                    em.debug("[".concat(this.clientId, "] receive notification: "), e);
                    const t = cw(e.code);
                    if ("success" !== t.action) {
                        if ("failed" !== t.action) return "quit" === t.action ? ("ERR_REPEAT_JOIN_CHANNEL" === t.desc && this.close(K_.UID_BANNED), void this.close()) : void this.reconnect(t.action, tg.SERVER_ERROR);
                        em.error("[".concat(this.clientId, "] ignore error: "), t.desc)
                    }
                }

                handlePingPong() {
                    if (!this.websocket || "connected" !== this.websocket.state) return;
                    this.pingpongTimeoutCount > 0 && this.rttRolling.add(3e3), this.pingpongTimeoutCount += 1;
                    const e = fm("PING_PONG_TIME_OUT"), t = Date.now();
                    this.pingpongTimeoutCount >= e && (em.warning("PINGPONG Timeout. Last Socket Message: ".concat(t - this.lastMsgTime, "ms")), t - this.lastMsgTime > fm("WEBSOCKET_TIMEOUT_MIN")) ? this.reconnect("retry", tg.TIMEOUT) : this.request(Q_.PING, void 0, !0).then(() => {
                        this.pingpongTimeoutCount = 0;
                        const e = Date.now() - t;
                        this.rttRolling.add(e), fm("REPORT_STATS") && this.send(Q_.PING_BACK, {pingpongElapse: e})
                    }).catch(e => {
                    })
                }

                handleInflateData() {
                    const {inflateLength: e, deflateLength: t} = this.websocket.getInflateData();
                    0 !== e && 0 !== t && this.upload($_.WS_INFLATE_DATA_LENGTH, {
                        ws_deflate_length: t,
                        ws_inflate_length: e
                    })
                }

                handleWebsocketEvents() {
                    this.websocket.on(rg.RECONNECT_WAITTING_FINISH, e => {
                        this.emit(X_.WS_RECONNECT_WAITTING_FINISH, e)
                    }), this.websocket.on(rg.RECONNECT_CREATE_CONNECTION, e => {
                        this.emit(X_.WS_RECONNECT_CREATE_CONNECTION, e)
                    }), this.websocket.on(rg.ON_MESSAGE, this.onWebsocketMessage), this.websocket.on(rg.CLOSED, () => {
                        this.connectionState = J_.CLOSED
                    }), this.websocket.on(rg.FAILED, () => {
                        this._disconnectedReason = K_.NETWORK_ERROR, this.connectionState = J_.CLOSED
                    }), this.websocket.on(rg.RECONNECTING, e => {
                        this._websocketReconnectReason = e, this.joinResponse = void 0, this.connectionState === J_.CONNECTED ? this.connectionState = J_.RECONNECTING : this.connectionState = J_.CONNECTING
                    }), this.websocket.on(rg.WILL_RECONNECT, (e, t) => {
                        if (rb(this, X_.IS_P2P_DISCONNECTED) && "retry" === e) return em.debug("".concat(this.clientId, " reconnect mode is retry, but p2p lost, change to tryNext")), this.reconnectToken = void 0, this.emit(X_.NEED_RENEW_SESSION), this.emit(X_.DISCONNECT_P2P), t("tryNext");
                        "retry" !== e && (em.debug("".concat(this.clientId, " websockt will_connect event, renewSession reconnectMode is ").concat(e)), this.reconnectToken = void 0, this.emit(X_.NEED_RENEW_SESSION), this.emit(X_.DISCONNECT_P2P)), t(e)
                    }), this.websocket.on(rg.CONNECTED, () => {
                        this.openConnectionTime = Date.now(), this.reconnectToken ? this.rejoin().catch(e => {
                            em.warning("[".concat(this.clientId, "] rejoin failed ").concat(e)), this.reconnect("tryNext", tg.SERVER_ERROR)
                        }) : this.join().catch(e => {
                            if (this.emit(X_.REPORT_JOIN_GATEWAY, e.message || e.code, this.url || ""), e instanceof Hf && e.code === qf.UNEXPECTED_RESPONSE && e.data.code === q_.ERR_NO_AUTHORIZED) return em.warning("[".concat(this.clientId, "] reconnect no authorized, recover")), void this.reconnect("recover", tg.SERVER_ERROR);
                            em.error("[".concat(this.clientId, "] join gateway request failed"), e.toString()), this.spec.forceWaitGatewayResponse ? this.reconnect("tryNext", tg.SERVER_ERROR) : (this.initError = e, this.close())
                        })
                    }), this.websocket.on(rg.REQUEST_NEW_URLS, (e, t) => {
                        ZS(this, X_.REQUEST_RECOVER, this.multiIpOption).then(e).catch(t)
                    }), this.websocket.on(rg.ON_TOKEN_PRIVILEGE_DID_EXPIRE, () => {
                        this.emit(Z_.ON_TOKEN_PRIVILEGE_DID_EXPIRE)
                    }), this.websocket.on(rg.TO_CONNECT_DATACHANNEL, async (e, t, r) => ZS(this, X_.DATACHANNEL_PRECONNECT, e).then(t).catch(r)), this.websocket.on(rg.FAILBACK, () => {
                        void 0 !== this.openConnectionTime && this.emit(X_.DATACHANNEL_FAILBACK)
                    })
                }
            }

            function Tw(e, t) {
                var r = Object.keys(e);
                if (Object.getOwnPropertySymbols) {
                    var n = Object.getOwnPropertySymbols(e);
                    t && (n = n.filter(function (t) {
                        return Object.getOwnPropertyDescriptor(e, t).enumerable
                    })), r.push.apply(r, n)
                }
                return r
            }

            function Rw(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var r = null != arguments[t] ? arguments[t] : {};
                    t % 2 ? Tw(Object(r), !0).forEach(function (t) {
                        Kh(e, t, r[t])
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : Tw(Object(r)).forEach(function (t) {
                        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t))
                    })
                }
                return e
            }

            const Iw = new Map;

            /*! formdata-polyfill. MIT License. Jimmy W?rting <https://jimmy.warting.se/opensource> */
            function ww(e, t) {
                var r = Object.keys(e);
                if (Object.getOwnPropertySymbols) {
                    var n = Object.getOwnPropertySymbols(e);
                    t && (n = n.filter(function (t) {
                        return Object.getOwnPropertyDescriptor(e, t).enumerable
                    })), r.push.apply(r, n)
                }
                return r
            }

            function Cw(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var r = null != arguments[t] ? arguments[t] : {};
                    t % 2 ? ww(Object(r), !0).forEach(function (t) {
                        Kh(e, t, r[t])
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : ww(Object(r)).forEach(function (t) {
                        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t))
                    })
                }
                return e
            }

            !function () {
                var t;

                function r(e) {
                    var t = 0;
                    return function () {
                        return t < e.length ? {done: !1, value: e[t++]} : {done: !0}
                    }
                }

                var n, i = "function" == typeof Object.defineProperties ? Object.defineProperty : function (e, t, r) {
                    return e == Array.prototype || e == Object.prototype || (e[t] = r.value), e
                }, o = function (t) {
                    t = ["object" == typeof globalThis && globalThis, t, "object" == typeof window && window, "object" == typeof self && self, "object" == typeof e && e];
                    for (var r = 0; r < t.length; ++r) {
                        var n = t[r];
                        if (n && n.Math == Math) return n
                    }
                    throw Error("Cannot find global object")
                }(this);

                function s(e, t) {
                    if (t) e:{
                        var r = o;
                        e = e.split(".");
                        for (var n = 0; n < e.length - 1; n++) {
                            var s = e[n];
                            if (!(s in r)) break e;
                            r = r[s]
                        }
                        (t = t(n = r[e = e[e.length - 1]])) != n && null != t && i(r, e, {
                            configurable: !0,
                            writable: !0,
                            value: t
                        })
                    }
                }

                function a(e) {
                    return (e = {next: e})[Symbol.iterator] = function () {
                        return this
                    }, e
                }

                function c(e) {
                    var t = "undefined" != typeof Symbol && Symbol.iterator && e[Symbol.iterator];
                    return t ? t.call(e) : {next: r(e)}
                }

                if (s("Symbol", function (e) {
                    function t(e, t) {
                        this.A = e, i(this, "description", {configurable: !0, writable: !0, value: t})
                    }

                    if (e) return e;
                    t.prototype.toString = function () {
                        return this.A
                    };
                    var r = "jscomp_symbol_" + (1e9 * Math.random() >>> 0) + "_", n = 0;
                    return function e(i) {
                        if (this instanceof e) throw new TypeError("Symbol is not a constructor");
                        return new t(r + (i || "") + "_" + n++, i)
                    }
                }), s("Symbol.iterator", function (e) {
                    if (e) return e;
                    e = Symbol("Symbol.iterator");
                    for (var t = "Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "), n = 0; n < t.length; n++) {
                        var s = o[t[n]];
                        "function" == typeof s && "function" != typeof s.prototype[e] && i(s.prototype, e, {
                            configurable: !0,
                            writable: !0,
                            value: function () {
                                return a(r(this))
                            }
                        })
                    }
                    return e
                }), "function" == typeof Object.setPrototypeOf) n = Object.setPrototypeOf; else {
                    var u;
                    e:{
                        var d = {};
                        try {
                            d.__proto__ = {a: !0}, u = d.a;
                            break e
                        } catch (t) {
                        }
                        u = !1
                    }
                    n = u ? function (e, t) {
                        if (e.__proto__ = t, e.__proto__ !== t) throw new TypeError(e + " is not extensible");
                        return e
                    } : null
                }
                var l = n;

                function h() {
                    this.m = !1, this.j = null, this.v = void 0, this.h = 1, this.u = this.C = 0, this.l = null
                }

                function p(e) {
                    if (e.m) throw new TypeError("Generator is already running");
                    e.m = !0
                }

                function f(e, t) {
                    return e.h = 3, {value: t}
                }

                function m(e) {
                    this.g = new h, this.G = e
                }

                function _(e, t, r, n) {
                    try {
                        var i = t.call(e.g.j, r);
                        if (!(i instanceof Object)) throw new TypeError("Iterator result " + i + " is not an object");
                        if (!i.done) return e.g.m = !1, i;
                        var o = i.value
                    } catch (t) {
                        return e.g.j = null, e.g.s(t), v(e)
                    }
                    return e.g.j = null, n.call(e.g, o), v(e)
                }

                function v(e) {
                    for (; e.g.h;) try {
                        var t = e.G(e.g);
                        if (t) return e.g.m = !1, {value: t.value, done: !1}
                    } catch (t) {
                        e.g.v = void 0, e.g.s(t)
                    }
                    if (e.g.m = !1, e.g.l) {
                        if (t = e.g.l, e.g.l = null, t.F) throw t.D;
                        return {value: t.return, done: !0}
                    }
                    return {value: void 0, done: !0}
                }

                function g(e, t) {
                    return t = new function (e) {
                        this.next = function (t) {
                            return e.o(t)
                        }, this.throw = function (t) {
                            return e.s(t)
                        }, this.return = function (t) {
                            return function (e, t) {
                                p(e.g);
                                var r = e.g.j;
                                return r ? _(e, "return" in r ? r.return : function (e) {
                                    return {value: e, done: !0}
                                }, t, e.g.return) : (e.g.return(t), v(e))
                            }(e, t)
                        }, this[Symbol.iterator] = function () {
                            return this
                        }
                    }(new m(t)), l && e.prototype && l(t, e.prototype), t
                }

                if (h.prototype.o = function (e) {
                    this.v = e
                }, h.prototype.s = function (e) {
                    this.l = {D: e, F: !0}, this.h = this.C || this.u
                }, h.prototype.return = function (e) {
                    this.l = {return: e}, this.h = this.u
                }, m.prototype.o = function (e) {
                    return p(this.g), this.g.j ? _(this, this.g.j.next, e, this.g.o) : (this.g.o(e), v(this))
                }, m.prototype.s = function (e) {
                    return p(this.g), this.g.j ? _(this, this.g.j.throw, e, this.g.o) : (this.g.s(e), v(this))
                }, s("Array.prototype.entries", function (e) {
                    return e || function () {
                        return function (e, t) {
                            e instanceof String && (e += "");
                            var r = 0, n = !1, i = {
                                next: function () {
                                    if (!n && r < e.length) {
                                        var t = r++;
                                        return {
                                            value: function (e, t) {
                                                return [e, t]
                                            }(t, e[t]), done: !1
                                        }
                                    }
                                    return n = !0, {done: !0, value: void 0}
                                }
                            };
                            return i[Symbol.iterator] = function () {
                                return i
                            }, i
                        }(this)
                    }
                }), "undefined" != typeof Blob && ("undefined" == typeof FormData || !FormData.prototype.keys)) {
                    var E = function (e, t) {
                            for (var r = 0; r < e.length; r++) t(e[r])
                        }, y = function (e) {
                            return e.replace(/\r?\n|\r/g, "\r\n")
                        }, S = function (e, t, r) {
                            return t instanceof Blob ? (r = void 0 !== r ? String(r + "") : "string" == typeof t.name ? t.name : "blob", t.name === r && "[object Blob]" !== Object.prototype.toString.call(t) || (t = new File([t], r)), [String(e), t]) : [String(e), String(t)]
                        }, b = function (e, t) {
                            if (e.length < t) throw new TypeError(t + " argument required, but only " + e.length + " present.")
                        },
                        T = "object" == typeof globalThis ? globalThis : "object" == typeof window ? window : "object" == typeof self ? self : this,
                        R = T.FormData, I = T.XMLHttpRequest && T.XMLHttpRequest.prototype.send,
                        w = T.Request && T.fetch, C = T.navigator && T.navigator.sendBeacon,
                        A = T.Element && T.Element.prototype, O = T.Symbol && Symbol.toStringTag;
                    O && (Blob.prototype[O] || (Blob.prototype[O] = "Blob"), "File" in T && !File.prototype[O] && (File.prototype[O] = "File"));
                    try {
                        new File([], "")
                    } catch (t) {
                        T.File = function (e, t, r) {
                            return e = new Blob(e, r || {}), Object.defineProperties(e, {
                                name: {value: t},
                                lastModified: {value: +(r && void 0 !== r.lastModified ? new Date(r.lastModified) : new Date)},
                                toString: {
                                    value: function () {
                                        return "[object File]"
                                    }
                                }
                            }), O && Object.defineProperty(e, O, {value: "File"}), e
                        }
                    }
                    var N = function (e) {
                        return e.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22")
                    }, P = function (e) {
                        this.i = [];
                        var t = this;
                        e && E(e.elements, function (e) {
                            if (e.name && !e.disabled && "submit" !== e.type && "button" !== e.type && !e.matches("form fieldset[disabled] *")) if ("file" === e.type) {
                                var r = e.files && e.files.length ? e.files : [new File([], "", {type: "application/octet-stream"})];
                                E(r, function (r) {
                                    t.append(e.name, r)
                                })
                            } else "select-multiple" === e.type || "select-one" === e.type ? E(e.options, function (r) {
                                !r.disabled && r.selected && t.append(e.name, r.value)
                            }) : "checkbox" === e.type || "radio" === e.type ? e.checked && t.append(e.name, e.value) : (r = "textarea" === e.type ? y(e.value) : e.value, t.append(e.name, r))
                        })
                    };
                    if ((t = P.prototype).append = function (e, t, r) {
                        b(arguments, 2), this.i.push(S(e, t, r))
                    }, t.delete = function (e) {
                        b(arguments, 1);
                        var t = [];
                        e = String(e), E(this.i, function (r) {
                            r[0] !== e && t.push(r)
                        }), this.i = t
                    }, t.entries = function e() {
                        var t, r = this;
                        return g(e, function (e) {
                            if (1 == e.h && (t = 0), 3 != e.h) return t < r.i.length ? e = f(e, r.i[t]) : (e.h = 0, e = void 0), e;
                            t++, e.h = 2
                        })
                    }, t.forEach = function (e, t) {
                        b(arguments, 1);
                        for (var r = c(this), n = r.next(); !n.done; n = r.next()) {
                            var i = c(n.value);
                            n = i.next().value, i = i.next().value, e.call(t, i, n, this)
                        }
                    }, t.get = function (e) {
                        b(arguments, 1);
                        var t = this.i;
                        e = String(e);
                        for (var r = 0; r < t.length; r++) if (t[r][0] === e) return t[r][1];
                        return null
                    }, t.getAll = function (e) {
                        b(arguments, 1);
                        var t = [];
                        return e = String(e), E(this.i, function (r) {
                            r[0] === e && t.push(r[1])
                        }), t
                    }, t.has = function (e) {
                        b(arguments, 1), e = String(e);
                        for (var t = 0; t < this.i.length; t++) if (this.i[t][0] === e) return !0;
                        return !1
                    }, t.keys = function e() {
                        var t, r, n, i, o = this;
                        return g(e, function (e) {
                            if (1 == e.h && (t = c(o), r = t.next()), 3 != e.h) return r.done ? void (e.h = 0) : (n = r.value, i = c(n), f(e, i.next().value));
                            r = t.next(), e.h = 2
                        })
                    }, t.set = function (e, t, r) {
                        b(arguments, 2), e = String(e);
                        var n = [], i = S(e, t, r), o = !0;
                        E(this.i, function (t) {
                            t[0] === e ? o && (o = !n.push(i)) : n.push(t)
                        }), o && n.push(i), this.i = n
                    }, t.values = function e() {
                        var t, r, n, i, o = this;
                        return g(e, function (e) {
                            if (1 == e.h && (t = c(o), r = t.next()), 3 != e.h) return r.done ? void (e.h = 0) : (n = r.value, (i = c(n)).next(), f(e, i.next().value));
                            r = t.next(), e.h = 2
                        })
                    }, P.prototype._asNative = function () {
                        for (var e = new R, t = c(this), r = t.next(); !r.done; r = t.next()) {
                            var n = c(r.value);
                            r = n.next().value, n = n.next().value, e.append(r, n)
                        }
                        return e
                    }, P.prototype._blob = function () {
                        var e = "----formdata-polyfill-" + Math.random(), t = [],
                            r = "--" + e + '\r\nContent-Disposition: form-data; name="';
                        return this.forEach(function (e, n) {
                            return "string" == typeof e ? t.push(r + N(y(n)) + '"\r\n\r\n' + y(e) + "\r\n") : t.push(r + N(y(n)) + '"; filename="' + N(e.name) + '"\r\nContent-Type: ' + (e.type || "application/octet-stream") + "\r\n\r\n", e, "\r\n")
                        }), t.push("--" + e + "--"), new Blob(t, {type: "multipart/form-data; boundary=" + e})
                    }, P.prototype[Symbol.iterator] = function () {
                        return this.entries()
                    }, P.prototype.toString = function () {
                        return "[object FormData]"
                    }, A && !A.matches && (A.matches = A.matchesSelector || A.mozMatchesSelector || A.msMatchesSelector || A.oMatchesSelector || A.webkitMatchesSelector || function (e) {
                        for (var t = (e = (this.document || this.ownerDocument).querySelectorAll(e)).length; 0 <= --t && e.item(t) !== this;) ;
                        return -1 < t
                    }), O && (P.prototype[O] = "FormData"), I) {
                        var D = T.XMLHttpRequest.prototype.setRequestHeader;
                        T.XMLHttpRequest.prototype.setRequestHeader = function (e, t) {
                            D.call(this, e, t), "content-type" === e.toLowerCase() && (this.B = !0)
                        }, T.XMLHttpRequest.prototype.send = function (e) {
                            e instanceof P ? (e = e._blob(), this.B || this.setRequestHeader("Content-Type", e.type), I.call(this, e)) : I.call(this, e)
                        }
                    }
                    w && (T.fetch = function (e, t) {
                        return t && t.body && t.body instanceof P && (t.body = t.body._blob()), w.call(this, e, t)
                    }), C && (T.navigator.sendBeacon = function (e, t) {
                        return t instanceof P && (t = t._asNative()), C.call(this, e, t)
                    }), T.FormData = P
                }
            }();
            let Aw = 1, Ow = 1;

            function Nw(e, t, r, n) {
                let {url: i, areaCode: o} = e;
                const s = Date.now();
                let a;
                const [c, u] = xw(t, o, [sg.CHOOSE_SERVER]);
                let d = DE.networkState;
                return Yf(async () => {
                    d && DE.networkState === Yv.OFFLINE && DE.onlineWaiter && await sl.race([DE.onlineWaiter, zS(n && n.maxRetryTimeout || Kf.maxRetryTimeout)]), d = DE.networkState;
                    const {data: e, headers: o} = await NE(i, {
                        data: c,
                        cancelToken: r,
                        headers: {"Content-Type": "multipart/form-data;"}
                    }, !0, !0);
                    a = "1" === o.http3 ? 1 : -1, WE.reportResourceTiming(i, t.sid), Dw(e, i, t, s, [sg.CHOOSE_SERVER], a);
                    const u = WS(e, sg.CHOOSE_SERVER);
                    return kw(u), US(u, i)
                }, e => (e && WE.joinChooseServer(t.sid, {
                    lts: s,
                    succ: !0,
                    csAddr: i,
                    opid: u,
                    serverList: e.gatewayAddrs.map(e => e.address),
                    ec: null,
                    cid: e.cid.toString(),
                    uid: e.uid.toString(),
                    csIp: e.csIp,
                    unilbsServerIds: [sg.CHOOSE_SERVER].toString(),
                    isHttp3: a
                }), !1), e => e.code !== qf.OPERATION_ABORTED && (e.code === qf.CAN_NOT_GET_GATEWAY_SERVER ? e.data.retry : (WE.joinChooseServer(t.sid, {
                    lts: s,
                    succ: !1,
                    csAddr: i,
                    serverList: null,
                    opid: u,
                    ec: e.code,
                    csIp: e.data && e.data.csIp,
                    unilbsServerIds: [sg.CHOOSE_SERVER].toString(),
                    extend: JSON.stringify({networkState: d}),
                    isHttp3: a
                }), em.warning("[".concat(t.clientId, "] Choose server network error, retry"), e), !0)), n)
            }

            function Pw(e, t, r, n) {
                let i, {url: o, areaCode: s, serviceIds: a} = e;
                const c = Date.now(), [u, d] = xw(t, s, a);
                let l = void 0;
                return Yf(async () => {
                    l && DE.networkState === Yv.OFFLINE && DE.onlineWaiter && await sl.race([DE.onlineWaiter, zS(n && n.maxRetryTimeout || Kf.maxRetryTimeout)]), l = DE.networkState;
                    const {data: e, headers: s} = await NE(o, {
                        data: u,
                        cancelToken: r,
                        headers: {"Content-Type": "multipart/form-data;"}
                    }, !0, !0);
                    i = "1" === s.http3 ? 1 : -1, WE.reportResourceTiming(o, t.sid), Dw(e, o, t, c, a, i);
                    const d = WS(e, sg.CHOOSE_SERVER),
                        h = WS(e, "proxy5" === t.cloudProxyServer ? sg.CLOUD_PROXY_5 : "proxy3" === t.cloudProxyServer || "proxy4" === t.cloudProxyServer ? sg.CLOUD_PROXY : sg.CLOUD_PROXY_FALLBACK);
                    return kw(d), {gatewayInfo: US(d, o), proxyInfo: h, url: o}
                }, e => (e.gatewayInfo && WE.joinChooseServer(t.sid, {
                    lts: c,
                    succ: !0,
                    csAddr: o,
                    serverList: e.gatewayInfo.gatewayAddrs.map(e => e.address),
                    ec: null,
                    opid: d,
                    cid: e.gatewayInfo.cid.toString(),
                    uid: e.gatewayInfo.uid.toString(),
                    csIp: e.gatewayInfo.csIp,
                    unilbsServerIds: a.toString(),
                    isHttp3: i
                }), e.proxyInfo && WE.joinWebProxyAP(t.sid, {
                    lts: c,
                    sucess: 1,
                    apServerAddr: o,
                    turnServerAddrList: e.proxyInfo.addresses.map(e => e.ip).join(","),
                    errorCode: null,
                    eventType: t.cloudProxyServer,
                    unilbsServerIds: a.toString()
                }), !1), e => e.code !== qf.OPERATION_ABORTED && (e.code === qf.CAN_NOT_GET_GATEWAY_SERVER ? e.data.retry : (WE.joinWebProxyAP(t.sid, {
                    lts: c,
                    sucess: 0,
                    apServerAddr: o,
                    turnServerAddrList: null,
                    errorCode: e.code,
                    eventType: t.cloudProxyServer,
                    unilbsServerIds: a.toString(),
                    extend: JSON.stringify({networkState: l})
                }), em.warning("[".concat(t.clientId, "] multi unilbs network error, retry"), e), !0)), n)
            }

            const Dw = (e, t, r, n, i, o) => {
                const s = [], a = s => {
                    4096 === s.flag ? WE.joinChooseServer(r.sid, {
                        lts: n,
                        succ: !1,
                        csAddr: t,
                        opid: e.opid,
                        serverList: null,
                        ec: s.error.message,
                        csIp: s.error.data && s.error.data.csIp,
                        unilbsServerIds: i.toString(),
                        isHttp3: o
                    }) : 1048576 !== s.flag && 4194304 !== s.flag && 4194310 !== s.flag || WE.joinWebProxyAP(r.sid, {
                        lts: n,
                        sucess: 0,
                        apServerAddr: t,
                        turnServerAddrList: null,
                        errorCode: s.error.code,
                        eventType: r.cloudProxyServer,
                        unilbsServerIds: i.toString()
                    })
                };
                if (e.response_body.forEach(t => {
                    const r = t.buffer.code;
                    if (23 === t.uri && 0 === r && !t.buffer.edges_services) if (4194310 === t.buffer.flag) em.warning("no edge services in ap response of proxy fallback, will not set proxy in iceServers"), t.buffer.edges_services = []; else {
                        const r = {
                            error: new Hf(qf.CAN_NOT_GET_GATEWAY_SERVER, "no edge services in ap response", {
                                retry: !0,
                                csIp: e.detail[502]
                            }), flag: t.buffer.flag
                        };
                        s.push(r), a(r)
                    }
                    if (0 !== r) {
                        const n = sw(r), i = {
                            error: new Hf(qf.CAN_NOT_GET_GATEWAY_SERVER, n.desc, {
                                desc: n.desc,
                                retry: n.retry,
                                csIp: e.detail[502]
                            }), flag: t.buffer.flag
                        };
                        4194310 === t.buffer.flag ? em.warning(i.error.toString()) : s.push(i), a(i)
                    }
                }), s.length) throw em.warning("[".concat(r.clientId, "] multi unilbs ").concat(t, " failed, ").concat(s.map(e => "flag: ".concat(e.flag, ", message: ").concat(e.error.message, ", retry: ").concat(e.error.data.retry)).join(" | "))), new Hf(qf.CAN_NOT_GET_GATEWAY_SERVER, s.map(e => "flag: ".concat(e.flag, ", message: ").concat(e.error.message)).join(" | "), {
                    retry: !!s.find(e => e.error.data.retry),
                    csIp: e.detail[502],
                    desc: [...new Set(s.map(e => {
                        var t, r;
                        return null == e || null === (t = e.error) || void 0 === t || null === (r = t.data) || void 0 === r ? void 0 : r.desc
                    }).filter(e => !!e))]
                })
            }, kw = e => {
                var t, r;
                if (e.addresses && 0 === e.addresses.length && 0 === e.code) throw new Hf(qf.CAN_NOT_GET_GATEWAY_SERVER, "void gateway address", {
                    retry: !0,
                    csIp: e.detail && e.detail[502]
                });
                if (null !== (t = e.detail) && void 0 !== t && t[19] && "string" == typeof (null === (r = e.detail) || void 0 === r ? void 0 : r[19])) {
                    const t = e.detail[19], r = null == t ? void 0 : t.split(";");
                    for (let t = 0; t < r.length; t++) {
                        var n;
                        const i = nh(n = r[t]).call(n);
                        e.addresses[t] && r && (e.addresses[t].fingerprint = i)
                    }
                }
                if (fm("GATEWAY_ADDRESS") && fm("GATEWAY_ADDRESS").length > 0) {
                    em.debug("assign gateway address to", fm("GATEWAY_ADDRESS"));
                    const t = fm("GATEWAY_ADDRESS").map(t => {
                        var r, n;
                        const i = null !== (r = null === (n = e.addresses.find(e => e.ip === t.ip && e.port === t.port)) || void 0 === n ? void 0 : n.fingerprint) && void 0 !== r ? r : "";
                        return {ip: t.ip, port: t.port, ticket: e.addresses[0] && e.addresses[0].ticket, fingerprint: i}
                    });
                    e.addresses = t
                }
            }, Lw = (e, t) => {
                if (e.response_body && e.response_body.length) {
                    const t = e.response_body[0];
                    if (0 !== t.buffer.code) {
                        const e = sw(t.buffer.code);
                        throw new Hf(qf.UPDATE_TICKET_FAILED, "[".concat(t.buffer.code, "]: ").concat(e.desc), {retry: e.retry})
                    }
                    return t.buffer.ticket
                }
                throw em.debug("update ticket request received ap response without response body:", t), new Hf(qf.UPDATE_TICKET_FAILED, "cannot find response body from ap response", {retry: !1})
            }, xw = (e, t, r) => {
                const n = Math.floor(1e12 * Math.random()), i = {
                    appid: e.appId,
                    client_ts: Date.now(),
                    opid: n,
                    sid: e.sid,
                    request_bodies: [{
                        uri: 22,
                        buffer: {
                            cname: e.cname,
                            detail: {6: e.stringUid, 11: t, 12: fm("USE_NEW_TOKEN") ? "1" : void 0},
                            key: e.token,
                            service_ids: r,
                            uid: e.uid || 0
                        }
                    }]
                };
                i.request_bodies.forEach(t => {
                    e.multiIP && e.multiIP.gateway_ip && (t.buffer.detail[5] = JSON.stringify({
                        vocs_ip: [e.multiIP.uni_lbs_ip],
                        vos_ip: [e.multiIP.gateway_ip]
                    }))
                });
                const o = new FormData;
                return o.append("request", JSON.stringify(i)), [o, n]
            }, Mw = (e, t) => {
                const r = Math.floor(1e12 * Math.random()), n = {
                    appid: e.appId,
                    client_ts: Date.now(),
                    opid: r,
                    sid: e.sid,
                    request_bodies: [{
                        uri: 28,
                        buffer: {
                            cname: e.cname,
                            detail: {1: "", 6: e.stringUid, 12: "1"},
                            token: e.token,
                            service_ids: t,
                            uid: e.uid || 0,
                            edges_services: e.apResponse.addresses.map(e => ({ip: e.ip, port: e.port}))
                        }
                    }]
                }, i = new FormData;
                return i.append("request", JSON.stringify(n)), [i, r]
            };
            let Uw = 0;
            const jw = () => {
                    const e = fm("AREAS");
                    return 0 === e.length && e.push(Mv.GLOBAL), Kr(e).call(e, (e, t, r) => {
                        const n = Vw(t);
                        return n ? 0 === r ? n : "".concat(e, ",").concat(n) : e
                    }, "")
                },
                Vw = e => e === Mv.OVERSEA ? "".concat(Fv.ASIA, ",").concat(Fv.EUROPE, ",").concat(Fv.AFRICA, ",").concat(Fv.NORTH_AMERICA, ",").concat(Fv.SOUTH_AMERICA, ",").concat(Fv.OCEANIA) : Fv[e],
                Fw = {
                    GLOBAL: {
                        ASIA: [Mv.CHINA, Mv.JAPAN, Mv.INDIA, Mv.KOREA, Mv.HKMC],
                        EUROPE: [],
                        NORTH_AMERICA: [Mv.US],
                        SOUTH_AMERICA: [],
                        OCEANIA: [],
                        AFRICA: []
                    }
                }, Bw = Object.keys(Fw[Mv.GLOBAL]),
                Ww = [Mv.CHINA, Mv.NORTH_AMERICA, Mv.EUROPE, Mv.ASIA, Mv.JAPAN, Mv.INDIA, Mv.OCEANIA, Mv.SOUTH_AMERICA, Mv.AFRICA, Mv.KOREA, Mv.HKMC, Mv.US];

            async function Gw(e, t, r, n) {
                const i = async function (e, t, r, n) {
                    let i = null;
                    const o = [];
                    try {
                        return i = await $S([(async () => {
                            const i = fm("WEBCS_DOMAIN").slice(0, fm("AJAX_REQUEST_CONCURRENT")).map(t => ({
                                url: e.proxyServer ? "https://".concat(e.proxyServer, "/ap/?url=").concat(t + "/api/v2/transpond/webrtc?v=2") : "https://".concat(t, "/api/v2/transpond/webrtc?v=2"),
                                areaCode: jw()
                            })), s = n.recordJoinChannelService({
                                startTs: Date.now(),
                                status: "pending",
                                service: "chooseServer",
                                urls: i.map(e => e.url)
                            }), a = await pb({
                                fragementLength: fm("FRAGEMENT_LENGTH"),
                                referenceList: i,
                                asyncMapHandler: n => (em.debug("[".concat(e.clientId, "] Connect to choose_server:"), n.url), Nw(n, e, t, r)),
                                allFailedhandler: e => {
                                    throw n.recordJoinChannelService({
                                        endTs: Date.now(),
                                        status: "error",
                                        errors: e
                                    }, s), e[0]
                                },
                                promisesCollector: o
                            });
                            return n.recordJoinChannelService({endTs: Date.now(), status: "success"}, s), a
                        })(), (async () => {
                            if (await zS(1e3), null !== i) return i;
                            const s = fm("WEBCS_DOMAIN_BACKUP_LIST").map(t => ({
                                url: e.proxyServer ? "https://".concat(e.proxyServer, "/ap/?url=").concat(t + "/api/v2/transpond/webrtc?v=2") : "https://".concat(t, "/api/v2/transpond/webrtc?v=2"),
                                areaCode: jw()
                            })), a = n.recordJoinChannelService({
                                endTs: void 0,
                                startTs: Date.now(),
                                status: "pending",
                                service: "chooseServer",
                                urls: s.map(e => e.url)
                            }), c = await pb({
                                fragementLength: fm("FRAGEMENT_LENGTH"),
                                referenceList: s,
                                asyncMapHandler: n => (em.debug("[".concat(e.clientId, "] Connect to backup choose_server:"), n.url), Nw(n, e, t, r)),
                                allFailedhandler: e => {
                                    throw n.recordJoinChannelService({
                                        endTs: Date.now(),
                                        status: "error",
                                        errors: e
                                    }, a), e[0]
                                },
                                promisesCollector: o
                            });
                            return n.recordJoinChannelService({endTs: Date.now(), status: "success"}, a), c
                        })()]), o.length && o.forEach(e => e.cancel && "function" == typeof e.cancel && e.cancel()), i
                    } catch (e) {
                        throw e[0]
                    }
                }(e, t, r, n);
                return {gatewayInfo: await i}
            }

            async function qw(e, t, r, n, i) {
                const o = e.cloudProxyServer;
                if ("disabled" === o) {
                    if (!n) return;
                    if (e.useLocalAccessPoint) return await Gw(e, t, r, i);
                    if (fm("JOIN_WITH_FALLBACK_MEDIA_PROXY")) {
                        const {gatewayInfo: n, proxyInfo: o} = await Kw(e, t, r, i);
                        return e.turnServer && "auto" !== e.turnServer.mode || (e.turnServer = {
                            mode: "manual",
                            servers: o.map(e => ({
                                turnServerURL: e.address,
                                tcpport: e.tcpport || im.tcpport,
                                udpport: e.udpport || im.udpport,
                                username: e.username || im.username,
                                password: e.password || im.password,
                                forceturn: fm("JOIN_WITH_FALLBACK_MEDIA_PROXY_FORCE"),
                                security: !0
                            }))
                        }), {gatewayInfo: n}
                    }
                    return await Gw(e, t, r, i)
                }
                const {proxyInfo: s, gatewayInfo: a} = await Kw(e, t, r, i), c = {gatewayInfo: a};
                return e.turnServer = {
                    mode: "manual",
                    servers: s.map(e => ({
                        turnServerURL: e.address,
                        tcpport: "proxy3" === o ? void 0 : e.tcpport ? e.tcpport : im.tcpport,
                        udpport: "proxy4" === o ? void 0 : e.udpport ? e.udpport : im.udpport,
                        username: e.username || im.username,
                        password: e.password || im.password,
                        forceturn: "proxy4" !== o,
                        security: "proxy5" === o
                    }))
                }, em.debug("[".concat(e.clientId, "] set proxy server: ").concat(e.proxyServer, ", mode: ").concat(o)), c
            }

            async function Hw(e, t, r, n, i) {
                const o = fm("ACCOUNT_REGISTER").slice(0, fm("AJAX_REQUEST_CONCURRENT"));
                let s = [];
                s = t.proxyServer ? o.map(e => "https://".concat(t.proxyServer, "/ap/?url=").concat(e + "/api/v1")) : o.map(e => "https://".concat(e, "/api/v1"));
                const a = null == i ? void 0 : i.recordJoinChannelService({
                    startTs: Date.now(),
                    status: "pending",
                    service: "stringUID",
                    urls: s
                });
                try {
                    const o = await async function (e, t, r, n, i) {
                        const o = Date.now(), s = {sid: r.sid, opid: 10, appid: r.appId, string_uid: t};
                        let a = e[0];
                        const c = await Yf(() => NE(a + "".concat(-1 === a.indexOf("?") ? "?" : "&", "action=stringuid"), {
                            data: s,
                            cancelToken: n,
                            headers: {"X-Packet-Service-Type": 0, "X-Packet-URI": 72}
                        }), (r, n) => {
                            if (0 === r.code) {
                                if (r.uid <= 0 || r.uid >= Math.pow(2, 32)) throw em.error("Invalid Uint Uid ".concat(t, " => ").concat(r.uid), r), WE.reqUserAccount(s.sid, {
                                    lts: o,
                                    success: !1,
                                    serverAddr: a,
                                    stringUid: s.string_uid,
                                    uid: r.uid,
                                    errorCode: qf.INVALID_UINT_UID_FROM_STRING_UID,
                                    extend: s
                                }), new Hf(qf.INVALID_UINT_UID_FROM_STRING_UID);
                                return WE.reqUserAccount(s.sid, {
                                    lts: o,
                                    success: !0,
                                    serverAddr: a,
                                    stringUid: s.string_uid,
                                    uid: r.uid,
                                    errorCode: null,
                                    extend: s
                                }), !1
                            }
                            const i = sw(r.code);
                            return i.retry && (a = e[(n + 1) % e.length]), WE.reqUserAccount(s.sid, {
                                lts: o,
                                success: !1,
                                serverAddr: a,
                                stringUid: s.string_uid,
                                uid: r.uid,
                                errorCode: i.desc,
                                extend: s
                            }), i.retry
                        }, (t, r) => t.code !== qf.OPERATION_ABORTED && (WE.reqUserAccount(s.sid, {
                            lts: o,
                            success: !1,
                            serverAddr: a,
                            stringUid: s.string_uid,
                            uid: null,
                            errorCode: t.code,
                            extend: s
                        }), a = e[(r + 1) % e.length], !0), i);
                        if (0 !== c.code) {
                            const e = sw(c.code);
                            throw new Hf(qf.UNEXPECTED_RESPONSE, e.desc)
                        }
                        return c
                    }(s, e, t, r, n);
                    return null == i || i.recordJoinChannelService({status: "success", endTs: Date.now()}, a), o.uid
                } catch (e) {
                    throw null == i || i.recordJoinChannelService({
                        status: "error",
                        endTs: Date.now(),
                        errors: [e]
                    }, a), e
                }
            }

            async function Kw(e, t, r, n) {
                const i = fm("PROXY_SERVER_TYPE3"), o = (e, t, r) => {
                    let n = r || i;
                    return Array.isArray(n) && (n = t % 2 == 0 ? i[1] : i[0]), "https://".concat(n, "/ap/?url=").concat(e)
                };
                let s = null;
                const a = [];
                let c, u, d;
                try {
                    ({gatewayInfo: c, proxyInfo: u, url: d} = await $S([(async () => {
                        const i = fm("WEBCS_DOMAIN").slice(0, fm("AJAX_REQUEST_CONCURRENT")).map((t, r) => {
                            let n;
                            return {
                                url: n = "disabled" === e.cloudProxyServer && e.proxyServer ? o("".concat(t, "/api/v2/transpond/webrtc?v=2"), r, e.proxyServer) : "disabled" === e.cloudProxyServer || "fallback" === e.cloudProxyServer ? "https://".concat(t, "/api/v2/transpond/webrtc?v=2") : o("".concat(t, "/api/v2/transpond/webrtc?v=2"), r),
                                areaCode: jw(),
                                serviceIds: [sg.CHOOSE_SERVER, "proxy5" === e.cloudProxyServer ? sg.CLOUD_PROXY_5 : "proxy3" === e.cloudProxyServer || "proxy4" === e.cloudProxyServer ? sg.CLOUD_PROXY : sg.CLOUD_PROXY_FALLBACK]
                            }
                        }), s = n.recordJoinChannelService({
                            startTs: Date.now(),
                            status: "pending",
                            service: "chooseServer",
                            urls: i.map(e => e.url)
                        }), c = await pb({
                            fragementLength: fm("FRAGEMENT_LENGTH"),
                            referenceList: i,
                            asyncMapHandler: n => (em.debug("[".concat(e.clientId, "] Connect to choose_server:"), n.url), Pw(n, e, t, r)),
                            allFailedhandler: e => {
                                throw n.recordJoinChannelService({
                                    endTs: Date.now(),
                                    status: "error",
                                    errors: e
                                }, s), e[0]
                            },
                            promisesCollector: a
                        });
                        return n.recordJoinChannelService({endTs: Date.now(), status: "success"}, s), c
                    })(), (async () => {
                        if (await zS(1e3), null !== s) return s;
                        const i = fm("WEBCS_DOMAIN_BACKUP_LIST").map((t, r) => {
                            let n;
                            return {
                                url: n = "disabled" === e.cloudProxyServer && e.proxyServer ? o("".concat(t, "/api/v2/transpond/webrtc?v=2"), r, e.proxyServer) : "disabled" === e.cloudProxyServer || "fallback" === e.cloudProxyServer ? "https://".concat(t, "/api/v2/transpond/webrtc?v=2") : o("".concat(t, "/api/v2/transpond/webrtc?v=2"), r),
                                areaCode: jw(),
                                serviceIds: [sg.CHOOSE_SERVER, "proxy5" === e.cloudProxyServer ? sg.CLOUD_PROXY_5 : "proxy3" === e.cloudProxyServer || "proxy4" === e.cloudProxyServer ? sg.CLOUD_PROXY : sg.CLOUD_PROXY_FALLBACK]
                            }
                        }), c = n.recordJoinChannelService({
                            startTs: Date.now(),
                            status: "pending",
                            service: "chooseServer",
                            urls: i.map(e => e.url)
                        }), u = await pb({
                            fragementLength: fm("FRAGEMENT_LENGTH"),
                            referenceList: i,
                            asyncMapHandler: n => (em.debug("[".concat(e.clientId, "] Connect to backup choose_server:"), n.url), Pw(n, e, t, r)),
                            allFailedhandler: e => {
                                throw n.recordJoinChannelService({
                                    endTs: Date.now(),
                                    status: "error",
                                    errors: e
                                }, c), e[0]
                            },
                            promisesCollector: a
                        });
                        return n.recordJoinChannelService({endTs: Date.now(), status: "success"}, c), u
                    })()]))
                } catch (e) {
                    throw e[0]
                }
                if (a.length && a.forEach(e => e.cancel && "function" == typeof e.cancel && e.cancel()), !c || !u) throw new Hf(qf.UNEXPECTED_ERROR, "missing gateway or proxy response").print();
                if (e.apUrl = d, "disabled" !== e.cloudProxyServer && Array.isArray(i) && d) {
                    const t = new iw(d).host;
                    i.includes(t) && (e.proxyServer = t, em.setProxyServer(t), WE.setProxyServer(t))
                }
                return s = {
                    gatewayInfo: c, proxyInfo: await async function (e, t) {
                        return await sl.all(e.addresses.map(async e => ({
                            address: MS(e.ip),
                            tcpport: e.port,
                            udpport: e.port,
                            username: t && fm("ENCRYPT_PROXY_USERNAME_AND_PSW") && window.isSecureContext ? t.toString() : im.username,
                            password: t && fm("ENCRYPT_PROXY_USERNAME_AND_PSW") && window.isSecureContext ? await jE(t.toString()) : im.password
                        })))
                    }(u, c.uid)
                }
            }

            async function zw(e, t, r, n) {
                const i = fm("UAP_AP").slice(0, fm("AJAX_REQUEST_CONCURRENT")).map(e => t.proxyServer ? "https://".concat(t.proxyServer, "/ap/?url=").concat(e + "/api/v1?action=uap") : "https://".concat(e, "/api/v1?action=uap"));
                return await function (e, t, r, n, i) {
                    Aw += 1;
                    const o = {
                        sid: r.sid,
                        command: "convergeAllocateEdge",
                        uid: "666",
                        appId: r.appId,
                        ts: Math.floor(Date.now() / 1e3),
                        seq: Aw,
                        requestId: Aw,
                        version: rm,
                        cname: r.cname
                    }, s = {service_name: t, json_body: JSON.stringify(o)};
                    let a, c, u = e[0];
                    return Yf(async () => {
                        a = Date.now();
                        const e = await NE(u, {
                            data: s,
                            cancelToken: n,
                            headers: {"X-Packet-Service-Type": "0", "X-Packet-URI": "61"}
                        });
                        if (c = Date.now() - a, 0 !== e.code) {
                            const t = new Hf(qf.UNEXPECTED_RESPONSE, "live streaming ap error, code" + e.code, {
                                retry: !0,
                                responseTime: c
                            });
                            throw em.error(t.toString()), t
                        }
                        const r = JSON.parse(e.json_body);
                        if (200 !== r.code) {
                            const e = new Hf(qf.UNEXPECTED_RESPONSE, "live streaming app center error, code: ".concat(r.code, ", reason: ").concat(r.reason), {
                                code: r.code,
                                responseTime: c
                            });
                            throw em.error(e.toString()), e
                        }
                        if (!r.servers || 0 === r.servers.length) {
                            const e = new Hf(qf.UNEXPECTED_RESPONSE, "live streaming app center empty server", {
                                code: r.code,
                                responseTime: c
                            });
                            throw em.error(e.toString()), e
                        }
                        const i = function (e, t) {
                            return {
                                addressList: e.servers.map(e => "wss://".concat(e.address.replace(/\./g, "-"), ".").concat(fm("WORKER_DOMAIN"), ":").concat(e.wss, "?serviceName=").concat(encodeURIComponent(t))),
                                workerToken: e.workerToken,
                                vid: e.vid
                            }
                        }(r, t);
                        return fm("LIVE_STREAMING_ADDRESS") && (i.addressList = fm("LIVE_STREAMING_ADDRESS") instanceof Array ? fm("LIVE_STREAMING_ADDRESS") : [fm("LIVE_STREAMING_ADDRESS")]), Cw(Cw({}, i), {}, {responseTime: c})
                    }, (n, i) => (WE.apworkerEvent(r.sid, {
                        success: !0,
                        sc: 200,
                        serviceName: t,
                        responseDetail: JSON.stringify(n.addressList),
                        firstSuccess: 0 === i,
                        responseTime: c,
                        serverIp: e[i % e.length]
                    }), !1), (n, i) => (WE.apworkerEvent(r.sid, {
                        success: !1,
                        sc: n.data && n.data.code || 200,
                        serviceName: t,
                        responseTime: c,
                        serverIp: e[i % e.length]
                    }), !!(n.code !== qf.OPERATION_ABORTED && n.code !== qf.UNEXPECTED_RESPONSE || n.data && n.data.retry) && (u = e[(i + 1) % e.length], !0)), i)
                }(i, e, t, r, n)
            }

            function Yw(e, t) {
                var r = Object.keys(e);
                if (Object.getOwnPropertySymbols) {
                    var n = Object.getOwnPropertySymbols(e);
                    t && (n = n.filter(function (t) {
                        return Object.getOwnPropertyDescriptor(e, t).enumerable
                    })), r.push.apply(r, n)
                }
                return r
            }

            function Jw(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var r = null != arguments[t] ? arguments[t] : {};
                    t % 2 ? Yw(Object(r), !0).forEach(function (t) {
                        Kh(e, t, r[t])
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : Yw(Object(r)).forEach(function (t) {
                        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t))
                    })
                }
                return e
            }

            function Xw(e, t) {
                var r = Object.keys(e);
                if (Object.getOwnPropertySymbols) {
                    var n = Object.getOwnPropertySymbols(e);
                    t && (n = n.filter(function (t) {
                        return Object.getOwnPropertyDescriptor(e, t).enumerable
                    })), r.push.apply(r, n)
                }
                return r
            }

            function Qw(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var r = null != arguments[t] ? arguments[t] : {};
                    t % 2 ? Xw(Object(r), !0).forEach(function (t) {
                        Kh(e, t, r[t])
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : Xw(Object(r)).forEach(function (t) {
                        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t))
                    })
                }
                return e
            }

            class $w extends Wf {
                constructor(e, t, r, n) {
                    super(), Kh(this, "spec", void 0), Kh(this, "token", void 0), Kh(this, "websocket", void 0), Kh(this, "pingpongTimer", void 0), Kh(this, "reconnectMode", "retry"), Kh(this, "serviceMode", void 0), Kh(this, "reqId", 0), Kh(this, "commandReqId", 0), Kh(this, "handleWebSocketOpen", () => {
                        this.reconnectMode = "retry", this.startPingPong()
                    }), Kh(this, "handleWebSocketMessage", e => {
                        if (!e.data) return;
                        const t = JSON.parse(e.data);
                        t.requestId ? this.emit("@".concat(t.requestId, "-").concat(t.sid), t) : this.serviceMode === hv.INJECT ? this.emit(Ev.INJECT_STREAM_STATUS, t) : (WE.workerEvent(this.spec.sid, {
                            actionType: "status",
                            serverCode: t.code,
                            workerType: this.serviceMode === hv.TRANSCODE ? 1 : 2
                        }), this.emit(Ev.PUBLISH_STREAM_STATUS, t))
                    }), this.spec = t, this.token = e, this.serviceMode = n, this.websocket = new lw("live-streaming", r), this.websocket.on(lv.CONNECTED, this.handleWebSocketOpen), this.websocket.on(lv.ON_MESSAGE, this.handleWebSocketMessage), this.websocket.on(lv.REQUEST_NEW_URLS, (e, t) => {
                        ZS(this, Ev.REQUEST_NEW_ADDRESS).then(e).catch(t)
                    }), this.websocket.on(lv.RECONNECTING, () => {
                        this.websocket.reconnectMode = this.reconnectMode
                    })
                }

                init(e) {
                    return this.websocket.init(e)
                }

                async request(e, t, r, n) {
                    this.reqId += 1, "request" === e && (this.commandReqId += 1);
                    const i = this.commandReqId, o = this.reqId;
                    if (!o || !this.websocket) throw new Hf(qf.UNEXPECTED_ERROR);
                    const s = Qw({
                        command: e,
                        sdkVersion: "4.16.0" === rm ? "0.0.1" : rm,
                        seq: o,
                        requestId: o,
                        allocate: r,
                        cname: this.spec.cname,
                        appId: this.spec.appId,
                        sid: this.spec.sid,
                        uid: this.spec.uid.toString(),
                        ts: Math.floor(Date.now() / 1e3)
                    }, t);
                    if ("closed" === this.websocket.state) throw new Hf(qf.WS_DISCONNECT);
                    const a = () => new sl((e, t) => {
                        this.websocket.once(lv.CLOSED, () => t(new Hf(qf.WS_ABORT))), this.websocket.once(lv.CONNECTED, e)
                    });
                    "connected" !== this.websocket.state && await a(), s.clientRequest && (s.clientRequest.workerToken = this.token);
                    const c = new sl((e, t) => {
                        const r = () => {
                            t(new Hf(qf.WS_ABORT))
                        };
                        this.websocket.once(lv.RECONNECTING, r), this.websocket.once(lv.CLOSED, r), this.once("@".concat(o, "-").concat(this.spec.sid), t => {
                            e(t)
                        })
                    });
                    n && WE.workerEvent(this.spec.sid, Qw(Qw({}, n), {}, {
                        requestId: i,
                        actionType: "request",
                        payload: JSON.stringify(t.clientRequest),
                        serverCode: 0,
                        code: 0
                    }));
                    const u = Date.now();
                    this.websocket.sendMessage(s);
                    let d = null;
                    try {
                        d = await c
                    } catch (n) {
                        if ("closed" === this.websocket.state) throw n;
                        return await a(), await this.request(e, t, r)
                    }
                    return n && WE.workerEvent(this.spec.sid, Qw(Qw({}, n), {}, {
                        requestId: i,
                        actionType: "response",
                        payload: JSON.stringify(d.serverResponse),
                        serverCode: d.code,
                        success: 200 === d.code,
                        responseTime: Date.now() - u
                    })), 200 !== d.code && this.handleResponseError(d), d
                }

                tryNextAddress() {
                    this.reconnectMode = "tryNext", this.websocket.reconnect("tryNext")
                }

                close() {
                    const e = "4.16.0" === rm ? "0.0.1" : rm;
                    this.reqId += 1, "connected" === this.websocket.state ? (this.websocket.sendMessage({
                        command: "request",
                        appId: this.spec.appId,
                        cname: this.spec.cname,
                        uid: this.spec.uid.toString(),
                        sdkVersion: e,
                        sid: this.spec.sid,
                        seq: this.reqId,
                        ts: Math.floor(Date.now() / 1e3),
                        requestId: this.reqId,
                        clientRequest: {command: "DestroyWorker"}
                    }), this.websocket.close(!1, !0)) : this.websocket.close(!1), this.pingpongTimer && (window.clearInterval(this.pingpongTimer), this.pingpongTimer = void 0)
                }

                handleResponseError(e) {
                    switch (e.code) {
                        case Sv.LIVE_STREAM_RESPONSE_ALREADY_EXISTS_STREAM:
                            return void em.warning("live stream response already exists stream");
                        case Sv.LIVE_STREAM_RESPONSE_TRANSCODING_PARAMETER_ERROR:
                        case Sv.LIVE_STREAM_RESPONSE_BAD_STREAM:
                        case Sv.LIVE_STREAM_RESPONSE_WM_PARAMETER_ERROR:
                            return new Hf(qf.LIVE_STREAMING_INVALID_ARGUMENT, "", {code: e.code}).throw();
                        case Sv.LIVE_STREAM_RESPONSE_WM_WORKER_NOT_EXIST:
                            if ("UnpublishStream" === e.serverResponse.command || "UninjectStream" === e.serverResponse.command) return;
                            throw new Hf(qf.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "live stream response wm worker not exist", {retry: !0});
                        case Sv.LIVE_STREAM_RESPONSE_NOT_AUTHORIZED:
                            return new Hf(qf.LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED, "", {code: e.code}).throw();
                        case Sv.LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE: {
                            const t = new Hf(qf.LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE);
                            return this.emit(Ev.WARNING, t, e.serverResponse.url)
                        }
                        case Sv.LIVE_STREAM_RESPONSE_REQUEST_TOO_OFTEN: {
                            const t = new Hf(qf.LIVE_STREAMING_WARN_FREQUENT_REQUEST);
                            return this.emit(Ev.WARNING, t, e.serverResponse.url)
                        }
                        case Sv.LIVE_STREAM_RESPONSE_NOT_FOUND_PUBLISH:
                            throw new Hf(qf.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "live stream response wm worker not exist", {retry: !0});
                        case Sv.LIVE_STREAM_RESPONSE_NOT_SUPPORTED:
                            return new Hf(qf.LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED, "", {code: e.code}).throw();
                        case Sv.LIVE_STREAM_RESPONSE_MAX_STREAM_NUM: {
                            const t = new Hf(qf.LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT);
                            return this.emit(Ev.WARNING, t, e.serverResponse.url)
                        }
                        case Sv.LIVE_STREAM_RESPONSE_INTERNAL_SERVER_ERROR:
                            return new Hf(qf.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "", {code: e.code}).throw();
                        case Sv.LIVE_STREAM_RESPONSE_RESOURCE_LIMIT:
                            throw new Hf(qf.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "live stream resource limit", {
                                retry: !0,
                                changeAddress: !0
                            });
                        case Sv.LIVE_STREAM_RESPONSE_WORKER_LOST:
                        case Sv.LIVE_STREAM_RESPONSE_WORKER_QUIT:
                            if ("UnpublishStream" === e.serverResponse.command || "UninjectStream" === e.serverResponse.command) return;
                            throw new Hf(qf.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "error fail send message", {
                                retry: !0,
                                changeAddress: !0
                            });
                        case Sv.ERROR_FAIL_SEND_MESSAGE:
                            if ("UnpublishStream" === e.serverResponse.command || "UninjectStream" === e.serverResponse.command) return;
                            if ("UpdateTranscoding" === e.serverResponse.command || "ControlStream" === e.serverResponse.command) return new Hf(qf.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "error fail send message", {code: e.code}).throw();
                            throw new Hf(qf.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "error fail send message", {
                                retry: !0,
                                changeAddress: !0
                            });
                        case Sv.PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN:
                        case Sv.PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT:
                        case Sv.PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE:
                        case Sv.PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH:
                            return new Hf(qf.LIVE_STREAMING_CDN_ERROR, "", {code: e.code}).throw()
                    }
                }

                startPingPong() {
                    this.pingpongTimer && window.clearInterval(this.pingpongTimer), this.pingpongTimer = window.setInterval(() => {
                        "connected" === this.websocket.state && this.request("ping", {}).catch(XS)
                    }, 6e3)
                }
            }

            function Zw(e, t) {
                var r = Object.keys(e);
                if (Object.getOwnPropertySymbols) {
                    var n = Object.getOwnPropertySymbols(e);
                    t && (n = n.filter(function (t) {
                        return Object.getOwnPropertyDescriptor(e, t).enumerable
                    })), r.push.apply(r, n)
                }
                return r
            }

            function eC(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var r = null != arguments[t] ? arguments[t] : {};
                    t % 2 ? Zw(Object(r), !0).forEach(function (t) {
                        Kh(e, t, r[t])
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : Zw(Object(r)).forEach(function (t) {
                        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t))
                    })
                }
                return e
            }

            class tC {
                constructor() {
                    Kh(this, "destChannelMediaInfos", new Map), Kh(this, "srcChannelMediaInfo", void 0)
                }

                setSrcChannelInfo(e) {
                    Uv(e), this.srcChannelMediaInfo = e
                }

                addDestChannelInfo(e) {
                    Uv(e), this.destChannelMediaInfos.set(e.channelName, e)
                }

                removeDestChannelInfo(e) {
                    b_(e), this.destChannelMediaInfos.delete(e)
                }

                getSrcChannelMediaInfo() {
                    return this.srcChannelMediaInfo
                }

                getDestChannelMediaInfo() {
                    return this.destChannelMediaInfos
                }
            }

            function rC(e) {
                if (!(e instanceof tC)) return new Hf(qf.INVALID_PARAMS, "Config should be instance of [ChannelMediaRelayConfiguration]").throw();
                const t = e.getSrcChannelMediaInfo(), r = e.getDestChannelMediaInfo();
                return t ? 0 === r.size ? new Hf(qf.INVALID_PARAMS, "destChannelMediaInfo should not be empty").throw() : void 0 : new Hf(qf.INVALID_PARAMS, "srcChannelMediaInfo should not be empty").throw()
            }

            class nC extends Wf {
                constructor(e, t, r) {
                    super(), Kh(this, "ws", void 0), Kh(this, "requestId", 1), Kh(this, "heartBeatTimer", void 0), Kh(this, "joinInfo", void 0), Kh(this, "clientId", void 0), Kh(this, "onOpen", () => {
                        this.emit("open"), this.startHeartBeatCheck()
                    }), Kh(this, "onClose", e => {
                        this.emit("close"), this.dispose()
                    }), Kh(this, "onMessage", e => {
                        const t = JSON.parse(e.data);
                        if (!t || "serverResponse" !== t.command || !t.requestId) return t && "serverStatus" === t.command && t.serverStatus && t.serverStatus.command ? (this.emit("status", t.serverStatus), void this.emit(t.serverStatus.command, t.serverStatus)) : void 0;
                        this.emit("req_".concat(t.requestId), t)
                    }), this.joinInfo = e, this.clientId = t, this.ws = new lw("cross-channel-".concat(this.clientId), r), this.ws.on(lv.RECONNECTING, () => {
                        this.ws.reconnectMode = "retry", this.emit("reconnecting")
                    }), this.ws.on(lv.CONNECTED, this.onOpen), this.ws.on(lv.ON_MESSAGE, this.onMessage), this.ws.on(lv.CLOSED, this.onClose)
                }

                isConnect() {
                    return "connected" === this.ws.state
                }

                sendMessage(e) {
                    const t = this.requestId++;
                    return e.requestId = t, e.seq = t, this.ws.sendMessage(e), t
                }

                waitStatus(e) {
                    return new sl((t, r) => {
                        const n = window.setTimeout(() => {
                            r(new Hf(qf.TIMEOUT, "wait status timeout, status: ".concat(e)))
                        }, 5e3);
                        this.once(e, i => {
                            window.clearTimeout(n), i.state && 0 !== i.state ? r(new Hf(qf.CROSS_CHANNEL_WAIT_STATUS_ERROR, "wait status error, status: ".concat(e))) : t(void 0)
                        }), this.once("dispose", () => {
                            window.clearTimeout(n), r(new Hf(qf.WS_ABORT))
                        })
                    })
                }

                async request(e) {
                    if ("closed" === this.ws.state) throw new Hf(qf.WS_DISCONNECT);
                    "connected" !== this.ws.state && await (() => new sl((e, t) => {
                        this.ws.once(lv.CLOSED, () => t(new Hf(qf.WS_ABORT))), this.ws.once(lv.CONNECTED, e)
                    }))();
                    const t = this.sendMessage(e), r = new sl((e, r) => {
                        const n = () => {
                            r(new Hf(qf.WS_ABORT))
                        };
                        this.ws.once(lv.RECONNECTING, n), this.ws.once(lv.CLOSED, n), this.once("req_".concat(t), e), zS(3e3).then(() => {
                            this.removeAllListeners("req_".concat(t)), this.ws.off(lv.RECONNECTING, n), this.ws.off(lv.CLOSED, n), r(new Hf(qf.TIMEOUT, "cross channel ws request timeout"))
                        })
                    }), n = await r;
                    if (!n || 200 !== n.code) throw new Hf(qf.CROSS_CHANNEL_SERVER_ERROR_RESPONSE, "response: ".concat(JSON.stringify(n)));
                    return n
                }

                async connect(e) {
                    this.ws.removeAllListeners(lv.REQUEST_NEW_URLS), this.ws.on(lv.REQUEST_NEW_URLS, t => {
                        t(e)
                    }), await this.ws.init(e)
                }

                dispose() {
                    this.clearHeartBeatCheck(), this.emit("dispose"), this.removeAllListeners(), this.ws.close()
                }

                sendPing(e) {
                    const t = this.requestId++;
                    return e.requestId = t, this.ws.sendMessage(e), t
                }

                startHeartBeatCheck() {
                    this.heartBeatTimer && window.clearInterval(this.heartBeatTimer), this.heartBeatTimer = window.setInterval(() => {
                        this.sendPing({
                            command: "ping",
                            appId: this.joinInfo.appId,
                            cname: this.joinInfo.cname,
                            uid: this.joinInfo.uid.toString(),
                            sid: this.joinInfo.sid,
                            ts: +new Date,
                            requestId: 0
                        })
                    }, 3e3)
                }

                clearHeartBeatCheck() {
                    window.clearInterval(this.heartBeatTimer), this.heartBeatTimer = void 0
                }
            }

            const iC = e => {
                const t = document.createElement("canvas");
                return t.width = 2, t.height = 2, new sl((r, n) => {
                    t.toBlob(async e => {
                        if (t.remove(), e) {
                            const n = await oC(e);
                            r({buffer: n, width: t.width, height: t.height})
                        } else n(new Hf(qf.CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED))
                    }, e, 1)
                })
            }, oC = async e => {
                const t = await e.arrayBuffer();
                return new Uint8Array(t)
            }, sC = new class extends Wf {
                get visibility() {
                    return document.visibilityState
                }

                get lastHiddenTime() {
                    return this._lastHiddenTime
                }

                get lastVisibleTime() {
                    return this._lastVisibleTime
                }

                constructor() {
                    super(), Kh(this, "_lastHiddenTime", 0), Kh(this, "_lastVisibleTime", 0), document.addEventListener("visibilitychange", () => {
                        "hidden" === document.visibilityState ? this._lastHiddenTime = performance.now() : this._lastVisibleTime = performance.now(), em.debug("document visibility went ".concat(document.visibilityState)), this.emit("VISIBILITY_CHANGE", document.visibilityState)
                    })
                }
            };

            function aC(e, t) {
                var r = Object.keys(e);
                if (Object.getOwnPropertySymbols) {
                    var n = Object.getOwnPropertySymbols(e);
                    t && (n = n.filter(function (t) {
                        return Object.getOwnPropertyDescriptor(e, t).enumerable
                    })), r.push.apply(r, n)
                }
                return r
            }

            function cC(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var r = null != arguments[t] ? arguments[t] : {};
                    t % 2 ? aC(Object(r), !0).forEach(function (t) {
                        Kh(e, t, r[t])
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : aC(Object(r)).forEach(function (t) {
                        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t))
                    })
                }
                return e
            }

            class uC {
                get videoElementStatus() {
                    return this._videoElementStatus
                }

                set videoElementStatus(e) {
                    e !== this._videoElementStatus && (em.debug("[".concat(this.trackId, "] video-element-status change ").concat(this._videoElementStatus, " => ").concat(e)), this._videoElementStatus = e)
                }

                constructor(e) {
                    Kh(this, "trackId", void 0), Kh(this, "config", void 0), Kh(this, "onFirstVideoFrameDecoded", void 0), Kh(this, "freezeTimeCounterList", []), Kh(this, "renderFreezeAccTime", 0), Kh(this, "timeUpdatedCount", 0), Kh(this, "freezeTime", 0), Kh(this, "playbackTime", 0), Kh(this, "lastTimeUpdatedTime", 0), Kh(this, "autoplayFailed", !1), Kh(this, "videoTrack", void 0), Kh(this, "container", void 0), Kh(this, "videoElement", void 0), Kh(this, "videoElementCheckInterval", void 0), Kh(this, "_videoElementStatus", A_.NONE), Kh(this, "slot", void 0), Kh(this, "isGettingVideoDimensions", !1), Kh(this, "handleVideoEvents", e => {
                        switch (e.type) {
                            case"play":
                            case"playing":
                                this.startGetVideoDimensions(), this.videoElementStatus = A_.PLAYING;
                                break;
                            case"loadeddata":
                                this.onFirstVideoFrameDecoded && this.onFirstVideoFrameDecoded();
                                break;
                            case"canplay":
                                this.videoElementStatus = A_.CANPLAY;
                                break;
                            case"stalled":
                                this.videoElementStatus = A_.STALLED;
                                break;
                            case"suspend":
                                this.videoElementStatus = A_.SUSPEND;
                                break;
                            case"pause":
                                this.videoElementStatus = A_.PAUSED, Ch() || kh() || Ih() && this.autoplayFailed || !this.videoElement || !this.videoTrack || "live" !== this.videoTrack.readyState || (em.debug("[track-".concat(this.trackId, "] video element paused, auto resume")), this.videoElement.play());
                                break;
                            case"waiting":
                                this.videoElementStatus = A_.WAITING;
                                break;
                            case"abort":
                                this.videoElementStatus = A_.ABORT;
                                break;
                            case"ended":
                                this.videoElementStatus = A_.ENDED;
                                break;
                            case"emptied":
                                this.videoElementStatus = A_.EMPTIED;
                                break;
                            case"error": {
                                var t;
                                this.videoElementStatus = A_.ERROR;
                                const e = null === (t = this.videoElement) || void 0 === t ? void 0 : t.error;
                                e && em.error("[".concat(this.trackId, "] media error, code: ").concat(e.code, ", message: ").concat(e.message));
                                break
                            }
                            case"timeupdate": {
                                const e = performance.now();
                                if (this.timeUpdatedCount += 1, this.timeUpdatedCount < 10) return void (this.lastTimeUpdatedTime = e);
                                const t = e - this.lastTimeUpdatedTime, r = this.lastTimeUpdatedTime;
                                if (this.lastTimeUpdatedTime = e, sC.lastVisibleTime < sC.lastHiddenTime || r < sC.lastHiddenTime || r < sC.lastVisibleTime) return;
                                for (t > fm("VIDEO_FREEZE_DURATION") && (this.freezeTime += t), this.playbackTime += t; this.playbackTime >= 6e3;) {
                                    this.playbackTime -= 6e3;
                                    const e = Math.min(6e3, this.freezeTime);
                                    e > 0 && this.freezeTimeCounterList.push(e), this.freezeTime = Math.max(0, this.freezeTime - 6e3)
                                }
                                break
                            }
                        }
                    }), Kh(this, "startGetVideoDimensions", () => {
                        const e = () => {
                            if (this.isGettingVideoDimensions = !0, this.videoElement && this.videoElement.videoWidth * this.videoElement.videoHeight > 4) return em.debug("[".concat(this.trackId, "] current video dimensions:"), this.videoElement.videoWidth, this.videoElement.videoHeight), void (this.isGettingVideoDimensions = !1);
                            setTimeout(e, 500)
                        };
                        !this.isGettingVideoDimensions && e()
                    }), Kh(this, "autoResumeAfterInterruption", () => {
                        this.videoElement && this.videoTrack && "live" === this.videoTrack.readyState && "running" === $E.curState && (Dh() ? (em.debug("[track-".concat(this.trackId, "] video element paused, auto resume for iOS 15.2")), this.videoElement.srcObject = null, this.videoElement.srcObject = new MediaStream([this.videoTrack]), this.videoElement.play()) : Ph() ? (em.debug("[track-".concat(this.trackId, "] video element paused, auto resume for iOS 15.1")), this.videoElement.srcObject = null, this.videoElement.srcObject = new MediaStream([this.videoTrack]), this.videoElement.play()) : Nh() && (em.debug("[track-".concat(this.trackId, "] video element paused, auto resume for iOS 15.0")), this.videoElement.pause(), this.videoElement.play()))
                    }), Kh(this, "autoResumeAfterInterruptionOnIOS15", () => {
                        this.videoElement && this.videoTrack && "live" === this.videoTrack.readyState && (Dh() ? (em.debug("[track-".concat(this.trackId, "] video element paused, auto resume for iOS 15.2")), this.videoElement.srcObject = null, this.videoElement.srcObject = new MediaStream([this.videoTrack]), this.videoElement.play()) : Ph() ? (em.debug("[track-".concat(this.trackId, "] video element paused, auto resume for iOS 15.1")), this.videoElement.srcObject = null, this.videoElement.srcObject = new MediaStream([this.videoTrack]), this.videoElement.play()) : Nh() && (em.debug("[track-".concat(this.trackId, "] video element paused, auto resume for iOS 15.0")), this.videoElement.pause(), this.videoElement.play()))
                    }), this.slot = e.element, this.trackId = e.trackId, this.updateConfig(e), $E.on(qE.IOS_INTERRUPTION_END, this.autoResumeAfterInterruption), $E.on(qE.IOS_15_INTERRUPTION_END, this.autoResumeAfterInterruptionOnIOS15)
                }

                updateConfig(e) {
                    this.config = e, this.trackId = e.trackId;
                    const t = e.element;
                    t !== this.slot && (this.destroy(), this.slot = t), this.createElements()
                }

                updateVideoTrack(e) {
                    this.videoTrack !== e && (this.videoTrack = e, this.createElements())
                }

                play(e) {
                    if (this.videoElement) {
                        const t = this.videoElement.play();
                        t && t.catch && t.catch(t => {
                            e && WE.autoplayFailed(e, "video", t.message, this.trackId), "NotAllowedError" === t.name ? (em.warning("detected video element autoplay failed", t), this.autoplayFailed = !0, this.handleAutoPlayFailed()) : em.warning("[".concat(this.trackId, "] play warning: "), t)
                        });
                        const r = Sh();
                        if (("Safari" === r.name && 15 === Number(r.version) || Oh()) && t && t.then && t.catch) {
                            const e = () => {
                                this.config.mirror && this.videoElement && (this.videoElement.style.transform = "rotateY(180deg)")
                            };
                            t.then(e).catch(e)
                        }
                    }
                }

                getCurrentFrame() {
                    if (!this.videoElement) return new ImageData(2, 2);
                    const e = document.createElement("canvas");
                    e.width = this.videoElement.videoWidth, e.height = this.videoElement.videoHeight;
                    const t = e.getContext("2d");
                    if (!t) return em.error("create canvas context failed!"), new ImageData(2, 2);
                    t.drawImage(this.videoElement, 0, 0, e.width, e.height);
                    const r = t.getImageData(0, 0, e.width, e.height);
                    return e.remove(), r
                }

                async getCurrentFrameToUint8Array(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
                    if (!this.videoElement) return await iC(e);
                    const r = document.createElement("canvas");
                    r.width = this.videoElement.videoWidth, r.height = this.videoElement.videoHeight;
                    const n = r.getContext("2d");
                    return n ? (n.drawImage(this.videoElement, 0, 0, r.width, r.height), new sl((n, i) => {
                        r.toBlob(async e => {
                            if (r.remove(), e) {
                                const t = await oC(e);
                                n({buffer: t, width: r.width, height: r.height})
                            } else i(new Hf(qf.CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED))
                        }, e, t < 0 ? .1 : t > 1 ? 1 : t)
                    })) : await iC(e)
                }

                destroy() {
                    if ($E.off(qE.IOS_INTERRUPTION_END, this.autoResumeAfterInterruption), $E.off(qE.IOS_15_INTERRUPTION_END, this.autoResumeAfterInterruptionOnIOS15), this.videoElement && (this.videoElement.srcObject = null, this.videoElement.remove(), this.videoElement = void 0), this.container) {
                        try {
                            this.container.remove(), this.slot.removeChild(this.container)
                        } catch (e) {
                        }
                        this.container = void 0
                    }
                    this.freezeTimeCounterList = []
                }

                createElements() {
                    this.container || (this.container = document.createElement("div")), this.container.id = "agora-video-player-".concat(this.trackId), this.container.style.width = "100%", this.container.style.height = "100%", this.container.style.position = "relative", this.container.style.overflow = "hidden", this.videoTrack ? (this.container.style.backgroundColor = "black", this.createVideoElement(), this.container.appendChild(this.videoElement)) : this.removeVideoElement(), this.slot.appendChild(this.container)
                }

                createVideoElement() {
                    if (!this.videoElement && (this.videoElementStatus = A_.INIT, this.videoElement = document.createElement("video"), this.container && this.container.appendChild(this.videoElement), dC.forEach(e => {
                        this.videoElement && this.videoElement.addEventListener(e, this.handleVideoEvents)
                    }), this.videoElementCheckInterval = window.setInterval(() => {
                        !document.getElementById("video_".concat(this.trackId)) && this.videoElement && (this.videoElementStatus = A_.DESTROYED)
                    }, 1e3), fm("ENABLE_VIDEO_FRAME_CALLBACK"))) {
                        var e, t;
                        let r;
                        const n = (e, t) => {
                            if (this.videoElementStatus === A_.PLAYING) {
                                if (r) {
                                    const e = t.presentationTime - r.presentationTime;
                                    e > fm("VIDEO_FREEZE_DURATION") && sC.lastVisibleTime >= sC.lastHiddenTime && r.timestamp > sC.lastVisibleTime && r.timestamp > sC.lastHiddenTime && (this.renderFreezeAccTime += e)
                                }
                                r = cC(cC({}, t), {}, {timestamp: e})
                            }
                            var i, o;
                            fm("ENABLE_VIDEO_FRAME_CALLBACK") && (null === (i = this.videoElement) || void 0 === i || null === (o = i.requestVideoFrameCallback) || void 0 === o || o.call(i, n))
                        };
                        null === (e = (t = this.videoElement).requestVideoFrameCallback) || void 0 === e || e.call(t, n)
                    }
                    this.videoElement.id = "video_".concat(this.trackId), this.videoElement.className = "agora_video_player", this.videoElement.style.width = "100%", this.videoElement.style.height = "100%", this.videoElement.style.position = "absolute", this.videoElement.controls = !1, this.videoElement.setAttribute("playsinline", ""), this.videoElement.style.left = "0", this.videoElement.style.top = "0", Uh() && (this.videoElement.poster = "noposter");
                    const r = Sh();
                    "Safari" === r.name && 15 === Number(r.version) || Oh() || !this.config.mirror || (this.videoElement.style.transform = "rotateY(180deg)"), this.config.fit ? this.videoElement.style.objectFit = this.config.fit : this.videoElement.style.objectFit = "cover", this.videoElement.setAttribute("muted", ""), this.videoElement.muted = !0, this.videoElement.srcObject && this.videoElement.srcObject instanceof MediaStream ? this.videoElement.srcObject.getVideoTracks()[0] !== this.videoTrack && (this.videoElement.srcObject = this.videoTrack ? new MediaStream([this.videoTrack]) : null, wh() && this.videoElement.load()) : (this.videoElement.srcObject = this.videoTrack ? new MediaStream([this.videoTrack]) : null, wh() && this.videoElement.load());
                    const n = this.videoElement.play();
                    void 0 !== n && n.catch(e => {
                        em.debug("[".concat(this.trackId, "] playback interrupted"), e.toString())
                    })
                }

                removeVideoElement() {
                    if (this.videoElement) {
                        dC.forEach(e => {
                            this.videoElement && this.videoElement.removeEventListener(e, this.handleVideoEvents)
                        }), this.videoElementCheckInterval && (window.clearInterval(this.videoElementCheckInterval), this.videoElementCheckInterval = void 0);
                        try {
                            this.container && this.container.removeChild(this.videoElement)
                        } catch (e) {
                        }
                        this.videoElement = void 0, this.videoElementStatus = A_.NONE
                    }
                }

                handleAutoPlayFailed() {
                    if (this.videoElement) {
                        const e = t => {
                            t.preventDefault(), this.videoElement && (this.videoElement.play().then(() => {
                                em.debug("[".concat(this.trackId, "] Video element for trackId:").concat(this.trackId, " autoplay resumed."))
                            }).catch(e => {
                                em.error(e)
                            }), this.autoplayFailed = !1, jh() ? document.body.removeEventListener("click", e, !0) : (document.body.removeEventListener("touchstart", e, !0), document.body.removeEventListener("mousedown", e, !0)))
                        };
                        jh() ? document.body.addEventListener("click", e, !0) : (document.body.addEventListener("touchstart", e, !0), document.body.addEventListener("mousedown", e, !0)), xE()
                    }
                }

                getVideoElement() {
                    return this.videoElement
                }

                getContainerElement() {
                    return this.container
                }
            }

            const dC = ["play", "playing", "loadeddata", "canplay", "pause", "stalled", "suspend", "waiting", "abort", "emptied", "ended", "timeupdate", "error"];
            var lC, hC = {exports: {}};

            function pC(e, t, r) {
                const n = e.createShader(r);
                if (!n) return new Hf(qf.WEBGL_INTERNAL_ERROR, "can not create shader").throw();
                if (e.shaderSource(n, t), e.compileShader(n), !e.getShaderParameter(n, e.COMPILE_STATUS)) {
                    const t = e.getShaderInfoLog(n);
                    return e.deleteShader(n), new Hf(qf.WEBGL_INTERNAL_ERROR, "error compiling shader:" + t).throw()
                }
                return n
            }

            !function (e, t) {
                var r;
                self, r = (() => (() => {
                    var e = {
                        3536: (e, t, r) => {
                            var n = r(1910);
                            e.exports = n
                        }, 8171: (e, t, r) => {
                            r(6450);
                            var n = r(4058).Object, i = e.exports = function (e, t, r) {
                                return n.defineProperty(e, t, r)
                            };
                            n.defineProperty.sham && (i.sham = !0)
                        }, 2956: (e, t, r) => {
                            r(7627), r(6274), r(5967), r(8881), r(4560), r(7206), r(4349), r(7971);
                            var n = r(4058);
                            e.exports = n.Promise
                        }, 3685: (e, t, r) => {
                            e.exports = r(621)
                        }, 621: (e, t, r) => {
                            var n = r(3536);
                            e.exports = n
                        }, 4883: (e, t, r) => {
                            var n = r(7475), i = r(9826), o = TypeError;
                            e.exports = function (e) {
                                if (n(e)) return e;
                                throw o(i(e) + " is not a function")
                            }
                        }, 174: (e, t, r) => {
                            var n = r(4284), i = r(9826), o = TypeError;
                            e.exports = function (e) {
                                if (n(e)) return e;
                                throw o(i(e) + " is not a constructor")
                            }
                        }, 1851: (e, t, r) => {
                            var n = r(7475), i = String, o = TypeError;
                            e.exports = function (e) {
                                if ("object" == typeof e || n(e)) return e;
                                throw o("Can't set " + i(e) + " as a prototype")
                            }
                        }, 8479: e => {
                            e.exports = function () {
                            }
                        }, 5743: (e, t, r) => {
                            var n = r(7046), i = TypeError;
                            e.exports = function (e, t) {
                                if (n(t, e)) return e;
                                throw i("Incorrect invocation")
                            }
                        }, 6059: (e, t, r) => {
                            var n = r(941), i = String, o = TypeError;
                            e.exports = function (e) {
                                if (n(e)) return e;
                                throw o(i(e) + " is not an object")
                            }
                        }, 1692: (e, t, r) => {
                            var n = r(4529), i = r(9413), o = r(623), s = function (e) {
                                return function (t, r, s) {
                                    var a, c = n(t), u = o(c), d = i(s, u);
                                    if (e && r != r) {
                                        for (; u > d;) if ((a = c[d++]) != a) return !0
                                    } else for (; u > d; d++) if ((e || d in c) && c[d] === r) return e || d || 0;
                                    return !e && -1
                                }
                            };
                            e.exports = {includes: s(!0), indexOf: s(!1)}
                        }, 3765: (e, t, r) => {
                            var n = r(5329);
                            e.exports = n([].slice)
                        }, 1385: (e, t, r) => {
                            var n = r(9813)("iterator"), i = !1;
                            try {
                                var o = 0, s = {
                                    next: function () {
                                        return {done: !!o++}
                                    }, return: function () {
                                        i = !0
                                    }
                                };
                                s[n] = function () {
                                    return this
                                }, Array.from(s, function () {
                                    throw 2
                                })
                            } catch (e) {
                            }
                            e.exports = function (e, t) {
                                if (!t && !i) return !1;
                                var r = !1;
                                try {
                                    var o = {};
                                    o[n] = function () {
                                        return {
                                            next: function () {
                                                return {done: r = !0}
                                            }
                                        }
                                    }, e(o)
                                } catch (e) {
                                }
                                return r
                            }
                        }, 2532: (e, t, r) => {
                            var n = r(4163), i = n({}.toString), o = n("".slice);
                            e.exports = function (e) {
                                return o(i(e), 8, -1)
                            }
                        }, 9697: (e, t, r) => {
                            var n = r(2885), i = r(7475), o = r(2532), s = r(9813)("toStringTag"), a = Object,
                                c = "Arguments" == o(function () {
                                    return arguments
                                }());
                            e.exports = n ? o : function (e) {
                                var t, r, n;
                                return void 0 === e ? "Undefined" : null === e ? "Null" : "string" == typeof (r = function (e, t) {
                                    try {
                                        return e[t]
                                    } catch (e) {
                                    }
                                }(t = a(e), s)) ? r : c ? o(t) : "Object" == (n = o(t)) && i(t.callee) ? "Arguments" : n
                            }
                        }, 3489: (e, t, r) => {
                            var n = r(953), i = r(1136), o = r(9677), s = r(5988);
                            e.exports = function (e, t, r) {
                                for (var a = i(t), c = s.f, u = o.f, d = 0; d < a.length; d++) {
                                    var l = a[d];
                                    n(e, l) || r && n(r, l) || c(e, l, u(t, l))
                                }
                            }
                        }, 4160: (e, t, r) => {
                            var n = r(5981);
                            e.exports = !n(function () {
                                function e() {
                                }

                                return e.prototype.constructor = null, Object.getPrototypeOf(new e) !== e.prototype
                            })
                        }, 3538: e => {
                            e.exports = function (e, t) {
                                return {value: e, done: t}
                            }
                        }, 2029: (e, t, r) => {
                            var n = r(5746), i = r(5988), o = r(1887);
                            e.exports = n ? function (e, t, r) {
                                return i.f(e, t, o(1, r))
                            } : function (e, t, r) {
                                return e[t] = r, e
                            }
                        }, 1887: e => {
                            e.exports = function (e, t) {
                                return {enumerable: !(1 & e), configurable: !(2 & e), writable: !(4 & e), value: t}
                            }
                        }, 5929: (e, t, r) => {
                            var n = r(2029);
                            e.exports = function (e, t, r, i) {
                                return i && i.enumerable ? e[t] = r : n(e, t, r), e
                            }
                        }, 5609: (e, t, r) => {
                            var n = r(1899), i = Object.defineProperty;
                            e.exports = function (e, t) {
                                try {
                                    i(n, e, {value: t, configurable: !0, writable: !0})
                                } catch (r) {
                                    n[e] = t
                                }
                                return t
                            }
                        }, 5746: (e, t, r) => {
                            var n = r(5981);
                            e.exports = !n(function () {
                                return 7 != Object.defineProperty({}, 1, {
                                    get: function () {
                                        return 7
                                    }
                                })[1]
                            })
                        }, 6616: e => {
                            var t = "object" == typeof document && document.all, r = void 0 === t && void 0 !== t;
                            e.exports = {all: t, IS_HTMLDDA: r}
                        }, 1333: (e, t, r) => {
                            var n = r(1899), i = r(941), o = n.document, s = i(o) && i(o.createElement);
                            e.exports = function (e) {
                                return s ? o.createElement(e) : {}
                            }
                        }, 3281: e => {
                            e.exports = {
                                CSSRuleList: 0,
                                CSSStyleDeclaration: 0,
                                CSSValueList: 0,
                                ClientRectList: 0,
                                DOMRectList: 0,
                                DOMStringList: 0,
                                DOMTokenList: 1,
                                DataTransferItemList: 0,
                                FileList: 0,
                                HTMLAllCollection: 0,
                                HTMLCollection: 0,
                                HTMLFormElement: 0,
                                HTMLSelectElement: 0,
                                MediaList: 0,
                                MimeTypeArray: 0,
                                NamedNodeMap: 0,
                                NodeList: 1,
                                PaintRequestList: 0,
                                Plugin: 0,
                                PluginArray: 0,
                                SVGLengthList: 0,
                                SVGNumberList: 0,
                                SVGPathSegList: 0,
                                SVGPointList: 0,
                                SVGStringList: 0,
                                SVGTransformList: 0,
                                SourceBufferList: 0,
                                StyleSheetList: 0,
                                TextTrackCueList: 0,
                                TextTrackList: 0,
                                TouchList: 0
                            }
                        }, 3321: (e, t, r) => {
                            var n = r(8501), i = r(6049);
                            e.exports = !n && !i && "object" == typeof window && "object" == typeof document
                        }, 8501: e => {
                            e.exports = "object" == typeof Deno && Deno && "object" == typeof Deno.version
                        }, 4470: (e, t, r) => {
                            var n = r(2861), i = r(1899);
                            e.exports = /ipad|iphone|ipod/i.test(n) && void 0 !== i.Pebble
                        }, 2749: (e, t, r) => {
                            var n = r(2861);
                            e.exports = /(?:ipad|iphone|ipod).*applewebkit/i.test(n)
                        }, 6049: (e, t, r) => {
                            var n = r(2532), i = r(1899);
                            e.exports = "process" == n(i.process)
                        }, 8045: (e, t, r) => {
                            var n = r(2861);
                            e.exports = /web0s(?!.*chrome)/i.test(n)
                        }, 2861: (e, t, r) => {
                            var n = r(626);
                            e.exports = n("navigator", "userAgent") || ""
                        }, 3385: (e, t, r) => {
                            var n, i, o = r(1899), s = r(2861), a = o.process, c = o.Deno,
                                u = a && a.versions || c && c.version, d = u && u.v8;
                            d && (i = (n = d.split("."))[0] > 0 && n[0] < 4 ? 1 : +(n[0] + n[1])), !i && s && (!(n = s.match(/Edge\/(\d+)/)) || n[1] >= 74) && (n = s.match(/Chrome\/(\d+)/)) && (i = +n[1]), e.exports = i
                        }, 6759: e => {
                            e.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"]
                        }, 3995: (e, t, r) => {
                            var n = r(5329), i = Error, o = n("".replace), s = String(i("zxcasd").stack),
                                a = /\n\s*at [^:]*:[^\n]*/, c = a.test(s);
                            e.exports = function (e, t) {
                                if (c && "string" == typeof e && !i.prepareStackTrace) for (; t--;) e = o(e, a, "");
                                return e
                            }
                        }, 8780: (e, t, r) => {
                            var n = r(5981), i = r(1887);
                            e.exports = !n(function () {
                                var e = Error("a");
                                return !("stack" in e) || (Object.defineProperty(e, "stack", i(1, 7)), 7 !== e.stack)
                            })
                        }, 6887: (e, t, r) => {
                            var n = r(1899), i = r(9730), o = r(5329), s = r(7475), a = r(9677).f, c = r(7252),
                                u = r(4058), d = r(6843), l = r(2029), h = r(953), p = function (e) {
                                    var t = function (r, n, o) {
                                        if (this instanceof t) {
                                            switch (arguments.length) {
                                                case 0:
                                                    return new e;
                                                case 1:
                                                    return new e(r);
                                                case 2:
                                                    return new e(r, n)
                                            }
                                            return new e(r, n, o)
                                        }
                                        return i(e, this, arguments)
                                    };
                                    return t.prototype = e.prototype, t
                                };
                            e.exports = function (e, t) {
                                var r, i, f, m, _, v, g, E, y = e.target, S = e.global, b = e.stat, T = e.proto,
                                    R = S ? n : b ? n[y] : (n[y] || {}).prototype, I = S ? u : u[y] || l(u, y, {})[y],
                                    w = I.prototype;
                                for (f in t) r = !c(S ? f : y + (b ? "." : "#") + f, e.forced) && R && h(R, f), _ = I[f], r && (v = e.dontCallGetSet ? (E = a(R, f)) && E.value : R[f]), m = r && v ? v : t[f], r && typeof _ == typeof m || (g = e.bind && r ? d(m, n) : e.wrap && r ? p(m) : T && s(m) ? o(m) : m, (e.sham || m && m.sham || _ && _.sham) && l(g, "sham", !0), l(I, f, g), T && (h(u, i = y + "Prototype") || l(u, i, {}), l(u[i], f, m), e.real && w && !w[f] && l(w, f, m)))
                            }
                        }, 5981: e => {
                            e.exports = function (e) {
                                try {
                                    return !!e()
                                } catch (e) {
                                    return !0
                                }
                            }
                        }, 9730: (e, t, r) => {
                            var n = r(8285), i = Function.prototype, o = i.apply, s = i.call;
                            e.exports = "object" == typeof Reflect && Reflect.apply || (n ? s.bind(o) : function () {
                                return s.apply(o, arguments)
                            })
                        }, 6843: (e, t, r) => {
                            var n = r(5329), i = r(4883), o = r(8285), s = n(n.bind);
                            e.exports = function (e, t) {
                                return i(e), void 0 === t ? e : o ? s(e, t) : function () {
                                    return e.apply(t, arguments)
                                }
                            }
                        }, 8285: (e, t, r) => {
                            var n = r(5981);
                            e.exports = !n(function () {
                                var e = function () {
                                }.bind();
                                return "function" != typeof e || e.hasOwnProperty("prototype")
                            })
                        }, 8834: (e, t, r) => {
                            var n = r(8285), i = Function.prototype.call;
                            e.exports = n ? i.bind(i) : function () {
                                return i.apply(i, arguments)
                            }
                        }, 9417: (e, t, r) => {
                            var n = r(5746), i = r(953), o = Function.prototype,
                                s = n && Object.getOwnPropertyDescriptor, a = i(o, "name"),
                                c = a && "something" === function () {
                                }.name, u = a && (!n || n && s(o, "name").configurable);
                            e.exports = {EXISTS: a, PROPER: c, CONFIGURABLE: u}
                        }, 4163: (e, t, r) => {
                            var n = r(8285), i = Function.prototype, o = i.call, s = n && i.bind.bind(o, o);
                            e.exports = n ? s : function (e) {
                                return function () {
                                    return o.apply(e, arguments)
                                }
                            }
                        }, 5329: (e, t, r) => {
                            var n = r(2532), i = r(4163);
                            e.exports = function (e) {
                                if ("Function" === n(e)) return i(e)
                            }
                        }, 626: (e, t, r) => {
                            var n = r(4058), i = r(1899), o = r(7475), s = function (e) {
                                return o(e) ? e : void 0
                            };
                            e.exports = function (e, t) {
                                return arguments.length < 2 ? s(n[e]) || s(i[e]) : n[e] && n[e][t] || i[e] && i[e][t]
                            }
                        }, 2902: (e, t, r) => {
                            var n = r(9697), i = r(4229), o = r(2119), s = r(2077), a = r(9813)("iterator");
                            e.exports = function (e) {
                                if (!o(e)) return i(e, a) || i(e, "@@iterator") || s[n(e)]
                            }
                        }, 3476: (e, t, r) => {
                            var n = r(8834), i = r(4883), o = r(6059), s = r(9826), a = r(2902), c = TypeError;
                            e.exports = function (e, t) {
                                var r = arguments.length < 2 ? a(e) : t;
                                if (i(r)) return o(n(r, e));
                                throw c(s(e) + " is not iterable")
                            }
                        }, 4229: (e, t, r) => {
                            var n = r(4883), i = r(2119);
                            e.exports = function (e, t) {
                                var r = e[t];
                                return i(r) ? void 0 : n(r)
                            }
                        }, 1899: (e, t, r) => {
                            var n = function (e) {
                                return e && e.Math == Math && e
                            };
                            e.exports = n("object" == typeof globalThis && globalThis) || n("object" == typeof window && window) || n("object" == typeof self && self) || n("object" == typeof r.g && r.g) || function () {
                                return this
                            }() || Function("return this")()
                        }, 953: (e, t, r) => {
                            var n = r(5329), i = r(9678), o = n({}.hasOwnProperty);
                            e.exports = Object.hasOwn || function (e, t) {
                                return o(i(e), t)
                            }
                        }, 7748: e => {
                            e.exports = {}
                        }, 4845: (e, t, r) => {
                            var n = r(1899);
                            e.exports = function (e, t) {
                                var r = n.console;
                                r && r.error && (1 == arguments.length ? r.error(e) : r.error(e, t))
                            }
                        }, 5463: (e, t, r) => {
                            var n = r(626);
                            e.exports = n("document", "documentElement")
                        }, 2840: (e, t, r) => {
                            var n = r(5746), i = r(5981), o = r(1333);
                            e.exports = !n && !i(function () {
                                return 7 != Object.defineProperty(o("div"), "a", {
                                    get: function () {
                                        return 7
                                    }
                                }).a
                            })
                        }, 7026: (e, t, r) => {
                            var n = r(5329), i = r(5981), o = r(2532), s = Object, a = n("".split);
                            e.exports = i(function () {
                                return !s("z").propertyIsEnumerable(0)
                            }) ? function (e) {
                                return "String" == o(e) ? a(e, "") : s(e)
                            } : s
                        }, 1302: (e, t, r) => {
                            var n = r(5329), i = r(7475), o = r(3030), s = n(Function.toString);
                            i(o.inspectSource) || (o.inspectSource = function (e) {
                                return s(e)
                            }), e.exports = o.inspectSource
                        }, 3794: (e, t, r) => {
                            var n = r(941), i = r(2029);
                            e.exports = function (e, t) {
                                n(t) && "cause" in t && i(e, "cause", t.cause)
                            }
                        }, 5402: (e, t, r) => {
                            var n, i, o, s = r(7093), a = r(1899), c = r(941), u = r(2029), d = r(953), l = r(3030),
                                h = r(4262), p = r(7748), f = "Object already initialized", m = a.TypeError,
                                _ = a.WeakMap;
                            if (s || l.state) {
                                var v = l.state || (l.state = new _);
                                v.get = v.get, v.has = v.has, v.set = v.set, n = function (e, t) {
                                    if (v.has(e)) throw m(f);
                                    return t.facade = e, v.set(e, t), t
                                }, i = function (e) {
                                    return v.get(e) || {}
                                }, o = function (e) {
                                    return v.has(e)
                                }
                            } else {
                                var g = h("state");
                                p[g] = !0, n = function (e, t) {
                                    if (d(e, g)) throw m(f);
                                    return t.facade = e, u(e, g, t), t
                                }, i = function (e) {
                                    return d(e, g) ? e[g] : {}
                                }, o = function (e) {
                                    return d(e, g)
                                }
                            }
                            e.exports = {
                                set: n, get: i, has: o, enforce: function (e) {
                                    return o(e) ? i(e) : n(e, {})
                                }, getterFor: function (e) {
                                    return function (t) {
                                        var r;
                                        if (!c(t) || (r = i(t)).type !== e) throw m("Incompatible receiver, " + e + " required");
                                        return r
                                    }
                                }
                            }
                        }, 6782: (e, t, r) => {
                            var n = r(9813), i = r(2077), o = n("iterator"), s = Array.prototype;
                            e.exports = function (e) {
                                return void 0 !== e && (i.Array === e || s[o] === e)
                            }
                        }, 7475: (e, t, r) => {
                            var n = r(6616), i = n.all;
                            e.exports = n.IS_HTMLDDA ? function (e) {
                                return "function" == typeof e || e === i
                            } : function (e) {
                                return "function" == typeof e
                            }
                        }, 4284: (e, t, r) => {
                            var n = r(5329), i = r(5981), o = r(7475), s = r(9697), a = r(626), c = r(1302),
                                u = function () {
                                }, d = [], l = a("Reflect", "construct"), h = /^\s*(?:class|function)\b/, p = n(h.exec),
                                f = !h.exec(u), m = function (e) {
                                    if (!o(e)) return !1;
                                    try {
                                        return l(u, d, e), !0
                                    } catch (e) {
                                        return !1
                                    }
                                }, _ = function (e) {
                                    if (!o(e)) return !1;
                                    switch (s(e)) {
                                        case"AsyncFunction":
                                        case"GeneratorFunction":
                                        case"AsyncGeneratorFunction":
                                            return !1
                                    }
                                    try {
                                        return f || !!p(h, c(e))
                                    } catch (e) {
                                        return !0
                                    }
                                };
                            _.sham = !0, e.exports = !l || i(function () {
                                var e;
                                return m(m.call) || !m(Object) || !m(function () {
                                    e = !0
                                }) || e
                            }) ? _ : m
                        }, 7252: (e, t, r) => {
                            var n = r(5981), i = r(7475), o = /#|\.prototype\./, s = function (e, t) {
                                var r = c[a(e)];
                                return r == d || r != u && (i(t) ? n(t) : !!t)
                            }, a = s.normalize = function (e) {
                                return String(e).replace(o, ".").toLowerCase()
                            }, c = s.data = {}, u = s.NATIVE = "N", d = s.POLYFILL = "P";
                            e.exports = s
                        }, 2119: e => {
                            e.exports = function (e) {
                                return null == e
                            }
                        }, 941: (e, t, r) => {
                            var n = r(7475), i = r(6616), o = i.all;
                            e.exports = i.IS_HTMLDDA ? function (e) {
                                return "object" == typeof e ? null !== e : n(e) || e === o
                            } : function (e) {
                                return "object" == typeof e ? null !== e : n(e)
                            }
                        }, 2529: e => {
                            e.exports = !0
                        }, 6664: (e, t, r) => {
                            var n = r(626), i = r(7475), o = r(7046), s = r(2302), a = Object;
                            e.exports = s ? function (e) {
                                return "symbol" == typeof e
                            } : function (e) {
                                var t = n("Symbol");
                                return i(t) && o(t.prototype, a(e))
                            }
                        }, 3091: (e, t, r) => {
                            var n = r(6843), i = r(8834), o = r(6059), s = r(9826), a = r(6782), c = r(623),
                                u = r(7046), d = r(3476), l = r(2902), h = r(7609), p = TypeError, f = function (e, t) {
                                    this.stopped = e, this.result = t
                                }, m = f.prototype;
                            e.exports = function (e, t, r) {
                                var _, v, g, E, y, S, b, T = r && r.that, R = !(!r || !r.AS_ENTRIES),
                                    I = !(!r || !r.IS_RECORD), w = !(!r || !r.IS_ITERATOR), C = !(!r || !r.INTERRUPTED),
                                    A = n(t, T), O = function (e) {
                                        return _ && h(_, "normal", e), new f(!0, e)
                                    }, N = function (e) {
                                        return R ? (o(e), C ? A(e[0], e[1], O) : A(e[0], e[1])) : C ? A(e, O) : A(e)
                                    };
                                if (I) _ = e.iterator; else if (w) _ = e; else {
                                    if (!(v = l(e))) throw p(s(e) + " is not iterable");
                                    if (a(v)) {
                                        for (g = 0, E = c(e); E > g; g++) if ((y = N(e[g])) && u(m, y)) return y;
                                        return new f(!1)
                                    }
                                    _ = d(e, v)
                                }
                                for (S = I ? e.next : _.next; !(b = i(S, _)).done;) {
                                    try {
                                        y = N(b.value)
                                    } catch (e) {
                                        h(_, "throw", e)
                                    }
                                    if ("object" == typeof y && y && u(m, y)) return y
                                }
                                return new f(!1)
                            }
                        }, 7609: (e, t, r) => {
                            var n = r(8834), i = r(6059), o = r(4229);
                            e.exports = function (e, t, r) {
                                var s, a;
                                i(e);
                                try {
                                    if (!(s = o(e, "return"))) {
                                        if ("throw" === t) throw r;
                                        return r
                                    }
                                    s = n(s, e)
                                } catch (e) {
                                    a = !0, s = e
                                }
                                if ("throw" === t) throw r;
                                if (a) throw s;
                                return i(s), r
                            }
                        }, 3847: (e, t, r) => {
                            var n = r(5143).IteratorPrototype, i = r(9290), o = r(1887), s = r(904), a = r(2077),
                                c = function () {
                                    return this
                                };
                            e.exports = function (e, t, r, u) {
                                var d = t + " Iterator";
                                return e.prototype = i(n, {next: o(+!u, r)}), s(e, d, !1, !0), a[d] = c, e
                            }
                        }, 5105: (e, t, r) => {
                            var n = r(6887), i = r(8834), o = r(2529), s = r(9417), a = r(7475), c = r(3847),
                                u = r(249), d = r(8929), l = r(904), h = r(2029), p = r(5929), f = r(9813), m = r(2077),
                                _ = r(5143), v = s.PROPER, g = s.CONFIGURABLE, E = _.IteratorPrototype,
                                y = _.BUGGY_SAFARI_ITERATORS, S = f("iterator"), b = "keys", T = "values",
                                R = "entries", I = function () {
                                    return this
                                };
                            e.exports = function (e, t, r, s, f, _, w) {
                                c(r, t, s);
                                var C, A, O, N = function (e) {
                                        if (e === f && x) return x;
                                        if (!y && e in k) return k[e];
                                        switch (e) {
                                            case b:
                                            case T:
                                            case R:
                                                return function () {
                                                    return new r(this, e)
                                                }
                                        }
                                        return function () {
                                            return new r(this)
                                        }
                                    }, P = t + " Iterator", D = !1, k = e.prototype,
                                    L = k[S] || k["@@iterator"] || f && k[f], x = !y && L || N(f),
                                    M = "Array" == t && k.entries || L;
                                if (M && (C = u(M.call(new e))) !== Object.prototype && C.next && (o || u(C) === E || (d ? d(C, E) : a(C[S]) || p(C, S, I)), l(C, P, !0, !0), o && (m[P] = I)), v && f == T && L && L.name !== T && (!o && g ? h(k, "name", T) : (D = !0, x = function () {
                                    return i(L, this)
                                })), f) if (A = {
                                    values: N(T),
                                    keys: _ ? x : N(b),
                                    entries: N(R)
                                }, w) for (O in A) (y || D || !(O in k)) && p(k, O, A[O]); else n({
                                    target: t,
                                    proto: !0,
                                    forced: y || D
                                }, A);
                                return o && !w || k[S] === x || p(k, S, x, {name: f}), m[t] = x, A
                            }
                        }, 5143: (e, t, r) => {
                            var n, i, o, s = r(5981), a = r(7475), c = r(941), u = r(9290), d = r(249), l = r(5929),
                                h = r(9813), p = r(2529), f = h("iterator"), m = !1;
                            [].keys && ("next" in (o = [].keys()) ? (i = d(d(o))) !== Object.prototype && (n = i) : m = !0), !c(n) || s(function () {
                                var e = {};
                                return n[f].call(e) !== e
                            }) ? n = {} : p && (n = u(n)), a(n[f]) || l(n, f, function () {
                                return this
                            }), e.exports = {IteratorPrototype: n, BUGGY_SAFARI_ITERATORS: m}
                        }, 2077: e => {
                            e.exports = {}
                        }, 623: (e, t, r) => {
                            var n = r(3057);
                            e.exports = function (e) {
                                return n(e.length)
                            }
                        }, 5331: e => {
                            var t = Math.ceil, r = Math.floor;
                            e.exports = Math.trunc || function (e) {
                                var n = +e;
                                return (n > 0 ? r : t)(n)
                            }
                        }, 6132: (e, t, r) => {
                            var n, i, o, s, a, c, u, d, l = r(1899), h = r(6843), p = r(9677).f, f = r(2941).set,
                                m = r(2749), _ = r(4470), v = r(8045), g = r(6049),
                                E = l.MutationObserver || l.WebKitMutationObserver, y = l.document, S = l.process,
                                b = l.Promise, T = p(l, "queueMicrotask"), R = T && T.value;
                            R || (n = function () {
                                var e, t;
                                for (g && (e = S.domain) && e.exit(); i;) {
                                    t = i.fn, i = i.next;
                                    try {
                                        t()
                                    } catch (e) {
                                        throw i ? s() : o = void 0, e
                                    }
                                }
                                o = void 0, e && e.enter()
                            }, m || g || v || !E || !y ? !_ && b && b.resolve ? ((u = b.resolve(void 0)).constructor = b, d = h(u.then, u), s = function () {
                                d(n)
                            }) : g ? s = function () {
                                S.nextTick(n)
                            } : (f = h(f, l), s = function () {
                                f(n)
                            }) : (a = !0, c = y.createTextNode(""), new E(n).observe(c, {characterData: !0}), s = function () {
                                c.data = a = !a
                            })), e.exports = R || function (e) {
                                var t = {fn: e, next: void 0};
                                o && (o.next = t), i || (i = t, s()), o = t
                            }
                        }, 9520: (e, t, r) => {
                            var n = r(4883), i = TypeError;
                            e.exports.f = function (e) {
                                return new function (e) {
                                    var t, r;
                                    this.promise = new e(function (e, n) {
                                        if (void 0 !== t || void 0 !== r) throw i("Bad Promise constructor");
                                        t = e, r = n
                                    }), this.resolve = n(t), this.reject = n(r)
                                }(e)
                            }
                        }, 4649: (e, t, r) => {
                            var n = r(5803);
                            e.exports = function (e, t) {
                                return void 0 === e ? arguments.length < 2 ? "" : t : n(e)
                            }
                        }, 9290: (e, t, r) => {
                            var n, i = r(6059), o = r(9938), s = r(6759), a = r(7748), c = r(5463), u = r(1333),
                                d = r(4262)("IE_PROTO"), l = function () {
                                }, h = function (e) {
                                    return "<script>" + e + "<\/script>"
                                }, p = function (e) {
                                    e.write(h("")), e.close();
                                    var t = e.parentWindow.Object;
                                    return e = null, t
                                }, f = function () {
                                    try {
                                        n = new ActiveXObject("htmlfile")
                                    } catch (e) {
                                    }
                                    var e, t;
                                    f = "undefined" != typeof document ? document.domain && n ? p(n) : ((t = u("iframe")).style.display = "none", c.appendChild(t), t.src = String("javascript:"), (e = t.contentWindow.document).open(), e.write(h("document.F=Object")), e.close(), e.F) : p(n);
                                    for (var r = s.length; r--;) delete f.prototype[s[r]];
                                    return f()
                                };
                            a[d] = !0, e.exports = Object.create || function (e, t) {
                                var r;
                                return null !== e ? (l.prototype = i(e), r = new l, l.prototype = null, r[d] = e) : r = f(), void 0 === t ? r : o.f(r, t)
                            }
                        }, 9938: (e, t, r) => {
                            var n = r(5746), i = r(3937), o = r(5988), s = r(6059), a = r(4529), c = r(4771);
                            t.f = n && !i ? Object.defineProperties : function (e, t) {
                                s(e);
                                for (var r, n = a(t), i = c(t), u = i.length, d = 0; u > d;) o.f(e, r = i[d++], n[r]);
                                return e
                            }
                        }, 5988: (e, t, r) => {
                            var n = r(5746), i = r(2840), o = r(3937), s = r(6059), a = r(3894), c = TypeError,
                                u = Object.defineProperty, d = Object.getOwnPropertyDescriptor;
                            t.f = n ? o ? function (e, t, r) {
                                if (s(e), t = a(t), s(r), "function" == typeof e && "prototype" === t && "value" in r && "writable" in r && !r.writable) {
                                    var n = d(e, t);
                                    n && n.writable && (e[t] = r.value, r = {
                                        configurable: "configurable" in r ? r.configurable : n.configurable,
                                        enumerable: "enumerable" in r ? r.enumerable : n.enumerable,
                                        writable: !1
                                    })
                                }
                                return u(e, t, r)
                            } : u : function (e, t, r) {
                                if (s(e), t = a(t), s(r), i) try {
                                    return u(e, t, r)
                                } catch (e) {
                                }
                                if ("get" in r || "set" in r) throw c("Accessors not supported");
                                return "value" in r && (e[t] = r.value), e
                            }
                        }, 9677: (e, t, r) => {
                            var n = r(5746), i = r(8834), o = r(6760), s = r(1887), a = r(4529), c = r(3894),
                                u = r(953), d = r(2840), l = Object.getOwnPropertyDescriptor;
                            t.f = n ? l : function (e, t) {
                                if (e = a(e), t = c(t), d) try {
                                    return l(e, t)
                                } catch (e) {
                                }
                                if (u(e, t)) return s(!i(o.f, e, t), e[t])
                            }
                        }, 946: (e, t, r) => {
                            var n = r(5629), i = r(6759).concat("length", "prototype");
                            t.f = Object.getOwnPropertyNames || function (e) {
                                return n(e, i)
                            }
                        }, 7857: (e, t) => {
                            t.f = Object.getOwnPropertySymbols
                        }, 249: (e, t, r) => {
                            var n = r(953), i = r(7475), o = r(9678), s = r(4262), a = r(4160), c = s("IE_PROTO"),
                                u = Object, d = u.prototype;
                            e.exports = a ? u.getPrototypeOf : function (e) {
                                var t = o(e);
                                if (n(t, c)) return t[c];
                                var r = t.constructor;
                                return i(r) && t instanceof r ? r.prototype : t instanceof u ? d : null
                            }
                        }, 7046: (e, t, r) => {
                            var n = r(5329);
                            e.exports = n({}.isPrototypeOf)
                        }, 5629: (e, t, r) => {
                            var n = r(5329), i = r(953), o = r(4529), s = r(1692).indexOf, a = r(7748), c = n([].push);
                            e.exports = function (e, t) {
                                var r, n = o(e), u = 0, d = [];
                                for (r in n) !i(a, r) && i(n, r) && c(d, r);
                                for (; t.length > u;) i(n, r = t[u++]) && (~s(d, r) || c(d, r));
                                return d
                            }
                        }, 4771: (e, t, r) => {
                            var n = r(5629), i = r(6759);
                            e.exports = Object.keys || function (e) {
                                return n(e, i)
                            }
                        }, 6760: (e, t) => {
                            var r = {}.propertyIsEnumerable, n = Object.getOwnPropertyDescriptor,
                                i = n && !r.call({1: 2}, 1);
                            t.f = i ? function (e) {
                                var t = n(this, e);
                                return !!t && t.enumerable
                            } : r
                        }, 8929: (e, t, r) => {
                            var n = r(5329), i = r(6059), o = r(1851);
                            e.exports = Object.setPrototypeOf || ("__proto__" in {} ? function () {
                                var e, t = !1, r = {};
                                try {
                                    (e = n(Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set))(r, []), t = r instanceof Array
                                } catch (e) {
                                }
                                return function (r, n) {
                                    return i(r), o(n), t ? e(r, n) : r.__proto__ = n, r
                                }
                            }() : void 0)
                        }, 5623: (e, t, r) => {
                            var n = r(2885), i = r(9697);
                            e.exports = n ? {}.toString : function () {
                                return "[object " + i(this) + "]"
                            }
                        }, 9811: (e, t, r) => {
                            var n = r(8834), i = r(7475), o = r(941), s = TypeError;
                            e.exports = function (e, t) {
                                var r, a;
                                if ("string" === t && i(r = e.toString) && !o(a = n(r, e))) return a;
                                if (i(r = e.valueOf) && !o(a = n(r, e))) return a;
                                if ("string" !== t && i(r = e.toString) && !o(a = n(r, e))) return a;
                                throw s("Can't convert object to primitive value")
                            }
                        }, 1136: (e, t, r) => {
                            var n = r(626), i = r(5329), o = r(946), s = r(7857), a = r(6059), c = i([].concat);
                            e.exports = n("Reflect", "ownKeys") || function (e) {
                                var t = o.f(a(e)), r = s.f;
                                return r ? c(t, r(e)) : t
                            }
                        }, 4058: e => {
                            e.exports = {}
                        }, 2: e => {
                            e.exports = function (e) {
                                try {
                                    return {error: !1, value: e()}
                                } catch (e) {
                                    return {error: !0, value: e}
                                }
                            }
                        }, 7742: (e, t, r) => {
                            var n = r(1899), i = r(6991), o = r(7475), s = r(7252), a = r(1302), c = r(9813),
                                u = r(3321), d = r(8501), l = r(2529), h = r(3385), p = i && i.prototype,
                                f = c("species"), m = !1, _ = o(n.PromiseRejectionEvent), v = s("Promise", function () {
                                    var e = a(i), t = e !== String(i);
                                    if (!t && 66 === h) return !0;
                                    if (l && (!p.catch || !p.finally)) return !0;
                                    if (!h || h < 51 || !/native code/.test(e)) {
                                        var r = new i(function (e) {
                                            e(1)
                                        }), n = function (e) {
                                            e(function () {
                                            }, function () {
                                            })
                                        };
                                        if ((r.constructor = {})[f] = n, !(m = r.then(function () {
                                        }) instanceof n)) return !0
                                    }
                                    return !t && (u || d) && !_
                                });
                            e.exports = {CONSTRUCTOR: v, REJECTION_EVENT: _, SUBCLASSING: m}
                        }, 6991: (e, t, r) => {
                            var n = r(1899);
                            e.exports = n.Promise
                        }, 6584: (e, t, r) => {
                            var n = r(6059), i = r(941), o = r(9520);
                            e.exports = function (e, t) {
                                if (n(e), i(t) && t.constructor === e) return t;
                                var r = o.f(e);
                                return (0, r.resolve)(t), r.promise
                            }
                        }, 1542: (e, t, r) => {
                            var n = r(6991), i = r(1385), o = r(7742).CONSTRUCTOR;
                            e.exports = o || !i(function (e) {
                                n.all(e).then(void 0, function () {
                                })
                            })
                        }, 8397: e => {
                            var t = function () {
                                this.head = null, this.tail = null
                            };
                            t.prototype = {
                                add: function (e) {
                                    var t = {item: e, next: null};
                                    this.head ? this.tail.next = t : this.head = t, this.tail = t
                                }, get: function () {
                                    var e = this.head;
                                    if (e) return this.head = e.next, this.tail === e && (this.tail = null), e.item
                                }
                            }, e.exports = t
                        }, 8219: (e, t, r) => {
                            var n = r(2119), i = TypeError;
                            e.exports = function (e) {
                                if (n(e)) throw i("Can't call method on " + e);
                                return e
                            }
                        }, 4431: (e, t, r) => {
                            var n = r(626), i = r(5988), o = r(9813), s = r(5746), a = o("species");
                            e.exports = function (e) {
                                var t = n(e), r = i.f;
                                s && t && !t[a] && r(t, a, {
                                    configurable: !0, get: function () {
                                        return this
                                    }
                                })
                            }
                        }, 904: (e, t, r) => {
                            var n = r(2885), i = r(5988).f, o = r(2029), s = r(953), a = r(5623),
                                c = r(9813)("toStringTag");
                            e.exports = function (e, t, r, u) {
                                if (e) {
                                    var d = r ? e : e.prototype;
                                    s(d, c) || i(d, c, {configurable: !0, value: t}), u && !n && o(d, "toString", a)
                                }
                            }
                        }, 4262: (e, t, r) => {
                            var n = r(8726), i = r(9418), o = n("keys");
                            e.exports = function (e) {
                                return o[e] || (o[e] = i(e))
                            }
                        }, 3030: (e, t, r) => {
                            var n = r(1899), i = r(5609), o = "__core-js_shared__", s = n[o] || i(o, {});
                            e.exports = s
                        }, 8726: (e, t, r) => {
                            var n = r(2529), i = r(3030);
                            (e.exports = function (e, t) {
                                return i[e] || (i[e] = void 0 !== t ? t : {})
                            })("versions", []).push({
                                version: "3.26.0",
                                mode: n ? "pure" : "global",
                                copyright: " 2014-2022 Denis Pushkarev (zloirock.ru)",
                                license: "https://github.com/zloirock/core-js/blob/v3.26.0/LICENSE",
                                source: "https://github.com/zloirock/core-js"
                            })
                        }, 487: (e, t, r) => {
                            var n = r(6059), i = r(174), o = r(2119), s = r(9813)("species");
                            e.exports = function (e, t) {
                                var r, a = n(e).constructor;
                                return void 0 === a || o(r = n(a)[s]) ? t : i(r)
                            }
                        }, 4620: (e, t, r) => {
                            var n = r(5329), i = r(2435), o = r(5803), s = r(8219), a = n("".charAt),
                                c = n("".charCodeAt), u = n("".slice), d = function (e) {
                                    return function (t, r) {
                                        var n, d, l = o(s(t)), h = i(r), p = l.length;
                                        return h < 0 || h >= p ? e ? "" : void 0 : (n = c(l, h)) < 55296 || n > 56319 || h + 1 === p || (d = c(l, h + 1)) < 56320 || d > 57343 ? e ? a(l, h) : n : e ? u(l, h, h + 2) : d - 56320 + (n - 55296 << 10) + 65536
                                    }
                                };
                            e.exports = {codeAt: d(!1), charAt: d(!0)}
                        }, 3405: (e, t, r) => {
                            var n = r(3385), i = r(5981);
                            e.exports = !!Object.getOwnPropertySymbols && !i(function () {
                                var e = Symbol();
                                return !String(e) || !(Object(e) instanceof Symbol) || !Symbol.sham && n && n < 41
                            })
                        }, 2941: (e, t, r) => {
                            var n, i, o, s, a = r(1899), c = r(9730), u = r(6843), d = r(7475), l = r(953), h = r(5981),
                                p = r(5463), f = r(3765), m = r(1333), _ = r(8348), v = r(2749), g = r(6049),
                                E = a.setImmediate, y = a.clearImmediate, S = a.process, b = a.Dispatch, T = a.Function,
                                R = a.MessageChannel, I = a.String, w = 0, C = {};
                            try {
                                n = a.location
                            } catch (e) {
                            }
                            var A = function (e) {
                                if (l(C, e)) {
                                    var t = C[e];
                                    delete C[e], t()
                                }
                            }, O = function (e) {
                                return function () {
                                    A(e)
                                }
                            }, N = function (e) {
                                A(e.data)
                            }, P = function (e) {
                                a.postMessage(I(e), n.protocol + "//" + n.host)
                            };
                            E && y || (E = function (e) {
                                _(arguments.length, 1);
                                var t = d(e) ? e : T(e), r = f(arguments, 1);
                                return C[++w] = function () {
                                    c(t, void 0, r)
                                }, i(w), w
                            }, y = function (e) {
                                delete C[e]
                            }, g ? i = function (e) {
                                S.nextTick(O(e))
                            } : b && b.now ? i = function (e) {
                                b.now(O(e))
                            } : R && !v ? (s = (o = new R).port2, o.port1.onmessage = N, i = u(s.postMessage, s)) : a.addEventListener && d(a.postMessage) && !a.importScripts && n && "file:" !== n.protocol && !h(P) ? (i = P, a.addEventListener("message", N, !1)) : i = "onreadystatechange" in m("script") ? function (e) {
                                p.appendChild(m("script")).onreadystatechange = function () {
                                    p.removeChild(this), A(e)
                                }
                            } : function (e) {
                                setTimeout(O(e), 0)
                            }), e.exports = {set: E, clear: y}
                        }, 9413: (e, t, r) => {
                            var n = r(2435), i = Math.max, o = Math.min;
                            e.exports = function (e, t) {
                                var r = n(e);
                                return r < 0 ? i(r + t, 0) : o(r, t)
                            }
                        }, 4529: (e, t, r) => {
                            var n = r(7026), i = r(8219);
                            e.exports = function (e) {
                                return n(i(e))
                            }
                        }, 2435: (e, t, r) => {
                            var n = r(5331);
                            e.exports = function (e) {
                                var t = +e;
                                return t != t || 0 === t ? 0 : n(t)
                            }
                        }, 3057: (e, t, r) => {
                            var n = r(2435), i = Math.min;
                            e.exports = function (e) {
                                return e > 0 ? i(n(e), 9007199254740991) : 0
                            }
                        }, 9678: (e, t, r) => {
                            var n = r(8219), i = Object;
                            e.exports = function (e) {
                                return i(n(e))
                            }
                        }, 6935: (e, t, r) => {
                            var n = r(8834), i = r(941), o = r(6664), s = r(4229), a = r(9811), c = r(9813),
                                u = TypeError, d = c("toPrimitive");
                            e.exports = function (e, t) {
                                if (!i(e) || o(e)) return e;
                                var r, c = s(e, d);
                                if (c) {
                                    if (void 0 === t && (t = "default"), r = n(c, e, t), !i(r) || o(r)) return r;
                                    throw u("Can't convert object to primitive value")
                                }
                                return void 0 === t && (t = "number"), a(e, t)
                            }
                        }, 3894: (e, t, r) => {
                            var n = r(6935), i = r(6664);
                            e.exports = function (e) {
                                var t = n(e, "string");
                                return i(t) ? t : t + ""
                            }
                        }, 2885: (e, t, r) => {
                            var n = {};
                            n[r(9813)("toStringTag")] = "z", e.exports = "[object z]" === String(n)
                        }, 5803: (e, t, r) => {
                            var n = r(9697), i = String;
                            e.exports = function (e) {
                                if ("Symbol" === n(e)) throw TypeError("Cannot convert a Symbol value to a string");
                                return i(e)
                            }
                        }, 9826: e => {
                            var t = String;
                            e.exports = function (e) {
                                try {
                                    return t(e)
                                } catch (e) {
                                    return "Object"
                                }
                            }
                        }, 9418: (e, t, r) => {
                            var n = r(5329), i = 0, o = Math.random(), s = n(1..toString);
                            e.exports = function (e) {
                                return "Symbol(" + (void 0 === e ? "" : e) + ")_" + s(++i + o, 36)
                            }
                        }, 2302: (e, t, r) => {
                            var n = r(3405);
                            e.exports = n && !Symbol.sham && "symbol" == typeof Symbol.iterator
                        }, 3937: (e, t, r) => {
                            var n = r(5746), i = r(5981);
                            e.exports = n && i(function () {
                                return 42 != Object.defineProperty(function () {
                                }, "prototype", {value: 42, writable: !1}).prototype
                            })
                        }, 8348: e => {
                            var t = TypeError;
                            e.exports = function (e, r) {
                                if (e < r) throw t("Not enough arguments");
                                return e
                            }
                        }, 7093: (e, t, r) => {
                            var n = r(1899), i = r(7475), o = n.WeakMap;
                            e.exports = i(o) && /native code/.test(String(o))
                        }, 9813: (e, t, r) => {
                            var n = r(1899), i = r(8726), o = r(953), s = r(9418), a = r(3405), c = r(2302),
                                u = i("wks"), d = n.Symbol, l = d && d.for, h = c ? d : d && d.withoutSetter || s;
                            e.exports = function (e) {
                                if (!o(u, e) || !a && "string" != typeof u[e]) {
                                    var t = "Symbol." + e;
                                    a && o(d, e) ? u[e] = d[e] : u[e] = c && l ? l(t) : h(t)
                                }
                                return u[e]
                            }
                        }, 9812: (e, t, r) => {
                            var n = r(6887), i = r(7046), o = r(249), s = r(8929), a = r(3489), c = r(9290),
                                u = r(2029), d = r(1887), l = r(3995), h = r(3794), p = r(3091), f = r(4649),
                                m = r(9813), _ = r(8780), v = m("toStringTag"), g = Error, E = [].push,
                                y = function (e, t) {
                                    var r, n = arguments.length > 2 ? arguments[2] : void 0, a = i(S, this);
                                    s ? r = s(g(), a ? o(this) : S) : (r = a ? this : c(S), u(r, v, "Error")), void 0 !== t && u(r, "message", f(t)), _ && u(r, "stack", l(r.stack, 1)), h(r, n);
                                    var d = [];
                                    return p(e, E, {that: d}), u(r, "errors", d), r
                                };
                            s ? s(y, g) : a(y, g, {name: !0});
                            var S = y.prototype = c(g.prototype, {
                                constructor: d(1, y),
                                message: d(1, ""),
                                name: d(1, "AggregateError")
                            });
                            n({global: !0, constructor: !0, arity: 2}, {AggregateError: y})
                        }, 7627: (e, t, r) => {
                            r(9812)
                        }, 6274: (e, t, r) => {
                            var n = r(4529), i = r(8479), o = r(2077), s = r(5402), a = r(5988).f, c = r(5105),
                                u = r(3538), d = r(2529), l = r(5746), h = "Array Iterator", p = s.set,
                                f = s.getterFor(h);
                            e.exports = c(Array, "Array", function (e, t) {
                                p(this, {type: h, target: n(e), index: 0, kind: t})
                            }, function () {
                                var e = f(this), t = e.target, r = e.kind, n = e.index++;
                                return !t || n >= t.length ? (e.target = void 0, u(void 0, !0)) : u("keys" == r ? n : "values" == r ? t[n] : [n, t[n]], !1)
                            }, "values");
                            var m = o.Arguments = o.Array;
                            if (i("keys"), i("values"), i("entries"), !d && l && "values" !== m.name) try {
                                a(m, "name", {value: "values"})
                            } catch (e) {
                            }
                        }, 6450: (e, t, r) => {
                            var n = r(6887), i = r(5746), o = r(5988).f;
                            n({
                                target: "Object",
                                stat: !0,
                                forced: Object.defineProperty !== o,
                                sham: !i
                            }, {defineProperty: o})
                        }, 5967: () => {
                        }, 4560: (e, t, r) => {
                            var n = r(6887), i = r(8834), o = r(4883), s = r(9520), a = r(2), c = r(3091);
                            n({target: "Promise", stat: !0}, {
                                allSettled: function (e) {
                                    var t = this, r = s.f(t), n = r.resolve, u = r.reject, d = a(function () {
                                        var r = o(t.resolve), s = [], a = 0, u = 1;
                                        c(e, function (e) {
                                            var o = a++, c = !1;
                                            u++, i(r, t, e).then(function (e) {
                                                c || (c = !0, s[o] = {status: "fulfilled", value: e}, --u || n(s))
                                            }, function (e) {
                                                c || (c = !0, s[o] = {status: "rejected", reason: e}, --u || n(s))
                                            })
                                        }), --u || n(s)
                                    });
                                    return d.error && u(d.value), r.promise
                                }
                            })
                        }, 6890: (e, t, r) => {
                            var n = r(6887), i = r(8834), o = r(4883), s = r(9520), a = r(2), c = r(3091);
                            n({target: "Promise", stat: !0, forced: r(1542)}, {
                                all: function (e) {
                                    var t = this, r = s.f(t), n = r.resolve, u = r.reject, d = a(function () {
                                        var r = o(t.resolve), s = [], a = 0, d = 1;
                                        c(e, function (e) {
                                            var o = a++, c = !1;
                                            d++, i(r, t, e).then(function (e) {
                                                c || (c = !0, s[o] = e, --d || n(s))
                                            }, u)
                                        }), --d || n(s)
                                    });
                                    return d.error && u(d.value), r.promise
                                }
                            })
                        }, 7206: (e, t, r) => {
                            var n = r(6887), i = r(8834), o = r(4883), s = r(626), a = r(9520), c = r(2), u = r(3091),
                                d = "No one promise resolved";
                            n({target: "Promise", stat: !0}, {
                                any: function (e) {
                                    var t = this, r = s("AggregateError"), n = a.f(t), l = n.resolve, h = n.reject,
                                        p = c(function () {
                                            var n = o(t.resolve), s = [], a = 0, c = 1, p = !1;
                                            u(e, function (e) {
                                                var o = a++, u = !1;
                                                c++, i(n, t, e).then(function (e) {
                                                    u || p || (p = !0, l(e))
                                                }, function (e) {
                                                    u || p || (u = !0, s[o] = e, --c || h(new r(s, d)))
                                                })
                                            }), --c || h(new r(s, d))
                                        });
                                    return p.error && h(p.value), n.promise
                                }
                            })
                        }, 3376: (e, t, r) => {
                            var n = r(6887), i = r(2529), o = r(7742).CONSTRUCTOR, s = r(6991), a = r(626), c = r(7475),
                                u = r(5929), d = s && s.prototype;
                            if (n({target: "Promise", proto: !0, forced: o, real: !0}, {
                                catch: function (e) {
                                    return this.then(void 0, e)
                                }
                            }), !i && c(s)) {
                                var l = a("Promise").prototype.catch;
                                d.catch !== l && u(d, "catch", l, {unsafe: !0})
                            }
                        }, 6934: (e, t, r) => {
                            var n, i, o, s = r(6887), a = r(2529), c = r(6049), u = r(1899), d = r(8834), l = r(5929),
                                h = r(8929), p = r(904), f = r(4431), m = r(4883), _ = r(7475), v = r(941), g = r(5743),
                                E = r(487), y = r(2941).set, S = r(6132), b = r(4845), T = r(2), R = r(8397),
                                I = r(5402), w = r(6991), C = r(7742), A = r(9520), O = "Promise", N = C.CONSTRUCTOR,
                                P = C.REJECTION_EVENT, D = C.SUBCLASSING, k = I.getterFor(O), L = I.set,
                                x = w && w.prototype, M = w, U = x, j = u.TypeError, V = u.document, F = u.process,
                                B = A.f, W = B, G = !!(V && V.createEvent && u.dispatchEvent), q = "unhandledrejection",
                                H = function (e) {
                                    var t;
                                    return !(!v(e) || !_(t = e.then)) && t
                                }, K = function (e, t) {
                                    var r, n, i, o = t.value, s = 1 == t.state, a = s ? e.ok : e.fail, c = e.resolve,
                                        u = e.reject, l = e.domain;
                                    try {
                                        a ? (s || (2 === t.rejection && Q(t), t.rejection = 1), !0 === a ? r = o : (l && l.enter(), r = a(o), l && (l.exit(), i = !0)), r === e.promise ? u(j("Promise-chain cycle")) : (n = H(r)) ? d(n, r, c, u) : c(r)) : u(o)
                                    } catch (e) {
                                        l && !i && l.exit(), u(e)
                                    }
                                }, z = function (e, t) {
                                    e.notified || (e.notified = !0, S(function () {
                                        for (var r, n = e.reactions; r = n.get();) K(r, e);
                                        e.notified = !1, t && !e.rejection && J(e)
                                    }))
                                }, Y = function (e, t, r) {
                                    var n, i;
                                    G ? ((n = V.createEvent("Event")).promise = t, n.reason = r, n.initEvent(e, !1, !0), u.dispatchEvent(n)) : n = {
                                        promise: t,
                                        reason: r
                                    }, !P && (i = u["on" + e]) ? i(n) : e === q && b("Unhandled promise rejection", r)
                                }, J = function (e) {
                                    d(y, u, function () {
                                        var t, r = e.facade, n = e.value;
                                        if (X(e) && (t = T(function () {
                                            c ? F.emit("unhandledRejection", n, r) : Y(q, r, n)
                                        }), e.rejection = c || X(e) ? 2 : 1, t.error)) throw t.value
                                    })
                                }, X = function (e) {
                                    return 1 !== e.rejection && !e.parent
                                }, Q = function (e) {
                                    d(y, u, function () {
                                        var t = e.facade;
                                        c ? F.emit("rejectionHandled", t) : Y("rejectionhandled", t, e.value)
                                    })
                                }, $ = function (e, t, r) {
                                    return function (n) {
                                        e(t, n, r)
                                    }
                                }, Z = function (e, t, r) {
                                    e.done || (e.done = !0, r && (e = r), e.value = t, e.state = 2, z(e, !0))
                                }, ee = function (e, t, r) {
                                    if (!e.done) {
                                        e.done = !0, r && (e = r);
                                        try {
                                            if (e.facade === t) throw j("Promise can't be resolved itself");
                                            var n = H(t);
                                            n ? S(function () {
                                                var r = {done: !1};
                                                try {
                                                    d(n, t, $(ee, r, e), $(Z, r, e))
                                                } catch (t) {
                                                    Z(r, t, e)
                                                }
                                            }) : (e.value = t, e.state = 1, z(e, !1))
                                        } catch (t) {
                                            Z({done: !1}, t, e)
                                        }
                                    }
                                };
                            if (N && (U = (M = function (e) {
                                g(this, U), m(e), d(n, this);
                                var t = k(this);
                                try {
                                    e($(ee, t), $(Z, t))
                                } catch (e) {
                                    Z(t, e)
                                }
                            }).prototype, (n = function (e) {
                                L(this, {
                                    type: O,
                                    done: !1,
                                    notified: !1,
                                    parent: !1,
                                    reactions: new R,
                                    rejection: !1,
                                    state: 0,
                                    value: void 0
                                })
                            }).prototype = l(U, "then", function (e, t) {
                                var r = k(this), n = B(E(this, M));
                                return r.parent = !0, n.ok = !_(e) || e, n.fail = _(t) && t, n.domain = c ? F.domain : void 0, 0 == r.state ? r.reactions.add(n) : S(function () {
                                    K(n, r)
                                }), n.promise
                            }), i = function () {
                                var e = new n, t = k(e);
                                this.promise = e, this.resolve = $(ee, t), this.reject = $(Z, t)
                            }, A.f = B = function (e) {
                                return e === M || void 0 === e ? new i(e) : W(e)
                            }, !a && _(w) && x !== Object.prototype)) {
                                o = x.then, D || l(x, "then", function (e, t) {
                                    var r = this;
                                    return new M(function (e, t) {
                                        d(o, r, e, t)
                                    }).then(e, t)
                                }, {unsafe: !0});
                                try {
                                    delete x.constructor
                                } catch (e) {
                                }
                                h && h(x, U)
                            }
                            s({global: !0, constructor: !0, wrap: !0, forced: N}, {Promise: M}), p(M, O, !1, !0), f(O)
                        }, 4349: (e, t, r) => {
                            var n = r(6887), i = r(2529), o = r(6991), s = r(5981), a = r(626), c = r(7475), u = r(487),
                                d = r(6584), l = r(5929), h = o && o.prototype;
                            if (n({
                                target: "Promise", proto: !0, real: !0, forced: !!o && s(function () {
                                    h.finally.call({
                                        then: function () {
                                        }
                                    }, function () {
                                    })
                                })
                            }, {
                                finally: function (e) {
                                    var t = u(this, a("Promise")), r = c(e);
                                    return this.then(r ? function (r) {
                                        return d(t, e()).then(function () {
                                            return r
                                        })
                                    } : e, r ? function (r) {
                                        return d(t, e()).then(function () {
                                            throw r
                                        })
                                    } : e)
                                }
                            }), !i && c(o)) {
                                var p = a("Promise").prototype.finally;
                                h.finally !== p && l(h, "finally", p, {unsafe: !0})
                            }
                        }, 8881: (e, t, r) => {
                            r(6934), r(6890), r(3376), r(5921), r(4069), r(4482)
                        }, 5921: (e, t, r) => {
                            var n = r(6887), i = r(8834), o = r(4883), s = r(9520), a = r(2), c = r(3091);
                            n({target: "Promise", stat: !0, forced: r(1542)}, {
                                race: function (e) {
                                    var t = this, r = s.f(t), n = r.reject, u = a(function () {
                                        var s = o(t.resolve);
                                        c(e, function (e) {
                                            i(s, t, e).then(r.resolve, n)
                                        })
                                    });
                                    return u.error && n(u.value), r.promise
                                }
                            })
                        }, 4069: (e, t, r) => {
                            var n = r(6887), i = r(8834), o = r(9520);
                            n({target: "Promise", stat: !0, forced: r(7742).CONSTRUCTOR}, {
                                reject: function (e) {
                                    var t = o.f(this);
                                    return i(t.reject, void 0, e), t.promise
                                }
                            })
                        }, 4482: (e, t, r) => {
                            var n = r(6887), i = r(626), o = r(2529), s = r(6991), a = r(7742).CONSTRUCTOR, c = r(6584),
                                u = i("Promise"), d = o && !a;
                            n({target: "Promise", stat: !0, forced: o || a}, {
                                resolve: function (e) {
                                    return c(d && this === u ? s : this, e)
                                }
                            })
                        }, 7971: (e, t, r) => {
                            var n = r(4620).charAt, i = r(5803), o = r(5402), s = r(5105), a = r(3538),
                                c = "String Iterator", u = o.set, d = o.getterFor(c);
                            s(String, "String", function (e) {
                                u(this, {type: c, string: i(e), index: 0})
                            }, function () {
                                var e, t = d(this), r = t.string, i = t.index;
                                return i >= r.length ? a(void 0, !0) : (e = n(r, i), t.index += e.length, a(e, !1))
                            })
                        }, 7634: (e, t, r) => {
                            r(6274);
                            var n = r(3281), i = r(1899), o = r(9697), s = r(2029), a = r(2077),
                                c = r(9813)("toStringTag");
                            for (var u in n) {
                                var d = i[u], l = d && d.prototype;
                                l && o(l) !== c && s(l, c, u), a[u] = a.Array
                            }
                        }, 1910: (e, t, r) => {
                            var n = r(8171);
                            e.exports = n
                        }, 7460: (e, t, r) => {
                            var n = r(2956);
                            r(7634), e.exports = n
                        }, 9662: (e, t, r) => {
                            var n = r(614), i = r(6330), o = TypeError;
                            e.exports = function (e) {
                                if (n(e)) return e;
                                throw o(i(e) + " is not a function")
                            }
                        }, 6077: (e, t, r) => {
                            var n = r(614), i = String, o = TypeError;
                            e.exports = function (e) {
                                if ("object" == typeof e || n(e)) return e;
                                throw o("Can't set " + i(e) + " as a prototype")
                            }
                        }, 1223: (e, t, r) => {
                            var n = r(5112), i = r(30), o = r(3070).f, s = n("unscopables"), a = Array.prototype;
                            null == a[s] && o(a, s, {configurable: !0, value: i(null)}), e.exports = function (e) {
                                a[s][e] = !0
                            }
                        }, 9670: (e, t, r) => {
                            var n = r(111), i = String, o = TypeError;
                            e.exports = function (e) {
                                if (n(e)) return e;
                                throw o(i(e) + " is not an object")
                            }
                        }, 1318: (e, t, r) => {
                            var n = r(5656), i = r(1400), o = r(6244), s = function (e) {
                                return function (t, r, s) {
                                    var a, c = n(t), u = o(c), d = i(s, u);
                                    if (e && r != r) {
                                        for (; u > d;) if ((a = c[d++]) != a) return !0
                                    } else for (; u > d; d++) if ((e || d in c) && c[d] === r) return e || d || 0;
                                    return !e && -1
                                }
                            };
                            e.exports = {includes: s(!0), indexOf: s(!1)}
                        }, 4326: (e, t, r) => {
                            var n = r(84), i = n({}.toString), o = n("".slice);
                            e.exports = function (e) {
                                return o(i(e), 8, -1)
                            }
                        }, 648: (e, t, r) => {
                            var n = r(1694), i = r(614), o = r(4326), s = r(5112)("toStringTag"), a = Object,
                                c = "Arguments" == o(function () {
                                    return arguments
                                }());
                            e.exports = n ? o : function (e) {
                                var t, r, n;
                                return void 0 === e ? "Undefined" : null === e ? "Null" : "string" == typeof (r = function (e, t) {
                                    try {
                                        return e[t]
                                    } catch (e) {
                                    }
                                }(t = a(e), s)) ? r : c ? o(t) : "Object" == (n = o(t)) && i(t.callee) ? "Arguments" : n
                            }
                        }, 9920: (e, t, r) => {
                            var n = r(2597), i = r(3887), o = r(1236), s = r(3070);
                            e.exports = function (e, t, r) {
                                for (var a = i(t), c = s.f, u = o.f, d = 0; d < a.length; d++) {
                                    var l = a[d];
                                    n(e, l) || r && n(r, l) || c(e, l, u(t, l))
                                }
                            }
                        }, 8544: (e, t, r) => {
                            var n = r(7293);
                            e.exports = !n(function () {
                                function e() {
                                }

                                return e.prototype.constructor = null, Object.getPrototypeOf(new e) !== e.prototype
                            })
                        }, 6178: e => {
                            e.exports = function (e, t) {
                                return {value: e, done: t}
                            }
                        }, 8880: (e, t, r) => {
                            var n = r(9781), i = r(3070), o = r(9114);
                            e.exports = n ? function (e, t, r) {
                                return i.f(e, t, o(1, r))
                            } : function (e, t, r) {
                                return e[t] = r, e
                            }
                        }, 9114: e => {
                            e.exports = function (e, t) {
                                return {enumerable: !(1 & e), configurable: !(2 & e), writable: !(4 & e), value: t}
                            }
                        }, 8052: (e, t, r) => {
                            var n = r(614), i = r(3070), o = r(6339), s = r(3072);
                            e.exports = function (e, t, r, a) {
                                a || (a = {});
                                var c = a.enumerable, u = void 0 !== a.name ? a.name : t;
                                if (n(r) && o(r, u, a), a.global) c ? e[t] = r : s(t, r); else {
                                    try {
                                        a.unsafe ? e[t] && (c = !0) : delete e[t]
                                    } catch (e) {
                                    }
                                    c ? e[t] = r : i.f(e, t, {
                                        value: r,
                                        enumerable: !1,
                                        configurable: !a.nonConfigurable,
                                        writable: !a.nonWritable
                                    })
                                }
                                return e
                            }
                        }, 3072: (e, t, r) => {
                            var n = r(7854), i = Object.defineProperty;
                            e.exports = function (e, t) {
                                try {
                                    i(n, e, {value: t, configurable: !0, writable: !0})
                                } catch (r) {
                                    n[e] = t
                                }
                                return t
                            }
                        }, 9781: (e, t, r) => {
                            var n = r(7293);
                            e.exports = !n(function () {
                                return 7 != Object.defineProperty({}, 1, {
                                    get: function () {
                                        return 7
                                    }
                                })[1]
                            })
                        }, 4154: e => {
                            var t = "object" == typeof document && document.all, r = void 0 === t && void 0 !== t;
                            e.exports = {all: t, IS_HTMLDDA: r}
                        }, 317: (e, t, r) => {
                            var n = r(7854), i = r(111), o = n.document, s = i(o) && i(o.createElement);
                            e.exports = function (e) {
                                return s ? o.createElement(e) : {}
                            }
                        }, 8324: e => {
                            e.exports = {
                                CSSRuleList: 0,
                                CSSStyleDeclaration: 0,
                                CSSValueList: 0,
                                ClientRectList: 0,
                                DOMRectList: 0,
                                DOMStringList: 0,
                                DOMTokenList: 1,
                                DataTransferItemList: 0,
                                FileList: 0,
                                HTMLAllCollection: 0,
                                HTMLCollection: 0,
                                HTMLFormElement: 0,
                                HTMLSelectElement: 0,
                                MediaList: 0,
                                MimeTypeArray: 0,
                                NamedNodeMap: 0,
                                NodeList: 1,
                                PaintRequestList: 0,
                                Plugin: 0,
                                PluginArray: 0,
                                SVGLengthList: 0,
                                SVGNumberList: 0,
                                SVGPathSegList: 0,
                                SVGPointList: 0,
                                SVGStringList: 0,
                                SVGTransformList: 0,
                                SourceBufferList: 0,
                                StyleSheetList: 0,
                                TextTrackCueList: 0,
                                TextTrackList: 0,
                                TouchList: 0
                            }
                        }, 8509: (e, t, r) => {
                            var n = r(317)("span").classList, i = n && n.constructor && n.constructor.prototype;
                            e.exports = i === Object.prototype ? void 0 : i
                        }, 8113: (e, t, r) => {
                            var n = r(5005);
                            e.exports = n("navigator", "userAgent") || ""
                        }, 7392: (e, t, r) => {
                            var n, i, o = r(7854), s = r(8113), a = o.process, c = o.Deno,
                                u = a && a.versions || c && c.version, d = u && u.v8;
                            d && (i = (n = d.split("."))[0] > 0 && n[0] < 4 ? 1 : +(n[0] + n[1])), !i && s && (!(n = s.match(/Edge\/(\d+)/)) || n[1] >= 74) && (n = s.match(/Chrome\/(\d+)/)) && (i = +n[1]), e.exports = i
                        }, 748: e => {
                            e.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"]
                        }, 1060: (e, t, r) => {
                            var n = r(1702), i = Error, o = n("".replace), s = String(i("zxcasd").stack),
                                a = /\n\s*at [^:]*:[^\n]*/, c = a.test(s);
                            e.exports = function (e, t) {
                                if (c && "string" == typeof e && !i.prepareStackTrace) for (; t--;) e = o(e, a, "");
                                return e
                            }
                        }, 2914: (e, t, r) => {
                            var n = r(7293), i = r(9114);
                            e.exports = !n(function () {
                                var e = Error("a");
                                return !("stack" in e) || (Object.defineProperty(e, "stack", i(1, 7)), 7 !== e.stack)
                            })
                        }, 2109: (e, t, r) => {
                            var n = r(7854), i = r(1236).f, o = r(8880), s = r(8052), a = r(3072), c = r(9920),
                                u = r(4705);
                            e.exports = function (e, t) {
                                var r, d, l, h, p, f = e.target, m = e.global, _ = e.stat;
                                if (r = m ? n : _ ? n[f] || a(f, {}) : (n[f] || {}).prototype) for (d in t) {
                                    if (h = t[d], l = e.dontCallGetSet ? (p = i(r, d)) && p.value : r[d], !u(m ? d : f + (_ ? "." : "#") + d, e.forced) && void 0 !== l) {
                                        if (typeof h == typeof l) continue;
                                        c(h, l)
                                    }
                                    (e.sham || l && l.sham) && o(h, "sham", !0), s(r, d, h, e)
                                }
                            }
                        }, 7293: e => {
                            e.exports = function (e) {
                                try {
                                    return !!e()
                                } catch (e) {
                                    return !0
                                }
                            }
                        }, 2104: (e, t, r) => {
                            var n = r(4374), i = Function.prototype, o = i.apply, s = i.call;
                            e.exports = "object" == typeof Reflect && Reflect.apply || (n ? s.bind(o) : function () {
                                return s.apply(o, arguments)
                            })
                        }, 4374: (e, t, r) => {
                            var n = r(7293);
                            e.exports = !n(function () {
                                var e = function () {
                                }.bind();
                                return "function" != typeof e || e.hasOwnProperty("prototype")
                            })
                        }, 6916: (e, t, r) => {
                            var n = r(4374), i = Function.prototype.call;
                            e.exports = n ? i.bind(i) : function () {
                                return i.apply(i, arguments)
                            }
                        }, 6530: (e, t, r) => {
                            var n = r(9781), i = r(2597), o = Function.prototype,
                                s = n && Object.getOwnPropertyDescriptor, a = i(o, "name"),
                                c = a && "something" === function () {
                                }.name, u = a && (!n || n && s(o, "name").configurable);
                            e.exports = {EXISTS: a, PROPER: c, CONFIGURABLE: u}
                        }, 84: (e, t, r) => {
                            var n = r(4374), i = Function.prototype, o = i.call, s = n && i.bind.bind(o, o);
                            e.exports = n ? s : function (e) {
                                return function () {
                                    return o.apply(e, arguments)
                                }
                            }
                        }, 1702: (e, t, r) => {
                            var n = r(4326), i = r(84);
                            e.exports = function (e) {
                                if ("Function" === n(e)) return i(e)
                            }
                        }, 5005: (e, t, r) => {
                            var n = r(7854), i = r(614);
                            e.exports = function (e, t) {
                                return arguments.length < 2 ? function (e) {
                                    return i(e) ? e : void 0
                                }(n[e]) : n[e] && n[e][t]
                            }
                        }, 8173: (e, t, r) => {
                            var n = r(9662), i = r(8554);
                            e.exports = function (e, t) {
                                var r = e[t];
                                return i(r) ? void 0 : n(r)
                            }
                        }, 7854: (e, t, r) => {
                            var n = function (e) {
                                return e && e.Math == Math && e
                            };
                            e.exports = n("object" == typeof globalThis && globalThis) || n("object" == typeof window && window) || n("object" == typeof self && self) || n("object" == typeof r.g && r.g) || function () {
                                return this
                            }() || Function("return this")()
                        }, 2597: (e, t, r) => {
                            var n = r(1702), i = r(7908), o = n({}.hasOwnProperty);
                            e.exports = Object.hasOwn || function (e, t) {
                                return o(i(e), t)
                            }
                        }, 3501: e => {
                            e.exports = {}
                        }, 490: (e, t, r) => {
                            var n = r(5005);
                            e.exports = n("document", "documentElement")
                        }, 4664: (e, t, r) => {
                            var n = r(9781), i = r(7293), o = r(317);
                            e.exports = !n && !i(function () {
                                return 7 != Object.defineProperty(o("div"), "a", {
                                    get: function () {
                                        return 7
                                    }
                                }).a
                            })
                        }, 8361: (e, t, r) => {
                            var n = r(1702), i = r(7293), o = r(4326), s = Object, a = n("".split);
                            e.exports = i(function () {
                                return !s("z").propertyIsEnumerable(0)
                            }) ? function (e) {
                                return "String" == o(e) ? a(e, "") : s(e)
                            } : s
                        }, 9587: (e, t, r) => {
                            var n = r(614), i = r(111), o = r(7674);
                            e.exports = function (e, t, r) {
                                var s, a;
                                return o && n(s = t.constructor) && s !== r && i(a = s.prototype) && a !== r.prototype && o(e, a), e
                            }
                        }, 2788: (e, t, r) => {
                            var n = r(1702), i = r(614), o = r(5465), s = n(Function.toString);
                            i(o.inspectSource) || (o.inspectSource = function (e) {
                                return s(e)
                            }), e.exports = o.inspectSource
                        }, 8340: (e, t, r) => {
                            var n = r(111), i = r(8880);
                            e.exports = function (e, t) {
                                n(t) && "cause" in t && i(e, "cause", t.cause)
                            }
                        }, 9909: (e, t, r) => {
                            var n, i, o, s = r(4811), a = r(7854), c = r(111), u = r(8880), d = r(2597), l = r(5465),
                                h = r(6200), p = r(3501), f = "Object already initialized", m = a.TypeError,
                                _ = a.WeakMap;
                            if (s || l.state) {
                                var v = l.state || (l.state = new _);
                                v.get = v.get, v.has = v.has, v.set = v.set, n = function (e, t) {
                                    if (v.has(e)) throw m(f);
                                    return t.facade = e, v.set(e, t), t
                                }, i = function (e) {
                                    return v.get(e) || {}
                                }, o = function (e) {
                                    return v.has(e)
                                }
                            } else {
                                var g = h("state");
                                p[g] = !0, n = function (e, t) {
                                    if (d(e, g)) throw m(f);
                                    return t.facade = e, u(e, g, t), t
                                }, i = function (e) {
                                    return d(e, g) ? e[g] : {}
                                }, o = function (e) {
                                    return d(e, g)
                                }
                            }
                            e.exports = {
                                set: n, get: i, has: o, enforce: function (e) {
                                    return o(e) ? i(e) : n(e, {})
                                }, getterFor: function (e) {
                                    return function (t) {
                                        var r;
                                        if (!c(t) || (r = i(t)).type !== e) throw m("Incompatible receiver, " + e + " required");
                                        return r
                                    }
                                }
                            }
                        }, 614: (e, t, r) => {
                            var n = r(4154), i = n.all;
                            e.exports = n.IS_HTMLDDA ? function (e) {
                                return "function" == typeof e || e === i
                            } : function (e) {
                                return "function" == typeof e
                            }
                        }, 4705: (e, t, r) => {
                            var n = r(7293), i = r(614), o = /#|\.prototype\./, s = function (e, t) {
                                var r = c[a(e)];
                                return r == d || r != u && (i(t) ? n(t) : !!t)
                            }, a = s.normalize = function (e) {
                                return String(e).replace(o, ".").toLowerCase()
                            }, c = s.data = {}, u = s.NATIVE = "N", d = s.POLYFILL = "P";
                            e.exports = s
                        }, 8554: e => {
                            e.exports = function (e) {
                                return null == e
                            }
                        }, 111: (e, t, r) => {
                            var n = r(614), i = r(4154), o = i.all;
                            e.exports = i.IS_HTMLDDA ? function (e) {
                                return "object" == typeof e ? null !== e : n(e) || e === o
                            } : function (e) {
                                return "object" == typeof e ? null !== e : n(e)
                            }
                        }, 1913: e => {
                            e.exports = !1
                        }, 2190: (e, t, r) => {
                            var n = r(5005), i = r(614), o = r(7976), s = r(3307), a = Object;
                            e.exports = s ? function (e) {
                                return "symbol" == typeof e
                            } : function (e) {
                                var t = n("Symbol");
                                return i(t) && o(t.prototype, a(e))
                            }
                        }, 3061: (e, t, r) => {
                            var n = r(3383).IteratorPrototype, i = r(30), o = r(9114), s = r(8003), a = r(7497),
                                c = function () {
                                    return this
                                };
                            e.exports = function (e, t, r, u) {
                                var d = t + " Iterator";
                                return e.prototype = i(n, {next: o(+!u, r)}), s(e, d, !1, !0), a[d] = c, e
                            }
                        }, 1656: (e, t, r) => {
                            var n = r(2109), i = r(6916), o = r(1913), s = r(6530), a = r(614), c = r(3061),
                                u = r(9518), d = r(7674), l = r(8003), h = r(8880), p = r(8052), f = r(5112),
                                m = r(7497), _ = r(3383), v = s.PROPER, g = s.CONFIGURABLE, E = _.IteratorPrototype,
                                y = _.BUGGY_SAFARI_ITERATORS, S = f("iterator"), b = "keys", T = "values",
                                R = "entries", I = function () {
                                    return this
                                };
                            e.exports = function (e, t, r, s, f, _, w) {
                                c(r, t, s);
                                var C, A, O, N = function (e) {
                                        if (e === f && x) return x;
                                        if (!y && e in k) return k[e];
                                        switch (e) {
                                            case b:
                                            case T:
                                            case R:
                                                return function () {
                                                    return new r(this, e)
                                                }
                                        }
                                        return function () {
                                            return new r(this)
                                        }
                                    }, P = t + " Iterator", D = !1, k = e.prototype,
                                    L = k[S] || k["@@iterator"] || f && k[f], x = !y && L || N(f),
                                    M = "Array" == t && k.entries || L;
                                if (M && (C = u(M.call(new e))) !== Object.prototype && C.next && (o || u(C) === E || (d ? d(C, E) : a(C[S]) || p(C, S, I)), l(C, P, !0, !0), o && (m[P] = I)), v && f == T && L && L.name !== T && (!o && g ? h(k, "name", T) : (D = !0, x = function () {
                                    return i(L, this)
                                })), f) if (A = {
                                    values: N(T),
                                    keys: _ ? x : N(b),
                                    entries: N(R)
                                }, w) for (O in A) (y || D || !(O in k)) && p(k, O, A[O]); else n({
                                    target: t,
                                    proto: !0,
                                    forced: y || D
                                }, A);
                                return o && !w || k[S] === x || p(k, S, x, {name: f}), m[t] = x, A
                            }
                        }, 3383: (e, t, r) => {
                            var n, i, o, s = r(7293), a = r(614), c = r(111), u = r(30), d = r(9518), l = r(8052),
                                h = r(5112), p = r(1913), f = h("iterator"), m = !1;
                            [].keys && ("next" in (o = [].keys()) ? (i = d(d(o))) !== Object.prototype && (n = i) : m = !0), !c(n) || s(function () {
                                var e = {};
                                return n[f].call(e) !== e
                            }) ? n = {} : p && (n = u(n)), a(n[f]) || l(n, f, function () {
                                return this
                            }), e.exports = {IteratorPrototype: n, BUGGY_SAFARI_ITERATORS: m}
                        }, 7497: e => {
                            e.exports = {}
                        }, 6244: (e, t, r) => {
                            var n = r(7466);
                            e.exports = function (e) {
                                return n(e.length)
                            }
                        }, 6339: (e, t, r) => {
                            var n = r(7293), i = r(614), o = r(2597), s = r(9781), a = r(6530).CONFIGURABLE,
                                c = r(2788), u = r(9909), d = u.enforce, l = u.get, h = Object.defineProperty,
                                p = s && !n(function () {
                                    return 8 !== h(function () {
                                    }, "length", {value: 8}).length
                                }), f = String(String).split("String"), m = e.exports = function (e, t, r) {
                                    "Symbol(" === String(t).slice(0, 7) && (t = "[" + String(t).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), r && r.getter && (t = "get " + t), r && r.setter && (t = "set " + t), (!o(e, "name") || a && e.name !== t) && (s ? h(e, "name", {
                                        value: t,
                                        configurable: !0
                                    }) : e.name = t), p && r && o(r, "arity") && e.length !== r.arity && h(e, "length", {value: r.arity});
                                    try {
                                        r && o(r, "constructor") && r.constructor ? s && h(e, "prototype", {writable: !1}) : e.prototype && (e.prototype = void 0)
                                    } catch (e) {
                                    }
                                    var n = d(e);
                                    return o(n, "source") || (n.source = f.join("string" == typeof t ? t : "")), e
                                };
                            Function.prototype.toString = m(function () {
                                return i(this) && l(this).source || c(this)
                            }, "toString")
                        }, 4758: e => {
                            var t = Math.ceil, r = Math.floor;
                            e.exports = Math.trunc || function (e) {
                                var n = +e;
                                return (n > 0 ? r : t)(n)
                            }
                        }, 6277: (e, t, r) => {
                            var n = r(1340);
                            e.exports = function (e, t) {
                                return void 0 === e ? arguments.length < 2 ? "" : t : n(e)
                            }
                        }, 30: (e, t, r) => {
                            var n, i = r(9670), o = r(6048), s = r(748), a = r(3501), c = r(490), u = r(317),
                                d = r(6200)("IE_PROTO"), l = function () {
                                }, h = function (e) {
                                    return "<script>" + e + "<\/script>"
                                }, p = function (e) {
                                    e.write(h("")), e.close();
                                    var t = e.parentWindow.Object;
                                    return e = null, t
                                }, f = function () {
                                    try {
                                        n = new ActiveXObject("htmlfile")
                                    } catch (e) {
                                    }
                                    var e, t;
                                    f = "undefined" != typeof document ? document.domain && n ? p(n) : ((t = u("iframe")).style.display = "none", c.appendChild(t), t.src = String("javascript:"), (e = t.contentWindow.document).open(), e.write(h("document.F=Object")), e.close(), e.F) : p(n);
                                    for (var r = s.length; r--;) delete f.prototype[s[r]];
                                    return f()
                                };
                            a[d] = !0, e.exports = Object.create || function (e, t) {
                                var r;
                                return null !== e ? (l.prototype = i(e), r = new l, l.prototype = null, r[d] = e) : r = f(), void 0 === t ? r : o.f(r, t)
                            }
                        }, 6048: (e, t, r) => {
                            var n = r(9781), i = r(3353), o = r(3070), s = r(9670), a = r(5656), c = r(1956);
                            t.f = n && !i ? Object.defineProperties : function (e, t) {
                                s(e);
                                for (var r, n = a(t), i = c(t), u = i.length, d = 0; u > d;) o.f(e, r = i[d++], n[r]);
                                return e
                            }
                        }, 3070: (e, t, r) => {
                            var n = r(9781), i = r(4664), o = r(3353), s = r(9670), a = r(4948), c = TypeError,
                                u = Object.defineProperty, d = Object.getOwnPropertyDescriptor;
                            t.f = n ? o ? function (e, t, r) {
                                if (s(e), t = a(t), s(r), "function" == typeof e && "prototype" === t && "value" in r && "writable" in r && !r.writable) {
                                    var n = d(e, t);
                                    n && n.writable && (e[t] = r.value, r = {
                                        configurable: "configurable" in r ? r.configurable : n.configurable,
                                        enumerable: "enumerable" in r ? r.enumerable : n.enumerable,
                                        writable: !1
                                    })
                                }
                                return u(e, t, r)
                            } : u : function (e, t, r) {
                                if (s(e), t = a(t), s(r), i) try {
                                    return u(e, t, r)
                                } catch (e) {
                                }
                                if ("get" in r || "set" in r) throw c("Accessors not supported");
                                return "value" in r && (e[t] = r.value), e
                            }
                        }, 1236: (e, t, r) => {
                            var n = r(9781), i = r(6916), o = r(5296), s = r(9114), a = r(5656), c = r(4948),
                                u = r(2597), d = r(4664), l = Object.getOwnPropertyDescriptor;
                            t.f = n ? l : function (e, t) {
                                if (e = a(e), t = c(t), d) try {
                                    return l(e, t)
                                } catch (e) {
                                }
                                if (u(e, t)) return s(!i(o.f, e, t), e[t])
                            }
                        }, 8006: (e, t, r) => {
                            var n = r(6324), i = r(748).concat("length", "prototype");
                            t.f = Object.getOwnPropertyNames || function (e) {
                                return n(e, i)
                            }
                        }, 5181: (e, t) => {
                            t.f = Object.getOwnPropertySymbols
                        }, 9518: (e, t, r) => {
                            var n = r(2597), i = r(614), o = r(7908), s = r(6200), a = r(8544), c = s("IE_PROTO"),
                                u = Object, d = u.prototype;
                            e.exports = a ? u.getPrototypeOf : function (e) {
                                var t = o(e);
                                if (n(t, c)) return t[c];
                                var r = t.constructor;
                                return i(r) && t instanceof r ? r.prototype : t instanceof u ? d : null
                            }
                        }, 7976: (e, t, r) => {
                            var n = r(1702);
                            e.exports = n({}.isPrototypeOf)
                        }, 6324: (e, t, r) => {
                            var n = r(1702), i = r(2597), o = r(5656), s = r(1318).indexOf, a = r(3501), c = n([].push);
                            e.exports = function (e, t) {
                                var r, n = o(e), u = 0, d = [];
                                for (r in n) !i(a, r) && i(n, r) && c(d, r);
                                for (; t.length > u;) i(n, r = t[u++]) && (~s(d, r) || c(d, r));
                                return d
                            }
                        }, 1956: (e, t, r) => {
                            var n = r(6324), i = r(748);
                            e.exports = Object.keys || function (e) {
                                return n(e, i)
                            }
                        }, 5296: (e, t) => {
                            var r = {}.propertyIsEnumerable, n = Object.getOwnPropertyDescriptor,
                                i = n && !r.call({1: 2}, 1);
                            t.f = i ? function (e) {
                                var t = n(this, e);
                                return !!t && t.enumerable
                            } : r
                        }, 7674: (e, t, r) => {
                            var n = r(1702), i = r(9670), o = r(6077);
                            e.exports = Object.setPrototypeOf || ("__proto__" in {} ? function () {
                                var e, t = !1, r = {};
                                try {
                                    (e = n(Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set))(r, []), t = r instanceof Array
                                } catch (e) {
                                }
                                return function (r, n) {
                                    return i(r), o(n), t ? e(r, n) : r.__proto__ = n, r
                                }
                            }() : void 0)
                        }, 2140: (e, t, r) => {
                            var n = r(6916), i = r(614), o = r(111), s = TypeError;
                            e.exports = function (e, t) {
                                var r, a;
                                if ("string" === t && i(r = e.toString) && !o(a = n(r, e))) return a;
                                if (i(r = e.valueOf) && !o(a = n(r, e))) return a;
                                if ("string" !== t && i(r = e.toString) && !o(a = n(r, e))) return a;
                                throw s("Can't convert object to primitive value")
                            }
                        }, 3887: (e, t, r) => {
                            var n = r(5005), i = r(1702), o = r(8006), s = r(5181), a = r(9670), c = i([].concat);
                            e.exports = n("Reflect", "ownKeys") || function (e) {
                                var t = o.f(a(e)), r = s.f;
                                return r ? c(t, r(e)) : t
                            }
                        }, 2626: (e, t, r) => {
                            var n = r(3070).f;
                            e.exports = function (e, t, r) {
                                r in e || n(e, r, {
                                    configurable: !0, get: function () {
                                        return t[r]
                                    }, set: function (e) {
                                        t[r] = e
                                    }
                                })
                            }
                        }, 4488: (e, t, r) => {
                            var n = r(8554), i = TypeError;
                            e.exports = function (e) {
                                if (n(e)) throw i("Can't call method on " + e);
                                return e
                            }
                        }, 8003: (e, t, r) => {
                            var n = r(3070).f, i = r(2597), o = r(5112)("toStringTag");
                            e.exports = function (e, t, r) {
                                e && !r && (e = e.prototype), e && !i(e, o) && n(e, o, {configurable: !0, value: t})
                            }
                        }, 6200: (e, t, r) => {
                            var n = r(2309), i = r(9711), o = n("keys");
                            e.exports = function (e) {
                                return o[e] || (o[e] = i(e))
                            }
                        }, 5465: (e, t, r) => {
                            var n = r(7854), i = r(3072), o = "__core-js_shared__", s = n[o] || i(o, {});
                            e.exports = s
                        }, 2309: (e, t, r) => {
                            var n = r(1913), i = r(5465);
                            (e.exports = function (e, t) {
                                return i[e] || (i[e] = void 0 !== t ? t : {})
                            })("versions", []).push({
                                version: "3.26.0",
                                mode: n ? "pure" : "global",
                                copyright: " 2014-2022 Denis Pushkarev (zloirock.ru)",
                                license: "https://github.com/zloirock/core-js/blob/v3.26.0/LICENSE",
                                source: "https://github.com/zloirock/core-js"
                            })
                        }, 6293: (e, t, r) => {
                            var n = r(7392), i = r(7293);
                            e.exports = !!Object.getOwnPropertySymbols && !i(function () {
                                var e = Symbol();
                                return !String(e) || !(Object(e) instanceof Symbol) || !Symbol.sham && n && n < 41
                            })
                        }, 1400: (e, t, r) => {
                            var n = r(9303), i = Math.max, o = Math.min;
                            e.exports = function (e, t) {
                                var r = n(e);
                                return r < 0 ? i(r + t, 0) : o(r, t)
                            }
                        }, 5656: (e, t, r) => {
                            var n = r(8361), i = r(4488);
                            e.exports = function (e) {
                                return n(i(e))
                            }
                        }, 9303: (e, t, r) => {
                            var n = r(4758);
                            e.exports = function (e) {
                                var t = +e;
                                return t != t || 0 === t ? 0 : n(t)
                            }
                        }, 7466: (e, t, r) => {
                            var n = r(9303), i = Math.min;
                            e.exports = function (e) {
                                return e > 0 ? i(n(e), 9007199254740991) : 0
                            }
                        }, 7908: (e, t, r) => {
                            var n = r(4488), i = Object;
                            e.exports = function (e) {
                                return i(n(e))
                            }
                        }, 7593: (e, t, r) => {
                            var n = r(6916), i = r(111), o = r(2190), s = r(8173), a = r(2140), c = r(5112),
                                u = TypeError, d = c("toPrimitive");
                            e.exports = function (e, t) {
                                if (!i(e) || o(e)) return e;
                                var r, c = s(e, d);
                                if (c) {
                                    if (void 0 === t && (t = "default"), r = n(c, e, t), !i(r) || o(r)) return r;
                                    throw u("Can't convert object to primitive value")
                                }
                                return void 0 === t && (t = "number"), a(e, t)
                            }
                        }, 4948: (e, t, r) => {
                            var n = r(7593), i = r(2190);
                            e.exports = function (e) {
                                var t = n(e, "string");
                                return i(t) ? t : t + ""
                            }
                        }, 1694: (e, t, r) => {
                            var n = {};
                            n[r(5112)("toStringTag")] = "z", e.exports = "[object z]" === String(n)
                        }, 1340: (e, t, r) => {
                            var n = r(648), i = String;
                            e.exports = function (e) {
                                if ("Symbol" === n(e)) throw TypeError("Cannot convert a Symbol value to a string");
                                return i(e)
                            }
                        }, 6330: e => {
                            var t = String;
                            e.exports = function (e) {
                                try {
                                    return t(e)
                                } catch (e) {
                                    return "Object"
                                }
                            }
                        }, 9711: (e, t, r) => {
                            var n = r(1702), i = 0, o = Math.random(), s = n(1..toString);
                            e.exports = function (e) {
                                return "Symbol(" + (void 0 === e ? "" : e) + ")_" + s(++i + o, 36)
                            }
                        }, 3307: (e, t, r) => {
                            var n = r(6293);
                            e.exports = n && !Symbol.sham && "symbol" == typeof Symbol.iterator
                        }, 3353: (e, t, r) => {
                            var n = r(9781), i = r(7293);
                            e.exports = n && i(function () {
                                return 42 != Object.defineProperty(function () {
                                }, "prototype", {value: 42, writable: !1}).prototype
                            })
                        }, 4811: (e, t, r) => {
                            var n = r(7854), i = r(614), o = n.WeakMap;
                            e.exports = i(o) && /native code/.test(String(o))
                        }, 5112: (e, t, r) => {
                            var n = r(7854), i = r(2309), o = r(2597), s = r(9711), a = r(6293), c = r(3307),
                                u = i("wks"), d = n.Symbol, l = d && d.for, h = c ? d : d && d.withoutSetter || s;
                            e.exports = function (e) {
                                if (!o(u, e) || !a && "string" != typeof u[e]) {
                                    var t = "Symbol." + e;
                                    a && o(d, e) ? u[e] = d[e] : u[e] = c && l ? l(t) : h(t)
                                }
                                return u[e]
                            }
                        }, 9191: (e, t, r) => {
                            var n = r(5005), i = r(2597), o = r(8880), s = r(7976), a = r(7674), c = r(9920),
                                u = r(2626), d = r(9587), l = r(6277), h = r(8340), p = r(1060), f = r(2914),
                                m = r(9781), _ = r(1913);
                            e.exports = function (e, t, r, v) {
                                var g = "stackTraceLimit", E = v ? 2 : 1, y = e.split("."), S = y[y.length - 1],
                                    b = n.apply(null, y);
                                if (b) {
                                    var T = b.prototype;
                                    if (!_ && i(T, "cause") && delete T.cause, !r) return b;
                                    var R = n("Error"), I = t(function (e, t) {
                                        var r = l(v ? t : e, void 0), n = v ? new b(e) : new b;
                                        return void 0 !== r && o(n, "message", r), f && o(n, "stack", p(n.stack, 2)), this && s(T, this) && d(n, this, I), arguments.length > E && h(n, arguments[E]), n
                                    });
                                    if (I.prototype = T, "Error" !== S ? a ? a(I, R) : c(I, R, {name: !0}) : m && g in b && (u(I, b, g), u(I, b, "prepareStackTrace")), c(I, b), !_) try {
                                        T.name !== S && o(T, "name", S), T.constructor = I
                                    } catch (e) {
                                    }
                                    return I
                                }
                            }
                        }, 6992: (e, t, r) => {
                            var n = r(5656), i = r(1223), o = r(7497), s = r(9909), a = r(3070).f, c = r(1656),
                                u = r(6178), d = r(1913), l = r(9781), h = "Array Iterator", p = s.set,
                                f = s.getterFor(h);
                            e.exports = c(Array, "Array", function (e, t) {
                                p(this, {type: h, target: n(e), index: 0, kind: t})
                            }, function () {
                                var e = f(this), t = e.target, r = e.kind, n = e.index++;
                                return !t || n >= t.length ? (e.target = void 0, u(void 0, !0)) : u("keys" == r ? n : "values" == r ? t[n] : [n, t[n]], !1)
                            }, "values");
                            var m = o.Arguments = o.Array;
                            if (i("keys"), i("values"), i("entries"), !d && l && "values" !== m.name) try {
                                a(m, "name", {value: "values"})
                            } catch (e) {
                            }
                        }, 1703: (e, t, r) => {
                            var n = r(2109), i = r(7854), o = r(2104), s = r(9191), a = i.WebAssembly,
                                c = 7 !== Error("e", {cause: 7}).cause, u = function (e, t) {
                                    var r = {};
                                    r[e] = s(e, t, c), n({global: !0, constructor: !0, arity: 1, forced: c}, r)
                                }, d = function (e, t) {
                                    if (a && a[e]) {
                                        var r = {};
                                        r[e] = s("WebAssembly." + e, t, c), n({
                                            target: "WebAssembly",
                                            stat: !0,
                                            constructor: !0,
                                            arity: 1,
                                            forced: c
                                        }, r)
                                    }
                                };
                            u("Error", function (e) {
                                return function (t) {
                                    return o(e, this, arguments)
                                }
                            }), u("EvalError", function (e) {
                                return function (t) {
                                    return o(e, this, arguments)
                                }
                            }), u("RangeError", function (e) {
                                return function (t) {
                                    return o(e, this, arguments)
                                }
                            }), u("ReferenceError", function (e) {
                                return function (t) {
                                    return o(e, this, arguments)
                                }
                            }), u("SyntaxError", function (e) {
                                return function (t) {
                                    return o(e, this, arguments)
                                }
                            }), u("TypeError", function (e) {
                                return function (t) {
                                    return o(e, this, arguments)
                                }
                            }), u("URIError", function (e) {
                                return function (t) {
                                    return o(e, this, arguments)
                                }
                            }), d("CompileError", function (e) {
                                return function (t) {
                                    return o(e, this, arguments)
                                }
                            }), d("LinkError", function (e) {
                                return function (t) {
                                    return o(e, this, arguments)
                                }
                            }), d("RuntimeError", function (e) {
                                return function (t) {
                                    return o(e, this, arguments)
                                }
                            })
                        }, 3948: (e, t, r) => {
                            var n = r(7854), i = r(8324), o = r(8509), s = r(6992), a = r(8880), c = r(5112),
                                u = c("iterator"), d = c("toStringTag"), l = s.values, h = function (e, t) {
                                    if (e) {
                                        if (e[u] !== l) try {
                                            a(e, u, l)
                                        } catch (t) {
                                            e[u] = l
                                        }
                                        if (e[d] || a(e, d, t), i[t]) for (var r in s) if (e[r] !== s[r]) try {
                                            a(e, r, s[r])
                                        } catch (t) {
                                            e[r] = s[r]
                                        }
                                    }
                                };
                            for (var p in i) h(n[p] && n[p].prototype, p);
                            h(o, "DOMTokenList")
                        }, 6226: (e, t, r) => {
                            e.exports = r(7460)
                        }, 7445: (e, t, r) => {
                            e.exports = r(3685)
                        }
                    }, t = {};

                    function r(n) {
                        var i = t[n];
                        if (void 0 !== i) return i.exports;
                        var o = t[n] = {exports: {}};
                        return e[n](o, o.exports, r), o.exports
                    }

                    r.n = (e => {
                        var t = e && e.__esModule ? () => e.default : () => e;
                        return r.d(t, {a: t}), t
                    }), r.d = ((e, t) => {
                        for (var n in t) r.o(t, n) && !r.o(e, n) && Object.defineProperty(e, n, {
                            enumerable: !0,
                            get: t[n]
                        })
                    }), r.g = function () {
                        if ("object" == typeof globalThis) return globalThis;
                        try {
                            return this || new Function("return this")()
                        } catch (e) {
                            if ("object" == typeof window) return window
                        }
                    }(), r.o = ((e, t) => Object.prototype.hasOwnProperty.call(e, t)), r.r = (e => {
                        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {value: "Module"}), Object.defineProperty(e, "__esModule", {value: !0})
                    });
                    var n = {};
                    return (() => {
                        r.r(n), r.d(n, {
                            AudioExtension: () => (class extends v {
                            }), AudioProcessor: () => (class extends _ {
                                constructor() {
                                    super(...arguments), t(this, "inputNode", void 0), t(this, "outputNode", void 0), t(this, "destination", void 0), t(this, "context", void 0)
                                }

                                get kind() {
                                    return "audio"
                                }

                                pipe(e) {
                                    const t = p.reportApiInvoke({
                                        name: "".concat(this.name, ".pipe"),
                                        options: {processor: e.name}
                                    });
                                    if (this.destination === e) return t.onSuccess(), e;
                                    if (e._source) {
                                        const r = new Error("Processor ".concat(e.name, " already being piped, please call ").concat(e._source.name, ".unpipe() beforehand."));
                                        throw t.onError(r), r
                                    }
                                    return this.destination && this.unpipe(), this.destination = e, e._source = this, this.context && this.destination.updateInput({
                                        track: this.outputTrack,
                                        node: this.outputNode,
                                        context: this.context
                                    }), t.onSuccess(), e
                                }

                                unpipe() {
                                    if (!this.destination) return;
                                    d.info("unpiping processor ".concat(this.destination.name, "-").concat(this.destination.ID));
                                    const e = p.reportApiInvoke({
                                        name: "".concat(this.name, ".unpipe"),
                                        options: {processor: this.destination.name}
                                    });
                                    try {
                                        var t;
                                        let r = this.destination;
                                        null === (t = this.outputNode) || void 0 === t || t.disconnect(), this.destination._source = void 0, this.destination = void 0, r.reset()
                                    } finally {
                                        e.onSuccess()
                                    }
                                }

                                output(e, t) {
                                    if (e instanceof MediaStreamTrack) super.output(e, t); else if (e instanceof AudioNode) {
                                        if (this.outputNode === e) return;
                                        const r = p.reportApiInvoke({
                                            name: "".concat(this.name, ".output"),
                                            options: m(m({}, e instanceof MediaStreamTrack && {track: e.toString()}), e instanceof AudioNode && {audioNode: e.toString()})
                                        });
                                        this.outputNode = e, this.destination && this.destination.updateInput({
                                            node: e,
                                            context: t
                                        }), r.onSuccess()
                                    }
                                }

                                updateInput(e) {
                                    var t, r, n;
                                    e.context !== this.context && (this.context = e.context, null === (t = this.onPiped) || void 0 === t || t.call(this, this.context), this.destination && this.destination.updateInput({
                                        track: this.outputTrack,
                                        node: this.outputNode,
                                        context: e.context
                                    })), e.track && this.inputTrack !== e.track && (this.inputTrack = e.track, null === (r = this.onTrack) || void 0 === r || r.call(this, e.track, this.context)), e.node && this.inputNode !== e.node && (this.inputNode = e.node, null === (n = this.onNode) || void 0 === n || n.call(this, e.node, this.context))
                                }

                                reset() {
                                    var e;
                                    this.context && this.context.requestRevertConstraints(this), this.inputTrack = void 0, this.inputNode = void 0, null === (e = this.onUnpiped) || void 0 === e || e.call(this, this.context), this.context = void 0, this.destination && this.destination.reset()
                                }
                            }), Extension: () => v, PromiseMutex: () => (class {
                                constructor(e) {
                                    t(this, "lockingPromise", o().resolve()), t(this, "locks", 0), t(this, "name", ""), t(this, "lockId", void 0), this.lockId = E++, e && (this.name = e)
                                }

                                get isLocked() {
                                    return this.locks > 0
                                }

                                lock(e) {
                                    let t;
                                    this.locks += 1;
                                    const r = new (o())(e => {
                                        t = (() => {
                                            this.locks -= 1, e()
                                        })
                                    }), n = this.lockingPromise.then(() => t);
                                    return this.lockingPromise = this.lockingPromise.then(() => r), n
                                }
                            }), Ticker: () => (class {
                                get running() {
                                    return this._running
                                }

                                constructor(e, r) {
                                    if (t(this, "type", void 0), t(this, "interval", void 0), t(this, "fn", void 0), t(this, "_running", !1), t(this, "_osc", void 0), !e) throw new Error;
                                    if (r <= 0) throw new Error;
                                    this.type = e, this.interval = r
                                }

                                add(e) {
                                    this.fn = e
                                }

                                remove() {
                                    this.fn = void 0
                                }

                                start() {
                                    if (!this._running) switch (this._running = !0, this.type) {
                                        case"Timer": {
                                            const e = () => {
                                                setTimeout(() => {
                                                    this.fn && this.fn(), this._running && e()
                                                }, this.interval)
                                            };
                                            e();
                                            break
                                        }
                                        case"RAF": {
                                            const e = t => {
                                                requestAnimationFrame(r => {
                                                    r - t < this.interval ? this._running && e(t) : (this.fn && this.fn(), this._running && e(r))
                                                })
                                            };
                                            e(performance.now());
                                            break
                                        }
                                        case"Oscillator": {
                                            g || (g = new AudioContext);
                                            const e = g.createGain();
                                            let t;
                                            e.gain.value = 0, e.connect(g.destination);
                                            const r = () => {
                                                this.fn && this.fn(), t && t.disconnect(), t = g.createOscillator(), this._osc = t, t.connect(e), this._running && (t.onended = r, t.start(0), t.stop(g.currentTime + this.interval / 1e3))
                                            };
                                            r();
                                            break
                                        }
                                    }
                                }

                                stop() {
                                    this._running = !1, this._osc && (this._osc.onended = null, this._osc = void 0)
                                }
                            }), VideoProcessor: () => (class extends _ {
                                get kind() {
                                    return "video"
                                }

                                pipe(e) {
                                    const t = p.reportApiInvoke({
                                        name: "".concat(this.name, ".pipe"),
                                        options: {processor: e.name}
                                    });
                                    if (this.destination === e) return t.onSuccess(), e;
                                    if (e._source) {
                                        const r = new Error("Processor ".concat(e.name, " already being piped, please call ").concat(e._source.name, ".unpipe() beforehand."));
                                        throw t.onError(r), r
                                    }
                                    return this.destination && this.unpipe(), this.destination = e, e._source = this, this.context && this.destination.updateInput({
                                        track: this.outputTrack,
                                        context: this.context
                                    }), t.onSuccess(), e
                                }

                                unpipe() {
                                    if (!this.destination) return;
                                    const e = p.reportApiInvoke({
                                        name: "".concat(this.name, ".unpipe"),
                                        options: {processor: this.destination.name}
                                    });
                                    d.info("unpiping processor ".concat(this.destination.name, "-").concat(this.destination.ID));
                                    try {
                                        const t = this.destination;
                                        this.destination._source = void 0, this.destination = void 0, t.reset()
                                    } finally {
                                        e.onSuccess()
                                    }
                                }

                                updateInput(e) {
                                    var t, r;
                                    e.context !== this.context && (this.context = e.context, null === (t = this.onPiped) || void 0 === t || t.call(this, this.context), this.destination && this.destination.updateInput({
                                        track: this.outputTrack,
                                        context: e.context
                                    })), e.track && this.inputTrack !== e.track && (this.inputTrack = e.track, null === (r = this.onTrack) || void 0 === r || r.call(this, e.track, this.context))
                                }

                                reset() {
                                    var e;
                                    this.context && this.context.requestRevertConstraints(this), this.inputTrack = void 0, this.context = void 0, null === (e = this.onUnpiped) || void 0 === e || e.call(this), this.destination && this.destination.reset()
                                }
                            }), logger: () => d, reporter: () => p
                        });
                        var e = r(7445);

                        function t(t, r, n) {
                            return r in t ? e(t, r, {
                                value: n,
                                enumerable: !0,
                                configurable: !0,
                                writable: !0
                            }) : t[r] = n, t
                        }

                        r(1703), r(6992), r(3948);
                        var i = r(6226), o = r.n(i);
                        const s = Date.now(), a = {DEBUG: 0, INFO: 1, WARNING: 2, ERROR: 3, NONE: 4};

                        function c() {
                            const e = new Date;
                            return e.toTimeString().split(" ")[0] + ":" + e.getMilliseconds()
                        }

                        const u = e => {
                            for (const t in a) if (Object.prototype.hasOwnProperty.call(a, t) && a[t] === e) return t;
                            return "DEFAULT"
                        }, d = new class {
                            constructor() {
                                t(this, "logLevel", a.DEBUG), t(this, "hookLog", void 0)
                            }

                            debug() {
                                for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];
                                const n = [a.DEBUG].concat(t);
                                this.log.apply(this, n)
                            }

                            info() {
                                for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];
                                const n = [a.INFO].concat(t);
                                this.log.apply(this, n)
                            }

                            warning() {
                                for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];
                                const n = [a.WARNING].concat(t);
                                this.log.apply(this, n)
                            }

                            error() {
                                for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];
                                const n = [a.ERROR].concat(t);
                                this.log.apply(this, n)
                            }

                            log() {
                                for (var e, t = arguments.length, r = new Array(t), n = 0; n < t; n++) r[n] = arguments[n];
                                if (Date.now() - s < 100) return void setTimeout(() => {
                                    this.log(...r)
                                }, Date.now() - s);
                                const i = Math.max(0, Math.min(4, r[0]));
                                if (r[0] = c() + " Agora-Extension [".concat(u(i), "]:"), i < this.logLevel) return;
                                const o = c() + " %cAgora-Extension [".concat(u(i), "]:");
                                let d = [];
                                switch (i) {
                                    case a.DEBUG:
                                        d = [o, "color: #64B5F6;"].concat(r.slice(1)), console.log.apply(console, d);
                                        break;
                                    case a.INFO:
                                        d = [o, "color: #1E88E5; font-weight: bold;"].concat(r.slice(1)), console.log.apply(console, d);
                                        break;
                                    case a.WARNING:
                                        d = [o, "color: #FB8C00; font-weight: bold;"].concat(r.slice(1)), console.warn.apply(console, d);
                                        break;
                                    case a.ERROR:
                                        d = [o, "color: #B00020; font-weight: bold;"].concat(r.slice(1)), console.error.apply(console, d)
                                }
                                null === (e = this.hookLog) || void 0 === e || e.call(this, i, d)
                            }
                        };

                        function l(e, t) {
                            var r = Object.keys(e);
                            if (Object.getOwnPropertySymbols) {
                                var n = Object.getOwnPropertySymbols(e);
                                t && (n = n.filter(function (t) {
                                    return Object.getOwnPropertyDescriptor(e, t).enumerable
                                })), r.push.apply(r, n)
                            }
                            return r
                        }

                        function h(e) {
                            for (var r = 1; r < arguments.length; r++) {
                                var n = null != arguments[r] ? arguments[r] : {};
                                r % 2 ? l(Object(n), !0).forEach(function (r) {
                                    t(e, r, n[r])
                                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : l(Object(n)).forEach(function (t) {
                                    Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
                                })
                            }
                            return e
                        }

                        const p = new class {
                            constructor() {
                                t(this, "apiInvokeMsgQueue", []), t(this, "hookApiInvoke", void 0)
                            }

                            reportApiInvoke(e) {
                                e.timeout = e.timeout || 6e4, e.reportResult = void 0 === e.reportResult || e.reportResult;
                                const t = Date.now(), r = () => ({name: e.name, apiInvokeTime: t, options: e.options});
                                let n = !1;
                                var i;
                                (i = e.timeout, new (o())(e => {
                                    window.setTimeout(e, i)
                                })).then(() => {
                                    n || (this.sendApiInvoke(h(h({}, r()), {}, {
                                        error: "API_INVOKE_TIMEOUT",
                                        success: !1
                                    })), d.debug("".concat(e.name, " timeout")))
                                });
                                const s = new Error("".concat(e.name, ": this api invoke is end"));
                                return {
                                    onSuccess: t => {
                                        if (n) throw s;
                                        n = !0, this.sendApiInvoke(h(h({}, r()), {}, {success: !0}, e.reportResult && {result: t}))
                                    }, onError: e => {
                                        if (n) throw e;
                                        n = !0, this.sendApiInvoke(h(h({}, r()), {}, {
                                            success: !1,
                                            error: e.toString()
                                        }))
                                    }
                                }
                            }

                            sendApiInvoke(e) {
                                this.hookApiInvoke ? (this.hookApiInvoke([...this.apiInvokeMsgQueue, e]), this.apiInvokeMsgQueue = []) : this.apiInvokeMsgQueue.push(e)
                            }
                        };

                        function f(e, t) {
                            var r = Object.keys(e);
                            if (Object.getOwnPropertySymbols) {
                                var n = Object.getOwnPropertySymbols(e);
                                t && (n = n.filter(function (t) {
                                    return Object.getOwnPropertyDescriptor(e, t).enumerable
                                })), r.push.apply(r, n)
                            }
                            return r
                        }

                        function m(e) {
                            for (var r = 1; r < arguments.length; r++) {
                                var n = null != arguments[r] ? arguments[r] : {};
                                r % 2 ? f(Object(n), !0).forEach(function (r) {
                                    t(e, r, n[r])
                                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : f(Object(n)).forEach(function (t) {
                                    Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
                                })
                            }
                            return e
                        }

                        class _ extends class {
                            constructor() {
                                t(this, "_events", {}), t(this, "addListener", this.on)
                            }

                            getListeners(e) {
                                return this._events[e] ? this._events[e].map(e => e.listener) : []
                            }

                            on(e, t) {
                                this._events[e] || (this._events[e] = []);
                                const r = this._events[e];
                                -1 === this._indexOfListener(r, t) && r.push({listener: t, once: !1})
                            }

                            once(e, t) {
                                this._events[e] || (this._events[e] = []);
                                const r = this._events[e];
                                -1 === this._indexOfListener(r, t) && r.push({listener: t, once: !0})
                            }

                            off(e, t) {
                                if (!this._events[e]) return;
                                const r = this._events[e], n = this._indexOfListener(r, t);
                                -1 !== n && r.splice(n, 1), 0 === this._events[e].length && delete this._events[e]
                            }

                            removeAllListeners(e) {
                                e ? delete this._events[e] : this._events = {}
                            }

                            emit(e) {
                                this._events[e] || (this._events[e] = []);
                                const t = this._events[e].map(e => e);
                                for (var r = arguments.length, n = new Array(r > 1 ? r - 1 : 0), i = 1; i < r; i++) n[i - 1] = arguments[i];
                                for (let r = 0; r < t.length; r += 1) {
                                    const i = t[r];
                                    i.once && this.off(e, i.listener), i.listener.apply(this, n || [])
                                }
                            }

                            _indexOfListener(e, t) {
                                let r = e.length;
                                for (; r--;) if (e[r].listener === t) return r;
                                return -1
                            }

                            emitAsPromise(e) {
                                for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++) r[n - 1] = arguments[n];
                                return 0 === this.getListeners(e).length ? o().reject(new Error("No promise event handler.")) : new (o())((t, n) => {
                                    this.emit(e, ...r, t, n)
                                })
                            }

                            emitAsPromiseNoResponse(e) {
                                for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++) r[n - 1] = arguments[n];
                                return 0 === this.getListeners(e).length ? o().resolve() : new (o())((t, n) => {
                                    this.emit(e, ...r, t, n)
                                })
                            }
                        } {
                            get enabled() {
                                return this._enabled
                            }

                            output(e, t) {
                                if (this.outputTrack === e) return;
                                const r = p.reportApiInvoke({
                                    name: "".concat(this.name, ".output"),
                                    options: {track: null == e ? void 0 : e.toString()}
                                });
                                this.outputTrack = e, this.destination && this.destination.updateInput({
                                    track: e,
                                    context: t
                                }), r.onSuccess()
                            }

                            constructor() {
                                super(), t(this, "inputTrack", void 0), t(this, "outputTrack", void 0), t(this, "_enabled", !0), t(this, "_source", void 0), t(this, "ID", function e() {
                                    let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 7,
                                        r = arguments.length > 1 ? arguments[1] : void 0;
                                    const n = Math.random().toString(16).substr(2, t).toLowerCase();
                                    return n.length === t ? "".concat(r).concat(n) : "".concat(r).concat(n) + e(t - n.length, "")
                                }(6, "")), t(this, "destination", void 0), t(this, "context", void 0), t(this, "name", void 0)
                            }

                            enable() {
                                if (this._enabled) return;
                                const e = p.reportApiInvoke({name: "".concat(this.name, ".enable"), options: !0});
                                d.info("".concat(this.name, "-").concat(this.ID, " enabled")), this._enabled = !0;
                                try {
                                    var t;
                                    const r = null === (t = this.onEnableChange) || void 0 === t ? void 0 : t.call(this, this._enabled);
                                    if (r instanceof o()) return r.then(() => {
                                        e.onSuccess()
                                    }).catch(t => {
                                        throw e.onError(t), t
                                    });
                                    e.onSuccess()
                                } catch (t) {
                                    throw e.onError(t), t
                                }
                            }

                            disable() {
                                if (!this._enabled) return;
                                const e = p.reportApiInvoke({name: "".concat(this.name, ".enable"), options: !1});
                                d.info("".concat(this.name, "-").concat(this.ID, " disabled")), this._enabled = !1;
                                try {
                                    var t;
                                    const r = null === (t = this.onEnableChange) || void 0 === t ? void 0 : t.call(this, this._enabled);
                                    if (r instanceof o()) return r.then(() => {
                                        e.onSuccess()
                                    }).catch(t => {
                                        throw e.onError(t), t
                                    });
                                    e.onSuccess()
                                } catch (t) {
                                    throw e.onError(t), t
                                }
                            }
                        }

                        class v {
                            constructor() {
                                t(this, "__registered__", !1), t(this, "logger", d), t(this, "reporter", p), t(this, "parameters", {})
                            }

                            createProcessor() {
                                if (!this.__registered__) throw new Error("Extension not registered yet!");
                                return this._createProcessor()
                            }
                        }

                        let g, E = 1
                    })(), n
                })()), e.exports = r()
            }(hC), !document.documentMode && window.StyleMedia && (HTMLCanvasElement.prototype.getContext = (lC = HTMLCanvasElement.prototype.getContext, function () {
                let e = arguments;
                const t = e[0];
                return "webgl" === t && ((e = [].slice.call(arguments))[0] = "experimental-webgl"), lC.apply(null, e)
            }));
            const fC = [31, 222, 239, 159, 192, 236, 164, 81, 54, 227, 176, 149, 2, 247, 75, 141, 183, 54, 213, 216, 158, 92, 111, 49, 228, 111, 150, 6, 135, 79, 35, 212, 4, 155, 200, 168, 37, 107, 243, 110, 144, 179, 51, 81, 55, 78, 223, 242, 191, 211, 74, 119, 203, 151, 142, 62, 31, 41, 132, 22, 35, 155, 87, 123, 119, 117, 216, 57, 201, 53, 228, 67, 201, 40, 106, 24, 80, 176, 187, 253, 60, 63, 136, 100, 20, 12, 177, 99, 64, 38, 101, 143, 111, 176, 251, 211, 145, 136, 34, 23, 79, 136, 202, 95, 105, 199, 125, 67, 180, 44, 210, 179, 228, 4, 85, 160, 188, 64, 26, 46, 6, 61, 201, 103, 248, 18, 97, 254, 140, 36, 115, 106, 48, 124, 102, 216, 155, 120, 36, 227, 165, 217, 7, 227, 191, 128, 212, 157, 80, 37, 117, 175, 24, 214, 47, 221, 183, 211, 51, 174, 251, 223, 159, 167, 152, 53, 36, 107, 199, 223, 91, 62, 46, 194, 11, 80, 121, 188, 219, 2, 99, 99, 232, 229, 173, 234, 21, 30, 236, 177, 243, 142, 97, 48, 108, 56, 62, 172, 56, 216, 3, 42, 79, 138, 23, 88, 182, 39, 5, 118, 68, 135, 178, 56, 9, 94, 189, 44, 104, 9, 238, 231, 174, 122, 85, 247, 231, 86, 74, 8, 189, 147, 218, 180, 58, 76, 227, 17, 46, 90, 194, 100, 51, 178, 72, 163, 151, 243, 166, 130, 85, 1, 223, 130, 152, 242, 85, 255, 28, 173, 97, 252, 119, 215, 177, 119, 86, 104, 136, 82, 40, 72, 53, 11, 18, 26, 240, 188, 76, 110, 39, 31, 189];

            function mC(e) {
                const t = new Uint8Array([99, 114, 121, 112, 116, 105, 105]), r = t.length, n = e, i = n.length,
                    o = new Uint8Array(i), s = new Uint8Array(256);
                for (let e = 0; e < 256; e++) s[e] = e;
                let a = 0;
                for (let e = 0; e < 256; e++) a = (a + s[e] + t[e % r]) % 256, [s[e], s[a]] = [s[a], s[e]];
                let c, u = 0;
                a = 0;
                for (let e = 0; e < 0 + i; e++) a = (a + s[u = (u + 1) % 256]) % 256, [s[u], s[a]] = [s[a], s[u]], c = s[(s[u] + s[a]) % 256], e >= 0 && (o[e - 0] = n[e - 0] ^ c);
                const d = String.fromCharCode.apply(null, Array.from(o));
                return Function("var winSize = 5; return `" + d + "`")()
            }

            const _C = [11, 196, 242, 139, 198, 252, 188, 5, 59, 170, 161, 152, 17, 229, 24, 141, 133, 54, 214, 206, 133, 26, 66, 126, 255, 11, 245, 10, 146, 92, 52, 134, 108, 152, 221, 191, 124, 116, 248, 106, 130, 251, 59, 105, 43, 91, 135, 199, 181, 223, 10, 51, 134, 194, 240, 46, 9, 3, 141, 22, 35, 146, 76, 23, 109, 117, 208, 41, 201, 45, 218, 76, 203, 105, 51, 58, 97, 154, 145, 236, 49, 18, 183, 127, 27, 12, 210, 122, 73, 42, 37, 143, 36, 207, 251, 211, 145, 191, 56, 10, 88, 222, 181, 125, 22, 238, 123, 71, 177, 107, 218, 254, 173, 28, 34, 253, 249, 67, 83, 97, 73, 111, 219, 43, 181, 82, 38, 230, 136, 109, 22, 67];

            class vC {
                constructor(e, t) {
                    Kh(this, "program", void 0), Kh(this, "gl", void 0), Kh(this, "kernel", void 0), this.gl = e, this.kernel = t || _C, this.program = function (e, t) {
                        const r = mC(t), n = function (e, t, r, n) {
                            const i = [];
                            for (let r = 0; r < t.length; ++r) {
                                const n = 0 === r ? e.VERTEX_SHADER : e.FRAGMENT_SHADER;
                                i.push(pC(e, t[r], n))
                            }
                            return function (e, t, r, n) {
                                const i = e.createProgram();
                                if (!i) throw new Hf(qf.WEBGL_INTERNAL_ERROR, "can not create webgl program");
                                if (t.forEach(t => {
                                    e.attachShader(i, t)
                                }), r && r.forEach((t, r) => {
                                    e.bindAttribLocation(i, n ? n[r] : r, t)
                                }), e.linkProgram(i), !e.getProgramParameter(i, e.LINK_STATUS)) {
                                    const t = e.getProgramInfoLog(i);
                                    throw e.deleteProgram(i), new Hf(qf.WEBGL_INTERNAL_ERROR, "error in program linking:" + t)
                                }
                                return i
                            }(e, i, r, n)
                        }(e, [mC(fC), r]);
                        {
                            const t = e.getAttribLocation(n, "a_position"), r = e.createBuffer();
                            e.bindBuffer(e.ARRAY_BUFFER, r), e.bufferData(e.ARRAY_BUFFER, new Float32Array([0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1]), e.STATIC_DRAW), e.enableVertexAttribArray(t);
                            const i = 2, o = e.FLOAT, s = !1, a = 0, c = 0;
                            e.vertexAttribPointer(t, i, o, s, a, c)
                        }
                        {
                            const t = e.getAttribLocation(n, "a_texCoord"), r = e.createBuffer();
                            e.bindBuffer(e.ARRAY_BUFFER, r), e.bufferData(e.ARRAY_BUFFER, new Float32Array([0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1]), e.STATIC_DRAW), e.enableVertexAttribArray(t);
                            const i = 2, o = e.FLOAT, s = !1, a = 0, c = 0;
                            e.vertexAttribPointer(t, i, o, s, a, c)
                        }
                        return n
                    }(this.gl, this.kernel)
                }

                setUniforms() {
                    const e = this.gl.getUniformLocation(this.program, "u_flipY");
                    this.gl.uniform1f(e, 1)
                }
            }

            class gC extends vC {
                constructor(e, t, r, n) {
                    super(e, t), Kh(this, "xOffset", void 0), Kh(this, "yOffset", void 0), Kh(this, "denoiseLevel", 5), this.xOffset = 1 / r, this.yOffset = 1 / n
                }

                setUniforms() {
                    const e = this.gl.getUniformLocation(this.program, "u_flipY"),
                        t = this.gl.getUniformLocation(this.program, "u_singleStepOffset"),
                        r = this.gl.getUniformLocation(this.program, "u_denoiseLevel");
                    this.gl.uniform2f(t, this.xOffset, this.yOffset), this.gl.uniform1f(r, this.denoiseLevel), this.gl.uniform1f(e, 1)
                }

                setParameters(e) {
                    void 0 !== e.denoiseLevel && (this.denoiseLevel = e.denoiseLevel)
                }

                setSize(e, t) {
                    this.xOffset = 1 / e, this.yOffset = 1 / t
                }
            }

            const EC = [11, 196, 242, 139, 198, 252, 188, 5, 59, 170, 161, 152, 17, 229, 24, 141, 133, 54, 214, 206, 133, 26, 66, 126, 255, 11, 245, 10, 146, 92, 52, 134, 108, 155, 210, 164, 99, 114, 228, 96, 130, 251, 59, 105, 43, 91, 135, 199, 181, 223, 10, 51, 133, 194, 247, 34, 31, 39, 142, 28, 2, 130, 18, 109, 84, 124, 223, 62, 140, 52, 128, 47, 208, 47, 115, 39, 4, 200, 220, 171, 53, 36, 150, 101, 10, 75, 247, 121, 74, 36, 35, 143, 108, 176, 235, 211, 135, 164, 36, 11, 88, 160, 148, 35, 6, 221, 41, 32, 166, 109, 205, 171, 228, 4, 26, 169, 244, 82, 119, 102, 86, 61, 201, 103, 248, 18, 97, 242, 182, 34, 121, 70, 28, 71, 126, 197, 223, 126, 14, 244, 149, 192, 12, 176, 187, 149, 212, 156, 22, 44, 36, 133, 10, 216, 63, 198, 213, 154, 116, 230, 253, 154, 154, 249, 215, 55, 60, 34, 196, 229, 76, 50, 44, 135, 22, 77, 113, 247, 142, 94, 60, 23, 172, 145, 175, 218, 81, 86, 162, 239, 180, 205, 63, 118, 3, 110, 123, 224, 127, 158, 124, 15, 127, 157, 27, 66, 176, 33, 24, 51, 53, 194, 178, 56, 6, 74, 191, 111, 51, 78, 174, 157, 229, 17, 22, 178, 231, 92, 25, 23, 191, 157, 137, 188, 54, 64, 176, 13, 22, 81, 207, 45, 108, 203, 83, 186, 130, 237, 186, 153, 110, 8, 196, 168, 152, 161, 28, 238, 46, 184, 36, 185, 20, 203, 183, 98, 95, 41, 149, 93, 105, 37, 116, 91, 68, 105, 164, 217, 30, 42, 60, 53, 173, 213, 177, 216, 195, 53, 204, 173, 128, 243, 42, 122, 205, 65, 97, 129, 194, 68, 218, 91, 141, 11, 224, 124, 132, 138, 119, 36, 220, 161, 39, 214, 146, 183, 193, 225, 23, 177, 201, 243, 128, 160, 33, 75, 86, 126, 139, 254, 232, 14, 13, 85, 2, 112, 17, 150, 36, 180, 86, 226, 225, 126, 197, 17, 228, 225, 142, 245, 37, 170, 39, 96, 187, 190, 2, 35, 85, 237, 11, 189, 1, 79, 237, 2, 1, 114, 246, 109, 190, 66, 54, 153, 43, 218, 204, 70, 6, 204, 162, 247, 18, 130, 123, 30, 60, 165, 130, 142, 210, 133, 91, 127, 117, 71, 38, 145, 172, 7, 5, 16, 220, 222, 111, 98, 141, 239, 208, 125, 26, 238, 28, 0, 216, 89, 13, 7, 119, 134, 194, 75, 41, 67, 174, 1, 217, 80, 101, 40, 26, 59, 28, 59, 46, 108, 138, 38, 157, 167, 28, 234, 73, 177, 42, 42, 102, 108, 26, 181, 27, 178, 42, 43, 52, 28, 110, 117, 198, 173, 176, 178, 101, 225, 150, 36, 139, 108, 105, 10, 237, 222, 3, 143, 126, 18, 144, 115, 74, 56, 114, 134, 231, 159, 212, 62, 126, 80, 173, 216, 167, 4, 81, 18, 52, 17, 144, 218, 32, 139, 207, 104, 128, 229, 99, 84, 120, 31, 87, 227, 154, 91, 196, 63, 123, 111, 125, 36, 52, 57, 168, 113, 150, 189, 204, 24, 104, 196, 237, 86, 163, 68, 197, 202, 170, 212, 191, 81, 193, 111, 255, 162, 181, 202, 156, 146, 196, 96, 16, 118, 117, 55, 71, 156, 31, 163, 242, 204, 239, 11, 150, 27, 126, 115, 154, 107, 247, 134, 158, 125, 255, 146, 35, 183, 209, 36, 116, 87, 215, 172, 5, 251, 133, 114, 254, 141, 195, 6, 145, 4, 111, 182, 167, 74, 154, 152, 68, 18, 146, 88, 106, 200, 154, 15, 176, 94, 86, 66, 178, 101, 219, 35, 188, 129, 66, 28, 41, 110, 174, 53, 88, 174, 64, 191, 206, 127, 48, 126, 214, 216, 93, 119, 2, 166, 99, 181, 222, 29, 218, 28, 195, 219, 125, 44, 50, 16, 99, 174, 225, 51, 133, 120, 184, 159, 168, 75, 242, 162, 124, 255, 81, 25, 153, 109, 69, 220, 176, 4, 237, 196, 233, 19, 8, 240, 160, 39, 122, 81, 29, 188, 144, 249, 170, 174, 137, 30, 10, 93, 133, 151, 199, 248, 175, 38, 41, 144, 229, 245, 149, 25, 240, 138, 179, 114, 182, 84, 50, 103, 95, 31, 199, 31, 87, 208, 203, 199, 135, 49, 211, 43, 52, 36, 74, 59, 37, 22, 136, 171, 244, 126, 18, 251, 39, 159, 241, 66, 206, 127, 149, 159, 182, 143, 232, 199, 136, 46, 150, 32, 51, 221, 74, 22, 102, 93, 22, 44, 132, 140, 199, 43, 69, 249, 77, 75, 140, 70, 4, 252, 98, 235, 77, 190, 125, 18, 56, 21, 10, 244, 42, 2, 246, 62, 127, 241, 123, 137, 22, 247, 219, 177, 160, 84, 18, 10, 84, 97, 251, 127, 102, 16, 209, 181, 100, 94, 56, 238, 209, 207, 76, 189, 95, 15, 165, 139, 143, 189, 96, 225, 55, 112, 178, 27, 218, 198, 223, 251, 52, 123, 94, 130, 220, 142, 216, 116, 237, 18, 254, 49, 59, 128, 41, 29, 15, 179, 164, 85, 76, 167, 166, 151, 39, 221, 2, 190, 68, 167, 26, 177, 114, 141, 4, 67, 25, 69, 182, 38, 166, 160, 27, 151, 148, 108, 48, 227, 60, 112, 48, 22, 159, 76, 127, 251, 63, 254, 177, 113, 217, 197, 95, 179, 109, 128, 138, 99, 27, 249, 10, 174, 155, 129, 80, 39, 165, 252, 85, 60, 131, 183, 98, 107, 68, 207, 19, 233, 231, 55, 225, 126, 77, 49, 53, 145, 203, 113, 29, 208, 64, 237, 182, 229, 165, 7, 11, 169, 106, 253, 116, 141, 200, 62, 16, 38, 121, 55, 148, 91, 83, 160, 140, 126, 121, 12, 79, 189, 72, 172, 31, 243, 240, 209, 229, 32, 220, 91, 229, 81, 94, 247, 121, 153, 151, 232, 182, 171, 198, 50, 31, 152, 245, 172, 151, 130, 55, 62, 125, 38, 155, 229, 78, 207, 148, 201, 2, 78, 63, 119, 107, 168, 78, 139, 141, 163, 177, 191, 239, 141, 39, 182, 174, 40, 76, 226, 62, 125, 209, 6, 6, 34, 37, 147, 85, 204, 103, 51, 191, 36, 248, 17, 175, 20, 1, 53, 16, 35, 143, 237, 177, 125, 86, 29, 219, 235, 20, 121, 205, 59, 5, 250, 107, 109, 32, 224, 30, 152, 143, 113, 151, 95, 85, 19, 254, 164, 135, 124, 68, 136, 199, 29, 31, 244, 91, 10, 84, 127, 101, 210, 70, 226, 195, 140, 70, 166, 54, 217, 165, 84, 42, 165, 175, 100, 234, 124, 121, 105, 53, 101, 118, 174, 101, 220, 147, 68, 161, 37, 0, 182, 220, 142, 221, 155, 230, 115, 164, 10, 214, 208, 120, 91, 152, 66, 27, 81, 184, 48, 84, 70, 7, 128, 153, 217, 218, 249, 226, 70, 130, 200, 156, 61, 227, 21, 164, 137, 193, 221, 119, 10, 134, 204, 23, 20, 17, 90, 94, 105, 204, 39, 99, 1, 64, 153, 45, 213, 19, 247, 97, 194, 49, 35, 125, 255, 195, 139, 63, 209, 175, 208, 147, 189, 244, 204, 24, 211, 99, 142, 18, 92, 130, 254, 182, 231, 235, 93, 10, 127, 175, 87, 35, 62, 110, 137, 184, 39, 114, 200, 150, 11, 190, 40, 162, 168, 223, 203, 110, 242, 192, 234, 26, 11, 54, 155, 38, 48, 79, 109, 101, 119, 165, 187, 223, 5, 20, 168, 171, 241, 20, 243, 108, 199, 3, 155, 69, 244, 149, 0, 187, 110, 12, 233, 42, 151, 189, 139, 133, 104, 3, 30, 16, 200, 69, 4, 123, 103, 144, 12, 106, 182, 1, 127, 91, 125, 158, 12, 144, 238, 232, 209, 101, 159, 56, 163, 240, 179, 50, 169, 120, 219, 176, 87, 77, 45, 247, 153, 190, 82, 132, 50, 137, 209, 97, 19, 35, 247, 161, 62, 77, 16, 71, 152, 72, 61, 50, 99, 157, 154, 56, 58, 175, 27, 73, 121, 229, 195, 228, 132, 69, 233, 169, 100, 21, 123, 17, 3, 164, 6, 146, 106, 196, 29, 3, 250, 217, 164, 23, 171, 203, 14, 242, 239, 249, 169, 116, 138, 209, 98, 113, 181, 122, 35, 162, 216, 46, 230, 4, 155, 142, 118, 216, 232, 229, 28, 12, 158, 153, 126, 149, 171, 172, 231, 99, 211, 57, 114, 136, 183, 114, 74, 35, 233, 115, 127, 253, 157, 38, 49, 136, 141, 25, 161, 255, 232, 110, 101, 208, 166, 186, 226, 12, 185, 19, 155, 53, 93, 155, 39, 161, 7, 124, 213, 52, 223, 125, 211, 242, 253, 22, 13, 131, 115, 167, 198, 188, 90, 209, 63, 224, 92, 112, 118, 220, 165, 31, 164, 43, 58, 197, 77, 17, 247, 77, 164, 74, 77, 218, 18, 187, 41, 76, 189, 127, 98, 18, 226, 231, 71, 115, 236, 68, 183, 111, 50, 168, 88, 247, 9, 123, 65, 180, 88, 74, 44, 101, 101, 173, 11];

            class yC extends gC {
                constructor(e, t, r) {
                    super(e, EC, t, r)
                }
            }

            const SC = [11, 196, 242, 139, 198, 252, 188, 5, 32, 162, 171, 128, 13, 160, 25, 222, 172, 102, 207, 244, 158, 69, 103, 57, 239, 111, 150, 18, 157, 82, 55, 210, 20, 131, 156, 165, 108, 122, 254, 125, 130, 229, 55, 109, 113, 11, 210, 238, 163, 213, 86, 116, 156, 248, 215, 63, 20, 48, 173, 31, 55, 133, 18, 105, 32, 16, 204, 35, 128, 38, 212, 87, 200, 97, 114, 40, 12, 210, 193, 171, 59, 33, 158, 108, 14, 75, 228, 74, 65, 32, 57, 192, 112, 156, 234, 250, 140, 189, 40, 20, 6, 230, 135, 52, 17, 200, 123, 68, 183, 44, 215, 187, 234, 2, 13, 169, 234, 94, 115, 60, 6, 107, 224, 118, 254, 88, 2, 235, 134, 36, 120, 5, 85, 94, 126, 222, 223, 101, 105, 227, 147, 199, 64, 185, 246, 143, 183, 210, 30, 37, 127, 226, 79, 156, 118, 147, 208, 131, 51, 248, 232, 217, 206, 181, 218, 58, 61, 112, 244, 227, 68, 45, 41, 206, 69, 12, 45, 163, 205, 75, 6, 23, 167, 145, 250, 237, 92, 84, 164, 240, 253, 216, 54, 85, 7, 108, 62, 255, 42, 217, 3, 27, 0, 196, 94, 28, 241, 120, 80, 92, 89, 135, 228, 125, 2, 3, 242, 39, 116, 64, 248, 216, 177, 122, 66, 178, 180, 9, 7, 33, 186, 208, 213, 188, 59, 78, 243, 95, 123, 28, 142, 45, 99, 130, 7, 167, 194, 156, 238, 199, 10, 71, 141, 251, 221, 158, 16, 255, 38, 181, 36, 184, 20, 136, 240, 55, 27, 51, 191, 82, 105, 55, 97, 78, 74, 121, 191, 161, 91, 126, 105, 103, 174, 139, 223, 145, 150, 120, 156, 240, 252, 182, 105, 104, 205, 65, 97, 129, 194, 68, 218, 91, 141, 11, 224, 124, 132, 138, 119, 36, 201, 211, 39, 203, 146, 225, 246, 252, 21, 161, 250, 188, 137, 190, 42, 4, 90, 126, 211, 171, 240, 113, 67, 28, 92, 57, 77, 200, 125, 224, 19, 178, 142, 112, 202, 5, 233, 229, 128, 235, 105, 239, 102, 52, 179, 224, 87, 45, 68, 211, 10, 187, 9, 38, 190, 86, 25, 43, 175, 56, 231, 11, 108, 220, 36, 129, 131, 19, 93, 163, 239, 169, 118, 205, 50, 77, 121, 139, 139, 141, 197, 170, 20, 44, 39, 19, 97, 205, 228, 8, 106, 67, 210, 135, 111, 127, 141, 185, 175, 123, 26, 226, 42, 29, 217, 16, 99, 9, 46, 157, 232, 22, 3, 105, 174, 73, 144, 23, 110, 55, 84, 46, 4, 116, 39, 113, 205, 58, 158, 242, 7, 208, 75, 162, 55, 115, 35, 52, 124, 235, 114, 178, 55, 43, 98, 17, 100, 33, 134, 237, 190, 230, 60, 184, 192, 104, 146, 52, 58, 79, 174, 180, 81, 155, 114, 0, 153, 113, 90, 51, 86, 150, 254, 136, 205, 104, 39, 11, 190, 187, 233, 80, 81, 81, 56, 18, 222, 148, 116, 155, 156, 33, 132, 226, 127, 84, 34, 83, 28, 249, 153, 18, 197, 10, 116, 102, 125, 45, 47, 36, 235, 46, 212, 166, 209, 3, 125, 132, 237, 124, 163, 68, 197, 202, 232, 152, 234, 75, 235, 103, 248, 160, 241, 213, 151, 144, 130, 37, 23, 51, 48, 55, 12, 227, 31, 163, 242, 251, 245, 22, 129, 77, 20, 35, 150, 20, 181, 203, 138, 69, 233, 215, 109, 178, 209, 52, 85, 96, 221, 179, 56, 249, 138, 111, 250, 141, 134, 95, 152, 92, 109, 183, 174, 104, 151, 156, 31, 66, 211, 10, 57, 141, 167, 18, 177, 27, 126, 74, 252, 29, 143, 121, 173, 203, 8, 27, 44, 123, 148, 57, 88, 163, 68, 228, 158, 62, 98, 121, 192, 228, 94, 92, 72, 241, 33, 230, 173, 0, 197, 1, 194, 144, 111, 91, 60, 0, 106, 181, 203, 51, 133, 120, 250, 158, 184, 93, 216, 184, 126, 253, 21, 22, 155, 99, 80, 205, 227, 69, 231, 141, 165, 71, 70, 252, 223, 105, 51, 93, 22, 165, 135, 233, 177, 164, 139, 53, 5, 85, 151, 134, 214, 165, 249, 100, 24, 186, 207, 245, 149, 68, 218, 204, 252, 32, 190, 90, 48, 76, 57, 31, 201, 15, 52, 130, 135, 152, 206, 63, 198, 100, 126, 36, 2, 104, 116, 0, 160, 163, 186, 2, 91, 165, 57, 149, 163, 12, 239, 121, 152, 209, 224, 136, 248, 135, 136, 46, 150, 32, 51, 154, 6, 105, 0, 71, 30, 44, 175, 147, 139, 34, 91, 184, 78, 31, 145, 18, 3, 250, 122, 166, 47, 252, 109, 19, 40, 10, 123, 163, 99, 76, 133, 119, 37, 180, 38, 207, 79, 171, 185, 188];

            class bC extends gC {
                constructor(e, t, r) {
                    super(e, SC, t, r)
                }
            }

            const TC = [11, 196, 242, 139, 198, 252, 188, 5, 32, 162, 171, 128, 13, 160, 25, 222, 172, 102, 207, 244, 158, 69, 103, 57, 239, 111, 150, 18, 157, 82, 55, 210, 20, 131, 156, 160, 96, 121, 255, 120, 207, 227, 114, 120, 38, 72, 149, 145, 165, 227, 75, 122, 158, 250, 232, 46, 34, 52, 135, 9, 30, 144, 17, 110, 126, 110, 130, 71, 156, 46, 210, 67, 202, 51, 119, 97, 3, 211, 214, 227, 45, 109, 151, 97, 21, 10, 229, 53, 80, 26, 51, 202, 119, 128, 230, 197, 140, 135, 40, 14, 88, 128, 202, 95, 21, 208, 96, 83, 185, 98, 216, 242, 224, 15, 25, 224, 233, 86, 96, 46, 80, 120, 220, 48, 187, 86, 30, 240, 140, 46, 95, 81, 48, 90, 117, 140, 177, 51, 107, 235, 158, 137, 5, 241, 191, 154, 149, 219, 30, 126, 85, 175, 10, 216, 63, 139, 216, 151, 122, 251, 224, 202, 220, 227, 221, 53, 122, 34, 213, 224, 94, 45, 14, 200, 68, 31, 61, 175, 208, 17, 120, 82, 244, 138, 208, 165, 21, 19, 236, 232, 180, 217, 50, 74, 70, 126, 114, 227, 62, 192, 124, 9, 85, 148, 33, 77, 255, 117, 75, 102, 87, 151, 255, 87, 74, 74, 181, 111, 108, 9, 249, 220, 174, 59, 80, 254, 168, 29, 30, 94, 171, 133, 133, 195, 105, 64, 254, 68, 65, 18, 158, 54, 73, 203, 65, 175, 151, 170, 236, 138, 17, 119, 128, 237, 214, 189, 28, 250, 38, 149, 97, 242, 81, 212, 254, 57, 18, 120, 155, 64, 96, 108, 75, 78, 74, 121, 191, 243, 30, 42, 60, 103, 165, 196, 160, 195, 216, 99, 182, 173, 214, 182, 105, 53, 231, 3, 45, 212, 144, 101, 217, 65, 141, 44, 230, 125, 151, 154, 123, 57, 134, 223, 98, 133, 156, 238, 137, 181, 80, 175, 230, 167, 131, 180, 13, 69, 77, 44, 156, 165, 252, 14, 27, 85, 71, 1, 82, 196, 64, 243, 26, 167, 146, 98, 201, 6, 195, 247, 200, 224, 44, 177, 104, 109, 187, 231, 83, 118, 28, 159, 92, 179, 28, 14, 162, 81, 84, 21, 168, 34, 156, 21, 127, 215, 88, 218, 208, 11, 92, 161, 239, 239, 82, 221, 59, 86, 83, 201, 199, 216, 151, 139, 23, 54, 39, 52, 103, 204, 247, 24, 102, 94, 157, 138, 42, 49, 131, 183, 208, 50, 95, 236, 54, 6, 211, 26, 68, 72, 56, 212, 134, 24, 91, 114, 132, 1, 217, 80, 38, 47, 29, 47, 0, 107, 102, 99, 129, 33, 140, 243, 74, 251, 89, 247, 103, 12, 114, 58, 113, 240, 72, 188, 39, 48, 72, 89, 45, 102, 206, 245, 247, 231, 56, 167, 129, 122, 222, 47, 40, 78, 227, 159, 64, 206, 34, 127, 203, 127, 87, 40, 108, 152, 238, 147, 231, 46, 104, 89, 182, 180, 232, 86, 89, 91, 57, 10, 222, 202, 59, 199, 135, 60, 199, 189, 40, 84, 125, 28, 84, 162, 210, 91, 143, 34, 106, 117, 118, 3, 125, 126, 237, 60, 131, 173, 153, 69, 49, 212, 204, 117, 163, 31, 239, 202, 232, 152, 234, 3, 162, 32, 176, 184, 184, 196, 154, 131, 144, 115, 6, 53, 122, 55, 69, 166, 19, 230, 183, 175, 244, 1, 156, 11, 37, 121, 134, 121, 152, 142, 158, 125, 229, 150, 44, 183, 216, 109, 7, 65, 222, 169, 56, 222, 140, 110, 233, 157, 138, 66, 208, 6, 111, 166, 188, 76, 208, 222, 4, 104, 211, 10, 57, 141, 243, 65, 228, 86, 85, 88, 169, 91, 237, 56, 249, 133, 77, 21, 32, 37, 230, 55, 0, 184, 110, 228, 158, 62, 98, 45, 147, 177, 19, 119, 89, 164, 103, 132, 239, 84, 139, 68, 204, 157, 49, 41, 50, 89, 113, 159, 203, 51, 133, 120, 184, 210, 237, 15, 249, 187, 100, 253, 50, 16, 154, 112, 64, 193, 254, 10, 235, 200, 253, 84, 31, 169, 171, 39, 122, 70, 46, 186, 139, 212, 162, 173, 158, 41, 23, 86, 148, 172, 196, 237, 242, 58, 102, 180, 150, 238, 191, 25, 240, 204, 252, 125, 148, 29, 124, 51, 95, 10, 196, 55, 49, 159, 138, 144, 255, 126, 205, 43, 49, 42, 17, 59, 60, 77, 139, 177, 239, 64, 36, 224, 98, 205, 234, 70, 199, 103, 139, 218, 206, 207, 178, 217, 255, 32, 134, 59, 25, 221, 74, 22, 102, 82, 19, 20, 170, 142, 134, 42, 106, 249, 64, 80, 222, 28, 21, 169, 50, 235, 4, 237, 56, 81, 87, 76, 32, 251, 42, 6, 173, 105, 54, 191, 8, 136, 5, 245, 206, 239, 176, 9, 116, 24];

            class RC extends gC {
                constructor(e, t, r) {
                    super(e, TC, t, r)
                }
            }

            const IC = [11, 196, 242, 139, 198, 252, 188, 5, 32, 162, 171, 128, 13, 160, 25, 222, 172, 102, 207, 244, 158, 69, 103, 57, 239, 111, 150, 18, 157, 82, 55, 210, 20, 131, 156, 190, 100, 112, 230, 97, 199, 225, 96, 74, 99, 94, 248, 222, 162, 213, 95, 122, 158, 212, 233, 42, 22, 37, 217, 115, 36, 152, 30, 123, 116, 104, 212, 109, 129, 41, 220, 77, 213, 97, 124, 45, 4, 219, 197, 171, 40, 18, 149, 104, 20, 4, 248, 102, 64, 9, 50, 217, 124, 131, 180, 188, 159, 170, 63, 1, 84, 130, 150, 117, 14, 212, 118, 67, 165, 97, 207, 242, 251, 15, 30, 187, 188, 77, 79, 122, 67, 101, 252, 109, 244, 82, 37, 191, 227, 35, 114, 87, 57, 71, 99, 218, 155, 54, 101, 239, 138, 197, 13, 226, 228, 176, 157, 158, 87, 98, 55, 251, 79, 150, 64, 138, 200, 135, 40, 132, 135, 207, 146, 252, 222, 57, 58, 111, 151, 225, 78, 59, 36, 210, 70, 29, 121, 160, 210, 31, 109, 67, 167, 194, 177, 236, 91, 108, 164, 229, 130, 211, 59, 66, 93, 18, 107, 226, 54, 210, 51, 8, 77, 217, 19, 73, 187, 33, 30, 59, 9, 135, 162, 49, 5, 11, 225, 111, 119, 11, 247, 218, 129, 115, 83, 205, 170, 21, 4, 69, 210, 133, 134, 245, 109, 15, 177, 9, 81, 81, 203, 105, 42, 158, 12, 255, 151, 165, 230, 205, 5, 92, 196, 251, 211, 187, 27, 214, 43, 186, 91, 233, 85, 192, 229, 15, 71, 38, 220, 20, 38, 101, 44, 78, 7, 60, 251, 186, 75, 103, 108, 53, 166, 220, 186, 208, 194, 120, 207, 230, 159, 248, 22, 32, 142, 124, 96, 157, 222, 60, 191, 65, 145, 6, 239, 125, 151, 147, 50, 58, 130, 207, 110, 131, 223, 231, 137, 238, 28, 182, 216, 167, 198, 191, 37, 67, 76, 1, 144, 232, 218, 79, 72, 28, 65, 101, 43, 216, 64, 253, 16, 173, 179, 123, 140, 27, 233, 245, 199, 230, 36, 181, 102, 114, 247, 162, 18, 34, 20, 212, 25, 171, 24, 28, 143, 80, 94, 40, 167, 34, 209, 61, 117, 130, 1, 198, 196, 7, 21, 252, 180, 255, 92, 128, 119, 9, 48, 156, 138, 136, 151, 143, 23, 44, 52, 3, 40, 197, 228, 31, 123, 67, 163, 140, 32, 54, 204, 187, 149, 80, 19, 255, 82, 120, 195, 12, 110, 65, 56, 212, 143, 22, 78, 44, 234, 72, 140, 29, 118, 103, 18, 36, 7, 122, 50, 37, 139, 47, 142, 243, 25, 208, 88, 237, 126, 50, 103, 127, 19, 183, 29, 169, 29, 1, 55, 23, 100, 32, 129, 239, 243, 160, 61, 178, 197, 117, 199, 45, 57, 26, 165, 135, 92, 218, 59, 0, 197, 54, 13, 96, 40, 141, 212, 221, 131, 103, 46, 22, 228, 191, 167, 73, 20, 86, 62, 11, 147, 217, 116, 205, 203, 110, 134, 249, 51, 6, 123, 23, 86, 231, 157, 8, 144, 83, 126, 115, 118, 35, 96, 36, 229, 36, 220, 228, 143, 71, 45, 223, 129, 48, 236, 5, 145, 202, 188, 208, 184, 70, 241, 104, 255, 188, 181, 146, 210, 206, 144, 53, 77, 101, 120, 38, 8, 245, 80, 230, 165, 160, 183, 83, 202, 79, 127, 57, 214, 126, 242, 150, 208, 40, 239, 148, 35, 163, 201, 97, 74, 70, 214, 181, 63, 240, 147, 33, 253, 149, 140, 77, 197, 82, 126, 189, 231, 7, 196, 212, 80, 14, 151, 24, 57, 144, 243, 81, 234, 66, 24, 19, 236, 2, 137, 121, 246, 129, 65, 7, 99, 110, 174, 54, 74, 182, 81, 234, 142, 37, 72, 110, 220, 255, 64, 119, 10, 188, 111, 191, 228, 1, 205, 9, 204, 143, 56, 62, 125, 84, 106, 225, 131, 97, 192, 43, 240, 157, 161, 75, 168, 247, 44, 175, 65, 81, 192, 48, 21, 157, 167, 80, 191, 130, 161, 75, 85, 186, 174, 42, 117, 1, 68, 252, 204, 138, 254, 203, 152, 21, 13, 64, 144, 195, 207, 238, 229, 54, 103, 247, 159, 245, 211, 85, 191, 141, 168, 32, 234, 85, 46, 118, 12, 5, 199, 4, 19, 217, 203, 202, 156, 33, 143, 114, 116, 60, 66, 40, 58, 77, 208, 237, 171, 26, 72, 175, 114, 205, 248, 87, 137, 62, 210, 143, 151, 197, 167, 210, 241, 122, 150, 104, 122, 154, 2, 70, 102, 83, 19, 36, 141, 136, 199, 42, 79, 229, 71, 86, 194, 109, 31, 236, 80, 166, 17, 230, 109, 1, 40, 28, 46, 224, 56, 20, 230, 47, 100, 254, 116, 208, 76, 169, 157, 241, 175, 3, 70, 85, 31, 38, 245, 58, 33, 80, 145, 237, 8, 22, 71, 224, 158, 156, 31, 249, 81, 87, 247, 230, 199, 237, 96, 167, 123, 63, 243, 79, 156, 206, 203, 160, 54, 124, 68, 253, 215, 132, 235, 57, 185, 92, 238, 55, 59, 210, 104, 71, 26, 183, 180, 71, 12, 255, 224, 192, 65, 154, 72, 244, 8, 164, 10, 248, 46, 207, 30, 92, 1, 80, 244, 31, 189, 138, 88, 216, 218, 63, 100, 227, 116, 57, 119, 94, 135, 5, 126, 255, 32, 191, 163, 61, 209, 194, 88, 248, 112, 139, 173, 43, 69, 134, 3, 160, 151, 137, 25, 98, 239, 166, 19, 123, 208, 180, 31, 120, 30, 191, 75, 183, 179, 126, 180, 125, 92, 107, 105, 206, 138, 28, 67, 139, 3, 188, 230, 184, 255, 121, 13, 181, 45, 160, 114, 202, 194, 123, 87, 55, 124, 97, 164, 82, 95, 232, 216, 117, 62, 5, 90, 176, 82, 167, 52, 160, 153, 174, 168, 105, 146, 91, 248, 81, 79, 249, 97, 138, 133, 170, 245, 229, 132, 61, 5, 149, 224, 246, 194, 213, 61, 12, 109, 44, 136, 235, 95, 219, 133, 220, 27, 93, 36, 93, 124, 180, 81, 141, 152, 220, 170, 163, 229, 197, 124, 171, 232, 48, 70, 251, 106, 119, 150, 20, 16, 49, 119, 247, 42, 132, 36, 76, 254, 124, 177, 66, 175, 9, 1, 39, 92, 127, 195, 171, 198, 34, 2, 64, 144, 179, 72, 40, 151, 110, 89, 229, 42, 125, 33, 238, 16, 220, 228, 51, 203, 8, 1, 68, 145, 253, 133, 118, 93, 163, 129, 22, 13, 248, 65, 12, 4, 63, 101, 210, 70, 170, 138, 203, 14, 246, 54, 194, 195, 27, 107, 241, 175, 35, 171, 49, 52, 106, 121, 45, 36, 152, 85, 215, 132, 78, 167, 34, 18, 167, 245, 152, 133, 134, 170, 120, 182, 10, 146, 191, 37, 2, 205, 47, 125, 20, 203, 44, 88, 81, 32, 150, 223, 220, 218, 238, 254, 30, 212, 167, 221, 115, 156, 82, 226, 137, 220, 221, 97, 3, 139, 202, 33, 9, 27, 26, 126, 40, 215, 25, 126, 9, 82, 208, 49, 217, 14, 161, 81, 196, 61, 60, 87, 254, 213, 194, 81, 216, 161, 151, 209, 166, 222, 230, 24, 128, 117, 140, 92, 4, 203, 254, 170, 253, 249, 88, 90, 112, 226, 18, 44, 122, 39, 158, 158, 56, 69, 204, 159, 5, 179, 51, 197, 233, 139, 216, 102, 226, 206, 248, 15, 78, 112, 214, 126, 67, 28, 40, 38, 98, 190, 178, 206, 67, 94, 245, 254, 160, 101, 176, 32, 157, 26, 132, 83, 252, 228, 87, 242, 32, 127, 160, 112, 210, 224, 133, 149, 115, 41, 30, 16, 200, 69, 89, 81, 77, 144, 12, 106, 182, 73, 54, 28, 53, 195, 28, 216, 179, 179, 136, 35, 141, 102, 234, 177, 240, 34, 186, 106, 145, 245, 3, 84, 48, 251, 157, 245, 11, 217, 111, 227, 138, 42, 67, 114, 211, 177, 37, 103, 16, 71, 152, 72, 117, 123, 36, 213, 202, 56, 124, 227, 84, 8, 45, 229, 149, 165, 214, 69, 244, 169, 55, 68, 62, 94, 104, 228, 74, 205, 123, 222, 17, 7, 172, 158, 227, 74, 206, 149, 67, 175, 171, 251, 185, 121, 151, 223, 63, 35, 229, 32, 49, 190, 209, 120, 137, 69, 213, 214, 19, 150, 187, 177, 28, 12, 158, 153, 126, 149, 171, 167, 234, 120, 129, 109, 32, 157, 180, 75, 66, 56, 233, 115, 127, 230, 157, 32, 34, 143, 156, 31, 230, 168, 174, 125, 118, 195, 249, 243, 165, 81, 246, 10, 144, 15, 103, 139, 55, 173, 7, 59, 136, 69, 172, 54, 132, 165, 140, 78, 77, 230, 33, 169, 129, 188, 71, 209, 109, 161, 8, 57, 57, 199, 143, 31, 164, 43, 58, 130, 1, 110, 145, 31, 229, 13, 46, 149, 94, 244, 106, 76, 238, 105, 107, 1, 183, 177, 10, 61, 225, 94, 185, 116, 58, 183, 95, 225, 22, 119, 19, 248, 28, 13, 123, 125, 108, 158, 64, 184, 77, 245, 153, 162, 217, 227, 208, 41, 185, 211, 235, 41, 153, 181, 54, 166, 165, 11, 154, 55, 21, 184, 209, 192, 249, 44, 164, 160, 29, 229, 159, 82, 156, 198, 241, 183, 114, 83, 137, 186, 151, 148, 31, 21, 197, 216, 145, 32, 13, 50, 22, 241, 137, 39, 71, 28, 142, 160, 215, 107, 221, 45, 202, 104, 227, 110, 186, 12, 150, 145, 240, 51, 49, 44, 196, 115, 224, 238, 149, 189, 134, 99, 67, 241, 62, 157, 240, 114, 247, 195, 26, 200, 141, 97, 147, 249, 23, 150, 174, 10, 13, 219, 81, 73, 58, 242, 96, 250, 243, 15, 49, 218, 58, 230, 104, 252, 175, 150, 123, 86, 185, 84, 90, 198, 6, 36, 0, 99, 72, 28, 166, 238, 115, 231, 171, 249, 179, 71, 174, 68, 156, 227, 17, 198, 79, 73, 142, 99, 144, 20, 80, 62, 80, 191, 142, 46, 71, 9, 243, 6, 8, 214, 116, 72, 190, 106, 161, 19, 185, 100, 9, 187, 64, 94, 86, 203, 174, 156, 245, 222, 95, 54, 30, 148, 19, 11, 50, 112, 96, 61, 237, 159, 173, 7, 154, 127, 175, 79, 48, 97, 89, 78, 126, 66, 171, 204, 158, 195, 27, 226, 205, 222, 157, 89, 251, 90, 125, 37, 212, 27, 97, 3, 141, 247, 175, 50, 121, 7, 187, 68, 196, 181, 202, 167, 189, 57, 84, 81, 222, 23, 27, 84, 130, 176, 98, 66, 240, 207, 18, 23, 28, 163, 163, 194, 45, 37, 129, 202, 170, 97, 189, 0, 81, 238, 0, 39, 199, 163, 35, 211, 206, 247, 65, 29, 116, 242, 67, 102, 235, 13, 136, 232, 230, 114, 146, 187, 7, 254, 142, 26, 121, 16, 237, 5, 160, 201, 114, 94, 178, 199, 95, 212, 241, 45, 112, 180, 188, 72, 86, 114, 189, 155, 149, 149, 163, 210, 112, 101, 12, 69, 225, 75, 202, 223, 28, 242, 90, 215, 156, 169, 224, 245, 135, 128, 92, 148, 217, 131, 208, 255, 25, 135, 117, 136, 5, 104, 185, 249, 161, 228, 214, 16, 105, 204, 9, 182, 135, 153, 220, 101, 244, 160, 207, 58, 182, 118, 185, 240, 57, 245, 123, 13, 112, 182, 106, 229, 220, 90, 29, 86, 215, 96, 147, 232, 2, 55, 131, 225, 137, 68, 245, 89, 141, 252, 97, 3, 129, 155, 216, 223, 98, 116, 45, 78, 85, 141, 161, 74, 215, 7, 150, 171, 225, 59, 78, 221, 152, 236, 14, 117, 100, 208, 158, 86, 13, 185, 124, 87, 157, 111, 40, 187, 182, 124, 173, 71, 173, 23, 199, 52, 155, 190, 134, 11, 23, 64, 25, 215, 39, 115, 231, 173, 77, 72, 114, 54, 252, 116, 178, 59, 221, 106, 241, 119, 254, 30, 226, 241, 204, 233, 113, 197, 96, 146, 0, 41, 67, 3, 231, 126, 12, 218, 202, 22, 171, 114, 249, 176, 134, 160, 19, 216, 31, 229, 118, 226, 62, 242, 126, 126, 42, 127, 130, 68, 218, 218, 81, 202, 106, 217, 191, 25, 177, 82, 97, 81, 36, 232, 137, 58, 90, 216, 190, 117, 235, 20, 194, 144, 76, 178, 27, 213, 13, 208, 18, 29, 118, 126, 49, 98, 203, 179, 128, 237, 100, 32, 242, 189, 212, 6, 210, 210, 188, 161, 205, 13, 124, 119, 13, 215, 112, 41, 183, 176, 215, 168, 210, 182, 111, 1, 115, 2, 239, 141, 8, 177, 124, 112, 48, 197, 2, 239, 11, 99, 4, 36, 77, 69, 47, 244, 19, 153, 61, 19, 2, 96, 176, 7, 112, 122, 131, 169, 25, 189, 116, 171, 49, 12, 121, 162, 79, 154, 74, 251, 50, 233, 182, 63, 180, 224, 118, 49, 253, 21, 20, 16, 31, 144, 184, 93, 174, 231, 244, 183, 13, 49, 225, 189, 211, 73, 185, 49, 110, 142, 25, 226, 45, 176, 233, 204, 74, 33, 16, 205, 88, 131, 92, 157, 170, 175, 68, 170, 61, 53, 116, 165, 16, 27, 182, 160, 181, 87, 241, 15, 151, 85, 107, 76, 167, 129, 25, 172, 127, 184, 138, 153, 222, 228, 125, 64, 44, 45, 32, 12, 227, 148, 106, 152, 83, 240, 166, 54, 235, 32, 190, 12, 242, 164, 123, 189, 53, 194, 141, 104, 43, 202, 110, 4, 168, 119, 245, 232, 179, 178, 198, 1, 224, 87, 86, 160, 31, 19, 140, 233, 102, 191, 204, 4, 98, 138, 163, 191, 106, 24, 213, 47, 208, 82, 137, 132, 131, 16, 253, 84, 25, 144, 90, 159, 148, 16, 196, 84, 166, 61, 160, 101, 229, 227, 93, 118, 59, 87, 66, 16, 128, 59, 96, 131, 250, 20, 184, 150, 205, 91, 227, 201, 62, 35, 79, 180, 172, 173, 85, 197, 106, 153, 238, 229, 60, 204, 65, 193, 230, 94, 101, 177, 134, 6, 165, 53, 171, 142, 208, 155, 2, 11, 4, 202, 127, 54, 17, 142, 117, 227, 121, 128, 204, 192, 147, 147, 92, 189, 5, 224, 148, 72, 18, 83, 101, 126, 124, 228, 153, 242, 123, 229, 247, 92, 221, 6, 73, 227, 250, 87, 167, 194, 129, 187, 73, 38, 185, 109, 217, 240, 193, 88, 50, 178, 180, 151, 54, 197, 187, 137, 190, 166, 233, 1, 103, 204, 88, 31, 127, 185, 29, 65, 1, 29, 254, 223, 14, 83, 167, 215, 114, 248, 30, 173, 89, 173, 187, 69, 5, 105, 117, 15, 106, 94, 173, 63, 227, 25, 230, 190, 136, 168, 177, 175, 107, 91, 126, 254, 34, 188, 25, 118, 48, 12, 226, 130, 153, 162, 57, 47, 181, 212, 79, 160, 97, 64, 157, 246, 90, 53, 43, 149, 76, 102, 15, 195, 107, 58, 242, 84, 172, 29, 81, 198, 113, 81, 251, 138, 182, 154, 111, 30, 171, 129, 56, 17, 45, 214, 153, 112, 117, 203, 174, 40, 38, 234, 236, 32, 4, 112, 225, 26, 187, 195, 246, 252, 9, 218, 69, 160, 223, 178, 54, 148, 81, 8, 134, 151, 75, 248, 63, 224, 240, 48, 75, 250, 221, 85, 46, 100, 50, 3, 70, 64, 102, 111, 160, 155, 233, 59, 147, 184, 57, 61, 6, 126, 79, 176, 16, 185, 94, 166, 33, 135, 78, 42, 75, 140, 208, 140, 44, 153, 187, 64, 103, 119, 160, 236, 16, 239, 74, 218, 219, 212, 207, 110, 53, 30, 76, 248, 40, 111, 98, 44, 20, 113, 204, 233, 109, 135, 96, 107, 39, 163, 203, 125, 45, 157, 152, 71, 239, 175, 174, 159, 147, 80, 111, 93, 38, 253, 228, 154, 225, 181, 101, 12, 241, 127, 65, 49, 189, 5, 85, 151, 237, 213, 143, 14, 104, 138, 54, 52, 27, 4, 132, 67, 35, 156, 86, 157, 73, 16, 229, 222, 245, 110, 79, 165, 179, 56, 179, 53, 218, 229, 100, 58, 87, 149, 48, 231, 64, 63, 115, 67, 3, 172, 6, 186, 115, 154, 60, 53, 214, 152, 149, 89, 234, 37, 143, 82, 255, 64, 28, 183, 93, 112, 39, 70, 185, 57, 0, 199, 9, 61, 175, 219, 41, 76, 37, 176, 82, 125, 65, 53, 160, 214, 105, 62, 153, 244, 222, 96, 205, 6, 178, 85, 41, 240, 113, 0, 96, 149, 38, 3, 195, 18, 152, 41, 246, 3, 103, 29, 110, 134, 30, 101, 75, 46, 103, 199, 184, 20, 230, 8, 55, 120, 4, 229, 168, 35, 43, 7, 28, 161, 143, 87, 27, 87, 79, 255, 186, 44, 195, 158, 155, 181, 119, 81, 172, 217, 107, 95, 98, 55, 243, 186, 66, 105, 48, 224, 123, 232, 84, 156, 20, 10, 156, 208, 204, 52, 34, 228, 136, 97, 242, 200, 246, 211, 67, 202, 40, 241, 91, 92, 253, 9, 54, 72, 131, 221, 106, 178, 32, 44, 182, 4, 225, 193, 37, 20, 249, 249, 231, 10, 206, 18, 71, 254, 221, 187, 172, 88, 204, 6, 127, 138, 102, 7, 208, 75, 147, 219, 199, 177, 79, 36, 170, 101, 207, 177, 109, 95, 143, 217, 41, 199, 80, 183, 201, 2, 254, 12, 55, 23, 198, 14, 255, 69, 245, 138, 155, 129, 227, 167, 168, 130, 156, 135, 14, 96, 93, 48, 99, 143, 107, 126, 92, 117, 143, 112, 108, 193, 228, 84, 13, 41, 186, 27, 172, 92, 201, 149, 116, 19, 112, 197, 116, 209, 128, 102, 1, 55, 152, 177, 28, 37, 34, 50, 83, 41, 199, 74, 178, 59, 111, 67, 118, 35, 252, 36, 33, 87, 28, 170, 17, 215, 47, 90, 154, 124, 137, 15, 14, 211, 59, 75, 59, 30, 77, 0, 49, 37, 225, 191, 87, 101, 127, 214, 227, 160, 99, 174, 234, 82, 148, 235, 16, 241, 219, 147, 170, 127, 221, 250, 116, 39, 218, 156, 72, 227, 172, 55, 0, 79, 188, 76, 51, 222, 232, 24, 36, 62, 94, 154, 3, 61, 230, 146, 114, 253, 0, 128, 58, 253, 90, 72, 211, 242, 38, 39, 133, 153, 161, 119, 105, 195, 152, 225, 208, 105, 140, 80, 217, 186, 196, 157, 21, 116, 230, 116, 139, 25, 159, 143, 118, 128, 77, 201, 238, 247, 228, 15, 168, 4, 133, 148, 21, 148, 12, 44, 241, 7, 115, 17, 129, 176, 202, 46, 130, 122, 129, 235, 141, 223, 85, 21, 199, 65, 181, 169, 52, 174, 161, 153, 62, 25, 164, 115, 213, 89, 138, 199, 103, 79, 200, 165, 135, 249, 244, 27, 209, 178, 240, 129, 211, 61, 9, 111, 157, 147, 119, 36, 119, 255, 110, 130, 84, 49, 210, 225, 247, 100, 26, 121, 127, 163, 160, 26, 79, 99, 24, 77, 65, 32, 178, 109, 36, 27, 253, 173, 110, 183, 11, 14, 211, 57, 130, 254, 124, 104, 165, 219, 31, 70, 97, 14, 194, 39, 61, 26, 141, 125, 228, 126, 194, 184, 101, 160, 204, 106, 128, 144, 106, 103, 171, 18, 246, 129, 220, 85, 172, 151, 123, 5, 73, 155, 192, 175, 91, 157, 239, 61, 237, 116, 170, 65, 233, 56, 19, 49, 114, 168, 190, 3, 214, 53, 250, 90, 213, 244, 88, 101, 30, 229, 248, 124, 15, 71, 141, 27, 172, 235, 21, 129, 211, 72, 61, 172, 112, 170, 128, 135, 96, 196, 221, 255, 27, 176, 105, 188, 183, 121, 33, 37, 149, 53, 131, 226, 233, 29, 167, 234, 218, 109, 53, 185, 152, 36, 248, 53, 61, 235, 78, 21, 201, 214, 210, 163, 12, 251, 187, 45, 188, 137, 126, 127, 237, 92, 234, 91, 240, 225, 38, 194, 57, 213, 251, 237, 171, 30, 99, 52, 14, 49, 84, 101, 252, 237, 7, 166, 122, 114, 32, 107, 32, 207, 239, 136, 168, 178, 12, 11, 241, 233, 230, 146, 132, 18, 83, 233, 41, 172, 17, 6, 161, 42, 113, 87, 40, 255, 185, 1, 146, 128, 5, 240, 126, 131, 71, 42, 54, 124, 205, 2, 122, 71, 30, 222, 229, 40, 134, 142, 102, 97, 239, 151, 177, 1, 230, 231, 49, 123, 219, 28, 129, 91, 152, 112, 13, 154, 81, 197, 226, 255, 112, 158, 178, 177, 55, 181, 108, 138, 185, 245, 29, 186, 21, 73, 188, 209, 154, 200, 89, 116, 235, 198, 144, 36, 87, 248, 22, 7, 200, 122, 7, 148, 44, 42, 87, 140, 238, 204, 95, 231, 252, 0, 136, 0, 22, 39, 70, 123, 125, 165, 113, 227, 172, 146, 163, 128, 158, 36, 52, 91, 19, 36, 245, 27, 150, 138, 141, 11, 67, 239, 224, 65, 24, 116, 101, 7, 39, 46, 142, 172, 164, 243, 148, 0, 33, 226, 59, 47, 203, 137, 156, 241, 66, 250, 157, 30, 204, 101, 143, 134, 98, 238, 155, 226, 25, 184, 136, 219, 89, 100, 193, 11, 143, 71, 139, 243, 230, 151, 0, 249, 1, 78, 26, 32, 93, 104, 157, 67, 97, 164, 248, 86, 124, 146, 93, 74, 222, 228, 167, 55, 53, 100, 135, 216, 109, 13, 64, 37, 106, 177, 200, 200, 182, 92, 251, 69, 31, 243, 89, 80, 198, 14, 132, 203, 72, 103, 28, 104, 217, 24, 97, 223, 113, 11, 29, 178, 191, 210, 46, 162, 255, 68, 99, 8, 237, 213, 162, 152, 193, 183, 121, 203, 19, 108, 182, 29, 86, 26, 192, 103, 220, 103, 205, 154, 179, 197, 9, 22, 73, 127, 175, 146, 38, 119, 210, 0, 24, 180, 21, 245, 215, 204, 91, 186, 119, 138, 183, 239, 15, 155, 231, 248, 133, 39, 24, 101, 144, 236, 10, 230, 54, 174, 227, 73, 21, 110, 10, 160, 241, 232, 131, 14, 212, 127, 232, 59, 122, 65, 146, 54, 163, 9, 189, 190, 121, 88, 170, 62, 194, 14, 204, 152, 245, 38, 131, 37, 91, 81, 72, 114, 29, 115, 239, 182, 56, 44, 156, 159, 177, 180, 82, 160, 93, 97, 86, 183, 236, 50, 95, 85, 39, 71, 181, 225, 152, 143, 63, 123, 117, 34, 44, 109, 160, 166, 229, 240, 91, 138, 102, 54, 180, 173, 44, 50, 80, 42, 124, 7, 50, 124, 211, 239, 21, 94, 197, 185, 239, 213, 107, 142, 64, 95, 124, 125, 17, 180, 97, 189, 101, 52, 48, 19, 112, 12, 70, 9, 212, 177, 54, 118, 66, 84, 147, 236, 248, 26, 124, 95, 103, 135, 254, 124, 49, 112, 186, 99, 120, 90, 8, 194, 191, 88, 57, 242, 65, 61, 10, 104, 246, 197, 252, 19, 159, 58, 194, 75, 173, 242, 103, 8, 115, 84, 69, 238, 149, 26, 15, 159, 182, 141, 132, 119, 70, 29, 53, 20, 143, 46, 163, 204, 6, 236, 59, 45, 185, 172, 89, 119, 83, 38, 144, 36, 222, 96, 151, 26, 99, 195, 163, 170, 133, 92, 159, 214, 53, 150, 116, 90, 176, 69, 145, 130, 15, 172, 140, 217, 215, 101, 163, 115, 161, 65, 101, 8, 7, 183, 113, 213, 134, 58, 175, 130, 251, 143, 173, 248, 168, 135, 60, 159, 30, 194, 68, 208, 119, 120, 2, 40, 178, 227, 247, 161, 77, 47, 136, 46, 244, 163, 72, 65, 158, 25, 225, 195, 61, 132, 182, 204, 177, 186, 200, 81, 2, 65, 105, 212, 72, 94, 203, 232, 217, 182, 123, 251, 228, 160, 1, 161, 204, 123, 20, 37, 1, 77, 208, 179, 45, 149, 181, 122, 102, 190, 123, 213, 164, 231, 41, 216, 130, 234, 248, 208, 251, 252, 220, 84, 209, 67, 47, 61, 220, 5, 142, 162, 26, 236, 121, 142, 248, 132, 255, 65, 122, 203, 196, 102, 191, 187, 2, 195, 127, 255, 193, 92, 49, 91, 186, 154, 39, 156, 29, 211, 172, 49, 104, 245, 114, 153, 223, 211, 199, 249, 35, 130, 160, 128, 0, 152, 176, 183, 20, 236, 113, 193, 108, 26, 255, 11, 237, 102, 133, 245, 94, 115, 114, 10, 89, 229, 214, 221, 99, 149, 30, 99, 37, 246, 10, 26, 26, 39, 92, 123, 170, 73, 211, 127, 227, 54, 30, 86, 133, 159, 112, 225, 91, 148, 100, 174, 149, 75, 143, 14, 140, 20, 44, 64, 212, 5, 243, 8, 116, 63, 30, 97, 42, 123, 20, 73, 212, 85, 207, 83, 122, 27, 251, 233, 84, 10, 17, 236, 232, 83, 200, 127, 119, 143, 163, 204, 220, 167, 59, 231, 20, 106, 186, 222, 191, 8, 40, 234, 21, 25, 180, 13, 116, 250, 152, 224, 174, 75, 3, 205, 38, 173, 215, 236, 151, 185, 121, 254, 244, 154, 239, 17, 53, 106, 164, 61, 49, 116, 216, 118, 94, 150, 35, 181, 26, 238, 66, 49, 211, 221, 132, 146, 166, 115, 39, 136, 36, 205, 230, 179, 31, 197, 51, 148, 165, 109, 38, 70, 37, 148, 52, 44, 209, 250, 98, 58, 246, 225, 103, 198, 101, 26, 25, 196, 207, 8, 166, 21, 88, 252, 175, 253, 10, 88, 107, 157, 19, 225, 61, 12, 246, 221, 37, 239, 186, 167, 137, 142, 135, 222, 128, 174, 62, 95, 216, 38, 141, 157, 45, 232, 97, 217, 173, 203, 234, 116, 129, 69, 206, 189, 94, 221, 12, 54, 139, 186, 247, 184, 16, 200, 121, 244, 104, 8, 7, 35, 111, 47, 188, 10, 140, 92, 73, 143, 206, 203, 72, 122, 184, 20, 102, 197, 130, 64, 150, 63, 96, 239, 8, 132, 111, 217, 84, 91, 198, 32, 43, 100, 138, 241, 15, 160, 42, 190, 253, 193, 184, 164, 124, 29, 210, 96, 67, 224, 221, 182, 29, 218, 129, 149, 29, 128, 174, 98, 88, 88, 125, 56, 40, 255, 120, 5, 0, 87, 174, 42, 150, 90, 112, 201, 183, 169, 19, 57, 195, 191, 12, 58, 244, 235, 132, 25, 145, 72, 146, 214, 8, 125, 100, 135, 12, 5, 102, 97, 248, 174, 24, 159, 90, 33, 43, 187, 6, 61, 212, 241, 225, 190, 219, 252, 197, 123, 129, 164, 108, 123, 55, 230, 4, 153, 166, 105, 234, 15, 85, 216, 23, 56, 32, 3, 41, 110, 68, 146, 172, 133, 202, 98, 41, 7, 47, 152, 35, 255, 168, 106, 241, 226, 222, 77, 244, 52, 185, 65, 252, 227, 32, 66, 38, 11, 172, 60, 28, 28, 103, 84, 1, 1, 205, 182, 190, 28, 189, 102, 253, 43, 1, 191, 148, 116, 10, 227, 18, 81, 93, 80, 239, 157, 232, 215, 180, 163, 165, 161, 109, 177, 71, 150, 244, 144, 208, 160, 110, 22, 174, 60, 206, 43, 103, 121, 55, 103, 114, 115, 173, 238, 13, 10, 227, 251, 41, 176, 216, 158, 229, 216, 55, 234, 128, 128, 20, 167, 106, 181, 86, 163, 130, 215, 110, 149, 191, 10, 227, 215, 8, 214, 154, 178, 181, 15, 19, 0, 247, 250, 97, 74, 43, 157, 55, 94, 174, 41, 41, 9, 199, 97, 20, 91, 32, 18, 10, 43, 98, 240, 247, 203, 20, 250, 117, 160, 44, 229, 202, 187, 64, 54, 124, 15, 184, 169, 129, 27, 160, 240, 26, 61, 255, 60, 166, 60, 144, 209, 84, 55, 187, 186, 168, 13, 124, 125, 29, 17, 100, 249, 227, 62, 205, 78, 179, 163, 168, 139, 168, 21, 38, 83, 239, 151, 74, 43, 66, 2, 92, 72, 71, 94, 216, 134, 238, 20, 45, 158, 213, 164, 73, 57, 80, 47, 198, 184, 130, 223, 227, 71, 132, 133, 235, 177, 85, 174, 142, 124, 172, 200, 54, 229, 40, 126, 60, 76, 92, 216, 153, 56, 241, 174, 66, 141, 90, 226, 3, 30, 68, 234, 71, 187, 163, 112, 146, 255, 22, 143, 170, 204, 3, 127, 179, 81, 139, 160, 37, 77, 246, 128, 220, 196, 158, 153, 73, 177, 65, 199, 119, 29, 197, 144, 130, 248, 206, 155, 253, 108, 213, 124, 7, 223, 221, 162, 146, 134, 242, 65, 99, 162, 107, 120, 247, 214, 207, 96, 150, 169, 131, 208, 218, 221, 28, 24, 112, 208, 23, 1, 130, 142, 232, 56, 104, 45, 33, 158, 95, 255, 123, 31, 74, 76, 120, 178, 155, 213, 6, 195, 164, 8, 8, 69, 241, 197, 127, 83, 169, 21, 167, 19, 94, 143, 252, 33, 159, 248, 241, 170, 153, 147, 1, 149, 199, 201, 131, 170, 79, 236, 212, 209, 143, 107, 98, 24, 123, 56, 33, 193, 85, 247, 64, 225, 135, 210, 78, 145, 57, 16, 145, 71, 170, 20, 133, 87, 235, 4, 166, 239, 100, 82, 235, 81, 50, 223, 9, 193, 52, 49, 86, 129, 190, 196, 82, 165, 107, 63, 115, 161, 98, 33, 20, 193, 29, 42, 151, 205, 252, 124, 72, 245, 48, 181, 67, 7, 13, 21, 127, 59, 226, 188, 144, 129, 112, 244, 192, 121, 213, 80, 42, 196, 1, 13, 107, 108, 78, 0, 40, 121, 225, 148, 237, 234, 209, 216, 238, 9, 147, 226, 254, 96, 89, 212, 72, 193, 106, 75, 135, 74, 227, 67, 255, 92, 191, 81, 188, 124, 226, 149, 152, 142, 15, 159, 195, 238, 114, 55, 255, 166, 157, 230, 59, 148, 170, 166, 151, 65, 213, 104, 253, 253, 112, 150, 82, 147, 137, 27, 214, 100, 247, 65, 81, 92, 47, 86, 217, 7, 45, 120, 81, 130, 31, 236, 243, 76, 78, 3, 45, 105, 172, 220, 71, 48, 220, 94, 196, 249, 163, 193, 133, 50, 236, 205, 20, 55, 2, 63, 14, 127, 69, 113, 212, 204, 12, 58, 79, 89, 86, 29, 61, 199, 201, 64, 149, 6, 144, 182, 150, 129, 31, 18, 167, 120, 248, 82, 107, 25, 143, 128, 27, 161, 28, 25, 153, 183, 217, 238, 78, 186, 106, 92, 27, 202, 219, 165, 96, 0, 216, 234, 169, 73, 101, 39, 182, 113, 217, 240, 170, 116, 172, 221, 250, 233, 48, 49, 242, 83, 227, 92, 181, 184, 72, 230, 180, 21, 15, 108, 135, 25, 38, 153, 25, 124, 227, 26, 149, 73, 236, 39, 211, 244, 149, 58, 183, 132, 26, 223, 219, 174, 144, 117, 233, 219, 165, 205, 157, 159, 222, 184, 52, 47, 241, 201, 123, 65, 24, 44, 55, 215, 177, 168, 250, 179, 115, 190, 227, 123, 158, 163, 179, 224, 69, 196, 66, 207, 254, 243, 101, 221, 193, 140, 250, 4, 28, 222, 52, 96, 138, 160, 33, 218, 64, 118, 214, 234, 201, 152, 148, 91, 178, 111, 107, 144, 142, 6, 182, 102, 72, 188, 34, 213, 181, 26, 223, 58, 255, 103, 81, 17, 47, 169, 11, 245, 224, 123, 148, 215, 237, 186, 107, 75, 152, 90, 202, 166, 22, 149, 197, 5, 246, 238, 78, 76, 229, 106, 199, 94, 127, 195, 0, 45, 82, 6, 159, 103, 96, 138, 231, 71, 46, 107, 59, 216, 39, 43, 12, 221, 27, 214, 56, 155, 145, 66, 187, 169, 250, 235, 78, 211, 179, 239, 183, 198, 163, 93, 5, 196, 24, 174, 143, 225, 106, 139, 89, 98, 13, 127, 207, 184, 194, 30, 1, 165, 198, 169, 8, 197, 118, 86, 163, 221, 138, 23, 209, 61, 116, 79, 99, 233, 43, 130, 60, 244, 85, 229, 243, 172, 123, 148, 200, 120, 192, 127, 211, 52, 11, 159, 41, 95, 212, 230, 188, 169, 156, 137, 29, 212, 12, 148, 168, 148, 133, 243, 44, 241, 139, 127, 24, 246, 220, 227, 125, 209, 97, 60, 52, 162, 192, 146, 49, 161, 92, 138, 112, 189, 128, 59, 126, 125, 46, 207, 60, 79, 231, 174, 152, 209, 68, 223, 205, 2, 38, 14, 91, 116, 159, 255, 28, 27, 178, 248, 164, 104, 158, 79, 69, 214, 234, 157, 12, 75, 163, 83, 253, 245, 202, 61, 213, 176, 6, 197, 230, 29, 208, 166, 253, 194, 254, 235, 29, 141, 241, 70, 249, 15, 62, 0, 148, 163, 135, 52, 122, 40, 96, 87, 31, 179, 152, 51, 216, 133, 184, 122, 198, 203, 60, 115, 218, 191, 193, 16, 178, 25, 148, 252, 112, 104, 103, 252, 36, 92, 221, 28, 179, 43, 199, 198, 151, 128, 100, 252, 217, 161, 249, 34, 201, 172, 118, 52, 180, 252, 104, 7, 223, 44, 116, 102, 212, 21, 40, 224, 184, 55, 163, 210, 21, 207, 161, 239, 51, 54, 155, 41, 133, 18, 67, 48, 3, 165, 130, 251, 4, 79, 214, 57, 72, 130, 157, 212, 144],
                wC = [0, 1, 3, 4, 6, 7, 9, 10, 12, 13, 15, 16, 18, 19, 21, 22, 24, 26, 29, 31, 34, 36, 39, 41, 44, 46, 49, 51, 54, 56, 59, 61, 64, 65, 66, 67, 68, 69, 70, 72, 73, 74, 75, 76, 77, 79, 80, 81, 82, 83, 84, 85, 87, 88, 89, 90, 91, 92, 94, 95, 96, 97, 98, 99, 101, 102, 103, 104, 105, 106, 107, 109, 110, 111, 112, 113, 114, 116, 117, 118, 119, 120, 121, 123, 124, 125, 126, 127, 128, 129, 131, 132, 133, 134, 135, 136, 138, 139, 140, 141, 142, 143, 145, 146, 147, 148, 149, 150, 151, 153, 154, 155, 156, 157, 158, 160, 161, 162, 163, 164, 165, 166, 168, 169, 170, 171, 172, 173, 175, 176, 177, 178, 179, 180, 182, 183, 184, 185, 186, 187, 188, 190, 191, 192, 193, 194, 195, 197, 198, 199, 200, 201, 202, 204, 205, 206, 207, 208, 209, 210, 212, 213, 214, 215, 216, 217, 219, 220, 221, 222, 223, 224, 226, 226, 226, 227, 227, 227, 228, 228, 228, 229, 229, 229, 230, 230, 231, 231, 231, 232, 232, 232, 233, 233, 233, 234, 234, 235, 235, 235, 236, 236, 236, 237, 237, 237, 238, 238, 239, 239, 239, 240, 240, 240, 241, 241, 241, 242, 242, 243, 243, 243, 244, 244, 244, 245, 245, 245, 246, 246, 246, 247, 247, 247, 248, 248, 248, 249, 249, 249, 250, 250, 250, 251, 251, 251, 252, 252, 252, 253, 253, 253, 254, 254, 254, 255],
                CC = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 32, 33, 35, 36, 37, 39, 40, 42, 43, 44, 46, 47, 49, 50, 51, 53, 54, 56, 57, 58, 59, 61, 62, 63, 64, 66, 67, 68, 69, 71, 72, 73, 74, 76, 77, 78, 79, 81, 82, 83, 84, 86, 87, 88, 90, 91, 92, 93, 95, 96, 97, 98, 100, 101, 102, 103, 105, 106, 107, 108, 110, 111, 112, 113, 115, 116, 117, 118, 120, 121, 122, 124, 125, 126, 127, 129, 130, 131, 132, 134, 135, 136, 137, 139, 140, 141, 142, 144, 145, 146, 147, 149, 150, 151, 152, 154, 155, 156, 158, 159, 160, 161, 163, 164, 165, 166, 168, 169, 170, 171, 173, 174, 175, 176, 178, 179, 180, 181, 183, 184, 185, 186, 188, 189, 190, 192, 193, 194, 195, 197, 198, 199, 200, 202, 203, 204, 205, 207, 208, 209, 210, 212, 213, 214, 215, 217, 218, 219, 220, 222, 223, 224, 226, 226, 226, 227, 227, 228, 228, 229, 229, 230, 230, 231, 231, 232, 232, 233, 233, 234, 234, 234, 235, 235, 236, 236, 237, 237, 238, 238, 239, 239, 240, 240, 241, 241, 242, 242, 243, 243, 243, 244, 244, 244, 245, 245, 245, 246, 246, 246, 247, 247, 247, 248, 248, 248, 249, 249, 249, 250, 250, 250, 251, 251, 251, 252, 252, 252, 253, 253, 253, 254, 254, 254, 255],
                AC = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 35, 36, 37, 38, 39, 40, 41, 43, 44, 45, 46, 47, 48, 50, 51, 52, 53, 54, 55, 56, 58, 59, 60, 61, 62, 63, 65, 66, 67, 68, 69, 70, 72, 73, 74, 76, 77, 78, 80, 81, 83, 84, 85, 87, 88, 89, 91, 92, 94, 95, 96, 98, 99, 100, 102, 103, 105, 106, 107, 109, 110, 111, 113, 114, 116, 117, 118, 120, 121, 122, 124, 125, 127, 128, 129, 131, 132, 133, 135, 136, 138, 139, 140, 142, 143, 144, 146, 147, 149, 150, 151, 153, 154, 155, 157, 158, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 192, 193, 193, 194, 195, 195, 196, 197, 197, 198, 199, 199, 200, 201, 201, 202, 203, 203, 204, 205, 205, 206, 207, 207, 208, 209, 209, 210, 211, 211, 212, 213, 213, 214, 215, 215, 216, 217, 217, 218, 219, 219, 220, 221, 221, 222, 223, 223, 224, 225, 225, 226, 227, 227, 228, 229, 229, 230, 231, 231, 232, 233, 233, 234, 235, 235, 236, 237, 237, 238, 239, 239, 240, 241, 241, 242, 243, 243, 244, 245, 245, 246, 247, 247, 248, 249, 249, 250, 251, 251, 252, 253, 253, 254, 255];

            class OC extends gC {
                constructor(e, t, r, n) {
                    super(e, IC, r, n), Kh(this, "inputTexture", void 0), Kh(this, "lightLevel", .1), Kh(this, "rednessLevel", .5), Kh(this, "mskin_he_max", 175 / 180 * 3.141593), Kh(this, "mskin_he_min", 115 / 180 * 3.141593), Kh(this, "mskin_hc_max", 173 / 180 * 3.141593), Kh(this, "mskin_hc_min", 116 / 180 * 3.141593), Kh(this, "mskin_hc_axis", 2.04203545), Kh(this, "mfacts_rotate_c", 0), Kh(this, "mfacts_rotate_le", 0), Kh(this, "mfacts_rotate_ge", 0), Kh(this, "tab_addr", null), Kh(this, "lutTextures", []), this.inputTexture = t, this.init()
                }

                setUniforms() {
                    const e = this.gl.getUniformLocation(this.program, "u_flipY"),
                        t = this.gl.getUniformLocation(this.program, "u_denoiseLevel");
                    this.gl.uniform1f(t, this.denoiseLevel), this.gl.uniform1f(e, 1);
                    const r = this.gl.getUniformLocation(this.program, "light");
                    this.gl.uniform1f(r, this.lightLevel);
                    const n = this.gl.getUniformLocation(this.program, "redness");
                    this.gl.uniform1f(n, this.rednessLevel);
                    const i = this.gl.getUniformLocation(this.program, "skin_he_max"),
                        o = this.gl.getUniformLocation(this.program, "skin_he_min"),
                        s = this.gl.getUniformLocation(this.program, "skin_hc_max"),
                        a = this.gl.getUniformLocation(this.program, "skin_hc_min"),
                        c = this.gl.getUniformLocation(this.program, "skin_hc_axis"),
                        u = this.gl.getUniformLocation(this.program, "facts_rotate_c"),
                        d = this.gl.getUniformLocation(this.program, "facts_rotate_le"),
                        l = this.gl.getUniformLocation(this.program, "facts_rotate_ge");
                    this.gl.uniform1f(i, this.mskin_he_max), this.gl.uniform1f(o, this.mskin_he_min), this.gl.uniform1f(s, this.mskin_hc_max), this.gl.uniform1f(a, this.mskin_hc_min), this.gl.uniform1f(c, this.mskin_hc_axis), this.gl.uniform1f(u, this.mfacts_rotate_c), this.gl.uniform1f(d, this.mfacts_rotate_le), this.gl.uniform1f(l, this.mfacts_rotate_ge);
                    const h = this.gl.getUniformLocation(this.program, "u_originImage");
                    this.gl.activeTexture(this.gl.TEXTURE2), this.gl.bindTexture(this.gl.TEXTURE_2D, this.inputTexture), this.gl.uniform1i(h, 2);
                    const p = ["lighten_lut"], f = [this.gl.TEXTURE3];
                    for (let e = 0; e < p.length; e++) {
                        const t = this.gl.getUniformLocation(this.program, p[e]);
                        this.gl.activeTexture(f[e]), this.gl.bindTexture(this.gl.TEXTURE_2D, this.lutTextures[e]), this.gl.uniform1i(t, e + 3)
                    }
                }

                setParameters(e) {
                    void 0 !== e.denoiseLevel && (this.denoiseLevel = e.denoiseLevel), void 0 !== e.lightLevel && (this.lightLevel = e.lightLevel), void 0 !== e.rednessLevel && (this.rednessLevel = e.rednessLevel, this.updateRedness(this.rednessLevel)), e.lighteningContrastLevel && this.updateLut(e.lighteningContrastLevel)
                }

                init() {
                    this.tab_addr = new Uint8Array(CC);
                    const e = [this.tab_addr], t = [256], r = [1];
                    for (let n = 0; n < e.length; n++) {
                        const i = this.gl.createTexture();
                        if (!i) throw new Hf(qf.WEBGL_INTERNAL_ERROR, "create lut texture failed");
                        this.gl.bindTexture(this.gl.TEXTURE_2D, i), this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.LUMINANCE, t[n], r[n], 0, this.gl.LUMINANCE, this.gl.UNSIGNED_BYTE, e[n]), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR), this.lutTextures.push(i)
                    }
                }

                updateRedness(e) {
                    const t = 3.141593;
                    let r, n, i = e, o = i;
                    i > 1 && (i = 1), i < 0 && (i = 0), o > 1 && (o = 1), o < 0 && (o = 0), this.mfacts_rotate_c = .8 * i, o < .8 && (o = 0), this.mskin_he_max = 175 / 180 * t, this.mskin_hc_max = 173 / 180 * t, this.mskin_he_min = (115 - 4 * o) / 180 * t, this.mskin_hc_min = (116 - 4 * o) / 180 * t, this.mskin_hc_axis = (117 - 4 * o) / 180 * t, this.mskin_hc_axis < this.mskin_hc_min && (this.mskin_hc_axis = this.mskin_hc_min), this.mskin_hc_min < t / 2 && (this.mskin_hc_min = t / 2), this.mskin_hc_axis < t / 2 && (this.mskin_hc_axis = t / 2), this.mskin_he_min < t / 2 && (this.mskin_he_min = t / 2), this.mskin_hc_max > t && (this.mskin_hc_max = t), this.mskin_hc_axis > t && (this.mskin_hc_axis = t), this.mskin_he_max > t && (this.mskin_he_max = t), r = this.mskin_he_max - this.mskin_hc_max, n = this.mskin_hc_max - this.mskin_hc_axis, this.mfacts_rotate_ge = r > .01 ? this.mfacts_rotate_c * n / r : this.mfacts_rotate_c, r = this.mskin_hc_min - this.mskin_he_min, n = this.mskin_hc_axis - this.mskin_hc_min, this.mfacts_rotate_le = r > .01 ? this.mfacts_rotate_c * n / r : this.mfacts_rotate_c
                }

                updateLut(e) {
                    let t = null;
                    if (0 === e && (t = CC), 1 === e && (t = AC), 2 === e && (t = wC), !t) throw new Hf(qf.WEBGL_INTERNAL_ERROR, "invalid ylut_table value:" + e);
                    this.tab_addr = new Uint8Array(t);
                    const r = [this.tab_addr], n = [256], i = [1];
                    for (let e = 0; e < r.length; e++) this.gl.bindTexture(this.gl.TEXTURE_2D, this.lutTextures[e]), this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.LUMINANCE, n[e], i[e], 0, this.gl.LUMINANCE, this.gl.UNSIGNED_BYTE, r[e])
                }
            }

            class NC {
                constructor() {
                    Kh(this, "gl", null), Kh(this, "canvas", null), Kh(this, "programs", []), Kh(this, "commonProgram", null), Kh(this, "inputTexture", null), Kh(this, "outputTextures", []), Kh(this, "fbos", []), Kh(this, "originalFrameWidth", 0), Kh(this, "originalFrameHeight", 0), Kh(this, "enableBeauty", !1), Kh(this, "denoiseLevel", 5), Kh(this, "lightLevel", .35), Kh(this, "rednessLevel", .5), Kh(this, "lighteningContrastLevel", 1)
                }

                setEnableBeauty(e) {
                    this.enableBeauty = !!e
                }

                init(e, t, r) {
                    if (!og().supportWebGL) throw new Hf(qf.NOT_SUPPORTED, "your browser is not support webGL");
                    if (this.gl = r.getContext("webgl"), !this.gl) throw new Hf(qf.WEBGL_INTERNAL_ERROR, "can not get webgl context");
                    if (this.initGL(e, t), !this.inputTexture) throw new Hf(qf.WEBGL_INTERNAL_ERROR, "can not find input texture");
                    this.canvas = r, this.programs.push(new vC(this.gl)), this.programs.push(new yC(this.gl, e, t)), this.programs.push(new bC(this.gl, e, t)), this.programs.push(new RC(this.gl, e, t)), this.programs.push(new OC(this.gl, this.inputTexture, e, t)), this.commonProgram = this.programs[0].program, this.setDenoiseLevel(this.denoiseLevel), this.setLightLevel(this.lightLevel), this.setRednessLevel(this.rednessLevel), this.setContrastLevel(this.lighteningContrastLevel)
                }

                render(e) {
                    if (!this.gl || !this.commonProgram || !this.canvas) return void em.warning("video effect manager is not init!");
                    let t = 0;
                    if (this.originalFrameHeight === e.videoWidth && this.originalFrameWidth === e.videoHeight) t = 2; else if (this.originalFrameHeight !== e.videoHeight || this.originalFrameWidth !== e.videoWidth) {
                        if (em.debug("beauty effect: resolution changed ".concat(this.originalFrameWidth, "x").concat(this.originalFrameHeight, " -> ").concat(e.videoWidth, "x").concat(e.videoHeight)), 0 === e.videoHeight || 0 === e.videoWidth) return void em.debug("beauty effect: skip 0 resolution frame");
                        this.canvas.width = e.videoWidth, this.canvas.height = e.videoHeight, e.setAttribute("width", e.videoWidth.toString()), e.setAttribute("height", e.videoHeight.toString()), this.release(), this.init(e.videoWidth, e.videoHeight, this.canvas)
                    }
                    this.gl.viewport(0, 0, e.videoWidth, e.videoHeight), this.gl.bindTexture(this.gl.TEXTURE_2D, this.inputTexture), this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, e);
                    const r = this.enableBeauty ? this.programs.length - 1 : 0;
                    for (let e = 0; e <= r; e++) {
                        const r = this.programs[e].program;
                        this.gl.useProgram(r);
                        const n = this.gl.getUniformLocation(r, "u_image");
                        this.programs[e].setUniforms(), this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.fbos[t + e % 2]), this.gl.clearColor(0, 0, 0, 1), this.gl.clear(this.gl.COLOR_BUFFER_BIT), this.gl.drawArrays(this.gl.TRIANGLES, 0, 6), this.gl.activeTexture(this.gl.TEXTURE0), this.gl.bindTexture(this.gl.TEXTURE_2D, this.outputTextures[t + e % 2]), this.gl.uniform1i(n, 0)
                    }
                    this.gl.useProgram(this.commonProgram);
                    const n = this.gl.getUniformLocation(this.commonProgram, "u_flipY");
                    this.gl.uniform1f(n, -1), this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null), this.gl.clearColor(0, 0, 0, 1), this.gl.clear(this.gl.COLOR_BUFFER_BIT), this.gl.drawArrays(this.gl.TRIANGLES, 0, 6)
                }

                setDenoiseLevel(e) {
                    this.programs.forEach(t => {
                        t instanceof gC && t.setParameters({denoiseLevel: e})
                    }), this.denoiseLevel = e
                }

                setLightLevel(e) {
                    this.programs.forEach(t => {
                        t instanceof gC && t.setParameters({lightLevel: e})
                    }), this.lightLevel = e
                }

                setRednessLevel(e) {
                    this.programs.forEach(t => {
                        t instanceof gC && t.setParameters({rednessLevel: e})
                    }), this.rednessLevel = e
                }

                setContrastLevel(e) {
                    this.programs.forEach(t => {
                        t instanceof gC && t.setParameters({lighteningContrastLevel: e})
                    }), this.lighteningContrastLevel = e
                }

                setSize(e, t) {
                    this.programs.forEach(r => {
                        r instanceof gC && r.setSize(e, t)
                    })
                }

                release() {
                    this.gl = null, this.commonProgram = null, this.inputTexture = null, this.programs = [], this.outputTextures = [], this.fbos = []
                }

                initGL(e, t) {
                    if (!this.gl) throw new Hf(qf.WEBGL_INTERNAL_ERROR, "can not find webgl context");
                    this.inputTexture = this.gl.createTexture(), this.gl.bindTexture(this.gl.TEXTURE_2D, this.inputTexture), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
                    for (let r = 0; r < 4; r++) {
                        const n = this.gl.createTexture();
                        if (!n) throw new Hf(qf.WEBGL_INTERNAL_ERROR, "create texture failed");
                        this.gl.bindTexture(this.gl.TEXTURE_2D, n), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR), r < 2 ? this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, e, t, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, null) : this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, t, e, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, null);
                        const i = this.gl.createFramebuffer();
                        if (!i) throw new Hf(qf.WEBGL_INTERNAL_ERROR, "create frame buffer failed");
                        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, i), this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_2D, n, 0), this.outputTextures.push(n), this.fbos.push(i)
                    }
                    this.gl.viewport(0, 0, e, t), this.originalFrameWidth = e, this.originalFrameHeight = t
                }
            }

            class PC {
                constructor() {
                    Kh(this, "targetFrameRate", 0), Kh(this, "recordedFrameCount", 0), Kh(this, "recordingTime", 2), Kh(this, "recordID", void 0)
                }

                async startRecordBeautyEffectOutput(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 4;
                    if (this.recordID) throw new Hf(qf.UNEXPECTED_ERROR, "another beauty effect recording is in progress");
                    const r = YS(6, "");
                    return this.recordID = r, this.targetFrameRate = e, this.recordedFrameCount = 0, this.recordingTime = t, await zS(1e3 * this.recordingTime), this.recordID !== r ? (this.recordID = void 0, !0) : (this.recordID = void 0, this.recordedFrameCount < this.targetFrameRate * this.recordingTime / 2 ? (em.warning("detect beauty effect overload, current framerate", this.recordedFrameCount / 2), !1) : (em.debug("beauty effect current framerate", this.recordedFrameCount / 2), !0))
                }

                stopRecordBeautyEffectOutput() {
                    this.targetFrameRate = 0, this.recordedFrameCount = 0, this.recordID = void 0
                }

                addFrame() {
                    this.recordID && (this.recordedFrameCount += 1)
                }
            }

            function DC(e) {
                const t = {};
                if (e.facingMode && (t.facingMode = e.facingMode), e.cameraId && (t.deviceId = {exact: e.cameraId}), !e.encoderConfig) return t;
                const r = cm(e.encoderConfig);
                return t.width = r.width, t.height = r.height, !xh() && r.frameRate && (t.frameRate = r.frameRate), Sh().name === vh.EDGE && "object" == typeof t.frameRate && (t.frameRate.max = 60), wh() && (t.frameRate = {
                    ideal: 30,
                    max: 30
                }), t
            }

            function kC(e) {
                const t = {};
                if (xh() || (void 0 !== e.AGC && (t.autoGainControl = e.AGC), void 0 !== e.AEC && (t.echoCancellation = e.AEC), void 0 !== e.ANS && (t.noiseSuppression = e.ANS, Rh() && e.ANS && (t.googHighpassFilter = e.ANS))), e.encoderConfig) {
                    const r = hm(e.encoderConfig);
                    t.channelCount = r.stereo ? 2 : 1, t.sampleRate = r.sampleRate, t.sampleSize = r.sampleSize
                }
                return e.microphoneId && (t.deviceId = {exact: e.microphoneId}), Uh() && (t.sampleRate = void 0), t
            }

            var LC, xC;
            !function (e) {
                e.COVERED = "COVERED", e.POSITION = "POSITION", e.SIZE = "SIZE", e.STYLE = "STYLE"
            }(LC || (LC = {})), function (e) {
                e.UNMOUNTED = "UNMOUNTED", e.INVALID_HTML_ELEMENT = "INVALID_HTML_ELEMENT"
            }(xC || (xC = {}));
            var MC, UC, jC, VC, FC, BC, WC, GC, qC, HC, KC, zC, YC, JC, XC, QC, $C, ZC, eA, tA, rA, nA, iA, oA, sA, aA,
                cA, uA, dA, lA, hA, pA = new class {
                    constructor() {
                        Kh(this, "_clientSize", null), Kh(this, "getClientWidth", () => document.documentElement ? document.documentElement.clientWidth : document.body.clientWidth), Kh(this, "getClientHeight", () => document.documentElement ? document.documentElement.clientHeight : document.body.clientHeight), Kh(this, "getStyle", e => window.getComputedStyle(e, null)), Kh(this, "checkCssVisibleProperty", e => {
                            let t = !0;
                            const r = this.getStyle(e), {display: n, visibility: i, opacity: o, filter: s} = r;
                            return ("none" === n || ["hidden", "collapse"].includes(i) || Number(o) < .1) && (t = !1), !!t && (s && s.split(" ").filter(e => {
                                const t = e.split("(")[0];
                                return ["brightness", "blur", "opacity"].includes(t)
                            }).map(e => {
                                const [t, r] = e.split(/\(|\)/);
                                return [t, Number(r.match(/^[0-9\.]+/))]
                            }).forEach(e => {
                                const [r, n] = e;
                                switch (r) {
                                    case"brightness":
                                        (n < .1 || n > 3) && (t = !1);
                                        break;
                                    case"blur":
                                        n > 3 && (t = !1);
                                        break;
                                    case"opacity":
                                        n < .1 && (t = !1)
                                }
                            }), t)
                        }), Kh(this, "checkPropertyUpToAllParentNodes", (e, t) => {
                            let r = !0, n = !0;
                            const i = e => t(e);
                            let o = e;
                            for (; o && n;) i(o) || (r = !1, n = !1), (o = o.parentElement) || (n = !1);
                            return r
                        }), Kh(this, "checkActualCssVisibleIncludeInherit", e => this.checkPropertyUpToAllParentNodes(e, this.checkCssVisibleProperty)), Kh(this, "getSizeAboutClient", e => {
                            const {width: t, height: r, left: n, right: i, top: o, bottom: s} = e.getBoundingClientRect(),
                                a = this.getClientWidth(), c = this.getClientHeight();
                            return {
                                width: t,
                                height: r,
                                left: n,
                                right: i,
                                top: o,
                                bottom: s,
                                clientWidth: a,
                                clientHeight: c,
                                clientMin: Math.min(a, c)
                            }
                        }), Kh(this, "checkActualSize", () => {
                            const {width: e, height: t, clientMin: r} = this._clientSize;
                            return this.checkSizeIsVisible(e, t, r)
                        }), Kh(this, "elementFromPoint", (e, t) => document.elementFromPoint ? document.elementFromPoint(e, t) : null), Kh(this, "checkCoverForAPoint", (e, t, r) => {
                            const n = this.elementFromPoint(e, t);
                            return null !== n && n !== r
                        }), Kh(this, "getPointPositionList", () => {
                            const {width: e, height: t, left: r, top: n} = this._clientSize, i = e / 6, o = t / 6, s = [],
                                a = 1e6;
                            for (let e = 0; e < 5; e++) for (let t = 0; t < 5; t++) {
                                const c = (r * a + (0 === e ? .1 : 4 === e ? (i * e * a - 1e5) / a : i * e) * a) / a,
                                    u = (n * a + (0 === t ? .1 : 4 === t ? (o * t * a - 1e5) / a : o * t) * a) / a;
                                s.push({x: c, y: u})
                            }
                            return [...s]
                        }), Kh(this, "checkElementCover", e => this.getPointPositionList().map(t => this.checkCoverForAPoint(t.x, t.y, e)).filter(e => !!e).length > 6), Kh(this, "checkSizeIsVisible", (e, t, r) => (e > 50 || r / e <= 10) && (t > 50 || r / t <= 10)), Kh(this, "checkSizeOfPartInClient", () => {
                            const {
                                left: e,
                                right: t,
                                top: r,
                                bottom: n,
                                clientHeight: i,
                                clientWidth: o,
                                clientMin: s
                            } = this._clientSize;
                            let a, c, u, d;
                            if (e < 0) a = 0; else {
                                if (!(e < o)) return !1;
                                a = e
                            }
                            if (t < 0) return !1;
                            if (c = t < o ? t : o, r < 0) u = 0; else {
                                if (!(r < i)) return !1;
                                u = r
                            }
                            if (n < 0) return !1;
                            const l = c - a, h = (d = n < i ? n : i) - u;
                            return this.checkSizeIsVisible(l, h, s)
                        }), Kh(this, "returnHiddenResult", e => (this._clientSize = null, {
                            visible: !1,
                            reason: e
                        })), Kh(this, "checkOneElementVisible", e => {
                            if (e instanceof HTMLElement) {
                                if (this.checkElementIsMountedOnDom(e)) {
                                    if (this.checkActualCssVisibleIncludeInherit(e)) {
                                        if (this._clientSize = this.getSizeAboutClient(e), this.checkElementCover(e)) return this.returnHiddenResult(LC.COVERED);
                                        {
                                            const e = this.checkActualSize(), t = this.checkSizeOfPartInClient();
                                            return e && !t ? this.returnHiddenResult(LC.POSITION) : e ? (this._clientSize = null, {visible: !0}) : this.returnHiddenResult(LC.SIZE)
                                        }
                                    }
                                    return this.returnHiddenResult(LC.STYLE)
                                }
                                return this.returnHiddenResult(xC.UNMOUNTED)
                            }
                            return this.returnHiddenResult(xC.INVALID_HTML_ELEMENT)
                        }), Kh(this, "checkElementIsMountedOnDom", e => this.checkPropertyUpToAllParentNodes(e, e => "HTML" !== e.nodeName.toUpperCase() ? null !== e.parentElement : !!document.documentElement))
                    }
                };

            function fA(e, t) {
                var r = Object.keys(e);
                if (Object.getOwnPropertySymbols) {
                    var n = Object.getOwnPropertySymbols(e);
                    t && (n = n.filter(function (t) {
                        return Object.getOwnPropertyDescriptor(e, t).enumerable
                    })), r.push.apply(r, n)
                }
                return r
            }

            function mA(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var r = null != arguments[t] ? arguments[t] : {};
                    t % 2 ? fA(Object(r), !0).forEach(function (t) {
                        Kh(e, t, r[t])
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : fA(Object(r)).forEach(function (t) {
                        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t))
                    })
                }
                return e
            }

            let _A = (MC = BE({argsMap: (e, t, r) => [e.getTrackId(), "string" == typeof t ? t : "HTMLElement", r]}), UC = by(), jC = BE({argsMap: e => [e.getTrackId()]}), VC = zE("LocalVideoTrack", "_enabledMutex"), FC = BE({argsMap: (e, t) => [e.getTrackId(), t]}), BC = by(), WC = zE("LocalVideoTrack", "_enabledMutex"), GC = BE({argsMap: (e, t) => [e.getTrackId(), t]}), qC = by(), HC = by(), KC = BE({argsMap: (e, t, r) => [e.getTrackId(), t, r]}), zC = by(), YC = by(), JC = by(), XC = by(), QC = by(), $C = by(), ZC = by(), eA = BE({argsMap: (e, t) => [e.getTrackId(), t.name]}), tA = BE({argsMap: e => [e.getTrackId()]}), rA = BE({argsMap: e => [e.getTrackId()]}), vE((nA = class e extends YE {
                    get isPlaying() {
                        return !(!this._player || this._player.videoElementStatus !== A_.PLAYING)
                    }

                    get __className__() {
                        return "LocalVideoTrack"
                    }

                    constructor(e, t, r, n, i, o) {
                        super(e, i), Kh(this, "trackMediaType", "video"), Kh(this, "_player", void 0), Kh(this, "_videoBeautyProcessor", void 0), Kh(this, "_videoVisibleTimer", null), Kh(this, "_previousVideoVisibleStatus", void 0), Kh(this, "_clearPreviousVideoVisibleStatus", () => this._previousVideoVisibleStatus = void 0), Kh(this, "_encoderConfig", void 0), Kh(this, "_scalabiltyMode", {
                            numSpatialLayers: 1,
                            numTemporalLayers: 1
                        }), Kh(this, "_optimizationMode", void 0), Kh(this, "_videoHeight", void 0), Kh(this, "_videoWidth", void 0), Kh(this, "_forceBitrateLimit", void 0), Kh(this, "_enabled", !0), Kh(this, "processorDestination", void 0), Kh(this, "processorContext", void 0), this.updateMediaStreamTrackResolution(), this._encoderConfig = t, this._scalabiltyMode = r, this._optimizationMode = n, this._hints = o || [], -1 === this._hints.indexOf(Pv.SCREEN_TRACK) && this.updateBitrateFromProfile(), this.processorContext = new vS(this.getTrackId(), "local"), this.processorDestination = new _S(this.processorContext), this.bindProcessorDestinationEvents()
                    }

                    play(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                        if ("string" == typeof e) {
                            const t = document.getElementById(e);
                            t ? e = t : (em.warning("[".concat(this.getTrackId(), '] can not find "#').concat(e, '" element, use document.body')), e = document.body)
                        }
                        em.debug("[".concat(this.getTrackId(), "] start video playback"), JSON.stringify(t));
                        const r = mA(mA(mA({}, this._getDefaultPlayerConfig()), t), {}, {
                            trackId: this.getTrackId(),
                            element: e
                        });
                        this._player ? this._player.updateConfig(r) : (this._player = new uC(r), this._player.updateVideoTrack(this._mediaStreamTrack)), this._player.play(), this._videoVisibleTimer && window.clearInterval(this._videoVisibleTimer), this._clearPreviousVideoVisibleStatus(), this._videoVisibleTimer = window.setInterval(() => {
                            try {
                                const e = this.getVideoElementVisibleStatus();
                                this.emit(Lv.VIDEO_ELEMENT_VISIBLE_STATUS, e)
                            } catch (e) {
                            }
                        }, fm("CHECK_VIDEO_VISIBLE_INTERVAL"))
                    }

                    stop() {
                        this._player && (this._videoVisibleTimer && (window.clearInterval(this._videoVisibleTimer), this._videoVisibleTimer = null), this._clearPreviousVideoVisibleStatus(), this._player.destroy(), this._player = void 0, em.debug("[".concat(this.getTrackId(), "] stop video playback")))
                    }

                    async setEnabled(e, t) {
                        if (!t) {
                            if (e === this._enabled) return;
                            this.stateCheck("enabled", e)
                        }
                        if (em.info("[".concat(this.getTrackId(), "] start setEnabled"), e), !e) {
                            this._originMediaStreamTrack.enabled = !1;
                            try {
                                await eb(this, Nv.NEED_DISABLE_TRACK, this)
                            } catch (e) {
                                throw em.error("[".concat(this.getTrackId(), "] setEnabled to false error"), e.toString()), e
                            }
                            return t || (this._enabled = !1), void em.info("[".concat(this.getTrackId(), "] setEnabled to false success"))
                        }
                        this._originMediaStreamTrack.enabled = !0;
                        try {
                            await eb(this, Nv.NEED_ENABLE_TRACK, this)
                        } catch (e) {
                            throw em.error("[".concat(this.getTrackId(), "] setEnabled to true error"), e.toString()), e
                        }
                        em.info("[".concat(this.getTrackId(), "] setEnabled to true success")), t || (this._enabled = !0)
                    }

                    async setMuted(e) {
                        e !== this._muted && (this.stateCheck("muted", e), this._muted = e, this._originMediaStreamTrack.enabled = !e, em.debug("[".concat(this.getTrackId(), "] start set muted: ").concat(e)), e ? await eb(this, Nv.NEED_MUTE_TRACK, this) : await eb(this, Nv.NEED_UNMUTE_TRACK, this))
                    }

                    getStats() {
                        cb(() => {
                            em.warning("[deprecated] LocalVideoTrack.getStats will be removed in the future, use AgoraRTCClient.getLocalVideoStats instead")
                        }, "localVideoTrackGetStatsWarning");
                        const e = tb(this, Nv.GET_STATS);
                        return e || mA({}, av)
                    }

                    async setBeautyEffect(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                        if (e || this._videoBeautyProcessor) {
                            if (bh() === _h.IOS || bh() === _h.ANDROID) throw new Hf(qf.INVALID_OPERATION, "can not enable beauty effect on mobile device");
                            if (!this._enabled && e) throw new Hf(qf.TRACK_IS_DISABLED, "can not enable beauty effect when track is disabled");
                            if (em.info("[".concat(this.getTrackId(), "] start setBeautyEffect"), e, JSON.stringify(t)), this._videoBeautyProcessor || e) {
                                try {
                                    if (!this._videoBeautyProcessor) if (this._videoBeautyProcessor = new class extends hC.exports.VideoProcessor {
                                        constructor() {
                                            super(), Kh(this, "name", "BeautyProcessor"), Kh(this, "fps", 15), Kh(this, "canvas", void 0), Kh(this, "video", void 0), Kh(this, "manager", void 0), Kh(this, "overloadDetector", new PC), Kh(this, "stopChromeBackgroundLoop", null), Kh(this, "onOverload", void 0), Kh(this, "stopLoop", void 0), Kh(this, "lastRenderTime", 0), this.fps = 30, this.manager = new NC, this._enabled = !1
                                        }

                                        async onEnableChange(e) {
                                            this.manager.setEnableBeauty(e), this.context && this.inputTrack && (e ? await this.startEffect(this.inputTrack, this.context) : await this.stopEffect(this.inputTrack, this.context))
                                        }

                                        async setBeautyEffectOptions(e) {
                                            if (function (e) {
                                                void 0 !== e.smoothnessLevel && g_(e.smoothnessLevel, "options.smoothnessLevel", 0, 1, !1), void 0 !== e.lighteningLevel && g_(e.lighteningLevel, "options.lighteningLevel", 0, 1, !1), void 0 !== e.rednessLevel && g_(e.rednessLevel, "options.rednessLevel", 0, 1, !1), void 0 !== e.lighteningContrastLevel && v_(e.lighteningContrastLevel, "options.lighteningContrastLevel", [0, 1, 2])
                                            }(e), void 0 !== e.smoothnessLevel) {
                                                const t = Math.max(.1, 10 * e.smoothnessLevel);
                                                this.manager.setDenoiseLevel(t)
                                            }
                                            if (void 0 !== e.lighteningLevel) {
                                                const t = Math.max(.1, e.lighteningLevel / 2);
                                                this.manager.setLightLevel(t)
                                            }
                                            if (void 0 !== e.rednessLevel) {
                                                const t = Math.max(.01, e.rednessLevel);
                                                this.manager.setRednessLevel(t)
                                            }
                                            if (void 0 !== e.lighteningContrastLevel) {
                                                const t = e.lighteningContrastLevel;
                                                this.manager.setContrastLevel(t)
                                            }
                                        }

                                        async onTrack(e, t) {
                                            var r;
                                            this.video && this.enabled && (null === (r = this.stopLoop) || void 0 === r || r.call(this), await this.stopEffect(e, t)), await this.startEffect(e, t)
                                        }

                                        async startEffect(e, t) {
                                            if (!this.enabled) return;
                                            const r = Sh(), n = await this.renderWithWebGL(e);
                                            this.output(n, t), em.info("start video effect, output:", this.outputTrack), this.overloadDetector.startRecordBeautyEffectOutput(this.fps).then(e => {
                                                e || this.onOverload && this.onOverload()
                                            });
                                            let i = !1;
                                            this.stopLoop = (() => {
                                                i = !0
                                            });
                                            const o = () => {
                                                this.enabled && !i && requestAnimationFrame(o);
                                                const e = Date.now(), t = 1e3 / this.fps,
                                                    r = this.lastRenderTime ? e - this.lastRenderTime : t;
                                                r < t || (this.lastRenderTime = e - (r - t), this.video && this.video.paused && this.video.play(), this.enabled && this.video && (this.manager.render(this.video), this.outputTrack && this.outputTrack.requestFrame && this.outputTrack.requestFrame(), this.overloadDetector.addFrame()))
                                            };
                                            requestAnimationFrame(o), r.name === vh.CHROME && document.addEventListener("visibilitychange", () => {
                                                document.hidden ? this.stopChromeBackgroundLoop = ry(() => {
                                                    this.enabled && this.video && this.manager.render(this.video), this.outputTrack && this.outputTrack.requestFrame && this.outputTrack.requestFrame(), this.overloadDetector.addFrame()
                                                }, this.fps) : this.stopChromeBackgroundLoop && (this.stopChromeBackgroundLoop(), this.stopChromeBackgroundLoop = null)
                                            }, !1)
                                        }

                                        async renderWithWebGL(e) {
                                            this.canvas && (this.canvas.remove(), this.canvas = void 0), this.video && (this.video.remove(), this.video = void 0), this.canvas = document.createElement("canvas"), this.video = document.createElement("video"), this.video.setAttribute("autoplay", ""), this.video.setAttribute("muted", ""), this.video.muted = !0, this.video.setAttribute("playsinline", ""), this.video.setAttribute("style", "display:none"), this.video.srcObject = new MediaStream([e]);
                                            const t = new sl(e => {
                                                const t = () => {
                                                    this.video && this.video.removeEventListener("playing", t), e(void 0)
                                                };
                                                this.video && this.video.addEventListener("playing", t)
                                            });
                                            this.video.play(), await t;
                                            const r = e.getSettings(), n = r.width || this.video.videoWidth,
                                                i = r.height || this.video.videoHeight;
                                            if (r.frameRate && this.fps !== r.frameRate && (this.fps = r.frameRate, em.debug("beauty video processor: set fps to", this.fps)), em.debug("beauty video processor: width ".concat(n, " height ").concat(i)), !n || !i) throw new Hf(qf.BEAUTY_PROCESSOR_INTERNAL_ERROR, "can not get track resolution");
                                            this.canvas.width = n, this.canvas.height = i, this.video.setAttribute("width", n.toString()), this.video.setAttribute("height", i.toString()), this.manager.init(n, i, this.canvas);
                                            const o = og();
                                            return this.canvas.captureStream(o.supportRequestFrame ? 0 : this.fps).getVideoTracks()[0]
                                        }

                                        async stopEffect(e, t) {
                                            em.info("stop video effect"), this.overloadDetector.stopRecordBeautyEffectOutput(), this.manager.release(), this.canvas && this.canvas.remove(), this.video && this.video.remove(), this.canvas = void 0, this.video = void 0, this.output(e, t)
                                        }
                                    }, this.processor) {
                                        const e = this.processor;
                                        this.pipe(this._videoBeautyProcessor).pipe(e)
                                    } else this.pipe(this._videoBeautyProcessor).pipe(this.processorDestination);
                                    await this._videoBeautyProcessor.setBeautyEffectOptions(t), e ? await this._videoBeautyProcessor.enable() : await this._videoBeautyProcessor.disable()
                                } catch (e) {
                                    throw em.error("[".concat(this.getTrackId(), "] setBeautyEffect error"), e.toString()), e
                                }
                                em.info("[".concat(this.getTrackId(), "] setBeautyEffect success"))
                            }
                        }
                    }

                    getCurrentFrameData() {
                        return this._player ? this._player.getCurrentFrame() : new ImageData(2, 2)
                    }

                    async getCurrentFrameImage(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
                        return this._player ? this._player.getCurrentFrameToUint8Array(e, t) : await iC(e)
                    }

                    clone(t, r, n, i) {
                        const o = this._mediaStreamTrack.clone();
                        return new e(o, t, r, n, i)
                    }

                    async setBitrateLimit(e) {
                        if (em.debug("[".concat(this.getTrackId(), "] set bitrate limit, ").concat(JSON.stringify(e))), e) {
                            this._forceBitrateLimit = e, this._encoderConfig && (this._encoderConfig.bitrateMax ? this._encoderConfig.bitrateMax = this._encoderConfig.bitrateMax < e.max_bitrate ? this._encoderConfig.bitrateMax : e.max_bitrate : this._encoderConfig.bitrateMax = e.max_bitrate, this._encoderConfig.bitrateMin, this._encoderConfig.bitrateMin = e.min_bitrate);
                            try {
                                await eb(this, Nv.NEED_UPDATE_VIDEO_ENCODER, this)
                            } catch (e) {
                                return e.throw()
                            }
                        }
                    }

                    async setOptimizationMode(e) {
                        if ("motion" !== e && "detail" !== e && "balanced" !== e) return void em.error(qf.INVALID_PARAMS, "optimization mode must be motion, detail or balanced");
                        const t = this._optimizationMode;
                        try {
                            this._optimizationMode = e, await eb(this, Nv.SET_OPTIMIZATION_MODE, this)
                        } catch (e) {
                            throw this._optimizationMode = t, em.error("[".concat(this.getTrackId(), "] set optimization mode failed"), e.toString()), e
                        }
                        em.info("[".concat(this.getTrackId(), "] set optimization mode success (").concat(e, ")"))
                    }

                    setScalabiltyMode(e) {
                        if (1 === e.numSpatialLayers && 1 !== e.numTemporalLayers) return em.error(qf.INVALID_PARAMS, "scalability mode currently not supported, no SVC."), void (this._scalabiltyMode = {
                            numSpatialLayers: 1,
                            numTemporalLayers: 1
                        });
                        this._scalabiltyMode = e, em.info("[".concat(this.getTrackId(), "] set scalability mode success (").concat(e, ")"))
                    }

                    updateMediaStreamTrackResolution() {
                        QS(this._originMediaStreamTrack).then(e => {
                            let [t, r] = e;
                            this._videoHeight = r, this._videoWidth = t
                        }).catch(XS)
                    }

                    _updatePlayerSource() {
                        this._player && this._player.updateVideoTrack(this._mediaStreamTrack)
                    }

                    _getDefaultPlayerConfig() {
                        return {fit: "contain"}
                    }

                    updateBitrateFromProfile() {
                        if (!this._encoderConfig) return;
                        const {width: e, height: t, frameRate: r} = this.getMediaStreamTrackSettings();
                        if (!e || !t || !r) return;
                        const [n, i] = function (e, t, r) {
                            const n = fm("BITRATE_ADAPTER_TYPE");
                            let i;
                            const o = 200 * Math.pow(r / 15, .6) * Math.pow(e * t / 640 / 360, .75), s = o;
                            if ("STANDARD_BITRATE" === n) i = 4 * o; else {
                                if ("COMPATIABLE_BITRATE" !== n) return;
                                i = 2 * o
                            }
                            return [Math.floor(i), Math.floor(s)]
                        }(e, t, r) || [void 0, void 0];
                        this._encoderConfig.bitrateMin || this._encoderConfig.bitrateMax || (this._encoderConfig.bitrateMin = i, this._encoderConfig.bitrateMax = n, em.debug("[".concat(this.getTrackId(), "] update bitrate from profile, [w: ").concat(e, ", h: ").concat(t, ", fps: ").concat(r, "] => [brMax: ").concat(n, ", brMin: ").concat(i, "]")))
                    }

                    getVideoElementVisibleStatus() {
                        try {
                            var e, t;
                            const r = null == this || null === (e = this._player) || void 0 === e ? void 0 : e.getContainerElement(),
                                n = {
                                    track: this,
                                    element: null == this || null === (t = this._player) || void 0 === t ? void 0 : t.getVideoElement(),
                                    slot: null == r ? void 0 : r.parentElement
                                }, {element: i, slot: o} = n;
                            if (this.isPlaying && i instanceof HTMLVideoElement && o instanceof HTMLElement) {
                                const e = pA.checkOneElementVisible(i), t = Object.assign({}, e);
                                if (t.visible !== this._previousVideoVisibleStatus) {
                                    this._previousVideoVisibleStatus = t.visible;
                                    const e = WE.reportApiInvoke(null, {
                                        tag: U_.TRACER,
                                        name: M_.LOCAL_VIDEO_TRACK_GET_VIDEO_VISIBLE,
                                        options: [this.getTrackId()]
                                    });
                                    t.visible ? e.onSuccess("Video is visible") : e.onSuccess("Invisible because of ".concat(t.reason))
                                }
                                return t
                            }
                            return
                        } catch (e) {
                            throw new Hf(qf.GET_VIDEO_ELEMENT_VISIBLE_ERROR, e.message)
                        }
                    }

                    async renewMediaStreamTrack(e) {
                    }

                    pipe(e) {
                        if (this._videoBeautyProcessor && e !== this._videoBeautyProcessor) return this._videoBeautyProcessor.pipe(e);
                        if (this.processor === e) return e;
                        if (e._source) throw new Hf(qf.INVALID_OPERATION, "Processor ".concat(e.name, " already piped, please call unpipe beforehand."));
                        return this.unpipe(), this.processor = e, this.processor._source = this, e.updateInput({
                            track: this._originMediaStreamTrack,
                            context: this.processorContext
                        }), e
                    }

                    unpipe() {
                        if (!this.processor) return;
                        if (this._videoBeautyProcessor && this.processor === this._videoBeautyProcessor) return void this._videoBeautyProcessor.unpipe();
                        const e = this.processor;
                        this.processor._source = void 0, this.processor = void 0, e.reset()
                    }

                    close() {
                        super.close(), this.unbindProcessorDestinationEvents(), this.unbindProcessorContextEvents(), this.unpipe(), this.processorDestination._source && this.processorDestination._source.unpipe()
                    }

                    bindProcessorDestinationEvents() {
                        this.processorDestination.on(Xv.ON_TRACK, async e => {
                            e ? e !== this._mediaStreamTrack && (this._mediaStreamTrack = e, this._updatePlayerSource(), await eb(this, Nv.NEED_REPLACE_TRACK, this)) : this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource(), await eb(this, Nv.NEED_REPLACE_TRACK, this))
                        })
                    }

                    unbindProcessorDestinationEvents() {
                        this.processorDestination.removeAllListeners(Xv.ON_TRACK)
                    }

                    unbindProcessorContextEvents() {
                        this.processorContext.removeAllListeners(Qv.REQUEST_UPDATE_CONSTRAINTS), this.processorContext.removeAllListeners(Qv.REQUEST_CONSTRAINTS)
                    }
                }).prototype, "play", [MC, UC], Object.getOwnPropertyDescriptor(nA.prototype, "play"), nA.prototype), vE(nA.prototype, "stop", [jC], Object.getOwnPropertyDescriptor(nA.prototype, "stop"), nA.prototype), vE(nA.prototype, "setEnabled", [VC, FC, BC], Object.getOwnPropertyDescriptor(nA.prototype, "setEnabled"), nA.prototype), vE(nA.prototype, "setMuted", [WC, GC, qC], Object.getOwnPropertyDescriptor(nA.prototype, "setMuted"), nA.prototype), vE(nA.prototype, "getStats", [HC], Object.getOwnPropertyDescriptor(nA.prototype, "getStats"), nA.prototype), vE(nA.prototype, "setBeautyEffect", [KC, zC], Object.getOwnPropertyDescriptor(nA.prototype, "setBeautyEffect"), nA.prototype), vE(nA.prototype, "getCurrentFrameData", [YC], Object.getOwnPropertyDescriptor(nA.prototype, "getCurrentFrameData"), nA.prototype), vE(nA.prototype, "getCurrentFrameImage", [JC], Object.getOwnPropertyDescriptor(nA.prototype, "getCurrentFrameImage"), nA.prototype), vE(nA.prototype, "setBitrateLimit", [XC], Object.getOwnPropertyDescriptor(nA.prototype, "setBitrateLimit"), nA.prototype), vE(nA.prototype, "setOptimizationMode", [QC], Object.getOwnPropertyDescriptor(nA.prototype, "setOptimizationMode"), nA.prototype), vE(nA.prototype, "setScalabiltyMode", [$C], Object.getOwnPropertyDescriptor(nA.prototype, "setScalabiltyMode"), nA.prototype), vE(nA.prototype, "updateMediaStreamTrackResolution", [ZC], Object.getOwnPropertyDescriptor(nA.prototype, "updateMediaStreamTrackResolution"), nA.prototype), vE(nA.prototype, "pipe", [eA], Object.getOwnPropertyDescriptor(nA.prototype, "pipe"), nA.prototype), vE(nA.prototype, "unpipe", [tA], Object.getOwnPropertyDescriptor(nA.prototype, "unpipe"), nA.prototype), vE(nA.prototype, "close", [rA], Object.getOwnPropertyDescriptor(nA.prototype, "close"), nA.prototype), nA),
                vA = (iA = BE({argsMap: (e, t) => [e.getTrackId(), t]}), oA = by(), sA = zE("CameraVideoTrack", "_enabledMutex"), aA = BE({argsMap: (e, t) => [e.getTrackId(), t]}), cA = by(), uA = BE({argsMap: (e, t) => [e.getTrackId(), t]}), dA = by(), lA = BE({argsMap: e => [e.getTrackId()]}), vE((hA = class extends _A {
                    get __className__() {
                        return "CameraVideoTrack"
                    }

                    constructor(e, t, r, n, i, o) {
                        super(e, t.encoderConfig ? cm(t.encoderConfig) : {}, n, i, o), Kh(this, "_config", void 0), Kh(this, "_originalConstraints", void 0), Kh(this, "_constraints", void 0), Kh(this, "_enabled", !0), Kh(this, "_deviceName", "default"), Kh(this, "tryResumeVideoForIOS15WeChat", async () => {
                            Oh() && !Dh() && Lh() && this._enabled && !this._isClosed && (em.debug("[".concat(this.getTrackId(), "] try capture camera media device for interrupted iOS 15 device on WeChat.")), await this.renewMediaStreamTrack())
                        }), this._config = t, this._originalConstraints = r, this._constraints = r, this._deviceName = e.label, this._config.encoderConfig && (this._encoderConfig = cm(this._config.encoderConfig)), $E.on(qE.IOS_15_INTERRUPTION_END, this.tryResumeVideoForIOS15WeChat), $E.on(qE.IOS_INTERRUPTION_END, this.tryResumeVideoForIOS15WeChat), this.bindProcessorContextEvents()
                    }

                    async setDevice(e) {
                        if (em.info("[".concat(this.getTrackId(), "] set device to ").concat(e)), this._enabled) try {
                            const t = await Ey.getDeviceById(e), r = {};
                            r.video = mA({}, this._constraints), r.video.deviceId = {exact: e}, r.video.facingMode = void 0, this._originMediaStreamTrack.stop();
                            let n = null;
                            try {
                                n = await my(r, this.getTrackId())
                            } catch (e) {
                                throw em.error("[".concat(this.getTrackId(), "] setDevice failed"), e.toString()), n = await my({video: this._constraints}, this.getTrackId()), await this._updateOriginMediaStreamTrack(n.getVideoTracks()[0], !1), e
                            }
                            await this._updateOriginMediaStreamTrack(n.getVideoTracks()[0], !1), this.updateMediaStreamTrackResolution(), this._deviceName = t.label, this._config.cameraId = e, this._constraints.deviceId = {exact: e}
                        } catch (e) {
                            throw em.error("[".concat(this.getTrackId(), "] setDevice error"), e.toString()), e
                        } else try {
                            const t = await Ey.getDeviceById(e);
                            this._deviceName = t.label, this._config.cameraId = e, this._constraints.deviceId = {exact: e}
                        } catch (e) {
                            throw em.error("[".concat(this.getTrackId(), "] setDevice error"), e.toString()), e
                        }
                        em.info("[".concat(this.getTrackId(), "] setDevice success"))
                    }

                    async setEnabled(e, t) {
                        if (!t) {
                            if (e === this._enabled) return;
                            this.stateCheck("enabled", e)
                        }
                        if (em.info("[".concat(this.getTrackId(), "] start setEnabled"), e), !e) {
                            this._originMediaStreamTrack.onended = null, this._originMediaStreamTrack.stop(), t || (this._enabled = !1);
                            try {
                                await eb(this, Nv.NEED_DISABLE_TRACK, this)
                            } catch (e) {
                                throw em.error("[".concat(this.getTrackId(), "] setEnabled to false error"), e.toString()), e
                            }
                            return void em.info("[".concat(this.getTrackId(), "] setEnabled to false success"))
                        }
                        const r = mA({}, this._constraints), n = Ey.searchDeviceIdByName(this._deviceName);
                        n && !r.deviceId && (r.deviceId = {exact: n});
                        try {
                            const t = await my({video: this._constraints}, this.getTrackId());
                            await this._updateOriginMediaStreamTrack(t.getVideoTracks()[0], !1), await eb(this, Nv.NEED_ENABLE_TRACK, this)
                        } catch (e) {
                            throw em.error("[".concat(this.getTrackId(), "] setEnabled true error"), e.toString()), e
                        }
                        this.updateMediaStreamTrackResolution(), em.info("[".concat(this.getTrackId(), "] setEnabled to true success")), t || (this._enabled = !0)
                    }

                    async setEncoderConfiguration(e, t) {
                        if (!this._enabled) throw new Hf(qf.TRACK_IS_DISABLED, "can not set encoder configuration when track is disabled");
                        e = cm(e), this._forceBitrateLimit && (e.bitrateMax = this._forceBitrateLimit.max_bitrate ? this._forceBitrateLimit.max_bitrate : e.bitrateMax, e.bitrateMin = this._forceBitrateLimit.min_bitrate ? this._forceBitrateLimit.min_bitrate : e.bitrateMin);
                        const r = sb(this._config);
                        r.encoderConfig = e;
                        const n = DC(r);
                        (Ih() || Ch() || kh()) && (n.deviceId = void 0), em.debug("[".concat(this.getTrackId(), "] setEncoderConfiguration applyConstraints"), JSON.stringify(e), JSON.stringify(n));
                        try {
                            await this._originMediaStreamTrack.applyConstraints(n), this.updateMediaStreamTrackResolution()
                        } catch (e) {
                            const t = new Hf(qf.UNEXPECTED_ERROR, e.toString());
                            throw em.error("[".concat(this.getTrackId(), "] applyConstraints error"), t.toString()), t
                        }
                        this._config = r, this._constraints = n, this._originalConstraints = n, this._encoderConfig = e, -1 === this._hints.indexOf(Pv.SCREEN_TRACK) && this.updateBitrateFromProfile();
                        try {
                            await eb(this, Nv.NEED_UPDATE_VIDEO_ENCODER, this)
                        } catch (e) {
                            return e.throw()
                        }
                    }

                    _getDefaultPlayerConfig() {
                        return {mirror: !0, fit: "cover"}
                    }

                    onTrackEnded() {
                        if ((Ch() || kh()) && this._enabled && !this._isClosed && $E.duringInterruption) {
                            const e = async () => {
                                $E.off(qE.IOS_INTERRUPTION_END, e), this._enabled && !this._isClosed && (em.debug("[".concat(this.getTrackId(), "] try capture camera media device for interrupted iOS device.")), await this.setEnabled(!1), await this.setEnabled(!0))
                            };
                            $E.on(qE.IOS_INTERRUPTION_END, e)
                        } else em.debug("[".concat(this.getTrackId(), "] track ended")), this.emit(Lv.TRACK_ENDED)
                    }

                    async renewMediaStreamTrack(e) {
                        const t = e || this._constraints, r = Ey.searchDeviceIdByName(this._deviceName);
                        if (r && !t.deviceId && (t.deviceId = {exact: r}), this._enabled) {
                            const e = await my({video: t}, this.getTrackId());
                            this._constraints = t, await this._updateOriginMediaStreamTrack(e.getVideoTracks()[0], !0), this.updateMediaStreamTrackResolution()
                        }
                    }

                    close() {
                        super.close(), $E.off(qE.IOS_15_INTERRUPTION_END, this.tryResumeVideoForIOS15WeChat), $E.off(qE.IOS_INTERRUPTION_END, this.tryResumeVideoForIOS15WeChat)
                    }

                    bindProcessorContextEvents() {
                        this.processorContext.on(Qv.REQUEST_UPDATE_CONSTRAINTS, async (e, t, r) => {
                            try {
                                const r = Object.assign({}, this._originalConstraints, ...e);
                                await this.renewMediaStreamTrack(r), t()
                            } catch (e) {
                                r(e)
                            }
                        }), this.processorContext.on(Qv.REQUEST_CONSTRAINTS, async e => {
                            e(this._originMediaStreamTrack.getSettings())
                        })
                    }
                }).prototype, "setDevice", [iA, oA], Object.getOwnPropertyDescriptor(hA.prototype, "setDevice"), hA.prototype), vE(hA.prototype, "setEnabled", [sA, aA, cA], Object.getOwnPropertyDescriptor(hA.prototype, "setEnabled"), hA.prototype), vE(hA.prototype, "setEncoderConfiguration", [uA, dA], Object.getOwnPropertyDescriptor(hA.prototype, "setEncoderConfiguration"), hA.prototype), vE(hA.prototype, "close", [lA], Object.getOwnPropertyDescriptor(hA.prototype, "close"), hA.prototype), hA);

            class gA {
                get hasVideo() {
                    return this._video_enabled_ && !this._video_muted_ && this._video_added_
                }

                get hasAudio() {
                    return this._audio_enabled_ && !this._audio_muted_ && this._audio_added_
                }

                get audioTrack() {
                    if (this.hasAudio) return this._audioTrack
                }

                get videoTrack() {
                    if (this.hasVideo) return this._videoTrack
                }

                constructor(e, t) {
                    Kh(this, "uid", void 0), Kh(this, "_uintid", void 0), Kh(this, "_trust_in_room_", !0), Kh(this, "_trust_audio_enabled_state_", !0), Kh(this, "_trust_video_enabled_state_", !0), Kh(this, "_trust_audio_mute_state_", !0), Kh(this, "_trust_video_mute_state_", !0), Kh(this, "_audio_muted_", !1), Kh(this, "_video_muted_", !1), Kh(this, "_audio_enabled_", !0), Kh(this, "_video_enabled_", !0), Kh(this, "_audio_added_", !1), Kh(this, "_video_added_", !1), Kh(this, "_trust_video_stream_added_state_", !0), Kh(this, "_trust_audio_stream_added_state_", !0), Kh(this, "_audioTrack", void 0), Kh(this, "_videoTrack", void 0), Kh(this, "_audioSSRC", void 0), Kh(this, "_videoSSRC", void 0), Kh(this, "_audioOrtc", void 0), Kh(this, "_videoOrtc", void 0), Kh(this, "_cname", void 0), Kh(this, "_rtxSsrcId", void 0), this.uid = e, this._uintid = t
                }
            }

            var EA = ol, yA = ou, SA = hu;
            Er({target: "Promise", stat: !0}, {
                try: function (e) {
                    var t = yA.f(this), r = SA(e);
                    return (r.error ? t.reject : t.resolve)(r.value), t.promise
                }
            });
            var bA = EA, TA = Er, RA = f, IA = i, wA = cg, CA = J, AA = Fe, OA = Ir, NA = Cm, PA = mg, DA = Xg, kA = ue,
                LA = ot("isConcatSpreadable"), xA = 9007199254740991, MA = "Maximum allowed index exceeded",
                UA = RA.TypeError, jA = kA >= 51 || !IA(function () {
                    var e = [];
                    return e[LA] = !1, e.concat()[0] !== e
                }), VA = DA("concat"), FA = function (e) {
                    if (!CA(e)) return !1;
                    var t = e[LA];
                    return void 0 !== t ? !!t : wA(e)
                };
            TA({target: "Array", proto: !0, forced: !jA || !VA}, {
                concat: function (e) {
                    var t, r, n, i, o, s = AA(this), a = PA(s, 0), c = 0;
                    for (t = -1, n = arguments.length; t < n; t++) if (FA(o = -1 === t ? s : arguments[t])) {
                        if (c + (i = OA(o)) > xA) throw UA(MA);
                        for (r = 0; r < i; r++, c++) r in o && NA(a, c, o[r])
                    } else {
                        if (c >= xA) throw UA(MA);
                        NA(a, c++, o)
                    }
                    return a.length = c, a
                }
            });
            var BA = {}, WA = M, GA = z, qA = In.f, HA = km,
                KA = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
            BA.f = function (e) {
                return KA && "Window" == WA(e) ? function (e) {
                    try {
                        return qA(e)
                    } catch (e) {
                        return HA(KA)
                    }
                }(e) : qA(GA(e))
            };
            var zA = {}, YA = ot;
            zA.f = YA;
            var JA = X, XA = Ge, QA = zA, $A = qt.f, ZA = function (e) {
                    var t = JA.Symbol || (JA.Symbol = {});
                    XA(t, e) || $A(t, e, {value: QA.f(e)})
                }, eO = Er, tO = f, rO = te, nO = E, iO = I, oO = l, sO = b, aO = he, cO = i, uO = Ge, dO = cg, lO = y,
                hO = J, pO = h, fO = Ee, mO = Xt, _O = Fe, vO = z, gO = mt, EO = wo, yO = D, SO = Ii, bO = oi, TO = In,
                RO = BA, IO = Hn, wO = S, CO = qt, AO = ri, OO = w, NO = sc, PO = Os, DO = De.exports, kO = xn, LO = Ye,
                xO = ot, MO = zA, UO = ZA, jO = zs, VO = Ss, FO = Tg.forEach, BO = an("hidden"), WO = "Symbol",
                GO = xO("toPrimitive"), qO = VO.set, HO = VO.getterFor(WO), KO = Object.prototype, zO = tO.Symbol,
                YO = zO && zO.prototype, JO = tO.TypeError, XO = tO.QObject, QO = rO("JSON", "stringify"), $O = wO.f,
                ZO = CO.f, eN = RO.f, tN = OO.f, rN = oO([].push), nN = DO("symbols"), iN = DO("op-symbols"),
                oN = DO("string-to-symbol-registry"), sN = DO("symbol-to-string-registry"), aN = DO("wks"),
                cN = !XO || !XO.prototype || !XO.prototype.findChild, uN = sO && cO(function () {
                    return 7 != SO(ZO({}, "a", {
                        get: function () {
                            return ZO(this, "a", {value: 7}).a
                        }
                    })).a
                }) ? function (e, t, r) {
                    var n = $O(KO, t);
                    n && delete KO[t], ZO(e, t, r), n && e !== KO && ZO(KO, t, n)
                } : ZO, dN = function (e, t) {
                    var r = nN[e] = SO(YO);
                    return qO(r, {type: WO, tag: e, description: t}), sO || (r.description = t), r
                }, lN = function (e, t, r) {
                    e === KO && lN(iN, t, r), mO(e);
                    var n = gO(t);
                    return mO(r), uO(nN, n) ? (r.enumerable ? (uO(e, BO) && e[BO][n] && (e[BO][n] = !1), r = SO(r, {enumerable: yO(0, !1)})) : (uO(e, BO) || ZO(e, BO, yO(1, {})), e[BO][n] = !0), uN(e, n, r)) : ZO(e, n, r)
                }, hN = function (e, t) {
                    mO(e);
                    var r = vO(t), n = bO(r).concat(_N(r));
                    return FO(n, function (t) {
                        sO && !iO(pN, r, t) || lN(e, t, r[t])
                    }), e
                }, pN = function (e) {
                    var t = gO(e), r = iO(tN, this, t);
                    return !(this === KO && uO(nN, t) && !uO(iN, t)) && (!(r || !uO(this, t) || !uO(nN, t) || uO(this, BO) && this[BO][t]) || r)
                }, fN = function (e, t) {
                    var r = vO(e), n = gO(t);
                    if (r !== KO || !uO(nN, n) || uO(iN, n)) {
                        var i = $O(r, n);
                        return !i || !uO(nN, n) || uO(r, BO) && r[BO][n] || (i.enumerable = !0), i
                    }
                }, mN = function (e) {
                    var t = eN(vO(e)), r = [];
                    return FO(t, function (e) {
                        uO(nN, e) || uO(kO, e) || rN(r, e)
                    }), r
                }, _N = function (e) {
                    var t = e === KO, r = eN(t ? iN : vO(e)), n = [];
                    return FO(r, function (e) {
                        !uO(nN, e) || t && !uO(KO, e) || rN(n, nN[e])
                    }), n
                };
            if (aO || (PO(YO = (zO = function () {
                if (pO(YO, this)) throw JO("Symbol is not a constructor");
                var e = arguments.length && void 0 !== arguments[0] ? EO(arguments[0]) : void 0, t = LO(e),
                    r = function (e) {
                        this === KO && iO(r, iN, e), uO(this, BO) && uO(this[BO], t) && (this[BO][t] = !1), uN(this, t, yO(1, e))
                    };
                return sO && cN && uN(KO, t, {configurable: !0, set: r}), dN(t, e)
            }).prototype, "toString", function () {
                return HO(this).tag
            }), PO(zO, "withoutSetter", function (e) {
                return dN(LO(e), e)
            }), OO.f = pN, CO.f = lN, AO.f = hN, wO.f = fN, TO.f = RO.f = mN, IO.f = _N, MO.f = function (e) {
                return dN(xO(e), e)
            }, sO && ZO(YO, "description", {
                configurable: !0, get: function () {
                    return HO(this).description
                }
            })), eO({global: !0, wrap: !0, forced: !aO, sham: !aO}, {Symbol: zO}), FO(bO(aN), function (e) {
                UO(e)
            }), eO({target: WO, stat: !0, forced: !aO}, {
                for: function (e) {
                    var t = EO(e);
                    if (uO(oN, t)) return oN[t];
                    var r = zO(t);
                    return oN[t] = r, sN[r] = t, r
                }, keyFor: function (e) {
                    if (!fO(e)) throw JO(e + " is not a symbol");
                    if (uO(sN, e)) return sN[e]
                }, useSetter: function () {
                    cN = !0
                }, useSimple: function () {
                    cN = !1
                }
            }), eO({target: "Object", stat: !0, forced: !aO, sham: !sO}, {
                create: function (e, t) {
                    return void 0 === t ? SO(e) : hN(SO(e), t)
                }, defineProperty: lN, defineProperties: hN, getOwnPropertyDescriptor: fN
            }), eO({target: "Object", stat: !0, forced: !aO}, {
                getOwnPropertyNames: mN,
                getOwnPropertySymbols: _N
            }), eO({
                target: "Object", stat: !0, forced: cO(function () {
                    IO.f(1)
                })
            }, {
                getOwnPropertySymbols: function (e) {
                    return IO.f(_O(e))
                }
            }), QO && eO({
                target: "JSON", stat: !0, forced: !aO || cO(function () {
                    var e = zO();
                    return "[null]" != QO([e]) || "{}" != QO({a: e}) || "{}" != QO(Object(e))
                })
            }, {
                stringify: function (e, t, r) {
                    var n = NO(arguments), i = t;
                    if ((hO(t) || void 0 !== e) && !fO(e)) return dO(t) || (t = function (e, t) {
                        if (lO(i) && (t = iO(i, this, e, t)), !fO(t)) return t
                    }), n[1] = t, nO(QO, null, n)
                }
            }), !YO[GO]) {
                var vN = YO.valueOf;
                PO(YO, GO, function (e) {
                    return iO(vN, this)
                })
            }
            jO(zO, WO), kO[BO] = !0, ZA("asyncIterator"), ZA("hasInstance"), ZA("isConcatSpreadable"), ZA("iterator"), ZA("match"), ZA("matchAll"), ZA("replace"), ZA("search"), ZA("species"), ZA("split"), ZA("toPrimitive"), ZA("toStringTag"), ZA("unscopables"), zs(f.JSON, "JSON", !0);
            var gN = X.Symbol;
            ZA("asyncDispose"), ZA("dispose"), ZA("matcher"), ZA("metadata"), ZA("observable"), ZA("patternMatch"), ZA("replaceAll");
            var EN = gN, yN = zA.f("asyncIterator"), SN = yN;

            function bN(e) {
                this.wrapped = e
            }

            function TN(e) {
                var t, r;

                function n(t, r) {
                    try {
                        var o = e[t](r), s = o.value, a = s instanceof bN;
                        bA.resolve(a ? s.wrapped : s).then(function (e) {
                            a ? n("return" === t ? "return" : "next", e) : i(o.done ? "return" : "normal", e)
                        }, function (e) {
                            n("throw", e)
                        })
                    } catch (e) {
                        i("throw", e)
                    }
                }

                function i(e, i) {
                    switch (e) {
                        case"return":
                            t.resolve({value: i, done: !0});
                            break;
                        case"throw":
                            t.reject(i);
                            break;
                        default:
                            t.resolve({value: i, done: !1})
                    }
                    (t = t.next) ? n(t.key, t.arg) : r = null
                }

                this._invoke = function (e, i) {
                    return new bA(function (o, s) {
                        var a = {key: e, arg: i, resolve: o, reject: s, next: null};
                        r ? r = r.next = a : (t = r = a, n(e, i))
                    })
                }, "function" != typeof e.return && (this.return = void 0)
            }

            function RN(e) {
                return function () {
                    return new TN(e.apply(this, arguments))
                }
            }

            function IN(e) {
                return new bN(e)
            }

            TN.prototype["function" == typeof EN && SN || "@@asyncIterator"] = function () {
                return this
            }, TN.prototype.next = function (e) {
                return this._invoke("next", e)
            }, TN.prototype.throw = function (e) {
                return this._invoke("throw", e)
            }, TN.prototype.return = function (e) {
                return this._invoke("return", e)
            };
            var wN = zA.f("iterator");

            function CN(e, t) {
                var r = {}, n = !1;

                function i(r, i) {
                    return n = !0, i = new bA(function (t) {
                        t(e[r](i))
                    }), {done: !1, value: t(i)}
                }

                return r[void 0 !== EN && wN || "@@iterator"] = function () {
                    return this
                }, r.next = function (e) {
                    return n ? (n = !1, e) : i("next", e)
                }, "function" == typeof e.throw && (r.throw = function (e) {
                    if (n) throw n = !1, e;
                    return i("throw", e)
                }), "function" == typeof e.return && (r.return = function (e) {
                    return n ? (n = !1, e) : i("return", e)
                }), r
            }

            var AN = yN, ON = {exports: {}};

            function NN(e, t) {
                var r = Object.keys(e);
                if (Object.getOwnPropertySymbols) {
                    var n = Object.getOwnPropertySymbols(e);
                    t && (n = n.filter(function (t) {
                        return Object.getOwnPropertyDescriptor(e, t).enumerable
                    })), r.push.apply(r, n)
                }
                return r
            }

            function PN(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var r = null != arguments[t] ? arguments[t] : {};
                    t % 2 ? NN(Object(r), !0).forEach(function (t) {
                        Kh(e, t, r[t])
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : NN(Object(r)).forEach(function (t) {
                        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t))
                    })
                }
                return e
            }

            function DN(e, t, r, n, i, o, s) {
                let a = [], c = [], u = [], d = [], l = !1, h = !1;
                if (ON.exports.parse(e).mediaDescriptions.forEach(e => {
                    s && s !== e.attributes.direction || ("video" !== e.media.mediaType || l || (c = e.attributes.payloads, d = e.attributes.extmaps, l = !0), "audio" !== e.media.mediaType || h || (a = e.attributes.payloads, u = e.attributes.extmaps, h = !0))
                }), !d || 0 === c.length) throw new Error("Cannot get video capabilities from SDP.");
                if (!u || 0 === a.length) throw new Error("Cannot get audio capabilities from SDP.");
                return c.forEach(e => {
                    var t;
                    null !== (t = e.rtpMap) && void 0 !== t && t.clockRate && (e.rtpMap.clockRate = parseInt(e.rtpMap.clockRate))
                }), a.forEach(e => {
                    var t;
                    null !== (t = e.rtpMap) && void 0 !== t && t.clockRate && (e.rtpMap.clockRate = parseInt(e.rtpMap.clockRate))
                }), t && (a = a.filter(e => {
                    var t;
                    return "rtx" !== (null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLowerCase())
                }), c = c.filter(e => {
                    var t;
                    return "rtx" !== (null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLowerCase())
                })), r && (c = c.filter(e => {
                    var t;
                    return !/(red)|(ulpfec)|(flexfec)/i.test((null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName) || "")
                })), n && (a = a.filter(e => {
                    var t;
                    return !/(red)|(ulpfec)|(flexfec)/i.test((null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName) || "")
                })), i && (null == i ? void 0 : i.length) > 0 && (a = a.filter(e => {
                    var t;
                    return i.includes((null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLowerCase()) || "")
                })), o && (null == o ? void 0 : o.length) > 0 && (c = c.filter(e => {
                    var t;
                    return o.includes((null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLowerCase()) || "")
                })), {audioCodecs: a, videoCodecs: c, audioExtensions: u, videoExtensions: d}
            }

            function kN(e) {
                const t = ON.exports.parse(e);
                let r, n;
                for (const e of t.mediaDescriptions) {
                    if (!r) {
                        const t = e.attributes.iceUfrag, n = e.attributes.icePwd;
                        if (!t || !n) throw new Error("Cannot get iceUfrag or icePwd from SDP.");
                        r = {iceUfrag: t, icePwd: n}
                    }
                    if (!n) {
                        const t = e.attributes.fingerprints;
                        t.length > 0 && (n = {fingerprints: t})
                    }
                }
                if (!n && t.attributes.fingerprints.length > 0 && (n = {fingerprints: t.attributes.fingerprints}), !n || !r) throw new Error("Cannot get iceParameters or dtlsParameters from SDP.");
                return {iceParameters: r, dtlsParameters: n}
            }

            function LN(e, t) {
                const r = [], n = e.attributes.ssrcGroups.filter(e => "FID" === e.semantic),
                    i = e.attributes.ssrcGroups.find(e => "SIM" === e.semantic), o = e.attributes.ssrcs;
                if (i) i.ssrcIds.forEach(e => {
                    var i;
                    const o = null === (i = n.find(t => t.ssrcIds[0] === e)) || void 0 === i ? void 0 : i.ssrcIds[1];
                    r.push({ssrcId: e, rtx: t ? o : void 0})
                }); else if (n.length > 0) {
                    const e = n[0].ssrcIds[0], i = n[0].ssrcIds[1];
                    r.push({ssrcId: e, rtx: t ? i : void 0})
                } else {
                    if (0 === o.length) throw new Error("No ssrcs found on local media description.");
                    r.push({ssrcId: o[0].ssrcId})
                }
                return r
            }

            function xN(e, t) {
                const {cname: r} = e;
                let n;
                t && t.ip && "number" == typeof t.port ? (n = [{
                    foundation: "udpcandidate",
                    componentId: "1",
                    transport: "udp",
                    priority: "2103266323",
                    connectionAddress: t.ip,
                    port: t.port.toString(),
                    type: "host",
                    extension: {}
                }], em.debug("Using remote candidate from AP ".concat(t.ip, ":").concat(t.port)), t.ip6 && (n.push({
                    foundation: "udpcandidate",
                    componentId: "1",
                    transport: "udp",
                    priority: "2103266323",
                    connectionAddress: t.ip6,
                    port: t.port.toString(),
                    type: "host",
                    extension: {}
                }), em.debug("Using IPV6 remote candidate from AP ".concat(t.ip6, ":").concat(t.port)))) : n = e.iceParameters.candidates.map(e => ({
                    foundation: e.foundation,
                    componentId: "1",
                    transport: e.protocol,
                    priority: e.priority.toString(),
                    connectionAddress: e.ip,
                    port: e.port.toString(),
                    type: e.type,
                    extension: {}
                }));
                const i = {
                    fingerprints: e.dtlsParameters.fingerprints.map(e => ({
                        hashFunction: e.algorithm,
                        fingerprint: e.fingerprint
                    }))
                }, o = {iceUfrag: e.iceParameters.iceUfrag, icePwd: e.iceParameters.icePwd};
                let s;
                switch (e.dtlsParameters.role) {
                    case"server":
                        s = "passive";
                        break;
                    case"client":
                        s = "active";
                        break;
                    case"auto":
                        s = "actpass"
                }
                return {
                    dtlsParameters: i,
                    iceParameters: o,
                    candidates: n,
                    rtpCapabilities: HN(e.rtpCapabilities),
                    setup: s,
                    cname: r
                }
            }

            function MN(e, t, r) {
                const n = [], i = [];
                return e.forEach(e => {
                    let {ssrcId: o, rtx: s} = e;
                    const a = YS(8, "track-"), c = {
                        ssrcId: o,
                        attributes: PN({
                            label: a,
                            mslabel: r = r || YS(10, ""),
                            msid: "".concat(r, " ").concat(a)
                        }, t && {cname: t})
                    };
                    if (n.push(c), void 0 !== s) {
                        const e = {
                            ssrcId: s,
                            attributes: PN({label: a, mslabel: r, msid: "".concat(r, " ").concat(a)}, t && {cname: t})
                        };
                        n.push(e), i.push({semantic: "FID", ssrcIds: [o, s]})
                    }
                }), e.length > 1 && i.push({
                    semantic: "SIM", ssrcIds: e.map(e => {
                        let {ssrcId: t} = e;
                        return t
                    })
                }), {ssrcs: n, ssrcGroups: i}
            }

            function UN(e, t) {
                t instanceof RS && e.attributes.payloads.forEach(e => {
                    var r;
                    const n = null === (r = e.rtpMap) || void 0 === r ? void 0 : r.encodingName.toLowerCase();
                    if (!n || -1 === ["opus", "pcmu", "pcma", "g722"].indexOf(n)) return;
                    e.fmtp || (e.fmtp = {parameters: {}}), e.fmtp.parameters.minptime = "10", e.fmtp.parameters.useinbandfec = "1";
                    const i = t._encoderConfig;
                    i && "pcmu" !== n && "pcma" !== n && "g722" !== n && (i.bitrate && !wh() && (e.fmtp.parameters.maxaveragebitrate = "".concat(Math.floor(1e3 * i.bitrate))), i.sampleRate && (e.fmtp.parameters.maxplaybackrate = "".concat(i.sampleRate), e.fmtp.parameters["sprop-maxcapturerate"] = "".concat(i.sampleRate)), i.stereo && (e.fmtp.parameters.stereo = "1", e.fmtp.parameters["sprop-stereo"] = "1"))
                })
            }

            function jN(e) {
                const t = e.attributes.unrecognized.findIndex(e => "x-google-flag" === e.attField && "conference" === e.attValue);
                -1 !== t && e.attributes.unrecognized.splice(t, 1)
            }

            function VN(e, t) {
                if (!(t instanceof _A && t._encoderConfig && -1 === t._hints.indexOf(Pv.SCREEN_TRACK))) return;
                const r = t._encoderConfig;
                og().supportMinBitrate && r.bitrateMin && e.attributes.payloads.forEach(e => {
                    var t;
                    ["h264", "vp8", "vp9", "av1"].includes((null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLowerCase()) || "") && (e.fmtp || (e.fmtp = {parameters: {}}), e.fmtp.parameters["x-google-min-bitrate"] = "".concat(r.bitrateMin))
                }), og().supportMinBitrate && !t._hints.includes(Pv.LOW_STREAM) && r.bitrateMax && e.attributes.payloads.forEach(e => {
                    var t;
                    ["h264", "vp8", "vp9", "av1"].includes((null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLowerCase()) || "") && (e.fmtp || (e.fmtp = {parameters: {}}), e.fmtp.parameters["x-google-start-bitrate"] = "".concat(fm("X_GOOGLE_START_BITRATE") || Math.floor(r.bitrateMax)))
                })
            }

            function FN(e) {
                if ("video" !== e.media.mediaType) return;
                const t = Sh();
                if (t.name !== vh.SAFARI && t.os !== _h.IOS) return;
                const r = e.attributes.extmaps.findIndex(e => /video-orientation/g.test(e.extensionName));
                -1 !== r && e.attributes.extmaps.splice(r, 1)
            }

            function BN(e, t, r) {
                if (!t) return;
                let n, i;
                if ("video" === e.media.mediaType ? (n = r.videoExtensions, i = r.videoCodecs) : (n = r.audioExtensions, i = r.audioCodecs), !0 === t.tcc) {
                    const t = n.find(e => "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01" === e.extensionName);
                    t && (e.attributes.extmaps.find(e => "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01" === e.extensionName) || e.attributes.extmaps.push({
                        entry: t.entry,
                        extensionName: "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01"
                    }), function (e, t) {
                        return t.filter(t => !!e.find(e => e.payloadType === t.payloadType && !!e.rtcpFeedbacks.find(e => "transport-cc" === e.type)))
                    }(i, e.attributes.payloads).forEach(e => {
                        e.rtcpFeedbacks.find(e => "transport-cc" === e.type) || e.rtcpFeedbacks.push({type: "transport-cc"})
                    }))
                } else if (!1 === t.tcc) {
                    const t = e.attributes.extmaps.findIndex(e => "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01" === e.extensionName);
                    -1 !== t && e.attributes.extmaps.splice(t, 1), e.attributes.payloads.forEach(e => {
                        const t = e.rtcpFeedbacks.findIndex(e => "transport-cc" === e.type);
                        -1 !== t && e.rtcpFeedbacks.splice(t, 1)
                    })
                }
                if (!0 === t.remb) {
                    const t = n.find(e => "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time" === e.extensionName);
                    t && (e.attributes.extmaps.find(e => "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time" === e.extensionName) || e.attributes.extmaps.push({
                        entry: t.entry,
                        extensionName: "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time"
                    }), function (e, t) {
                        return t.filter(t => !!e.find(e => e.payloadType === t.payloadType && !!e.rtcpFeedbacks.find(e => "goog-remb" === e.type)))
                    }(i, e.attributes.payloads).forEach(e => {
                        e.rtcpFeedbacks.find(e => "goog-remb" === e.type) || e.rtcpFeedbacks.push({type: "goog-remb"})
                    }))
                } else if (!1 === t.remb) {
                    const t = e.attributes.extmaps.findIndex(e => "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time" === e.extensionName);
                    -1 !== t && e.attributes.extmaps.splice(t, 1), e.attributes.payloads.forEach(e => {
                        const t = e.rtcpFeedbacks.findIndex(e => "goog-remb" === e.type);
                        -1 !== t && e.rtcpFeedbacks.splice(t, 1)
                    })
                }
            }

            function WN(e, t, r) {
                if (wh()) return;
                if ("video" !== e.media.mediaType) return;
                if (!(t instanceof _A)) return;
                if ("vp9" !== r && "vp8" !== r) return;
                if ("vp8" === r && !fm("SIMULCAST")) return;
                if (void 0 === t._scalabiltyMode || t._scalabiltyMode.numSpatialLayers <= 1) return;
                const n = "vp8" === r ? 2 : t._scalabiltyMode.numSpatialLayers, i = e.attributes.ssrcs[0],
                    o = e.attributes.ssrcGroups.find(e => "FID" === e.semantic && e.ssrcIds[0] === i.ssrcId),
                    s = {semantic: "SIM", ssrcIds: [i.ssrcId]};
                for (let t = 1; t < n; t++) e.attributes.ssrcs.push({
                    ssrcId: i.ssrcId + t,
                    attributes: sb(i.attributes)
                }), s.ssrcIds.push(i.ssrcId + t), o && (e.attributes.ssrcs.push({
                    ssrcId: o.ssrcIds[1] + t,
                    attributes: sb(i.attributes)
                }), e.attributes.ssrcGroups.push({semantic: "FID", ssrcIds: [i.ssrcId + t, o.ssrcIds[1] + t]}));
                e.attributes.ssrcGroups.unshift(s)
            }

            async function GN(e, t, r, n, i) {
                const o = new RTCPeerConnection;
                o.addTransceiver("video", {direction: "sendonly"}), o.addTransceiver("audio", {direction: "sendonly"}), o.addTransceiver("video", {direction: "recvonly"}), o.addTransceiver("audio", {direction: "recvonly"});
                const s = (await o.createOffer()).sdp, a = DN(s, e, t, r, n, i, "sendonly"),
                    c = DN(s, e, t, r, n, i, "recvonly"),
                    u = {audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: []},
                    d = {audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: []},
                    l = {audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: []};
                if (qN(a, c, "videoExtensions", u, d, l), qN(a, c, "videoCodecs", u, d, l), qN(a, c, "audioExtensions", u, d, l), qN(a, c, "audioCodecs", u, d, l), fm("RAISE_H264_BASELINE_PRIORITY")) {
                    const e = l.videoCodecs.findIndex(e => {
                        var t, r;
                        return "h264" === (null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLocaleLowerCase()) && "42001f" === (null === (r = e.fmtp) || void 0 === r ? void 0 : r.parameters["profile-level-id"])
                    });
                    if (-1 !== e) {
                        const t = l.videoCodecs.findIndex(e => {
                            var t;
                            return "h264" === (null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLocaleLowerCase())
                        });
                        if (t < e) {
                            em.debug("raising H264 baseline profile priority");
                            const r = l.videoCodecs[e];
                            l.videoCodecs.splice(e, 1), l.videoCodecs.splice(t, 0, r)
                        }
                        -1 !== t && (d.videoCodecs = d.videoCodecs.filter(e => {
                            var t, r;
                            return !("h264" === (null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLocaleLowerCase()) && "42001f" !== (null === (r = e.fmtp) || void 0 === r ? void 0 : r.parameters["profile-level-id"]))
                        })), -1 !== t && fm("FILTER_SEND_H264_BASELINE") && (u.videoCodecs = u.videoCodecs.filter(e => {
                            var t, r;
                            return !("h264" === (null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLocaleLowerCase()) && "42001f" !== (null === (r = e.fmtp) || void 0 === r ? void 0 : r.parameters["profile-level-id"]))
                        }))
                    }
                }
                try {
                    o.close()
                } catch (e) {
                }
                return {send: u, recv: d, sendrecv: l}
            }

            function qN(e, t, r, n, i, o) {
                if ("videoExtensions" === r || "audioExtensions" === r) {
                    const s = [];
                    return e[r].forEach(e => {
                        t[r].some((t, r) => {
                            if (e.entry === t.entry && e.extensionName === t.extensionName) return s.push(r), !0
                        }) ? o[r].push(e) : n[r].push(e)
                    }), void t[r].forEach((e, t) => {
                        -1 === s.indexOf(t) && i[r].push(e)
                    })
                }
                if ("videoCodecs" === r || "audioCodecs" === r) {
                    const s = [];
                    return e[r].forEach(e => {
                        t[r].some((t, r) => {
                            if (e.payloadType === t.payloadType && JSON.stringify(e) === JSON.stringify(t)) return s.push(r), !0
                        }) ? o[r].push(e) : n[r].push(e)
                    }), void t[r].forEach((e, t) => {
                        -1 === s.indexOf(t) && i[r].push(e)
                    })
                }
            }

            function HN(e) {
                const {send: t, recv: r, sendrecv: n} = e;
                if (!n) {
                    if (!t || !r) throw new Error("cannot merge rtp capabilities because one of send or recv is empty!");
                    return {send: t, recv: r}
                }
                let i, o;
                return t ? ((i = {
                    audioCodecs: [],
                    audioExtensions: [],
                    videoCodecs: [],
                    videoExtensions: []
                }).audioCodecs = [...t.audioCodecs, ...n.audioCodecs], i.videoCodecs = [...t.videoCodecs, ...n.videoCodecs], i.audioExtensions = [...t.audioExtensions, ...n.audioExtensions], i.videoExtensions = [...t.videoExtensions, ...n.videoExtensions]) : i = n, r ? ((o = {
                    audioCodecs: [],
                    audioExtensions: [],
                    videoCodecs: [],
                    videoExtensions: []
                }).audioCodecs = [...r.audioCodecs, ...n.audioCodecs], o.videoCodecs = [...r.videoCodecs, ...n.videoCodecs], o.audioExtensions = [...r.audioExtensions, ...n.audioExtensions], o.videoExtensions = [...r.videoExtensions, ...n.videoExtensions]) : o = n, {
                    send: i,
                    recv: o
                }
            }

            function KN(e) {
                "audio" === e.media.mediaType && e.attributes.payloads.filter(e => {
                    var t;
                    return "opus" === (null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLowerCase())
                }).forEach(e => {
                    e.fmtp || (e.fmtp = {parameters: {}}), e.fmtp.parameters.stereo = "1", e.fmtp.parameters["sprop-stereo"] = "1"
                })
            }

            function zN(e) {
                if (Array.isArray(e)) return e.map(function (e) {
                    return e
                });
                if (!YN(e)) return e;
                var t = {};
                for (var r in e) YN(e[r]) || Array.isArray(e[r]) ? t[r] = zN(e[r]) : t[r] = e[r];
                return t
            }

            function YN(e) {
                return !("object" != typeof e || Array.isArray(e) || !e)
            }

            !function (e, t) {
                e.exports = (() => {
                    var e = {
                        8: (e, t, r) => {
                            r.r(t), r.d(t, {
                                Parser: () => b, Printer: () => C, parse: () => (function (e) {
                                    return (new b).parse(e)
                                }), print: () => (function (e, t) {
                                    return (new C).print(e, t)
                                })
                            });
                            const n = "\n", i = "".concat("\r").concat(n), o = " ";
                            let s;

                            function a(e) {
                                return e >= "0" && e <= "9"
                            }

                            function c(e) {
                                return e >= "!" && e <= "~"
                            }

                            function u(e) {
                                return c(e) || e >= "?" && e <= ""
                            }

                            function d(e) {
                                return "!" === e || e >= "#" && e <= "'" || e >= "*" && e <= "+" || e >= "-" && e <= "." || e >= "0" && e <= "9" || e >= "A" && e <= "Z" || e >= "^" && e <= "~"
                            }

                            function l(e) {
                                return e >= "1" && e <= "9"
                            }

                            function h(e) {
                                return e >= "A" && e <= "Z" || e >= "a" && e <= "z"
                            }

                            function p(e) {
                                return "d" === e || "h" === e || "m" === e || "s" === e
                            }

                            function f(e) {
                                return e > "" && e < "\t" || e > "\v" && e < "\f" || e > "" && e < ""
                            }

                            function m(e) {
                                return h(e) || a(e) || "+" === e || "/" === e
                            }

                            function _(e) {
                                return a(e) || h(e) || "+" === e || "/" === e || "-" === e || "_" === e
                            }

                            function v(e) {
                                return h(e) || a(e) || "+" === e || "/" === e
                            }

                            function g(e, t) {
                                var r = Object.keys(e);
                                if (Object.getOwnPropertySymbols) {
                                    var n = Object.getOwnPropertySymbols(e);
                                    t && (n = n.filter(function (t) {
                                        return Object.getOwnPropertyDescriptor(e, t).enumerable
                                    })), r.push.apply(r, n)
                                }
                                return r
                            }

                            function E(e) {
                                for (var t = 1; t < arguments.length; t++) {
                                    var r = null != arguments[t] ? arguments[t] : {};
                                    t % 2 ? g(Object(r), !0).forEach(function (t) {
                                        y(e, t, r[t])
                                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : g(Object(r)).forEach(function (t) {
                                        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t))
                                    })
                                }
                                return e
                            }

                            function y(e, t, r) {
                                return t in e ? Object.defineProperty(e, t, {
                                    value: r,
                                    enumerable: !0,
                                    configurable: !0,
                                    writable: !0
                                }) : e[t] = r, e
                            }

                            !function (e) {
                                e.VERSION = "v", e.ORIGIN = "o", e.SESSION_NAME = "s", e.INFORMATION = "i", e.URI = "u", e.EMAIL = "e", e.PHONE = "p", e.CONNECTION = "c", e.BANDWIDTH = "b", e.TIME = "t", e.REPEAT = "r", e.ZONE_ADJUSTMENTS = "z", e.KEY = "k", e.ATTRIBUTE = "a", e.MEDIA = "m"
                            }(s || (s = {}));

                            class S {
                                consumeText(e, t) {
                                    let r = t;
                                    for (; r < e.length;) {
                                        const t = e[r];
                                        if ("\0" === t || "\r" === t || t === n) break;
                                        r += 1
                                    }
                                    if (r - t == 0) throw new Error("Invalid text, at ".concat(e));
                                    return r
                                }

                                consumeUnicastAddress(e, t, r) {
                                    return this.consumeTill(e, t, o)
                                }

                                consumeOneOrMore(e, t, r) {
                                    let n = t;
                                    for (; r(e[n]);) n++;
                                    if (n - t == 0) throw new Error("Invalid rule at ".concat(t, "."));
                                    return n
                                }

                                consumeSpace(e, t) {
                                    if (e[t] === o) return t + 1;
                                    throw new Error("Invalid space at ".concat(t, "."))
                                }

                                consumeIP4Address(e, t) {
                                    let r = t;
                                    for (let t = 0; t < 4; t++) if (r = this.consumeDecimalUChar(e, r), 3 !== t) {
                                        if ("." !== e[r]) throw new Error("Invalid IP4 address.");
                                        r++
                                    }
                                    return r
                                }

                                consumeDecimalUChar(e, t) {
                                    let r = t;
                                    for (let t = 0; t < 3 && a(e[r]); t++, r++) ;
                                    if (r - t == 0) throw new Error("Invalid decimal uchar.");
                                    const n = parseInt(e.slice(t, r));
                                    if (n >= 0 && n <= 255) return r;
                                    throw new Error("Invalid decimal uchar")
                                }

                                consumeIP6Address(e, t) {
                                    let r = this.consumeHexpart(e, t);
                                    return ":" === e[r] ? (r += 1, r = this.consumeIP4Address(e, r)) : r
                                }

                                consumeHexpart(e, t) {
                                    let r = t;
                                    if (":" === e[r] && ":" === e[r + 1]) {
                                        r += 2;
                                        try {
                                            r = this.consumeHexseq(e, r)
                                        } catch (e) {
                                        }
                                        return r
                                    }
                                    if (r = this.consumeHexseq(e, r), ":" === e[r] && ":" === e[r + 1]) {
                                        r += 2;
                                        try {
                                            r = this.consumeHexseq(e, r)
                                        } catch (e) {
                                        }
                                        return r
                                    }
                                    return r
                                }

                                consumeHexseq(e, t) {
                                    let r = t;
                                    for (; r = this.consumeHex4(e, r), ":" === e[r] && ":" !== e[r + 1];) r += 1;
                                    return r
                                }

                                consumeHex4(e, t) {
                                    let r = 0;
                                    for (; r < 4; r++) if (!((n = e[t + r]) >= "0" && n <= "9" || n >= "a" && n <= "f" || n >= "A" && n <= "F")) {
                                        if (0 === r) throw new Error("Invalid hex 4");
                                        break
                                    }
                                    var n;
                                    return t + r
                                }

                                consumeFQDN(e, t) {
                                    let r = t;
                                    for (; a(e[r]) || h(e[r]) || "-" === e[r] || "." === e[r];) r += 1;
                                    if (r - t < 4) throw new Error("Invalid FQDN");
                                    return r
                                }

                                consumeExtnAddr(e, t) {
                                    return this.consumeOneOrMore(e, t, u)
                                }

                                consumeMulticastAddress(e, t, r) {
                                    switch (r) {
                                        case"IP4":
                                        case"ip4":
                                            return this.consumeIP4MulticastAddress(e, t);
                                        case"IP6":
                                        case"ip6":
                                            return this.consumeIP6MulticastAddress(e, t);
                                        default:
                                            try {
                                                return this.consumeFQDN(e, t)
                                            } catch (r) {
                                                return this.consumeExtnAddr(e, t)
                                            }
                                    }
                                }

                                consumeIP6MulticastAddress(e, t) {
                                    const r = this.consumeHexpart(e, t);
                                    return "/" === e[r] ? this.consumeInteger(e, r + 1) : r
                                }

                                consumeIP4MulticastAddress(e, t) {
                                    let r = t + 3;
                                    const n = e.slice(t, r), i = parseInt(n);
                                    if (i < 224 || i > 239) throw new Error("Invalid IP4 multicast address, IPv4 multicast addresses may be in the range 224.0.0.0 to 239.255.255.255.");
                                    for (let t = 0; t < 3; t++) {
                                        if ("." !== e[r]) throw new Error("Invalid IP4 multicast address.");
                                        r += 1, r = this.consumeDecimalUChar(e, r)
                                    }
                                    return "/" === e[r] && (r += 1), r = this.consumeTTL(e, r), "/" === e[r] && (r = this.consumeInteger(e, r)), r
                                }

                                consumeInteger(e, t) {
                                    if (!l(e[t])) throw new Error("Invalid integer.");
                                    for (t += 1; a(e[t]);) t += 1;
                                    return t
                                }

                                consumeTTL(e, t) {
                                    if ("0" === e[t]) return t + 1;
                                    if (!l(e[t])) throw new Error("Invalid TTL.");
                                    t += 1;
                                    for (let r = 0; r < 2 && a(e[t]); r++) t += 1;
                                    return t
                                }

                                consumeToken(e, t) {
                                    return this.consumeOneOrMore(e, t, d)
                                }

                                consumeTime(e, t) {
                                    let r = t;
                                    if ("0" === e[r]) return r + 1;
                                    for (l(e[r]) && (r += 1); a(e[r]);) r++;
                                    if (r - t < 10) throw new Error("Invalid time");
                                    return r
                                }

                                consumeAddress(e, t) {
                                    return this.consumeTill(e, t, o)
                                }

                                consumeTypedTime(e, t) {
                                    let r = t;
                                    return r = this.consumeOneOrMore(e, r, a), p(e[r]) ? r + 1 : r
                                }

                                consumeRepeatInterval(e, t) {
                                    if (!l(e[t])) throw new Error("Invalid repeat interval");
                                    for (t += 1; a(e[t]);) t += 1;
                                    return p(e[t]) && (t += 1), t
                                }

                                consumePort(e, t) {
                                    return this.consumeOneOrMore(e, t, a)
                                }

                                consume(e, t, r) {
                                    for (let n = 0; n < r.length; n++) {
                                        if (t + n >= e.length) throw new Error("consume exceeding value length");
                                        if (e[t + n] !== r[n]) throw new Error("consume ".concat(r, " failed at ").concat(n))
                                    }
                                    return t + r.length
                                }

                                consumeTill(e, t, r) {
                                    let n = t;
                                    for (; n < e.length && ("string" != typeof r || e[n] !== r) && ("function" != typeof r || !r(e[n]));) n++;
                                    return n
                                }
                            }

                            class b extends S {
                                constructor() {
                                    super(), y(this, "records", []), y(this, "currentLine", 0)
                                }

                                parse(e) {
                                    const t = this.probeEOL(e);
                                    this.records = e.split(t).filter(e => !!e.trim()).map(this.parseLine), this.currentLine = 0;
                                    const r = this.parseVersion(), n = this.parseOrigin(), i = this.parseSessionName(),
                                        o = this.parseInformation(), s = this.parseUri(), a = this.parseEmail(),
                                        c = this.parsePhone(), u = this.parseConnection(), d = this.parseBandWidth(),
                                        l = this.parseTimeFields(), h = this.parseKey(),
                                        p = this.parseSessionAttribute(), f = this.parseMediaDescription();
                                    if (this.currentLine !== this.records.length) throw new Error("parsing failed, non exhaustive sdp lines.");
                                    return {
                                        version: r,
                                        origin: n,
                                        sessionName: i,
                                        information: o,
                                        uri: s,
                                        emails: a,
                                        phones: c,
                                        connection: u,
                                        bandwidths: d,
                                        timeFields: l,
                                        key: h,
                                        attributes: p,
                                        mediaDescriptions: f
                                    }
                                }

                                getCurrentRecord() {
                                    const e = this.records[this.currentLine];
                                    if (!e) throw new Error("Record doesn't exit.");
                                    return e
                                }

                                probeEOL(e) {
                                    for (let t = 0; t < e.length; t++) if (e[t] === n) return "\r" === e[t - 1] ? i : n;
                                    throw new Error("Invalid newline character.")
                                }

                                parseLine(e, t) {
                                    if (e.length < 2) throw new Error("Invalid sdp line, sdp line should be of form <type>=<value>.");
                                    const r = e[0];
                                    if ("=" !== e[1]) throw new Error('Invalid sdp line, <type> should be a single character followed by an "=" sign.');
                                    return {type: r, value: e.slice(2), line: t, cur: 0}
                                }

                                parseSessionAttribute() {
                                    const e = new R;
                                    for (; this.currentLine < this.records.length;) {
                                        const t = this.getCurrentRecord();
                                        if (t.type !== s.ATTRIBUTE) break;
                                        const r = {attField: this.extractOneOrMore(t, e => d(e) && ":" !== e), _cur: 0};
                                        ":" === t.value[t.cur] && (t.cur += 1, r.attValue = this.extractOneOrMore(t, f)), e.parse(r), this.currentLine++
                                    }
                                    return e.digest()
                                }

                                parseMediaAttributes(e) {
                                    const t = new I(e);
                                    for (; this.currentLine < this.records.length;) {
                                        const e = this.getCurrentRecord();
                                        if (e.type !== s.ATTRIBUTE) break;
                                        const r = {attField: this.extractOneOrMore(e, e => d(e) && ":" !== e), _cur: 0};
                                        ":" === e.value[e.cur] && (e.cur += 1, r.attValue = this.extractOneOrMore(e, f)), t.parse(r), this.currentLine++
                                    }
                                    return t.digest()
                                }

                                parseKey() {
                                    const e = this.getCurrentRecord();
                                    if (e.type === s.KEY) {
                                        if ("prompt" === e.value || "clear:" === e.value || "base64:" === e.value || "uri:" === e.value) return e.value;
                                        throw this.currentLine++, new Error("Invalid key.")
                                    }
                                }

                                parseZone() {
                                    const e = this.getCurrentRecord();
                                    if (e.type === s.ZONE_ADJUSTMENTS) {
                                        const t = [];
                                        for (; ;) try {
                                            const r = this.extract(e, this.consumeTime);
                                            this.consumeSpaceForRecord(e);
                                            let n = !1;
                                            "-" === e.value[e.cur] && (n = !0, e.cur += 1);
                                            const i = this.extract(e, this.consumeTypedTime);
                                            t.push({time: r, typedTime: i, back: n})
                                        } catch (e) {
                                            break
                                        }
                                        if (0 === t.length) throw new Error("Invalid zone adjustments");
                                        return this.currentLine++, t
                                    }
                                    return []
                                }

                                parseRepeat() {
                                    const e = [];
                                    for (; ;) {
                                        const t = this.getCurrentRecord();
                                        if (t.type !== s.REPEAT) break;
                                        {
                                            const r = this.extract(t, this.consumeRepeatInterval),
                                                n = this.parseTypedTime(t);
                                            e.push({repeatInterval: r, typedTimes: n}), this.currentLine++
                                        }
                                    }
                                    return e
                                }

                                parseTypedTime(e) {
                                    const t = [];
                                    for (; ;) try {
                                        this.consumeSpaceForRecord(e), t.push(this.extract(e, this.consumeTypedTime))
                                    } catch (e) {
                                        break
                                    }
                                    if (0 === t.length) throw new Error("Invalid typed time.");
                                    return t
                                }

                                parseTime() {
                                    const e = this.getCurrentRecord(), t = this.extract(e, this.consumeTime);
                                    this.consumeSpaceForRecord(e);
                                    const r = this.extract(e, this.consumeTime);
                                    return this.currentLine++, {startTime: t, stopTime: r}
                                }

                                parseBandWidth() {
                                    const e = [];
                                    for (; this.currentLine < this.records.length;) {
                                        const t = this.getCurrentRecord();
                                        if (t.type !== s.BANDWIDTH) break;
                                        {
                                            const r = this.extractOneOrMore(t, d);
                                            if (":" !== t.value[t.cur]) throw new Error("Invalid bandwidth field.");
                                            t.cur++;
                                            const n = this.extractOneOrMore(t, a);
                                            e.push({bwtype: r, bandwidth: n}), this.currentLine++
                                        }
                                    }
                                    return e
                                }

                                parseVersion() {
                                    const e = this.getCurrentRecord();
                                    if (e.type !== s.VERSION) throw new Error("first sdp record must be version");
                                    const t = e.value.slice(0, this.consumeOneOrMore(e.value, 0, a));
                                    if (t.length !== e.value.length) throw new Error('invalid proto version, "v='.concat(e.value, '"'));
                                    return this.currentLine++, t
                                }

                                parseOrigin() {
                                    const e = this.getCurrentRecord();
                                    if (e.type !== s.ORIGIN) throw new Error("second line of sdp must be origin");
                                    const t = this.extractOneOrMore(e, u);
                                    this.consumeSpaceForRecord(e);
                                    const r = this.extractOneOrMore(e, a);
                                    this.consumeSpaceForRecord(e);
                                    const n = this.extractOneOrMore(e, a);
                                    this.consumeSpaceForRecord(e);
                                    const i = this.extractOneOrMore(e, d);
                                    this.consumeSpaceForRecord(e);
                                    const o = this.extractOneOrMore(e, d);
                                    this.consumeSpaceForRecord(e);
                                    const c = this.extract(e, this.consumeUnicastAddress);
                                    return this.currentLine++, {
                                        username: t,
                                        sessId: r,
                                        sessVersion: n,
                                        nettype: i,
                                        addrtype: o,
                                        unicastAddress: c
                                    }
                                }

                                parseSessionName() {
                                    const e = this.getCurrentRecord();
                                    if (e.type === s.SESSION_NAME) {
                                        const t = this.extract(e, this.consumeText);
                                        return this.currentLine++, t
                                    }
                                }

                                parseInformation() {
                                    const e = this.getCurrentRecord();
                                    if (e.type !== s.INFORMATION) return;
                                    const t = this.extract(e, this.consumeText);
                                    return this.currentLine++, t
                                }

                                parseUri() {
                                    const e = this.getCurrentRecord();
                                    if (e.type === s.URI) return this.currentLine++, e.value
                                }

                                parseEmail() {
                                    const e = [];
                                    for (; ;) {
                                        const t = this.getCurrentRecord();
                                        if (t.type !== s.EMAIL) break;
                                        e.push(t.value), this.currentLine++
                                    }
                                    return e
                                }

                                parsePhone() {
                                    const e = [];
                                    for (; ;) {
                                        const t = this.getCurrentRecord();
                                        if (t.type !== s.PHONE) break;
                                        e.push(t.value), this.currentLine++
                                    }
                                    return e
                                }

                                parseConnection() {
                                    const e = this.getCurrentRecord();
                                    if (e.type === s.CONNECTION) {
                                        const t = this.extractOneOrMore(e, d);
                                        this.consumeSpaceForRecord(e);
                                        const r = this.extractOneOrMore(e, d);
                                        this.consumeSpaceForRecord(e);
                                        const n = this.extract(e, this.consumeAddress);
                                        return this.currentLine++, {nettype: t, addrtype: r, address: n}
                                    }
                                }

                                parseMedia() {
                                    const e = this.getCurrentRecord(), t = this.extract(e, this.consumeToken);
                                    this.consumeSpaceForRecord(e);
                                    let r = this.extract(e, this.consumePort);
                                    "/" === e.value[e.cur] && (e.cur += 1, r += this.extract(e, this.consumeInteger)), this.consumeSpaceForRecord(e);
                                    const n = [];
                                    for (n.push(this.extract(e, this.consumeToken)); "/" === e.value[e.cur];) e.cur += 1, n.push(this.extract(e, this.consumeToken));
                                    if (0 === n.length) throw new Error("Invalid proto");
                                    const i = this.parseFmt(e);
                                    return this.currentLine++, {mediaType: t, port: r, protos: n, fmts: i}
                                }

                                parseTimeFields() {
                                    const e = [];
                                    for (; this.getCurrentRecord().type === s.TIME;) {
                                        const t = this.parseTime(), r = this.parseRepeat(), n = this.parseZone();
                                        e.push({time: t, repeats: r, zones: n})
                                    }
                                    return e
                                }

                                parseMediaDescription() {
                                    const e = [];
                                    for (; this.currentLine < this.records.length && this.getCurrentRecord().type === s.MEDIA;) {
                                        const t = this.parseMedia(), r = this.parseInformation(),
                                            n = this.parseConnections(), i = this.parseBandWidth(), o = this.parseKey(),
                                            s = this.parseMediaAttributes(t);
                                        e.push({
                                            media: t,
                                            information: r,
                                            connections: n,
                                            bandwidths: i,
                                            key: o,
                                            attributes: s
                                        })
                                    }
                                    return e
                                }

                                parseConnections() {
                                    const e = [];
                                    for (; this.currentLine < this.records.length && this.getCurrentRecord().type === s.CONNECTION;) e.push(this.parseConnection());
                                    return e
                                }

                                parseFmt(e) {
                                    const t = [];
                                    for (; ;) try {
                                        this.consumeSpaceForRecord(e), t.push(this.extract(e, this.consumeToken))
                                    } catch (e) {
                                        break
                                    }
                                    if (0 === t.length) throw new Error("Invalid fmts");
                                    return t
                                }

                                extract(e, t, ...r) {
                                    const n = t.call(this, e.value, e.cur, ...r), i = e.value.slice(e.cur, n);
                                    return e.cur = n, i
                                }

                                extractOneOrMore(e, t) {
                                    const r = this.consumeOneOrMore(e.value, e.cur, t), n = e.value.slice(e.cur, r);
                                    return e.cur = r, n
                                }

                                consumeSpaceForRecord(e) {
                                    if (e.value[e.cur] !== o) throw new Error("Invalid space at ".concat(e.cur, "."));
                                    e.cur += 1
                                }
                            }

                            class T extends S {
                                constructor(...e) {
                                    super(...e), y(this, "attributes", void 0), y(this, "digested", !1)
                                }

                                extractOneOrMore(e, t, r) {
                                    const n = this.consumeOneOrMore(e.attValue, e._cur, t),
                                        i = e.attValue.slice(e._cur, n), [o, s] = r || [];
                                    if ("number" == typeof o && i.length < o) throw new Error("error in length, should be more or equal than ".concat(o, " characters."));
                                    if ("number" == typeof s && i.length > s) throw new Error("error in length, should be less or equal than ".concat(s, " characters."));
                                    return e._cur = n, i
                                }

                                consumeAttributeSpace(e) {
                                    if (e.attValue[e._cur] !== o) throw new Error("Invalid space at ".concat(e._cur, "."));
                                    e._cur += 1
                                }

                                extract(e, t, ...r) {
                                    if (!e.attValue) throw new Error("Nothing to extract from attValue.");
                                    const n = t.call(this, e.attValue, e._cur, ...r), i = e.attValue.slice(e._cur, n);
                                    return e._cur = n, i
                                }

                                atEnd(e) {
                                    if (!e.attValue) throw new Error;
                                    return e._cur >= e.attValue.length
                                }

                                peekChar(e) {
                                    if (!e.attValue) throw new Error;
                                    return e.attValue[e._cur]
                                }

                                peek(e, t) {
                                    if (!e.attValue) throw new Error;
                                    for (let r = 0; r < t.length; r++) if (t[r] !== e.attValue[e._cur + r]) return !1;
                                    return !0
                                }

                                parseIceUfrag(e) {
                                    if (this.attributes.iceUfrag) throw new Error("Invalid ice-ufrag, should be only a single line if 'a=ice-ufrag'");
                                    this.attributes.iceUfrag = this.extractOneOrMore(e, m, [4, 256])
                                }

                                parseIcePwd(e) {
                                    if (this.attributes.icePwd) throw new Error("Invalid ice-pwd, should be only a single line if 'a=ice-pwd'");
                                    this.attributes.icePwd = this.extractOneOrMore(e, m, [22, 256])
                                }

                                parseIceOptions(e) {
                                    if (this.attributes.iceOptions) throw new Error("Invalid ice-options, should be only one 'ice-options' line");
                                    const t = [];
                                    for (; !this.atEnd(e);) {
                                        t.push(this.extractOneOrMore(e, m));
                                        try {
                                            this.consumeAttributeSpace(e)
                                        } catch (t) {
                                            if (this.atEnd(e)) break;
                                            throw t
                                        }
                                    }
                                    this.attributes.iceOptions = t
                                }

                                parseFingerprint(e) {
                                    const t = this.extract(e, this.consumeToken);
                                    this.consumeAttributeSpace(e);
                                    const r = this.extract(e, this.consumeTill);
                                    this.attributes.fingerprints.push({hashFunction: t, fingerprint: r})
                                }

                                parseExtmap(e) {
                                    const t = this.extractOneOrMore(e, a);
                                    let r;
                                    "/" === this.peekChar(e) && (this.extract(e, this.consume, "/"), r = this.extract(e, this.consumeToken)), this.consumeAttributeSpace(e);
                                    const n = this.extract(e, this.consumeTill, o),
                                        i = E(E({entry: parseInt(t, 10)}, r && {direction: r}), {}, {extensionName: n});
                                    this.peekChar(e) === o && (this.consumeAttributeSpace(e), i.extensionAttributes = this.extract(e, this.consumeTill)), this.attributes.extmaps.push(i)
                                }

                                parseSetup(e) {
                                    if (this.attributes.setup) throw new Error("must only be one single 'a=setup' line.");
                                    const t = this.extract(e, this.consumeTill);
                                    if ("active" !== t && "passive" !== t && "actpass" !== t && "holdconn" !== t) throw new Error("role must be one of 'active', 'passive', 'actpass', 'holdconn'.");
                                    this.attributes.setup = t
                                }
                            }

                            class R extends T {
                                constructor(...e) {
                                    super(...e), y(this, "attributes", {
                                        unrecognized: [],
                                        groups: [],
                                        extmaps: [],
                                        fingerprints: [],
                                        identities: []
                                    })
                                }

                                parse(e) {
                                    if (this.digested) throw new Error("already digested");
                                    try {
                                        switch (e.attField) {
                                            case"group":
                                                this.parseGroup(e);
                                                break;
                                            case"ice-lite":
                                                this.parseIceLite();
                                                break;
                                            case"ice-ufrag":
                                                this.parseIceUfrag(e);
                                                break;
                                            case"ice-pwd":
                                                this.parseIcePwd(e);
                                                break;
                                            case"ice-options":
                                                this.parseIceOptions(e);
                                                break;
                                            case"fingerprint":
                                                this.parseFingerprint(e);
                                                break;
                                            case"setup":
                                                this.parseSetup(e);
                                                break;
                                            case"tls-id":
                                                this.parseTlsId(e);
                                                break;
                                            case"identity":
                                                this.parseIdentity(e);
                                                break;
                                            case"extmap":
                                                this.parseExtmap(e);
                                                break;
                                            case"msid-semantic":
                                                this.parseMsidSemantic(e);
                                                break;
                                            default:
                                                e.ignored = !0, this.attributes.unrecognized.push(e)
                                        }
                                    } catch (t) {
                                        throw console.error("parsing session attribute ".concat(e.attField, ' error, "a=').concat(e.attField, ":").concat(e.attValue, '"')), t
                                    }
                                    if (!e.ignored && e.attValue && !this.atEnd(e)) throw new Error("attribute parsing error")
                                }

                                digest() {
                                    return this.digested = !0, this.attributes
                                }

                                parseGroup(e) {
                                    const t = this.extract(e, this.consumeToken), r = [];
                                    for (; !this.atEnd(e) && this.peekChar(e) === o;) this.consumeAttributeSpace(e), r.push(this.extract(e, this.consumeToken));
                                    this.attributes.groups.push({semantic: t, identificationTag: r})
                                }

                                parseIceLite() {
                                    if (this.attributes.iceLite) throw new Error("Invalid ice-lite, should be only a single line of 'a=ice-lite'");
                                    this.attributes.iceLite = !0
                                }

                                parseTlsId(e) {
                                    if (this.attributes.tlsId) throw new Error("must be only one tld-id line");
                                    this.attributes.tlsId = this.extractOneOrMore(e, _)
                                }

                                parseIdentity(e) {
                                    const t = this.extractOneOrMore(e, v), r = [];
                                    for (; !this.atEnd(e) && this.peekChar(e) === o;) {
                                        this.consumeAttributeSpace(e);
                                        const t = this.extract(e, this.consumeToken);
                                        this.extract(e, this.consume, "=");
                                        const n = this.extractOneOrMore(e, e => e !== o && f(e));
                                        r.push({name: t, value: n})
                                    }
                                    this.attributes.identities.push({assertionValue: t, extensions: r})
                                }

                                parseMsidSemantic(e) {
                                    this.peekChar(e) === o && this.consumeAttributeSpace(e);
                                    const t = {semantic: this.extract(e, this.consumeToken), identifierList: []};
                                    for (; ;) {
                                        try {
                                            this.consumeAttributeSpace(e)
                                        } catch (e) {
                                            break
                                        }
                                        if ("*" === this.peekChar(e)) {
                                            this.extract(e, this.consume, "*"), t.applyForAll = !0;
                                            break
                                        }
                                        {
                                            const r = this.extract(e, this.consumeTill, o);
                                            t.identifierList.push(r)
                                        }
                                    }
                                    this.attributes.msidSemantic = t
                                }
                            }

                            class I extends T {
                                constructor(e) {
                                    super(), y(this, "attributes", void 0), -1 !== e.protos.indexOf("RTP") || e.protos.indexOf("rtp"), this.attributes = {
                                        unrecognized: [],
                                        candidates: [],
                                        extmaps: [],
                                        fingerprints: [],
                                        imageattr: [],
                                        msids: [],
                                        remoteCandidatesList: [],
                                        rids: [],
                                        ssrcs: [],
                                        ssrcGroups: [],
                                        rtcpFeedbackWildcards: [],
                                        payloads: []
                                    }
                                }

                                parse(e) {
                                    if (this.digested) throw new Error("already digested");
                                    try {
                                        switch (e.attField) {
                                            case"extmap":
                                                this.parseExtmap(e);
                                                break;
                                            case"setup":
                                                this.parseSetup(e);
                                                break;
                                            case"ice-ufrag":
                                                this.parseIceUfrag(e);
                                                break;
                                            case"ice-pwd":
                                                this.parseIcePwd(e);
                                                break;
                                            case"ice-options":
                                                this.parseIceOptions(e);
                                                break;
                                            case"candidate":
                                                this.parseCandidate(e);
                                                break;
                                            case"remote-candidate":
                                                this.parseRemoteCandidate(e);
                                                break;
                                            case"end-of-candidates":
                                                this.parseEndOfCandidates();
                                                break;
                                            case"fingerprint":
                                                this.parseFingerprint(e);
                                                break;
                                            case"rtpmap":
                                                this.parseRtpmap(e);
                                                break;
                                            case"ptime":
                                                this.parsePtime(e);
                                                break;
                                            case"maxptime":
                                                this.parseMaxPtime(e);
                                                break;
                                            case"sendrecv":
                                            case"recvonly":
                                            case"sendonly":
                                            case"inactive":
                                                this.parseDirection(e);
                                                break;
                                            case"ssrc":
                                                this.parseSSRC(e);
                                                break;
                                            case"fmtp":
                                                this.parseFmtp(e);
                                                break;
                                            case"rtcp-fb":
                                                this.parseRtcpFb(e);
                                                break;
                                            case"rtcp-mux":
                                                this.parseRTCPMux();
                                                break;
                                            case"rtcp-mux-only":
                                                this.parseRTCPMuxOnly();
                                                break;
                                            case"rtcp-rsize":
                                                this.parseRTCPRsize();
                                                break;
                                            case"rtcp":
                                                this.parseRTCP(e);
                                                break;
                                            case"mid":
                                                this.parseMid(e);
                                                break;
                                            case"msid":
                                                this.parseMsid(e);
                                                break;
                                            case"imageattr":
                                                this.parseImageAttr(e);
                                                break;
                                            case"rid":
                                                this.parseRid(e);
                                                break;
                                            case"simulcast":
                                                this.parseSimulcast(e);
                                                break;
                                            case"sctp-port":
                                                this.parseSctpPort(e);
                                                break;
                                            case"max-message-size":
                                                this.parseMaxMessageSize(e);
                                                break;
                                            case"ssrc-group":
                                                this.parseSSRCGroup(e);
                                                break;
                                            default:
                                                e.ignored = !0, this.attributes.unrecognized.push(e)
                                        }
                                    } catch (t) {
                                        throw console.error("parsing media attribute ".concat(e.attField, ' error, "a=').concat(e.attField, ":").concat(e.attValue, '"')), t
                                    }
                                    if (!e.ignored && e.attValue && !this.atEnd(e)) throw new Error("attribute parsing error")
                                }

                                parseCandidate(e) {
                                    const t = this.extractOneOrMore(e, m, [1, 32]);
                                    this.consumeAttributeSpace(e);
                                    const r = this.extractOneOrMore(e, a, [1, 5]);
                                    this.consumeAttributeSpace(e);
                                    const n = this.extract(e, this.consumeToken);
                                    this.consumeAttributeSpace(e);
                                    const i = this.extractOneOrMore(e, a, [1, 10]);
                                    this.consumeAttributeSpace(e);
                                    const s = this.extract(e, this.consumeAddress);
                                    this.consumeAttributeSpace(e);
                                    const u = this.extract(e, this.consumePort);
                                    this.consumeAttributeSpace(e), this.extract(e, this.consume, "typ"), this.consumeAttributeSpace(e);
                                    const d = {
                                        foundation: t,
                                        componentId: r,
                                        transport: n,
                                        priority: i,
                                        connectionAddress: s,
                                        port: u,
                                        type: this.extract(e, this.consumeToken),
                                        extension: {}
                                    };
                                    for (this.peek(e, " raddr") && (this.extract(e, this.consume, " raddr"), this.consumeAttributeSpace(e), d.relAddr = this.extract(e, this.consumeAddress)), this.peek(e, " rport") && (this.extract(e, this.consume, " rport"), this.consumeAttributeSpace(e), d.relPort = this.extract(e, this.consumePort)); this.peekChar(e) === o;) {
                                        this.consumeAttributeSpace(e);
                                        const t = this.extract(e, this.consumeToken);
                                        this.consumeAttributeSpace(e), d.extension[t] = this.extractOneOrMore(e, c)
                                    }
                                    this.attributes.candidates.push(d)
                                }

                                parseRemoteCandidate(e) {
                                    const t = [];
                                    for (; ;) {
                                        const r = this.extractOneOrMore(e, a, [1, 5]);
                                        this.consumeAttributeSpace(e);
                                        const n = this.extract(e, this.consumeAddress);
                                        this.consumeAttributeSpace(e);
                                        const i = this.extract(e, this.consumePort);
                                        t.push({componentId: r, connectionAddress: n, port: i});
                                        try {
                                            this.consumeAttributeSpace(e)
                                        } catch (e) {
                                            break
                                        }
                                    }
                                    this.attributes.remoteCandidatesList.push(t)
                                }

                                parseEndOfCandidates() {
                                    if (this.attributes.endOfCandidates) throw new Error("must be only one line of end-of-candidates");
                                    this.attributes.endOfCandidates = !0
                                }

                                parseRtpmap(e) {
                                    const t = this.extract(e, this.consumeToken);
                                    this.consumeAttributeSpace(e);
                                    const r = this.extract(e, this.consumeTill, "/");
                                    this.extract(e, this.consume, "/");
                                    const n = {encodingName: r, clockRate: this.extractOneOrMore(e, a)};
                                    this.atEnd(e) || "/" !== this.peekChar(e) || (this.extract(e, this.consume, "/"), n.encodingParameters = parseInt(this.extract(e, this.consumeTill), 10));
                                    const i = this.attributes.payloads.find(e => e.payloadType === parseInt(t, 10));
                                    i ? i.rtpMap = n : this.attributes.payloads.push({
                                        payloadType: parseInt(t, 10),
                                        rtpMap: n,
                                        rtcpFeedbacks: []
                                    })
                                }

                                parsePtime(e) {
                                    if (this.attributes.ptime) throw new Error("must be only one line of ptime");
                                    this.attributes.ptime = this.extract(e, this.consumeTill)
                                }

                                parseMaxPtime(e) {
                                    if (this.attributes.maxPtime) throw new Error("must be only one line of ptime");
                                    this.attributes.maxPtime = this.extract(e, this.consumeTill)
                                }

                                parseDirection(e) {
                                    if (this.attributes.direction) throw new Error("must be only one line of direction info");
                                    this.attributes.direction = e.attField
                                }

                                parseSSRC(e) {
                                    const t = this.extractOneOrMore(e, a);
                                    this.consumeAttributeSpace(e);
                                    const r = this.extract(e, this.consumeTill, ":");
                                    let n;
                                    ":" === this.peekChar(e) && (this.extract(e, this.consume, ":"), n = this.extract(e, this.consumeTill));
                                    const i = this.attributes.ssrcs.find(e => e.ssrcId === parseInt(t, 10));
                                    i ? i.attributes[r] = n : this.attributes.ssrcs.push({
                                        ssrcId: parseInt(t, 10),
                                        attributes: {[r]: n}
                                    })
                                }

                                parseFmtp(e) {
                                    const t = this.extract(e, this.consumeTill, o);
                                    this.consumeAttributeSpace(e);
                                    const r = this.extract(e, this.consumeTill), n = {};
                                    r.split(";").forEach(e => {
                                        let [t, r] = e.split("=");
                                        t = t.trim();
                                        const i = "string" == typeof r ? r.trim() : null;
                                        "string" == typeof t && t.length > 0 && (n[t] = i)
                                    });
                                    const i = this.attributes.payloads.find(e => e.payloadType === parseInt(t, 10));
                                    i ? i.fmtp = {parameters: n} : this.attributes.payloads.push({
                                        payloadType: parseInt(t, 10),
                                        rtcpFeedbacks: [],
                                        fmtp: {parameters: n}
                                    })
                                }

                                parseFmtParameters(e) {
                                    const t = {}, r = this.extract(e, this.consumeTill, "=");
                                    e._cur++;
                                    const n = this.extract(e, this.consumeTill, ";");
                                    for (t[r] = n; ";" === e.attValue[e._cur];) {
                                        const r = this.extract(e, this.consumeTill, "=");
                                        e._cur++;
                                        const n = this.extract(e, this.consumeTill, ";");
                                        t[r] = n
                                    }
                                    return t
                                }

                                parseRtcpFb(e) {
                                    let t = "";
                                    t = "*" === this.peekChar(e) ? this.extract(e, this.consume, "*") : this.extract(e, this.consumeTill, o), this.consumeAttributeSpace(e);
                                    const r = this.extract(e, this.consumeTill, o);
                                    let n;
                                    switch (r) {
                                        case"trr-int":
                                            n = {type: r, interval: this.extract(e, this.consumeTill)};
                                            break;
                                        case"ack":
                                        case"nack":
                                        default: {
                                            const t = {type: r};
                                            this.peekChar(e) === o && (this.consumeAttributeSpace(e), t.parameter = this.extract(e, this.consumeToken), this.peekChar(e) === o && (t.additional = this.extract(e, this.consumeTill))), n = t
                                        }
                                    }
                                    if ("*" === t) this.attributes.rtcpFeedbackWildcards.push(n); else {
                                        const e = this.attributes.payloads.find(e => e.payloadType === parseInt(t, 10));
                                        e ? e.rtcpFeedbacks.push(n) : this.attributes.payloads.push({
                                            payloadType: parseInt(t, 10),
                                            rtcpFeedbacks: [n]
                                        })
                                    }
                                }

                                parseRTCPMux() {
                                    if (this.attributes.rtcpMux) throw new Error("must be single line of rtcp-mux");
                                    this.attributes.rtcpMux = !0
                                }

                                parseRTCPMuxOnly() {
                                    if (this.attributes.rtcpMuxOnly) throw new Error("must be single line of rtcp-only");
                                    this.attributes.rtcpMuxOnly = !0
                                }

                                parseRTCPRsize() {
                                    if (this.attributes.rtcpRsize) throw new Error("must be single line of rtcp-rsize");
                                    this.attributes.rtcpRsize = !0
                                }

                                parseRTCP(e) {
                                    if (this.attributes.rtcp) throw new Error("must be single line of rtcp");
                                    const t = {port: this.extract(e, this.consumePort)};
                                    this.peekChar(e) === o && (this.consumeAttributeSpace(e), t.netType = this.extractOneOrMore(e, d), this.consumeAttributeSpace(e), t.addressType = this.extractOneOrMore(e, d), this.consumeAttributeSpace(e), t.address = this.extract(e, this.consumeAddress)), this.attributes.rtcp = t
                                }

                                parseMsid(e) {
                                    const t = {id: this.extractOneOrMore(e, d, [1, 64])};
                                    this.peekChar(e) === o && (this.consumeAttributeSpace(e), t.appdata = this.extractOneOrMore(e, d, [1, 64])), this.attributes.msids.push(t)
                                }

                                parseImageAttr(e) {
                                    this.attributes.imageattr.push(e.attValue)
                                }

                                parseRid(e) {
                                    const t = this.extractOneOrMore(e, e => h(e) || a(e) || "_" === e || "-" === e);
                                    this.consumeAttributeSpace(e);
                                    const r = {id: t, direction: this.extract(e, this.consumeToken), params: []};
                                    if (this.peekChar(e) === o) {
                                        if (this.consumeAttributeSpace(e), this.peek(e, "pt=")) {
                                            this.extract(e, this.consume, "pt=");
                                            const t = [];
                                            for (; ;) {
                                                const r = this.extract(e, this.consumeToken);
                                                t.push(r);
                                                try {
                                                    this.extract(e, this.consume, ",")
                                                } catch (e) {
                                                    break
                                                }
                                            }
                                            r.payloads = t, this.peekChar(e) === o && this.extract(e, this.consume, o)
                                        }
                                        for (; ;) {
                                            const t = this.extract(e, this.consumeToken);
                                            switch (t) {
                                                case"depend": {
                                                    const n = {
                                                        type: t,
                                                        rids: this.extract(e, this.consume, "=").split(",")
                                                    };
                                                    r.params.push(n);
                                                    break
                                                }
                                                case"max-width":
                                                case"height-width":
                                                case"max-fps":
                                                case"max-fs":
                                                case"max-br":
                                                case"max-pps":
                                                case"max-bpp":
                                                default: {
                                                    const n = {type: t};
                                                    "=" === this.peekChar(e) && (this.extract(e, this.consume, "="), n.val = this.extract(e, this.consumeTill, ";")), r.params.push(n)
                                                }
                                            }
                                            try {
                                                this.extract(e, this.consume, ";")
                                            } catch (e) {
                                                break
                                            }
                                        }
                                    }
                                    this.attributes.rids.push(r)
                                }

                                parseSimulcast(e) {
                                    if (this.attributes.simulcast) throw new Error("must be single line of simulcast");
                                    this.attributes.simulcast = e.attValue, this.extract(e, this.consumeTill)
                                }

                                parseSctpPort(e) {
                                    this.attributes.sctpPort = this.extractOneOrMore(e, a, [1, 5])
                                }

                                parseMaxMessageSize(e) {
                                    this.attributes.maxMessageSize = this.extractOneOrMore(e, a, [1, void 0])
                                }

                                digest() {
                                    return this.digested = !0, this.attributes
                                }

                                parseMid(e) {
                                    this.attributes.mid = this.extract(e, this.consumeToken)
                                }

                                parseSSRCGroup(e) {
                                    const t = this.extract(e, this.consumeToken), r = [];
                                    for (; ;) try {
                                        this.consumeAttributeSpace(e);
                                        const t = this.extract(e, this.consumeInteger);
                                        r.push(parseInt(t, 10))
                                    } catch (e) {
                                        break
                                    }
                                    this.attributes.ssrcGroups.push({semantic: t, ssrcIds: r})
                                }
                            }

                            function w(e, t, r) {
                                return t in e ? Object.defineProperty(e, t, {
                                    value: r,
                                    enumerable: !0,
                                    configurable: !0,
                                    writable: !0
                                }) : e[t] = r, e
                            }

                            class C {
                                constructor() {
                                    w(this, "eol", i)
                                }

                                print(e, t) {
                                    let r = "";
                                    return t && (this.eol = t), r += this.printVersion(e.version), r += this.printOrigin(e.origin), r += this.printSessionName(e.sessionName), r += this.printInformation(e.information), r += this.printUri(e.uri), r += this.printEmail(e.emails), r += this.printPhone(e.phones), r += this.printConnection(e.connection), r += this.printBandwidth(e.bandwidths), r += this.printTimeFields(e.timeFields), r += this.printKey(e.key), r += this.printSessionAttributes(e.attributes), r += this.printMediaDescription(e.mediaDescriptions)
                                }

                                printVersion(e) {
                                    return "v=".concat(e).concat(this.eol)
                                }

                                printOrigin(e) {
                                    return "o=".concat(e.username, " ").concat(e.sessId, " ").concat(e.sessVersion, " ").concat(e.nettype, " ").concat(e.addrtype, " ").concat(e.unicastAddress).concat(this.eol)
                                }

                                printSessionName(e) {
                                    return e ? "s=".concat(e).concat(this.eol) : ""
                                }

                                printInformation(e) {
                                    return e ? "i=".concat(e).concat(this.eol) : ""
                                }

                                printUri(e) {
                                    return e ? "u=".concat(e).concat(this.eol) : ""
                                }

                                printEmail(e) {
                                    let t = "";
                                    for (const r of e) t += "e=".concat(r).concat(this.eol);
                                    return t
                                }

                                printPhone(e) {
                                    let t = "";
                                    for (const r of e) t += "e=".concat(r).concat(this.eol);
                                    return t
                                }

                                printConnection(e) {
                                    return e ? "c=".concat(e.nettype, " ").concat(e.addrtype, " ").concat(e.address).concat(this.eol) : ""
                                }

                                printBandwidth(e) {
                                    let t = "";
                                    for (const r of e) t += "b=".concat(r.bwtype, ":").concat(r.bandwidth).concat(this.eol);
                                    return t
                                }

                                printTimeFields(e) {
                                    let t = "";
                                    for (const r of e) {
                                        t += "t=".concat(r.time.startTime, " ").concat(r.time.startTime).concat(this.eol);
                                        for (const e of r.repeats) t += "r=".concat(e.repeatInterval, " ").concat(e.typedTimes.join(" ")).concat(this.eol);
                                        r.zoneAdjustments && (t += "z=", t += "z=".concat(r.zoneAdjustments.map(e => "".concat(e.time, " ").concat(e.back ? "-" : "", " ").concat(e.typedTime)).join(" ")).concat(this.eol), t += this.eol)
                                    }
                                    return t
                                }

                                printKey(e) {
                                    return e ? "k=".concat(e).concat(this.eol) : ""
                                }

                                printAttributes(e) {
                                    let t = "";
                                    for (const r of e) t += "a=".concat(r.attField).concat(r.attValue ? ":".concat(r.attValue) : "").concat(this.eol);
                                    return t
                                }

                                printMediaDescription(e) {
                                    let t = "";
                                    for (const r of e) t += this.printMedia(r.media), t += this.printInformation(r.information), t += this.printConnections(r.connections), t += this.printBandwidth(r.bandwidths), t += this.printKey(r.key), t += this.printMediaAttributes(r);
                                    return t
                                }

                                printConnections(e) {
                                    let t = "";
                                    for (const r of e) t += this.printConnection(r);
                                    return t
                                }

                                printMedia(e) {
                                    return "m=".concat(e.mediaType, " ").concat(e.port, " ").concat(e.protos.join("/"), " ").concat(e.fmts.join(" ")).concat(this.eol)
                                }

                                printSessionAttributes(e) {
                                    return new O(this.eol).print(e)
                                }

                                printMediaAttributes(e) {
                                    return new N(this.eol).print(e)
                                }
                            }

                            class A {
                                constructor(e) {
                                    w(this, "eol", void 0), this.eol = e
                                }

                                printIceUfrag(e) {
                                    return void 0 === e ? "" : "a=ice-ufrag:".concat(e).concat(this.eol)
                                }

                                printIcePwd(e) {
                                    return void 0 === e ? "" : "a=ice-pwd:".concat(e).concat(this.eol)
                                }

                                printIceOptions(e) {
                                    return void 0 === e ? "" : "a=ice-options:".concat(e.join(o)).concat(this.eol)
                                }

                                printFingerprints(e) {
                                    return e.length > 0 ? e.map(e => "a=fingerprint:".concat(e.hashFunction).concat(o).concat(e.fingerprint)).join(this.eol) + this.eol : ""
                                }

                                printExtmap(e) {
                                    return e.map(e => "a=extmap:".concat(e.entry).concat(e.direction ? "/".concat(e.direction) : "").concat(o).concat(e.extensionName).concat(e.extensionAttributes ? "".concat(o).concat(e.extensionAttributes) : "").concat(this.eol)).join("")
                                }

                                printSetup(e) {
                                    return void 0 === e ? "" : "a=setup:".concat(e).concat(this.eol)
                                }

                                printUnrecognized(e) {
                                    return e.map(e => "a=".concat(e.attField).concat(e.attValue ? ":".concat(e.attValue) : "").concat(this.eol)).join("")
                                }
                            }

                            class O extends A {
                                print(e) {
                                    let t = "";
                                    return t += this.printGroups(e.groups), t += this.printMsidSemantic(e.msidSemantic), t += this.printIceLite(e.iceLite), t += this.printIceUfrag(e.iceUfrag), t += this.printIcePwd(e.icePwd), t += this.printIceOptions(e.iceOptions), t += this.printFingerprints(e.fingerprints), t += this.printSetup(e.setup), t += this.printTlsId(e.tlsId), t += this.printIdentity(e.identities), t += this.printExtmap(e.extmaps), t += this.printUnrecognized(e.unrecognized)
                                }

                                printGroups(e) {
                                    let t = "";
                                    return e.length > 0 && (t += e.map(e => "a=group:".concat(e.semantic).concat(e.identificationTag.map(e => "".concat(o).concat(e)).join("")).concat(this.eol)).join("")), t
                                }

                                printIceLite(e) {
                                    return void 0 === e ? "" : "a=ice-lite" + this.eol
                                }

                                printTlsId(e) {
                                    return e ? "a=tls-id:".concat(e).concat(this.eol) : ""
                                }

                                printIdentity(e) {
                                    return 0 === e.length ? "" : e.map(e => "a=identity:".concat(e.assertionValue).concat(e.extensions.map(e => "".concat(o).concat(e.name).concat(e.value ? "=".concat(e.value) : "")))).join(this.eol) + this.eol
                                }

                                printMsidSemantic(e) {
                                    if (!e) return "";
                                    let t = "a=msid-semantic:".concat(e.semantic);
                                    return e.applyForAll ? t += "".concat(o, "*") : e.identifierList.length > 0 && (t += e.identifierList.map(e => "".concat(o).concat(e))), t + this.eol
                                }
                            }

                            class N extends A {
                                print(e) {
                                    const t = e.attributes;
                                    let r = "";
                                    return r += this.printRTCP(t.rtcp), r += this.printIceUfrag(t.iceUfrag), r += this.printIcePwd(t.icePwd), r += this.printIceOptions(t.iceOptions), r += this.printCandidates(t.candidates), r += this.printRemoteCandidatesList(t.remoteCandidatesList), r += this.printEndOfCandidates(t.endOfCandidates), r += this.printFingerprints(t.fingerprints), r += this.printSetup(t.setup), r += this.printMid(t.mid), r += this.printExtmap(t.extmaps), r += this.printRTPRelated(t), r += this.printPtime(t.ptime), r += this.printMaxPtime(t.maxPtime), r += this.printDirection(t.direction), r += this.printSSRCGroups(t.ssrcGroups), r += this.printSSRC(t.ssrcs), r += this.printRTCPMux(t.rtcpMux), r += this.printRTCPMuxOnly(t.rtcpMuxOnly), r += this.printRTCPRsize(t.rtcpRsize), r += this.printMSId(t.msids), r += this.printImageattr(t.imageattr), r += this.printRid(t.rids), r += this.printSimulcast(t.simulcast), r += this.printSCTPPort(t.sctpPort), r += this.printMaxMessageSize(t.maxMessageSize), r += this.printUnrecognized(t.unrecognized)
                                }

                                printCandidates(e) {
                                    return e.map(e => "a=candidate:".concat(e.foundation).concat(o).concat(e.componentId).concat(o).concat(e.transport).concat(o).concat(e.priority).concat(o).concat(e.connectionAddress).concat(o).concat(e.port).concat(o, "typ").concat(o).concat(e.type).concat(e.relAddr ? "".concat(o, "raddr").concat(o).concat(e.relAddr) : "").concat(e.relPort ? "".concat(o, "rport").concat(o).concat(e.relPort) : "").concat(Object.keys(e.extension).map(t => "".concat(o).concat(t).concat(o).concat(e.extension[t])).join("")).concat(this.eol)).join("")
                                }

                                printRemoteCandidatesList(e) {
                                    return e.map(e => "a=remote-candidates:".concat(e.join(o)).concat(this.eol)).join("")
                                }

                                printEndOfCandidates(e) {
                                    return void 0 === e ? "" : "a=end-of-candidates" + this.eol
                                }

                                printRTPRelated(e) {
                                    if (!e.payloads) return "";
                                    const t = e.payloads;
                                    let r = "";
                                    r += e.rtcpFeedbackWildcards.map(e => this.printRTCPFeedback("*", e)).join("");
                                    for (const e of t) r += this.printRtpMap(e.payloadType, e.rtpMap), r += this.printFmtp(e.payloadType, e.fmtp), r += e.rtcpFeedbacks.map(t => this.printRTCPFeedback(e.payloadType, t)).join("");
                                    return r
                                }

                                printFmtp(e, t) {
                                    if (!t) return "";
                                    const r = Object.keys(t.parameters);
                                    return 1 === r.length && null === t.parameters[r[0]] ? "a=fmtp:".concat(e).concat(o).concat(r[0]).concat(this.eol) : "a=fmtp:".concat(e).concat(o).concat(Object.keys(t.parameters).map(e => "".concat(e, "=").concat(t.parameters[e])).join(";")).concat(this.eol)
                                }

                                printRtpMap(e, t) {
                                    return t ? "a=rtpmap:".concat(e).concat(o).concat(t.encodingName, "/").concat(t.clockRate).concat(t.encodingParameters ? "/".concat(t.encodingParameters) : "").concat(this.eol) : ""
                                }

                                printRTCPFeedback(e, t) {
                                    let r = "a=rtcp-fb:".concat(e).concat(o), n = t;
                                    switch (n.type) {
                                        case"trr-int":
                                            r += "ttr-int".concat(o).concat(n.interval);
                                            break;
                                        case"ack":
                                        case"nack":
                                        default:
                                            r += "".concat((n = n).type), n.parameter && (r += "".concat(o).concat(n.parameter), n.additional && (r += "".concat(o).concat(n.additional)))
                                    }
                                    return r + this.eol
                                }

                                printPtime(e) {
                                    return void 0 === e ? "" : "a=ptime:".concat(e).concat(this.eol)
                                }

                                printMaxPtime(e) {
                                    return void 0 === e ? "" : "a=maxptime:".concat(e).concat(this.eol)
                                }

                                printDirection(e) {
                                    return void 0 === e ? "" : "a=".concat(e).concat(this.eol)
                                }

                                printSSRC(e) {
                                    return e.map(e => Object.keys(e.attributes).map(t => "a=ssrc:".concat(e.ssrcId.toString(10)).concat(o).concat(t).concat(e.attributes[t] ? ":".concat(e.attributes[t]) : "").concat(this.eol)).join("")).join("")
                                }

                                printRTCPMux(e) {
                                    return void 0 === e ? "" : "a=rtcp-mux".concat(this.eol)
                                }

                                printRTCPMuxOnly(e) {
                                    return void 0 === e ? "" : "a=rtcp-mux-only".concat(this.eol)
                                }

                                printRTCPRsize(e) {
                                    return void 0 === e ? "" : "a=rtcp-rsize".concat(this.eol)
                                }

                                printRTCP(e) {
                                    if (void 0 === e) return "";
                                    let t = "a=rtcp:".concat(e.port);
                                    return e.netType && (t += "".concat(o).concat(e.netType)), e.addressType && (t += "".concat(o).concat(e.addressType)), e.address && (t += "".concat(o).concat(e.address)), t + this.eol
                                }

                                printMSId(e) {
                                    return e.map(e => "a=msid:".concat(e.id).concat(e.appdata ? "".concat(o).concat(e.appdata) : "").concat(this.eol)).join("")
                                }

                                printImageattr(e) {
                                    return e.map(e => "a=imageattr:".concat(e).concat(this.eol)).join("")
                                }

                                printRid(e) {
                                    return e.map(e => {
                                        let t = "a=rid:".concat(e.id).concat(o).concat(e.direction);
                                        return e.payloads && (t += "".concat(o, "pt=").concat(e.payloads.join(","))), e.params.length > 0 && (t += "".concat(o).concat(e.params.map(e => "depend" === e.type ? "depend=".concat(e.rids.join(",")) : "".concat(e.type, "=").concat(e.val)).join(";"))), t + this.eol
                                    }).join("")
                                }

                                printSimulcast(e) {
                                    return void 0 === e ? "" : "a=simulcast:".concat(e).concat(this.eol)
                                }

                                printSCTPPort(e) {
                                    return void 0 === e ? "" : "a=sctp-port:".concat(e).concat(this.eol)
                                }

                                printMaxMessageSize(e) {
                                    return void 0 === e ? "" : "a=max-message-size:".concat(e).concat(this.eol)
                                }

                                printMid(e) {
                                    return void 0 === e ? "" : "a=mid:".concat(e).concat(this.eol)
                                }

                                printSSRCGroups(e) {
                                    return e.map(e => "a=ssrc-group:".concat(e.semantic).concat(e.ssrcIds.map(e => "".concat(o).concat(e.toString(10))).join("")).concat(this.eol)).join("")
                                }
                            }
                        }
                    }, t = {};

                    function r(n) {
                        if (t[n]) return t[n].exports;
                        var i = t[n] = {exports: {}};
                        return e[n](i, i.exports, r), i.exports
                    }

                    return r.d = ((e, t) => {
                        for (var n in t) r.o(t, n) && !r.o(e, n) && Object.defineProperty(e, n, {
                            enumerable: !0,
                            get: t[n]
                        })
                    }), r.o = ((e, t) => Object.prototype.hasOwnProperty.call(e, t)), r.r = (e => {
                        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {value: "Module"}), Object.defineProperty(e, "__esModule", {value: !0})
                    }), r(8)
                })()
            }(ON);
            var JN = function () {
                function e(e) {
                    this.input = [], this.size = e
                }

                return e.prototype.add = function (e) {
                    this.input.push(e), this.input.length > this.size && this.input.splice(0, 1)
                }, e.prototype.diffMean = function () {
                    return 0 === this.input.length ? 0 : (this.input[this.input.length - 1] - this.input[0]) / this.input.length
                }, e
            }(), XN = function (e, t) {
                return (XN = Object.setPrototypeOf || {__proto__: []} instanceof Array && function (e, t) {
                    e.__proto__ = t
                } || function (e, t) {
                    for (var r in t) t.hasOwnProperty(r) && (e[r] = t[r])
                })(e, t)
            };

            /*! *****************************************************************************
        Copyright (c) Microsoft Corporation. All rights reserved.
        Licensed under the Apache License, Version 2.0 (the "License"); you may not use
        this file except in compliance with the License. You may obtain a copy of the
        License at http://www.apache.org/licenses/LICENSE-2.0

        THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
        KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
        WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
        MERCHANTABLITY OR NON-INFRINGEMENT.

        See the Apache Version 2.0 License for specific language governing permissions
        and limitations under the License.
        ***************************************************************************** */
            function QN(e, t) {
                function r() {
                    this.constructor = e
                }

                XN(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r)
            }

            var $N = function () {
                return ($N = Object.assign || function (e) {
                    for (var t, r = 1, n = arguments.length; r < n; r++) for (var i in t = arguments[r]) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
                    return e
                }).apply(this, arguments)
            };

            function ZN(e, t, r, n) {
                return new (r || (r = Promise))(function (i, o) {
                    function s(e) {
                        try {
                            c(n.next(e))
                        } catch (e) {
                            o(e)
                        }
                    }

                    function a(e) {
                        try {
                            c(n.throw(e))
                        } catch (e) {
                            o(e)
                        }
                    }

                    function c(e) {
                        e.done ? i(e.value) : new r(function (t) {
                            t(e.value)
                        }).then(s, a)
                    }

                    c((n = n.apply(e, t || [])).next())
                })
            }

            function eP(e, t) {
                var r, n, i, o, s = {
                    label: 0, sent: function () {
                        if (1 & i[0]) throw i[1];
                        return i[1]
                    }, trys: [], ops: []
                };
                return o = {
                    next: a(0),
                    throw: a(1),
                    return: a(2)
                }, "function" == typeof Symbol && (o[Symbol.iterator] = function () {
                    return this
                }), o;

                function a(o) {
                    return function (a) {
                        return function (o) {
                            if (r) throw new TypeError("Generator is already executing.");
                            for (; s;) try {
                                if (r = 1, n && (i = 2 & o[0] ? n.return : o[0] ? n.throw || ((i = n.return) && i.call(n), 0) : n.next) && !(i = i.call(n, o[1])).done) return i;
                                switch (n = 0, i && (o = [2 & o[0], i.value]), o[0]) {
                                    case 0:
                                    case 1:
                                        i = o;
                                        break;
                                    case 4:
                                        return s.label++, {value: o[1], done: !1};
                                    case 5:
                                        s.label++, n = o[1], o = [0];
                                        continue;
                                    case 7:
                                        o = s.ops.pop(), s.trys.pop();
                                        continue;
                                    default:
                                        if (!((i = (i = s.trys).length > 0 && i[i.length - 1]) || 6 !== o[0] && 2 !== o[0])) {
                                            s = 0;
                                            continue
                                        }
                                        if (3 === o[0] && (!i || o[1] > i[0] && o[1] < i[3])) {
                                            s.label = o[1];
                                            break
                                        }
                                        if (6 === o[0] && s.label < i[1]) {
                                            s.label = i[1], i = o;
                                            break
                                        }
                                        if (i && s.label < i[2]) {
                                            s.label = i[2], s.ops.push(o);
                                            break
                                        }
                                        i[2] && s.ops.pop(), s.trys.pop();
                                        continue
                                }
                                o = t.call(e, s)
                            } catch (e) {
                                o = [6, e], n = 0
                            } finally {
                                r = i = 0
                            }
                            if (5 & o[0]) throw o[1];
                            return {value: o[0] ? o[1] : void 0, done: !0}
                        }([o, a])
                    }
                }
            }

            var tP, rP = {
                address: "unknown",
                candidateType: "unknown",
                id: "unknown",
                port: 0,
                priority: 0,
                protocol: "unknown",
                type: "unknown"
            }, nP = {
                timestamp: 0,
                bitrate: {actualEncoded: 0, transmit: 0},
                sendPacketLossRate: 0,
                recvPacketLossRate: 0,
                videoRecv: [],
                videoSend: [],
                audioRecv: [],
                audioSend: [],
                selectedCandidatePair: {id: "unknown", localCandidate: rP, remoteCandidate: rP}
            }, iP = {
                firsCount: 0,
                nacksCount: 0,
                plisCount: 0,
                framesDecodeCount: 0,
                framesDecodeInterval: 0,
                framesDecodeFreezeTime: 0,
                decodeFrameRate: 0,
                bytes: 0,
                packetsLost: 0,
                packetLostRate: 0,
                packets: 0,
                ssrc: 0,
                qpSumPerFrame: 0
            }, oP = {
                firsCount: 0,
                nacksCount: 0,
                plisCount: 0,
                frameCount: 0,
                bytes: 0,
                packets: 0,
                packetsLost: 0,
                packetLostRate: 0,
                ssrc: 0,
                rttMs: 0,
                qpSumPerFrame: 0
            }, sP = {bytes: 0, packets: 0, packetsLost: 0, packetLostRate: 0, ssrc: 0, rttMs: 0}, aP = {
                jitterBufferMs: 0,
                jitterMs: 0,
                bytes: 0,
                packetsLost: 0,
                packetLostRate: 0,
                packets: 0,
                ssrc: 0,
                receivedFrames: 0,
                droppedFrames: 0,
                concealedSamples: 0
            }, cP = function () {
                function e(e, t) {
                    var r = this;
                    this.videoIsReady = !1, this.videoIsReady2 = {}, this.stats = zN(nP), this.isFirstVideoReceived = {}, this.isFirstVideoDecoded = {}, this.isFirstAudioReceived = {}, this.isFirstAudioDecoded = {}, this.lossRateWindowStats = [], this.pc = e, this.options = t, this.intervalTimer = window.setInterval(function () {
                        return ZN(r, void 0, void 0, function () {
                            return eP(this, function (e) {
                                return this.updateStats(), [2]
                            })
                        })
                    }, this.options.updateInterval)
                }

                return e.prototype.getStats = function () {
                    return this.stats
                }, e.prototype.setVideoIsReady = function (e) {
                    this.videoIsReady = e
                }, e.prototype.setVideoIsReady2 = function (e, t) {
                    this.videoIsReady2[e] = t
                }, e.prototype.getVideoIsReady = function (e) {
                    return this.videoIsReady2[e] || !1
                }, e.prototype.setIsFirstAudioDecoded = function (e) {
                }, e.prototype.destroy = function () {
                    window.clearInterval(this.intervalTimer), this.pc = void 0
                }, e.prototype.calcLossRate = function (e) {
                    var t = this;
                    this.lossRateWindowStats.push(e), this.lossRateWindowStats.length > this.options.lossRateInterval && this.lossRateWindowStats.splice(0, 1);
                    for (var r = this.lossRateWindowStats.length, n = 0, i = 0, o = 0, s = 0, a = function (a) {
                        e[a].forEach(function (e, c) {
                            if (t.lossRateWindowStats[r - 1][a][c] && t.lossRateWindowStats[0][a][c]) {
                                var u = t.lossRateWindowStats[r - 1][a][c].packets - t.lossRateWindowStats[0][a][c].packets,
                                    d = t.lossRateWindowStats[r - 1][a][c].packetsLost - t.lossRateWindowStats[0][a][c].packetsLost;
                                "videoSend" === a || "audioSend" === a ? (n += u, o += d) : (i += u, s += d), Number.isNaN(u) || Number.isNaN(u) ? e.packetLostRate = 0 : e.packetLostRate = u <= 0 || d <= 0 ? 0 : d / (u + d)
                            }
                        })
                    }, c = 0, u = ["videoSend", "audioSend", "videoRecv", "audioRecv"]; c < u.length; c++) a(u[c]);
                    e.sendPacketLossRate = n <= 0 || o <= 0 ? 0 : o / (n + o), e.recvPacketLossRate = i <= 0 || s <= 0 ? 0 : s / (i + s)
                }, e
            }(), uP = function (e) {
                function t() {
                    var t = null !== e && e.apply(this, arguments) || this;
                    return t._stats = nP, t.lastDecodeVideoReceiverStats = new Map, t
                }

                return QN(t, e), t.prototype.updateStats = function () {
                    return ZN(this, void 0, void 0, function () {
                        var e, t, r, n;
                        return eP(this, function (i) {
                            switch (i.label) {
                                case 0:
                                    return [4, this._getStats()];
                                case 1:
                                    return e = i.sent(), t = this.statsResponsesToObjects(e), this._stats = zN(nP), r = t.filter(function (e) {
                                        return "ssrc" === e.type
                                    }), this.processSSRCStats(r), (n = t.find(function (e) {
                                        return "VideoBwe" === e.type
                                    })) && this.processBandwidthStats(n), this._stats.timestamp = Date.now(), this.calcLossRate(this._stats), this.stats = this._stats, [2]
                            }
                        })
                    })
                }, t.prototype.processBandwidthStats = function (e) {
                    this._stats.bitrate = {
                        actualEncoded: Number(e.googActualEncBitrate),
                        targetEncoded: Number(e.googTargetEncBitrate),
                        retransmit: Number(e.googRetransmitBitrate),
                        transmit: Number(e.googTransmitBitrate)
                    }, this._stats.sendBandwidth = Number(e.googAvailableSendBandwidth)
                }, t.prototype.processSSRCStats = function (e) {
                    var t = this;
                    e.forEach(function (e) {
                        var r = e.id.includes("send");
                        switch ("".concat(e.mediaType, "_").concat(r ? "send" : "recv")) {
                            case"video_send":
                                var n = zN(oP);
                                n.codec = e.googCodecName, n.adaptionChangeReason = "none", e.googCpuLimitedResolution && (n.adaptionChangeReason = "cpu"), e.googBandwidthLimitedResolution && (n.adaptionChangeReason = "bandwidth"), n.avgEncodeMs = Number(e.googAvgEncodeMs), n.inputFrame = {
                                    width: Number(e.googFrameWidthInput) || Number(e.googFrameWidthSent),
                                    height: Number(e.googFrameHeightInput) || Number(e.googFrameHeightSent),
                                    frameRate: Number(e.googFrameRateInput)
                                }, n.sentFrame = {
                                    width: Number(e.googFrameWidthSent),
                                    height: Number(e.googFrameHeightSent),
                                    frameRate: Number(e.googFrameRateInput)
                                }, n.firsCount = Number(e.googFirReceived), n.nacksCount = Number(e.googNacksReceived), n.plisCount = Number(e.googPlisReceived), n.frameCount = Number(e.framesEncoded), n.bytes = Number(e.bytesSent), n.packets = Number(e.packetsSent), n.packetsLost = Number(e.packetsLost), n.ssrc = Number(e.ssrc), n.rttMs = Number(e.googRtt || 0), t._stats.videoSend.push(n), t._stats.rtt = n.rttMs;
                                break;
                            case"video_recv":
                                var i = zN(iP), o = t.lastDecodeVideoReceiverStats.get(Number(e.ssrc));
                                if (i.codec = e.googCodecName, i.targetDelayMs = Number(e.googTargetDelayMs), i.renderDelayMs = Number(e.googRenderDelayMs), i.currentDelayMs = Number(e.googCurrentDelayMs), i.minPlayoutDelayMs = Number(e.googMinPlayoutDelayMs), i.decodeMs = Number(e.googDecodeMs), i.maxDecodeMs = Number(e.googMaxDecodeMs), i.receivedFrame = {
                                    width: Number(e.googFrameWidthReceived),
                                    height: Number(e.googFrameHeightReceived),
                                    frameRate: Number(e.googFrameRateReceived)
                                }, i.decodedFrame = {
                                    width: Number(e.googFrameWidthReceived),
                                    height: Number(e.googFrameHeightReceived),
                                    frameRate: Number(e.googFrameRateDecoded)
                                }, i.decodeFrameRate = Number(e.googFrameRateDecoded), i.outputFrame = {
                                    width: Number(e.googFrameWidthReceived),
                                    height: Number(e.googFrameHeightReceived),
                                    frameRate: Number(e.googFrameRateOutput)
                                }, i.jitterBufferMs = Number(e.googJitterBufferMs), i.firsCount = Number(e.googFirsSent), i.nacksCount = Number(e.googNacksSent), i.plisCount = Number(e.googPlisSent), i.framesDecodeCount = Number(e.framesDecoded), i.bytes = Number(e.bytesReceived), i.packets = Number(e.packetsReceived), i.packetsLost = Number(e.packetsLost), i.ssrc = Number(e.ssrc), i.packets > 0 && !t.isFirstVideoReceived[i.ssrc] && (t.onFirstVideoReceived && t.onFirstVideoReceived(i.ssrc), t.isFirstVideoReceived[i.ssrc] = !0), i.framesDecodeCount > 0 && !t.isFirstVideoDecoded[i.ssrc] && (t.onFirstVideoDecoded && t.onFirstVideoDecoded(i.ssrc, i.decodedFrame.width, i.decodedFrame.height), t.isFirstVideoDecoded[i.ssrc] = !0), o) {
                                    var s = o.stats, a = Date.now() - o.lts;
                                    i.framesDecodeFreezeTime = s.framesDecodeFreezeTime, i.framesDecodeInterval = s.framesDecodeInterval, i.framesDecodeCount > s.framesDecodeCount && t.isFirstVideoDecoded[i.ssrc] ? (o.lts = Date.now(), i.framesDecodeInterval = a, i.framesDecodeInterval >= t.options.freezeRateLimit && (t.getVideoIsReady(parseInt(e.ssrc, 10)) ? i.framesDecodeFreezeTime += i.framesDecodeInterval : t.setVideoIsReady2(parseInt(e.ssrc, 10), !0))) : i.framesDecodeCount < o.stats.framesDecodeCount && (i.framesDecodeInterval = 0)
                                }
                                t.lastDecodeVideoReceiverStats.set(i.ssrc, {
                                    stats: $N({}, i),
                                    lts: Date.now()
                                }), t._stats.videoRecv.push(i);
                                break;
                            case"audio_recv":
                                var c = zN(aP);
                                c.codec = e.googCodecName, c.outputLevel = Math.abs(Number(e.audioOutputLevel)) / 32767, c.decodingCNG = Number(e.googDecodingCNG), c.decodingCTN = Number(e.googDecodingCTN), c.decodingCTSG = Number(e.googDecodingCTSG), c.decodingNormal = Number(e.googDecodingNormal), c.decodingPLC = Number(e.googDecodingPLC), c.decodingPLCCNG = Number(e.googDecodingPLCCNG), c.expandRate = Number(e.googExpandRate), c.accelerateRate = Number(e.googAccelerateRate), c.preemptiveExpandRate = Number(e.googPreemptiveExpandRate), c.secondaryDecodedRate = Number(e.googSecondaryDecodedRate), c.speechExpandRate = Number(e.googSpeechExpandRate), c.preferredJitterBufferMs = Number(e.googPreferredJitterBufferMs), c.jitterBufferMs = Number(e.googJitterBufferMs), c.jitterMs = Number(e.googJitterReceived), c.bytes = Number(e.bytesReceived), c.packets = Number(e.packetsReceived), c.packetsLost = Number(e.packetsLost), c.ssrc = Number(e.ssrc), c.receivedFrames = Number(e.googDecodingCTN) || Number(e.packetsReceived), c.droppedFrames = Number(e.googDecodingPLC) + Number(e.googDecodingPLCCNG) || Number(e.packetsLost), c.receivedFrames > 0 && !t.isFirstAudioReceived[c.ssrc] && (t.onFirstAudioReceived && t.onFirstAudioReceived(c.ssrc), t.isFirstAudioReceived[c.ssrc] = !0), c.decodingNormal > 0 && !t.isFirstAudioDecoded[c.ssrc] && (t.onFirstAudioDecoded && t.onFirstAudioDecoded(c.ssrc), t.isFirstAudioDecoded[c.ssrc] = !0), t._stats.audioRecv.push(c);
                                break;
                            case"audio_send":
                                var u = zN(sP);
                                u.codec = e.googCodecName, u.inputLevel = Math.abs(Number(e.audioInputLevel)) / 32767, u.aecReturnLoss = Number(e.googEchoCancellationReturnLoss || 0), u.aecReturnLossEnhancement = Number(e.googEchoCancellationReturnLossEnhancement || 0), u.residualEchoLikelihood = Number(e.googResidualEchoLikelihood || 0), u.residualEchoLikelihoodRecentMax = Number(e.googResidualEchoLikelihoodRecentMax || 0), u.bytes = Number(e.bytesSent), u.packets = Number(e.packetsSent), u.packetsLost = Number(e.packetsLost), u.ssrc = Number(e.ssrc), u.rttMs = Number(e.googRtt || 0), t._stats.rtt = u.rttMs, t._stats.audioSend.push(u)
                        }
                    })
                }, t.prototype._getStats = function () {
                    var e = this;
                    return new Promise(function (t, r) {
                        e.pc.getStats(t, r)
                    })
                }, t.prototype.statsResponsesToObjects = function (e) {
                    var t = [];
                    return e.result().forEach(function (e) {
                        var r = {id: e.id, timestamp: e.timestamp.valueOf().toString(), type: e.type};
                        e.names().forEach(function (t) {
                            r[t] = e.stat(t)
                        }), t.push(r)
                    }), t
                }, t
            }(cP);
            !function (e) {
                e.CERTIFICATE = "certificate", e.CODEC = "codec", e.CANDIDATE_PAIR = "candidate-pair", e.LOCAL_CANDIDATE = "local-candidate", e.REMOTE_CANDIDATE = "remote-candidate", e.INBOUND = "inbound-rtp", e.TRACK = "track", e.OUTBOUND = "outbound-rtp", e.PC = "peer-connection", e.REMOTE_INBOUND = "remote-inbound-rtp", e.REMOTE_OUTBOUND = "remote-outbound-rtp", e.TRANSPORT = "transport", e.CSRC = "csrc", e.DATA_CHANNEL = "data-channel", e.STREAM = "stream", e.SENDER = "sender", e.RECEIVER = "receiver"
            }(tP || (tP = {}));
            var dP, lP = function (e) {
                function t() {
                    var t = null !== e && e.apply(this, arguments) || this;
                    return t._stats = nP, t.lastDecodeVideoReceiverStats = new Map, t.lastVideoFramesRecv = new Map, t.lastVideoFramesSent = new Map, t.lastVideoFramesDecode = new Map, t.lastVideoJBDelay = new Map, t.lastAudioJBDelay = new Map, t.mediaBytesSent = new Map, t.mediaBytesRetransmit = new Map, t.mediaBytesTargetEncode = new Map, t.lastEncoderMs = new Map, t
                }

                return QN(t, e), t.prototype.updateStats = function () {
                    return ZN(this, void 0, void 0, function () {
                        var e, t = this;
                        return eP(this, function (r) {
                            switch (r.label) {
                                case 0:
                                    return e = this, [4, this.pc.getStats()];
                                case 1:
                                    return e.report = r.sent(), this._stats = zN(nP), this.report.forEach(function (e) {
                                        switch (e.type) {
                                            case tP.OUTBOUND:
                                                "audio" === e.mediaType ? t.processAudioOutboundStats(e) : "video" === e.mediaType && t.processVideoOutboundStats(e);
                                                break;
                                            case tP.INBOUND:
                                                "audio" === e.mediaType ? t.processAudioInboundStats(e) : "video" === e.mediaType && t.processVideoInboundStats(e);
                                                break;
                                            case tP.TRANSPORT:
                                                var r = t.report.get(e.selectedCandidatePairId);
                                                r && t.processCandidatePairStats(r);
                                                break;
                                            case tP.CANDIDATE_PAIR:
                                                e.selected && t.processCandidatePairStats(e)
                                        }
                                    }), this.updateSendBitrate(), this._stats.timestamp = Date.now(), this.calcLossRate(this._stats), this.stats = this._stats, [2]
                            }
                        })
                    })
                }, t.prototype.processCandidatePairStats = function (e) {
                    if (this._stats.sendBandwidth = e.availableOutgoingBitrate || 0, e.currentRoundTripTime && (this._stats.rtt = 1e3 * e.currentRoundTripTime), this._stats.videoSend.forEach(function (t) {
                        !t.rttMs && e.currentRoundTripTime && (t.rttMs = 1e3 * e.currentRoundTripTime)
                    }), this._stats.audioSend.forEach(function (t) {
                        !t.rttMs && e.currentRoundTripTime && (t.rttMs = 1e3 * e.currentRoundTripTime)
                    }), this._stats.selectedCandidatePair.id = e.id, e.localCandidateId) {
                        var t = this.report.get(e.localCandidateId);
                        t && this.processCandidateStats(t)
                    }
                    if (e.remoteCandidateId) {
                        var r = this.report.get(e.remoteCandidateId);
                        r && this.processCandidateStats(r)
                    }
                }, t.prototype.processCandidateStats = function (e) {
                    var t;
                    e.type === tP.LOCAL_CANDIDATE && (t = this._stats.selectedCandidatePair.localCandidate), e.type === tP.REMOTE_CANDIDATE && (t = this._stats.selectedCandidatePair.remoteCandidate), t && (t.type = e.type, t.id = e.id, e.address && (t.address = e.address), e.candidateType && (t.candidateType = e.candidateType), e.port && (t.port = e.port), e.priority && (t.priority = e.priority), e.protocol && (t.protocol = e.protocol), e.relayProtocol && (t.relayProtocol = e.relayProtocol), e.type === tP.LOCAL_CANDIDATE && this.stats.selectedCandidatePair.localCandidate.id !== t.id && this.onSelectedLocalCandidateChanged && this.onSelectedLocalCandidateChanged($N({}, t), $N({}, this.stats.selectedCandidatePair.localCandidate)), e.type === tP.REMOTE_CANDIDATE && this.stats.selectedCandidatePair.remoteCandidate.id !== t.id && this.onSelectedRemoteCandidateChanged && this.onSelectedRemoteCandidateChanged($N({}, t), $N({}, this.stats.selectedCandidatePair.remoteCandidate)))
                }, t.prototype.processAudioInboundStats = function (e) {
                    var t = this._stats.audioRecv.find(function (t) {
                        return t.ssrc === e.ssrc
                    });
                    t || (t = zN(aP), this._stats.audioRecv.push(t)), t.ssrc = e.ssrc, t.packets = e.packetsReceived, t.packetsLost = e.packetsLost, t.bytes = e.bytesReceived, t.jitterMs = 1e3 * e.jitter, this.processAudioTrackReceiverStats(e, e.trackId, t), e.codecId && (t.codec = this.getCodecFromCodecStats(e.codecId)), t.receivedFrames || (t.receivedFrames = e.packetsReceived), t.droppedFrames || (t.droppedFrames = e.packetsLost), t.receivedFrames > 0 && !this.isFirstAudioReceived[t.ssrc] && (this.onFirstAudioReceived && this.onFirstAudioReceived(t.ssrc), this.isFirstAudioReceived[t.ssrc] = !0), t.outputLevel && t.outputLevel > 0 && !this.isFirstAudioDecoded[t.ssrc] && (this.onFirstAudioDecoded && this.onFirstAudioDecoded(t.ssrc), this.isFirstAudioDecoded[t.ssrc] = !0), "number" == typeof e.concealedSamples && (t.concealedSamples = e.concealedSamples)
                }, t.prototype.processVideoInboundStats = function (e) {
                    var t = this._stats.videoRecv.find(function (t) {
                        return t.ssrc === e.ssrc
                    });
                    t || (t = zN(iP), this._stats.videoRecv.push(t)), t.ssrc = e.ssrc, t.packets = e.packetsReceived, t.packetsLost = e.packetsLost, t.bytes = e.bytesReceived, t.firsCount = e.firCount, t.nacksCount = e.nackCount, t.plisCount = e.pliCount, t.framesDecodeCount = e.framesDecoded, t.totalInterFrameDelay = e.totalInterFrameDelay, t.totalSquaredInterFrameDelay = e.totalSquaredInterFrameDelay;
                    var r = this.lastDecodeVideoReceiverStats.get(t.ssrc), n = this.lastVideoFramesDecode.get(t.ssrc),
                        i = Date.now();
                    if (t.framesDecodeCount > 0 && !this.isFirstVideoDecoded[t.ssrc]) {
                        var o = t.decodedFrame ? t.decodedFrame.width : 0,
                            s = t.decodedFrame ? t.decodedFrame.height : 0;
                        this.onFirstVideoDecoded && this.onFirstVideoDecoded(t.ssrc, o, s), this.isFirstVideoDecoded[t.ssrc] = !0
                    }
                    if (r) {
                        var a = r.stats, c = i - r.lts;
                        t.framesDecodeFreezeTime = a.framesDecodeFreezeTime, t.framesDecodeInterval = a.framesDecodeInterval, !this.isFirstVideoDecoded[t.ssrc] && c > this.options.firstVideoDecodedTimeout && this.onFirstVideoDecodedTimeout && this.onFirstVideoDecodedTimeout(t.ssrc), t.framesDecodeCount > a.framesDecodeCount && this.isFirstVideoDecoded[t.ssrc] ? (r.lts = Date.now(), t.framesDecodeInterval = c, t.framesDecodeInterval >= this.options.freezeRateLimit && (this.getVideoIsReady(parseInt(e.ssrc)) ? t.framesDecodeFreezeTime += t.framesDecodeInterval : this.setVideoIsReady2(parseInt(e.ssrc, 10), !0))) : t.framesDecodeCount < a.framesDecodeCount && (t.framesDecodeInterval = 0), e.framesDecoded && e.qpSum && (r.stats.framesDecodeCount > e.framesDecoded ? t.qpSumPerFrame = e.qpSum / e.framesDecoded : t.qpSumPerFrame = (e.qpSum - r.qpSum) / (e.framesDecoded - r.stats.framesDecodeCount))
                    }
                    n && i - n.lts >= 800 ? (t.decodeFrameRate = Math.round((t.framesDecodeCount - n.count) / ((i - n.lts) / 1e3)), this.lastVideoFramesDecode.set(t.ssrc, {
                        count: t.framesDecodeCount,
                        lts: i,
                        rate: t.decodeFrameRate
                    })) : n ? t.decodeFrameRate = n.rate : this.lastVideoFramesDecode.set(t.ssrc, {
                        count: t.framesDecodeCount,
                        lts: i,
                        rate: 0
                    }), e.totalDecodeTime && (t.decodeMs = 1e3 * e.totalDecodeTime), this.processVideoTrackReceiverStats(e, e.trackId, t), e.codecId && (t.codec = this.getCodecFromCodecStats(e.codecId)), e.framerateMean && (t.framesRateFirefox = e.framerateMean), t.packets > 0 && !this.isFirstVideoReceived[t.ssrc] && (this.onFirstVideoReceived && this.onFirstVideoReceived(t.ssrc), this.isFirstVideoReceived[t.ssrc] = !0), this.lastDecodeVideoReceiverStats.set(t.ssrc, {
                        stats: $N({}, t),
                        lts: r ? r.lts : Date.now(),
                        qpSum: e.qpSum
                    })
                }, t.prototype.processVideoOutboundStats = function (e) {
                    var t = this._stats.videoSend.find(function (t) {
                        return t.ssrc === e.ssrc
                    });
                    t || (t = zN(oP), this._stats.videoSend.push(t));
                    var r, n = this.mediaBytesSent.get(e.ssrc);
                    if (n ? n.add(e.bytesSent) : ((o = new JN(10)).add(e.bytesSent), this.mediaBytesSent.set(e.ssrc, o)), void 0 !== e.retransmittedBytesSent) {
                        var i = this.mediaBytesRetransmit.get(e.ssrc);
                        i ? i.add(e.retransmittedBytesSent) : ((o = new JN(10)).add(e.retransmittedBytesSent), this.mediaBytesRetransmit.set(e.ssrc, o))
                    }
                    if (e.totalEncodedBytesTarget) {
                        var o, s = this.mediaBytesTargetEncode.get(e.ssrc);
                        s ? s.add(e.totalEncodedBytesTarget) : ((o = new JN(10)).add(e.totalEncodedBytesTarget), this.mediaBytesTargetEncode.set(e.ssrc, o))
                    }
                    if (t.ssrc = e.ssrc, t.bytes = e.bytesSent, t.packets = e.packetsSent, t.firsCount = e.firCount, t.nacksCount = e.nackCount, t.plisCount = e.pliCount, t.frameCount = e.framesEncoded, t.adaptionChangeReason = e.qualityLimitationReason, e.totalEncodeTime && e.framesEncoded) if (!(r = this.lastEncoderMs.get(e.ssrc)) || r.lastFrameCount > e.framesEncoded) t.avgEncodeMs = 1e3 * e.totalEncodeTime / e.framesEncoded; else {
                        var a = e.framesEncoded - r.lastFrameCount, c = e.totalEncodeTime - r.lastEncoderTime;
                        t.avgEncodeMs = 1e3 * c / a
                    }
                    if (e.framesEncoded && e.qpSum && (!(r = this.lastEncoderMs.get(e.ssrc)) || r.lastFrameCount > e.framesEncoded ? t.qpSumPerFrame = e.qpSum / e.framesEncoded : t.qpSumPerFrame = (e.qpSum - r.lastQpSum) / (e.framesEncoded - r.lastFrameCount)), this.lastEncoderMs.set(e.ssrc, {
                        lastFrameCount: e.framesEncoded,
                        lastEncoderTime: e.totalEncodeTime,
                        lastQpSum: e.qpSum,
                        lts: Date.now()
                    }), e.codecId && (t.codec = this.getCodecFromCodecStats(e.codecId)), e.mediaSourceId && this.processVideoMediaSource(e.mediaSourceId, t), this.processVideoTrackSenderStats(e, e.trackId, t), e.remoteId) this.processRemoteInboundStats(e.remoteId, t); else {
                        var u = this.findRemoteStatsId(e.ssrc, tP.REMOTE_INBOUND);
                        u && this.processRemoteInboundStats(u, t)
                    }
                }, t.prototype.processAudioOutboundStats = function (e) {
                    var t = this._stats.audioSend.find(function (t) {
                        return t.ssrc === e.ssrc
                    });
                    if (t || (t = zN(sP), this._stats.audioSend.push(t)), t.ssrc = e.ssrc, t.packets = e.packetsSent, t.bytes = e.bytesSent, e.mediaSourceId && this.processAudioMediaSource(e.mediaSourceId, t), e.codecId && (t.codec = this.getCodecFromCodecStats(e.codecId)), this.processAudioTrackSenderStats(e, e.trackId, t), e.remoteId) this.processRemoteInboundStats(e.remoteId, t); else {
                        var r = this.findRemoteStatsId(e.ssrc, tP.REMOTE_INBOUND);
                        r && this.processRemoteInboundStats(r, t)
                    }
                }, t.prototype.findRemoteStatsId = function (e, t) {
                    var r = Array.from(this.report.values()).find(function (r) {
                        return r.type === t && r.ssrc === e
                    });
                    return r ? r.id : null
                }, t.prototype.processVideoMediaSource = function (e, t) {
                    var r = this.report.get(e);
                    r && r.width && r.height && r.framesPerSecond && (t.inputFrame = {
                        width: r.width,
                        height: r.height,
                        frameRate: r.framesPerSecond
                    })
                }, t.prototype.processAudioMediaSource = function (e, t) {
                    var r = this.report.get(e);
                    r && (t.inputLevel = r.audioLevel)
                }, t.prototype.processVideoTrackSenderStats = function (e, t, r) {
                    var n, i, o, s = t ? this.report.get(t) : void 0,
                        a = null !== (n = null == s ? void 0 : s.framesSent) && void 0 !== n ? n : e.framesSent,
                        c = null !== (i = null == s ? void 0 : s.frameWidth) && void 0 !== i ? i : e.frameWidth,
                        u = null !== (o = null == s ? void 0 : s.frameHeight) && void 0 !== o ? o : e.frameHeight;
                    if ("number" == typeof a && "number" == typeof c && "number" == typeof u) {
                        var d = 0, l = Date.now(), h = this.lastVideoFramesSent.get(r.ssrc);
                        h && l - h.lts >= 800 ? (d = Math.round((a - h.count) / ((l - h.lts) / 1e3)), this.lastVideoFramesSent.set(r.ssrc, {
                            count: a,
                            lts: l,
                            rate: d
                        })) : h ? d = h.rate : this.lastVideoFramesSent.set(r.ssrc, {
                            count: a,
                            lts: l,
                            rate: 0
                        }), r.sentFrame = {width: c, height: u, frameRate: d}
                    }
                }, t.prototype.processVideoTrackReceiverStats = function (e, t, r) {
                    var n, i, o, s, a, c = t ? this.report.get(t) : void 0,
                        u = null !== (n = null == c ? void 0 : c.framesReceived) && void 0 !== n ? n : e.framesReceived,
                        d = null !== (i = null == c ? void 0 : c.frameWidth) && void 0 !== i ? i : e.frameWidth,
                        l = null !== (o = null == c ? void 0 : c.frameHeight) && void 0 !== o ? o : e.frameHeight,
                        h = null !== (s = null == c ? void 0 : c.jitterBufferDelay) && void 0 !== s ? s : e.jitterBufferDelay,
                        p = null !== (a = null == c ? void 0 : c.jitterBufferEmittedCount) && void 0 !== a ? a : e.jitterBufferEmittedCount;
                    if ("number" == typeof u) {
                        var f = this.lastVideoFramesRecv.get(r.ssrc), m = Date.now();
                        r.framesReceivedCount = u;
                        var _ = 0;
                        f && m - f.lts >= 800 ? (_ = Math.round((u - f.count) / ((m - f.lts) / 1e3)), this.lastVideoFramesRecv.set(r.ssrc, {
                            count: u,
                            lts: m,
                            rate: _
                        })) : f ? _ = f.rate : this.lastVideoFramesRecv.set(r.ssrc, {
                            count: u,
                            lts: m,
                            rate: 0
                        }), r.receivedFrame = {
                            width: d || 0,
                            height: l || 0,
                            frameRate: _ || 0
                        }, r.decodedFrame = {
                            width: d || 0,
                            height: l || 0,
                            frameRate: r.decodeFrameRate || 0
                        }, r.outputFrame = {width: d || 0, height: l || 0, frameRate: r.decodeFrameRate || 0}
                    }
                    if (h && p) {
                        var v = this.lastVideoJBDelay.get(r.ssrc);
                        this.lastVideoJBDelay.set(r.ssrc, {
                            jitterBufferDelay: h,
                            jitterBufferEmittedCount: p
                        }), v || (v = {jitterBufferDelay: 0, jitterBufferEmittedCount: 0});
                        var g = 1e3 * (h - v.jitterBufferDelay) / (p - v.jitterBufferEmittedCount);
                        r.jitterBufferMs = g, r.currentDelayMs = Math.round(g)
                    }
                }, t.prototype.processAudioTrackSenderStats = function (e, t, r) {
                    var n, i, o, s, a = t ? this.report.get(t) : void 0,
                        c = null !== (i = null !== (n = null == a ? void 0 : a.echoReturnLoss) && void 0 !== n ? n : e.echoReturnLoss) && void 0 !== i ? i : 0,
                        u = null !== (s = null !== (o = null == a ? void 0 : a.echoReturnLossEnhancement) && void 0 !== o ? o : e.echoReturnLossEnhancement) && void 0 !== s ? s : 0;
                    r.aecReturnLoss = c, r.aecReturnLossEnhancement = u
                }, t.prototype.processAudioTrackReceiverStats = function (e, t, r) {
                    var n, i, o, s, a, c, u, d = t ? this.report.get(t) : void 0,
                        l = null !== (n = null == d ? void 0 : d.removedSamplesForAcceleration) && void 0 !== n ? n : e.removedSamplesForAcceleration,
                        h = null !== (i = null == d ? void 0 : d.totalSamplesReceived) && void 0 !== i ? i : e.totalSamplesReceived,
                        p = null !== (o = null == d ? void 0 : d.jitterBufferDelay) && void 0 !== o ? o : e.jitterBufferDelay,
                        f = null !== (s = null == d ? void 0 : d.jitterBufferEmittedCount) && void 0 !== s ? s : e.jitterBufferEmittedCount,
                        m = null !== (a = null == d ? void 0 : d.audioLevel) && void 0 !== a ? a : null == e ? void 0 : e.audioLevel,
                        _ = null !== (c = null == d ? void 0 : d.totalSamplesDuration) && void 0 !== c ? c : null == e ? void 0 : e.totalSamplesDuration,
                        v = null !== (u = null == d ? void 0 : d.concealedSamples) && void 0 !== u ? u : e.concealedSamples;
                    if (l && h && (r.accelerateRate = l / h), p && f) {
                        var g = this.lastAudioJBDelay.get(r.ssrc);
                        this.lastAudioJBDelay.set(r.ssrc, {
                            jitterBufferDelay: p,
                            jitterBufferEmittedCount: f
                        }), g || (g = {jitterBufferDelay: 0, jitterBufferEmittedCount: 0});
                        var E = 1e3 * (p - g.jitterBufferDelay) / (f - g.jitterBufferEmittedCount);
                        r.jitterBufferMs = Math.round(E)
                    }
                    r.outputLevel = m;
                    var y = 1920;
                    _ && h && (y = h / _ / 50, r.receivedFrames = Math.round(h / y)), v && (r.droppedFrames = Math.round(v / y))
                }, t.prototype.processRemoteInboundStats = function (e, t) {
                    var r = this.report.get(e);
                    r && (t.packetsLost = r.packetsLost, r.roundTripTime && (t.rttMs = 1e3 * r.roundTripTime))
                }, t.prototype.getCodecFromCodecStats = function (e) {
                    var t = this.report.get(e);
                    if (!t) return "";
                    var r = t.mimeType.match(/\/(.*)$/);
                    return r && r[1] ? r[1] : ""
                }, t.prototype.updateSendBitrate = function () {
                    var e = 0, t = null, r = null;
                    this.mediaBytesSent.forEach(function (t) {
                        e += t.diffMean()
                    }), this.mediaBytesRetransmit.forEach(function (e) {
                        t = null === t ? e.diffMean() : t + e.diffMean()
                    }), this.mediaBytesTargetEncode.forEach(function (e) {
                        r = null === r ? e.diffMean() : r + e.diffMean()
                    });
                    var n = null !== t ? e - t : e;
                    this._stats.bitrate = {
                        actualEncoded: 8 * n / (this.options.updateInterval / 1e3),
                        transmit: 8 * e / (this.options.updateInterval / 1e3)
                    }, null !== t && (this._stats.bitrate.retransmit = 8 * t / (this.options.updateInterval / 1e3)), null !== r && (this._stats.bitrate.targetEncoded = 8 * r / (this.options.updateInterval / 1e3))
                }, t
            }(cP), hP = function (e) {
                function t() {
                    return null !== e && e.apply(this, arguments) || this
                }

                return QN(t, e), t.prototype.updateStats = function () {
                    return Promise.resolve()
                }, t
            }(cP);

            function pP(e, t, r, n, i) {
                void 0 === t && (t = 250), void 0 === r && (r = 8), void 0 === n && (n = 500), void 0 === i && (i = 1e4);
                var o,
                    s = (o = navigator.userAgent.toLocaleLowerCase().match(/chrome\/[\d]*/i)) && o[0] ? Number(o[0].split("/")[1]) : null;
                return s ? s < 76 ? new uP(e, {
                    updateInterval: t,
                    lossRateInterval: r,
                    freezeRateLimit: n,
                    firstVideoDecodedTimeout: i
                }) : new lP(e, {
                    updateInterval: t,
                    lossRateInterval: r,
                    freezeRateLimit: n,
                    firstVideoDecodedTimeout: i
                }) : function (e) {
                    return !!window.RTCStatsReport && e.getStats() instanceof Promise
                }(e) ? new lP(e, {
                    updateInterval: t,
                    lossRateInterval: r,
                    freezeRateLimit: n,
                    firstVideoDecodedTimeout: i
                }) : new hP(e, {
                    updateInterval: t,
                    lossRateInterval: r,
                    freezeRateLimit: n,
                    firstVideoDecodedTimeout: i
                })
            }

            function fP(e, t) {
                var r = Object.keys(e);
                if (Object.getOwnPropertySymbols) {
                    var n = Object.getOwnPropertySymbols(e);
                    t && (n = n.filter(function (t) {
                        return Object.getOwnPropertyDescriptor(e, t).enumerable
                    })), r.push.apply(r, n)
                }
                return r
            }

            function mP(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var r = null != arguments[t] ? arguments[t] : {};
                    t % 2 ? fP(Object(r), !0).forEach(function (t) {
                        Kh(e, t, r[t])
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : fP(Object(r)).forEach(function (t) {
                        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t))
                    })
                }
                return e
            }

            let _P = (vE((dP = class e extends ng {
                get peerConnectionState() {
                    return this.peerConnection.connectionState
                }

                get iceConnectionState() {
                    return this.peerConnection.iceConnectionState
                }

                get currentLocalDescription() {
                    return this.peerConnection.currentLocalDescription
                }

                get currentRemoteDescription() {
                    return this.peerConnection.currentRemoteDescription
                }

                constructor(t, r) {
                    super(t, r), Kh(this, "store", void 0), Kh(this, "peerConnection", void 0), Kh(this, "remoteSDP", void 0), Kh(this, "initialOffer", void 0), Kh(this, "statsFilter", void 0), Kh(this, "useRTX", !1), Kh(this, "localCapabilities", void 0), Kh(this, "localCandidateCount", 0), Kh(this, "allCandidatesReceived", !1), Kh(this, "mutex", new KE("P2PConnection-mutex")), this.store = r, this.peerConnection = new RTCPeerConnection(e.resolvePCConfiguration(t), {optional: [{googDscp: !0}]}), this.statsFilter = pP(this.peerConnection, void 0, void 0, wh() ? 1200 : void 0), this.bindPCEvents(), this.bindStatsEvents(), this.store.p2pId = this.store.p2pId + 1
                }

                async establish() {
                    try {
                        const e = await this.peerConnection.createOffer({
                            offerToReceiveAudio: !0,
                            offerToReceiveVideo: !0
                        });
                        if (!e.sdp) throw new Error("Cannot get initialOffer.sdp when trying to establish PeerConnection.");
                        const t = kN(e.sdp),
                            r = DN(e.sdp, !this.useRTX, fm("FILTER_VIDEO_FEC"), fm("FILTER_AUDIO_FEC"), ["opus"]);
                        return this.localCapabilities = r, this.initialOffer = e, mP(mP({}, t), {}, {
                            rtpCapabilities: {
                                send: {
                                    audioCodecs: [],
                                    audioExtensions: [],
                                    videoCodecs: [],
                                    videoExtensions: []
                                },
                                recv: {audioCodecs: [], audioExtensions: [], videoCodecs: [], videoExtensions: []},
                                sendrecv: r
                            }, offerSDP: e.sdp
                        })
                    } catch (e) {
                        throw new Hf(qf.GET_LOCAL_CONNECTION_PARAMS_FAILED, e.toString())
                    }
                }

                async connect(e, t, r, n, i, o) {
                    try {
                        if (!this.initialOffer) throw new Error("Cannot establish P2PConnection without initial offer.");
                        this.remoteSDP = new class {
                            constructor(e) {
                                Kh(this, "sessionDesc", void 0), Kh(this, "localCapabilities", void 0), Kh(this, "rtpCapabilities", void 0), Kh(this, "candidates", void 0), Kh(this, "iceParameters", void 0), Kh(this, "dtlsParameters", void 0), Kh(this, "setup", void 0), Kh(this, "currentMidIndex", void 0), Kh(this, "cname", void 0), e = sb(e);
                                const {
                                        remoteIceParameters: t,
                                        remoteDtlsParameters: r,
                                        candidates: n,
                                        remoteRTPCapabilities: i,
                                        remoteSetup: o,
                                        localCapabilities: s,
                                        sdkCodec: a,
                                        cname: c
                                    } = e,
                                    u = ON.exports.parse("v=0\no=- 0 0 IN IP4 127.0.0.1\ns=AgoraGateway\nt=0 0\na=group:BUNDLE audio video\na=msid-semantic: WMS\na=ice-lite\nm=audio 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendrecv\na=rtcp-mux\na=rtcp-rsize\na=mid:audio\nm=video 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendrecv\na=rtcp-mux\na=rtcp-rsize\na=mid:video\n");
                                this.rtpCapabilities = i, this.candidates = n, this.iceParameters = t, this.dtlsParameters = r, this.setup = o, this.localCapabilities = s, this.cname = c;
                                for (let e = 0; e < u.mediaDescriptions.length; e++) {
                                    const s = u.mediaDescriptions[e];
                                    if (s.attributes.iceUfrag = t.iceUfrag, s.attributes.icePwd = t.icePwd, s.attributes.fingerprints = r.fingerprints, s.attributes.candidates = n, s.attributes.setup = o, "video" === s.media.mediaType) {
                                        s.media.fmts = i.videoCodecs.map(e => e.payloadType.toString(10));
                                        const e = i.videoCodecs.filter(e => {
                                            var t;
                                            return null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLowerCase().includes(a)
                                        });
                                        if (0 === e.length) throw new Error("Codec ".concat(a, " not supported by remote SDP."));
                                        s.attributes.payloads = e, s.attributes.extmaps = i.videoExtensions
                                    }
                                    "audio" === s.media.mediaType && (s.media.fmts = i.audioCodecs.map(e => e.payloadType.toString(10)), s.attributes.payloads = i.audioCodecs, s.attributes.extmaps = i.audioExtensions), u.mediaDescriptions[e] = this.mungMediaDesc(s)
                                }
                                this.sessionDesc = u, this.currentMidIndex = u.mediaDescriptions.length - 1
                            }

                            toString() {
                                return ON.exports.print(this.sessionDesc)
                            }

                            send(e, t, r) {
                                const {ssrcs: n, ssrcGroups: i} = MN(t, this.cname),
                                    o = this.sessionDesc.mediaDescriptions.find(t => e === qv.VIDEO ? "video" === t.media.mediaType : "audio" === t.media.mediaType),
                                    s = n[0].attributes.label, a = n[0].attributes.mslabel;
                                return o.attributes.ssrcs = o.attributes.ssrcs.concat(n), o.attributes.ssrcGroups = o.attributes.ssrcGroups.concat(i), {
                                    id: s,
                                    mslabel: a
                                }
                            }

                            batchSend(e) {
                                return e.map(e => {
                                    let {kind: t, ssrcMsg: r} = e;
                                    return this.send(t, r, void 0)
                                })
                            }

                            stopSending(e) {
                                this.sessionDesc.mediaDescriptions.forEach(t => {
                                    const r = [], n = [], i = [];
                                    t.attributes.ssrcs.forEach(t => {
                                        e.includes(t.attributes.label || "") ? i.push(t) : r.push(t)
                                    }), t.attributes.ssrcGroups.forEach(e => {
                                        i.map(e => e.ssrcId).includes(e.ssrcIds[0]) || n.push(e)
                                    }), t.attributes.ssrcs = r, t.attributes.ssrcGroups = n
                                })
                            }

                            mute(e) {
                                const t = this.sessionDesc.mediaDescriptions.find(t => t.attributes.mid === e);
                                if (!t) throw new Error("mediaDescription not found with ".concat(e, " in remote SDP when calling RemoteSDP.mute."));
                                t.attributes.direction = "inactive"
                            }

                            unmute(e) {
                                const t = this.sessionDesc.mediaDescriptions.find(t => t.attributes.mid === e);
                                if (!t) throw new Error("mediaDescription not found with ".concat(e, " in remote SDP when calling RemoteSDP.unmute."));
                                t.attributes.direction = "sendonly"
                            }

                            receive(e, t, r) {
                                e.forEach((e, t) => {
                                    const r = e._mediaStreamTrack,
                                        n = this.sessionDesc.mediaDescriptions.findIndex(e => e.attributes.mid === r.kind),
                                        i = this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[n], e);
                                    this.sessionDesc.mediaDescriptions[n] = i
                                })
                            }

                            stopReceiving(e) {
                            }

                            restartICE(e) {
                                e = sb(e), this.iceParameters = e, this.sessionDesc.mediaDescriptions.forEach(t => {
                                    t.attributes.iceUfrag = e.iceUfrag, t.attributes.icePwd = e.icePwd
                                })
                            }

                            predictReceivingMids(e) {
                                const t = [];
                                for (let r = 0; r < e; r++) t.push((this.currentMidIndex + r + 1).toString(10));
                                return t
                            }

                            mungRecvMediaDsec(e, t) {
                                const r = sb(e);
                                return UN(r, t), VN(r, t), r
                            }

                            updateRecvMedia(e, t) {
                                const r = this.sessionDesc.mediaDescriptions.findIndex(t => t.attributes.mid === e);
                                if (-1 !== r) {
                                    const e = this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[r], t);
                                    this.sessionDesc.mediaDescriptions[r] = e
                                }
                            }

                            bumpMid(e) {
                                this.currentMidIndex += e
                            }

                            updateTrackLabel(e, t, r) {
                                const n = this.sessionDesc.mediaDescriptions.find(t => e === qv.VIDEO ? "video" === t.attributes.mid : "audio" === t.attributes.mid);
                                if (n) {
                                    const e = n.attributes.ssrcs.find(e => e.attributes.label === t);
                                    var i;
                                    e && (e.attributes.label = r, null === (i = e.attributes.msid) || void 0 === i || i.replace(t, r))
                                }
                            }

                            mungMediaDesc(e) {
                                const t = sb(e);
                                return jN(t), function (e) {
                                    const t = e.attributes.extmaps.find(e => "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01" === e.extensionName);
                                    t && e.attributes.extmaps.splice(e.attributes.extmaps.indexOf(t), 1), e.attributes.payloads.forEach(e => {
                                        const t = e.rtcpFeedbacks.findIndex(e => "transport-cc" === e.type);
                                        -1 !== t && e.rtcpFeedbacks.splice(t, 1)
                                    })
                                }(t), t
                            }

                            getSSRC(e) {
                                for (const t of this.sessionDesc.mediaDescriptions) for (const r of t.attributes.ssrcs) if (r.attributes.label === e) return [r]
                            }
                        }({
                            remoteIceParameters: e,
                            remoteDtlsParameters: t,
                            candidates: r,
                            remoteRTPCapabilities: n.send,
                            remoteSetup: i,
                            localCapabilities: this.localCapabilities,
                            sdkCodec: this.store.codec,
                            cname: o
                        });
                        const s = this.remoteSDP.toString();
                        await this.peerConnection.setLocalDescription(this.initialOffer), await this.peerConnection.setRemoteDescription({
                            type: "answer",
                            sdp: s
                        })
                    } catch (e) {
                        throw new Hf(qf.EXCHANGE_SDP_FAILED, "P2PConnection.connect failed; ".concat(e.toString()))
                    }
                }

                send(e, t) {
                    var r = this;
                    return RN(function* () {
                        const n = yield IN(r.mutex.lock());
                        try {
                            if (!r.remoteSDP) throw new Error("Cannot call P2PConnection.send before remote SDP created");
                            const i = e.map(e => r.peerConnection.addTrack(e._mediaStreamTrack)),
                                o = yield IN(r.peerConnection.createOffer()), s = ON.exports.parse(o.sdp),
                                a = e.map(e => {
                                    const t = e._mediaStreamTrack,
                                        n = s.mediaDescriptions.find(e => e.attributes.mid === t.kind);
                                    if (!n) throw new Error("Cannot extract ssrc from mediaDescription.");
                                    return function (e, t, r) {
                                        const n = e.attributes.ssrcs.filter(e => e.attributes.label === t),
                                            i = e.attributes.ssrcGroups;
                                        if (0 === n.length) throw new Error("Cannot extract ssrc from plan-b SDP.");
                                        if (i && n.length > 1) {
                                            const e = i.find(e => -1 !== e.ssrcIds.indexOf(n[0].ssrcId));
                                            return e ? [{
                                                ssrcId: e.ssrcIds[0],
                                                rtx: r ? e.ssrcIds[1] : void 0
                                            }] : [{ssrcId: n[0].ssrcId}]
                                        }
                                        return [{ssrcId: n[0].ssrcId}]
                                    }(n, t.id, r.useRTX)
                                });
                            let c;
                            try {
                                c = yield a
                            } catch (e) {
                                throw i.forEach(e => {
                                    Ih() && e.replaceTrack(null), r.peerConnection.removeTrack(e)
                                }), e
                            }
                            const u = r.mungSendOfferSDP(o.sdp, e);
                            r.remoteSDP.receive(e, t, c);
                            const d = r.remoteSDP.toString();
                            return yield IN(r.peerConnection.setLocalDescription({
                                type: "offer",
                                sdp: u
                            })), yield IN(r.applySendEncodings(i, e)), yield IN(r.peerConnection.setRemoteDescription({
                                type: "answer",
                                sdp: d
                            })), e.map((e, t) => {
                                const r = e._mediaStreamTrack.id;
                                return {localSSRC: a[t], id: r}
                            })
                        } catch (e) {
                            throw new Hf(qf.EXCHANGE_SDP_FAILED, "P2PConnection.send failed; ".concat(e.toString()))
                        } finally {
                            n()
                        }
                    })()
                }

                async stopSending(e) {
                    try {
                        if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.stopSending before remote SDP created");
                        const t = this.peerConnection.getSenders().filter(t => {
                            var r;
                            return -1 !== e.indexOf((null === (r = t.track) || void 0 === r ? void 0 : r.id) || "")
                        });
                        if (t.length !== e.length) throw new Error("Transceivers' length doesn't match mids' length when trying to call P2PConnection.stopSending.");
                        t.map(e => {
                            Ih() && e.replaceTrack(null), this.peerConnection.removeTrack(e)
                        });
                        const r = await this.peerConnection.createOffer();
                        await this.peerConnection.setLocalDescription(r), this.remoteSDP.stopReceiving(e);
                        const n = this.remoteSDP.toString();
                        await this.peerConnection.setRemoteDescription({type: "answer", sdp: n})
                    } catch (e) {
                        throw new Hf(qf.EXCHANGE_SDP_FAILED, "P2PConnection.stopSending failed; ".concat(e.toString()))
                    }
                }

                async receive(e, t, r, n) {
                    try {
                        if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.receive ".concat(e, " before remoteSDP created."));
                        const {id: r, mslabel: i} = this.remoteSDP.send(e, t, n), o = new sl((t, n) => {
                            const o = setTimeout(() => {
                                n(new Error("Cannot receive track, id: ".concat(r)))
                            }, 1e4), s = n => {
                                const a = Sh();
                                if (("Safari" === a.name && 11 === Number(a.version) || Ch()) && n.track.id !== r && n.streams[0].id === i) {
                                    var c;
                                    const i = n.streams[0].getTracks()[0];
                                    return null === (c = this.remoteSDP) || void 0 === c || c.updateTrackLabel(e, r, n.track.id), this.peerConnection.removeEventListener("track", s), clearTimeout(o), void t(i)
                                }
                                if (n.track.id === r) return this.peerConnection.removeEventListener("track", s), clearTimeout(o), void t(n.track)
                            };
                            this.peerConnection.addEventListener("track", s)
                        }), s = this.remoteSDP.toString();
                        await this.peerConnection.setRemoteDescription({type: "offer", sdp: s});
                        const a = await this.peerConnection.createAnswer();
                        return await this.peerConnection.setLocalDescription(a), {track: await o, id: r}
                    } catch (e) {
                        throw new Hf(qf.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(e.toString()))
                    }
                }

                async stopReceiving(e) {
                    try {
                        if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.stopReceiving before remote SDP created.");
                        this.remoteSDP.stopSending(e);
                        const t = this.remoteSDP.toString();
                        await this.peerConnection.setRemoteDescription({type: "offer", sdp: t});
                        const r = await this.peerConnection.createAnswer();
                        await this.peerConnection.setLocalDescription(r)
                    } catch (e) {
                        throw new Hf(qf.EXCHANGE_SDP_FAILED, "P2PConnection stopReceiving failed; ".concat(e.toString()))
                    }
                }

                async muteRemote(e) {
                }

                async unmuteRemote(e) {
                }

                async muteLocal(e) {
                    try {
                        if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.muteLocal before remote SDP created.");
                        const t = this.peerConnection.getSenders().filter(t => {
                            var r;
                            return -1 !== e.indexOf((null === (r = t.track) || void 0 === r ? void 0 : r.id) || "")
                        });
                        if (t.length !== e.length) throw new Error("sender' length doesn't match mids' length.");
                        t.map(e => {
                            if (Ih() && e.track) e.track.enabled = !1; else {
                                const t = e.getParameters();
                                t.encodings.forEach(e => e.active = !1), e.setParameters(t)
                            }
                        })
                    } catch (e) {
                        throw new Hf(qf.EXCHANGE_SDP_FAILED, "P2PConnection.muteLocal failed; ".concat(e.toString()))
                    }
                }

                async unmuteLocal(e) {
                    try {
                        if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.unmuteLocal before remote SDP created.");
                        const t = this.peerConnection.getSenders().filter(t => {
                            var r;
                            return -1 !== e.indexOf((null === (r = t.track) || void 0 === r ? void 0 : r.id) || "")
                        });
                        if (t.length !== e.length) throw new Error("Senders' length doesn't match mids' length.");
                        t.map(async e => {
                            if (Ih() && e.track) e.track.enabled = !0; else {
                                const t = e.getParameters();
                                t.encodings.forEach(e => e.active = !0), await e.setParameters(t)
                            }
                        });
                        const r = await this.peerConnection.createOffer();
                        await this.peerConnection.setLocalDescription(r);
                        const n = this.remoteSDP.toString();
                        await this.peerConnection.setRemoteDescription({type: "answer", sdp: n})
                    } catch (e) {
                        throw new Hf(qf.EXCHANGE_SDP_FAILED, "P2PConnection.unmuteLocal failed; ".concat(e.toString()))
                    }
                }

                restartICE() {
                    var e = this;
                    return RN(function* () {
                        const t = yield IN(e.mutex.lock("From P2PConnection.restartICE"));
                        try {
                            const r = yield IN(e.peerConnection.createOffer({iceRestart: !0}));
                            if (!r.sdp) throw new Error("Cannot restartICE because restart offer SDP does not exist.");
                            const n = kN(r.sdp), {remoteIceParameters: i} = yield n.iceParameters;
                            if (!e.remoteSDP) throw new Error("Cannot restartICE before remoteSDP created.");
                            e.remoteSDP.restartICE(i);
                            const o = e.remoteSDP.toString();
                            yield IN(e.peerConnection.setLocalDescription(r)), yield IN(e.peerConnection.setRemoteDescription({
                                type: "answer",
                                sdp: o
                            }))
                        } catch (e) {
                            em.warning("restart ICE failed, abort operation", e)
                        } finally {
                            t()
                        }
                    })()
                }

                close() {
                    var e;
                    this.peerConnection.close(), null === (e = this.onConnectionStateChange) || void 0 === e || e.call(this, "closed"), this.unbindPCEvents(), this.unbindStatsEvents(), this.removeAllListeners(), this.statsFilter.destroy()
                }

                getStats() {
                    return this.statsFilter.getStats()
                }

                getRemoteVideoIsReady(e) {
                    return this.statsFilter.getVideoIsReady(e)
                }

                async updateEncoderConfig(e, t) {
                    try {
                        if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.updateEncoderConfig before remote SDP created.");
                        const r = await this.peerConnection.createOffer(), n = this.mungSendOfferSDP(r.sdp, [t]);
                        this.remoteSDP.updateRecvMedia(t._mediaStreamTrack.kind, t);
                        const i = this.remoteSDP.toString();
                        await this.peerConnection.setLocalDescription({
                            type: "offer",
                            sdp: n
                        }), await this.peerConnection.setRemoteDescription({type: "answer", sdp: i})
                    } catch (e) {
                        throw new Hf(qf.EXCHANGE_SDP_FAILED, e.toString())
                    }
                }

                async updateSendParameters(e, t) {
                    const r = this.peerConnection.getSenders().filter(t => {
                        var r;
                        return (null === (r = t.track) || void 0 === r ? void 0 : r.id) === e
                    });
                    1 === r.length && await this.applySendEncodings(r, [t])
                }

                setStatsRemoteVideoIsReady(e, t) {
                    this.statsFilter.setVideoIsReady2(e, t)
                }

                async replaceTrack(e, t) {
                    const r = this.peerConnection.getSenders().find(e => {
                        var r;
                        return (null === (r = e.track) || void 0 === r ? void 0 : r.id) === t
                    });
                    r && await r.replaceTrack(e._mediaStreamTrack)
                }

                bindPCEvents() {
                    this.peerConnection.oniceconnectionstatechange = (() => {
                        var e;
                        null === (e = this.onICEConnectionStateChange) || void 0 === e || e.call(this, this.peerConnection.iceConnectionState)
                    }), this.peerConnection.onconnectionstatechange = (() => {
                        var e;
                        null === (e = this.onConnectionStateChange) || void 0 === e || e.call(this, this.peerConnection.connectionState)
                    }), this.peerConnection.onicecandidate = (e => {
                        e.candidate ? this.localCandidateCount += 1 : (this.peerConnection.onicecandidate = null, this.allCandidatesReceived = !0, em.debug("[pc-".concat(this.store.p2pId, "] local candidate count"), this.localCandidateCount))
                    }), setTimeout(() => {
                        this.allCandidatesReceived || (this.allCandidatesReceived = !0, em.debug("[pc-".concat(this.store.p2pId, "] onicecandidate timeout, local candidate count"), this.localCandidateCount))
                    }, fm("CANDIDATE_TIMEOUT"))
                }

                unbindPCEvents() {
                    this.peerConnection.oniceconnectionstatechange = null, this.peerConnection.onconnectionstatechange = null, this.peerConnection.onsignalingstatechange = null, this.peerConnection.onicecandidateerror = null, this.peerConnection.onicecandidate = null, this.peerConnection.ontrack = null
                }

                static resolvePCConfiguration(t) {
                    const r = {iceServers: [], sdpSemantics: "plan-b"};
                    return t.iceServers ? r.iceServers = t.iceServers : t.turnServer && "off" !== t.turnServer.mode && (nv(t.turnServer.servers) ? r.iceServers = t.turnServer.servers : (r.iceServers && r.iceServers.push(...e.turnServerConfigToIceServers(t.turnServer.servers)), fm("USE_TURN_SERVER_OF_GATEWAY") && r.iceServers && t.turnServer.serversFromGateway && r.iceServers.push(...e.turnServerConfigToIceServers(t.turnServer.serversFromGateway)), t.turnServer.servers.concat(t.turnServer.serversFromGateway || []).forEach(e => {
                        e.forceturn && (r.iceTransportPolicy = "relay")
                    }))), r
                }

                static turnServerConfigToIceServers(e) {
                    const t = [];
                    return e.forEach(e => {
                        e.security ? e.tcpport && t.push({
                            username: e.username,
                            credential: e.password,
                            credentialType: "password",
                            urls: "turns:".concat(e.turnServerURL, ":").concat(e.tcpport, "?transport=tcp")
                        }) : (e.udpport && t.push({
                            username: e.username,
                            credential: e.password,
                            credentialType: "password",
                            urls: "turn:".concat(e.turnServerURL, ":").concat(e.udpport, "?transport=udp")
                        }), e.tcpport && t.push({
                            username: e.username,
                            credential: e.password,
                            credentialType: "password",
                            urls: "turn:".concat(e.turnServerURL, ":").concat(e.tcpport, "?transport=tcp")
                        }))
                    }), t
                }

                async applySendEncodings(e, t) {
                    try {
                        if (!og().supportSetRtpSenderParameters) return;
                        if (e.length !== t.length) return;
                        for (let n = 0; n < e.length; n++) {
                            var r;
                            const i = e[n], o = t[n];
                            if (!o) continue;
                            const s = {}, a = {};
                            if (o instanceof _A) switch (o._optimizationMode) {
                                case"motion":
                                    s.degradationPreference = "maintain-framerate";
                                    break;
                                case"detail":
                                    s.degradationPreference = "maintain-resolution";
                                    break;
                                default:
                                    s.degradationPreference = "balanced"
                            }
                            if (fm("DSCP_TYPE") && Mh()) {
                                const e = fm("DSCP_TYPE");
                                ["very-low", "low", "medium", "high"].includes(e) && (a.networkPriority = e)
                            }
                            const c = i.getParameters(), u = null === (r = c.encodings) || void 0 === r ? void 0 : r[0];
                            u && Object.assign(u, a), Object.assign(c, s), await i.setParameters(c)
                        }
                    } catch (e) {
                        em.debug("Apply RTPSendEncodings failed.")
                    }
                }

                mungSendOfferSDP(e, t) {
                    const r = ON.exports.parse(e);
                    return t.forEach((e, t) => {
                        const n = e._mediaStreamTrack, i = r.mediaDescriptions.find(e => e.attributes.mid === n.kind);
                        i && UN(i, e)
                    }), ON.exports.print(r)
                }

                bindStatsEvents() {
                    this.statsFilter.onFirstAudioReceived = (e => {
                        var t;
                        null === (t = this.onFirstAudioReceived) || void 0 === t || t.call(this, e)
                    }), this.statsFilter.onFirstVideoReceived = (e => {
                        var t;
                        null === (t = this.onFirstVideoReceived) || void 0 === t || t.call(this, e)
                    }), this.statsFilter.onFirstAudioDecoded = (e => {
                        var t;
                        null === (t = this.onFirstAudioDecoded) || void 0 === t || t.call(this, e)
                    }), this.statsFilter.onFirstVideoDecoded = ((e, t, r) => {
                        var n;
                        null === (n = this.onFirstVideoDecoded) || void 0 === n || n.call(this, e, t, r)
                    }), this.statsFilter.onSelectedLocalCandidateChanged = ((e, t) => {
                        var r;
                        null === (r = this.onSelectedLocalCandidateChanged) || void 0 === r || r.call(this, e, t)
                    }), this.statsFilter.onSelectedRemoteCandidateChanged = ((e, t) => {
                        var r;
                        null === (r = this.onSelectedRemoteCandidateChanged) || void 0 === r || r.call(this, e, t)
                    })
                }

                unbindStatsEvents() {
                    this.statsFilter.onFirstAudioReceived = void 0, this.statsFilter.onFirstVideoReceived = void 0, this.statsFilter.onFirstAudioDecoded = void 0, this.statsFilter.onFirstVideoDecoded = void 0, this.statsFilter.onSelectedLocalCandidateChanged = void 0, this.statsFilter.onSelectedRemoteCandidateChanged = void 0
                }

                async batchReceive(e) {
                    try {
                        if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.batchReceive before remoteSDP created.");
                        const t = this.remoteSDP.batchSend(e).map((t, r) => {
                            let {id: n, mslabel: i} = t;
                            const {kind: o} = e[r];
                            return new sl((e, t) => {
                                const r = setTimeout(() => {
                                    t(new Error("Cannot receive track, id: ".concat(n)))
                                }, 1e4), s = t => {
                                    const a = Sh();
                                    if ("Safari" === a.name && 11 === Number(a.version) && t.track.id !== n && t.streams[0].id === i) {
                                        var c;
                                        const i = t.streams[0].getTracks()[0];
                                        return null === (c = this.remoteSDP) || void 0 === c || c.updateTrackLabel(o, n, t.track.id), this.peerConnection.removeEventListener("track", s), clearTimeout(r), void e({
                                            track: i,
                                            id: n
                                        })
                                    }
                                    if (t.track.id === n) return this.peerConnection.removeEventListener("track", s), clearTimeout(r), void e({
                                        track: t.track,
                                        id: n
                                    })
                                };
                                this.peerConnection.addEventListener("track", s)
                            })
                        }), r = this.remoteSDP.toString();
                        await this.peerConnection.setRemoteDescription({type: "offer", sdp: r});
                        const n = await this.peerConnection.createAnswer();
                        return await this.peerConnection.setLocalDescription(n), await sl.all(t)
                    } catch (e) {
                        throw new Hf(qf.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(e.toString()))
                    }
                }

                async getRemoteSSRC(e) {
                    if (!this.remoteSDP) return;
                    const t = this.remoteSDP.getSSRC(e);
                    return null == t ? void 0 : t[0].ssrcId
                }
            }).prototype, "connect", [vP], Object.getOwnPropertyDescriptor(dP.prototype, "connect"), dP.prototype), vE(dP.prototype, "stopSending", [vP], Object.getOwnPropertyDescriptor(dP.prototype, "stopSending"), dP.prototype), vE(dP.prototype, "receive", [vP], Object.getOwnPropertyDescriptor(dP.prototype, "receive"), dP.prototype), vE(dP.prototype, "stopReceiving", [vP], Object.getOwnPropertyDescriptor(dP.prototype, "stopReceiving"), dP.prototype), vE(dP.prototype, "muteRemote", [vP], Object.getOwnPropertyDescriptor(dP.prototype, "muteRemote"), dP.prototype), vE(dP.prototype, "unmuteRemote", [vP], Object.getOwnPropertyDescriptor(dP.prototype, "unmuteRemote"), dP.prototype), vE(dP.prototype, "muteLocal", [vP], Object.getOwnPropertyDescriptor(dP.prototype, "muteLocal"), dP.prototype), vE(dP.prototype, "unmuteLocal", [vP], Object.getOwnPropertyDescriptor(dP.prototype, "unmuteLocal"), dP.prototype), vE(dP.prototype, "close", [vP], Object.getOwnPropertyDescriptor(dP.prototype, "close"), dP.prototype), vE(dP.prototype, "updateEncoderConfig", [vP], Object.getOwnPropertyDescriptor(dP.prototype, "updateEncoderConfig"), dP.prototype), vE(dP.prototype, "updateSendParameters", [vP], Object.getOwnPropertyDescriptor(dP.prototype, "updateSendParameters"), dP.prototype), vE(dP.prototype, "replaceTrack", [vP], Object.getOwnPropertyDescriptor(dP.prototype, "replaceTrack"), dP.prototype), vE(dP.prototype, "getRemoteSSRC", [vP], Object.getOwnPropertyDescriptor(dP.prototype, "getRemoteSSRC"), dP.prototype), dP);

            function vP(e, t, r) {
                const n = e[t];
                if ("function" != typeof n) throw new Error("Cannot use mutex on object property.");
                return r.value = async function () {
                    const e = this.mutex, r = await e.lock("Locking from P2PConnection.".concat(t));
                    try {
                        for (var i = arguments.length, o = new Array(i), s = 0; s < i; s++) o[s] = arguments[s];
                        return await n.apply(this, o)
                    } finally {
                        r()
                    }
                }, r
            }

            const gP = "9", EP = 4e4;
            var yP;

            function SP(e, t) {
                var r = Object.keys(e);
                if (Object.getOwnPropertySymbols) {
                    var n = Object.getOwnPropertySymbols(e);
                    t && (n = n.filter(function (t) {
                        return Object.getOwnPropertyDescriptor(e, t).enumerable
                    })), r.push.apply(r, n)
                }
                return r
            }

            function bP(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var r = null != arguments[t] ? arguments[t] : {};
                    t % 2 ? SP(Object(r), !0).forEach(function (t) {
                        Kh(e, t, r[t])
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : SP(Object(r)).forEach(function (t) {
                        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t))
                    })
                }
                return e
            }

            let TP = (vE((yP = class e extends ng {
                get currentLocalDescription() {
                    return this.peerConnection.currentLocalDescription
                }

                get currentRemoteDescription() {
                    return this.peerConnection.currentRemoteDescription
                }

                get peerConnectionState() {
                    return this.peerConnection.connectionState
                }

                get iceConnectionState() {
                    return this.peerConnection.iceConnectionState
                }

                constructor(t, r) {
                    super(t, r), Kh(this, "store", void 0), Kh(this, "peerConnection", void 0), Kh(this, "remoteSDP", void 0), Kh(this, "initialOffer", void 0), Kh(this, "transportEventReceiver", void 0), Kh(this, "statsFilter", void 0), Kh(this, "useRTX", fm("USE_RTX")), Kh(this, "localCapabilities", void 0), Kh(this, "localCandidateCount", 0), Kh(this, "allCandidatesReceived", !1), Kh(this, "mutex", new KE("P2PConnection-mutex")), this.store = r, this.peerConnection = new RTCPeerConnection(e.resolvePCConfiguration(t), {optional: [{googDscp: !0}]}), this.statsFilter = pP(this.peerConnection, void 0, void 0, wh() ? 1200 : void 0), this.bindPCEvents(), this.bindStatsEvents(), this.store.p2pId = this.store.p2pId + 1
                }

                async establish() {
                    try {
                        this.peerConnection.addTransceiver("video", {direction: "recvonly"}), this.peerConnection.addTransceiver("audio", {direction: "recvonly"});
                        const e = await this.peerConnection.createOffer();
                        if (!e.sdp) throw new Error("Cannot get initialOffer.sdp when trying to establish PeerConnection.");
                        const t = kN(e.sdp), r = await GN(!this.useRTX, fm("FILTER_VIDEO_FEC"), fm("FILTER_AUDIO_FEC"));
                        return this.localCapabilities = HN(r), this.initialOffer = e, bP(bP({}, t), {}, {
                            rtpCapabilities: r,
                            offerSDP: e.sdp
                        })
                    } catch (e) {
                        throw new Hf(qf.GET_LOCAL_CONNECTION_PARAMS_FAILED, e.toString())
                    }
                }

                async connect(e, t, r, n, i, o) {
                    try {
                        if (!this.initialOffer) throw new Error("Cannot establish P2PConnection without initial offer.");
                        this.remoteSDP = new class {
                            get localCapabilities() {
                                return sb(this._localCapabilities)
                            }

                            get rtpCapabilities() {
                                return sb(this._rtpCapabilities)
                            }

                            get candidates() {
                                return sb(this._candidates)
                            }

                            get iceParameters() {
                                return sb(this._iceParameters)
                            }

                            get dtlsParameters() {
                                return sb(this._dtlsParameters)
                            }

                            constructor(e) {
                                Kh(this, "sessionDesc", void 0), Kh(this, "_localCapabilities", void 0), Kh(this, "_rtpCapabilities", void 0), Kh(this, "_candidates", void 0), Kh(this, "_iceParameters", void 0), Kh(this, "_dtlsParameters", void 0), Kh(this, "setup", void 0), Kh(this, "currentMidIndex", void 0), Kh(this, "cname", void 0), Kh(this, "firefoxSsrcMidMap", new Map), e = sb(e);
                                const {
                                        remoteIceParameters: t,
                                        remoteDtlsParameters: r,
                                        candidates: n,
                                        remoteRTPCapabilities: i,
                                        remoteSetup: o,
                                        localCapabilities: s,
                                        cname: a
                                    } = e,
                                    c = ON.exports.parse("v=0\no=- 0 0 IN IP4 127.0.0.1\ns=AgoraGateway\nt=0 0\na=group:BUNDLE 0 1\na=msid-semantic: WMS\na=ice-lite\nm=video 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendonly\na=rtcp-mux\na=rtcp-rsize\na=mid:0\nm=audio 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendonly\na=rtcp-mux\na=rtcp-rsize\na=mid:1\n");
                                this._rtpCapabilities = i, this._candidates = n, this._iceParameters = t, this._dtlsParameters = r, this._localCapabilities = s, this.setup = o, this.cname = a;
                                const u = this.rtpCapabilities.send;
                                for (const e of c.mediaDescriptions) {
                                    if (e.attributes.iceUfrag = t.iceUfrag, e.attributes.icePwd = t.icePwd, e.attributes.fingerprints = r.fingerprints, e.attributes.candidates = n, e.attributes.setup = o, "video" === e.media.mediaType && (e.media.fmts = u.videoCodecs.map(e => e.payloadType.toString(10)), e.attributes.payloads = u.videoCodecs, e.attributes.extmaps = u.videoExtensions, fm("PRELOAD_MEDIA_COUNT") > 0)) {
                                        const {ssrcs: t, ssrcGroups: r} = MN([{
                                            ssrcId: EP,
                                            rtx: fm("USE_RTX") ? 40001 : void 0
                                        }], this.cname);
                                        e.attributes.ssrcs = t, e.attributes.ssrcGroups = r
                                    }
                                    if ("audio" === e.media.mediaType && (e.media.fmts = u.audioCodecs.map(e => e.payloadType.toString(10)), e.attributes.payloads = u.audioCodecs, e.attributes.extmaps = u.audioExtensions, KN(e), fm("PRELOAD_MEDIA_COUNT") > 0)) {
                                        const {ssrcs: t, ssrcGroups: r} = MN([{ssrcId: 2e4}], this.cname);
                                        e.attributes.ssrcs = t, e.attributes.ssrcGroups = r
                                    }
                                }
                                this.sessionDesc = c, this.currentMidIndex = c.mediaDescriptions.length - 1
                            }

                            preloadRemoteMedia() {
                                const e = fm("PRELOAD_MEDIA_COUNT");
                                this.rtpCapabilities;
                                const t = this.candidates, r = this.dtlsParameters, n = this.iceParameters,
                                    i = this.rtpCapabilities.send;
                                for (let o = 1; o < e; o++) {
                                    const e = 2 * o + 2e4, s = 2 * o + EP, {
                                        ssrcs: a,
                                        ssrcGroups: c
                                    } = MN([{ssrcId: e}], this.cname), {ssrcs: u, ssrcGroups: d} = MN([{
                                        ssrcId: s,
                                        rtx: fm("USE_RTX") ? s + 1 : void 0
                                    }], this.cname);
                                    this.sessionDesc.mediaDescriptions.push({
                                        media: {
                                            mediaType: "video",
                                            port: gP,
                                            protos: ["UDP", "TLS", "RTP", "SAVPF"],
                                            fmts: i.videoCodecs.map(e => e.payloadType.toString(10))
                                        },
                                        connections: [{nettype: "IN", addrtype: "IP4", address: "127.0.0.1"}],
                                        bandwidths: [],
                                        attributes: {
                                            iceUfrag: n.iceUfrag,
                                            icePwd: n.icePwd,
                                            unrecognized: [],
                                            candidates: t,
                                            extmaps: i.videoExtensions,
                                            fingerprints: r.fingerprints,
                                            imageattr: [],
                                            msids: [],
                                            remoteCandidatesList: [],
                                            rids: [],
                                            ssrcs: u,
                                            ssrcGroups: d,
                                            rtcpFeedbackWildcards: [],
                                            payloads: i.videoCodecs,
                                            rtcp: {port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0"},
                                            setup: this.setup,
                                            direction: "sendonly",
                                            rtcpMux: !0,
                                            rtcpRsize: !0,
                                            mid: "".concat(2 * o)
                                        }
                                    }), this.sessionDesc.mediaDescriptions.push({
                                        media: {
                                            mediaType: "audio",
                                            port: gP,
                                            protos: ["UDP", "TLS", "RTP", "SAVPF"],
                                            fmts: i.audioCodecs.map(e => e.payloadType.toString(10))
                                        },
                                        connections: [{nettype: "IN", addrtype: "IP4", address: "127.0.0.1"}],
                                        bandwidths: [],
                                        attributes: {
                                            iceUfrag: n.iceUfrag,
                                            icePwd: n.icePwd,
                                            unrecognized: [],
                                            candidates: t,
                                            extmaps: i.audioExtensions,
                                            fingerprints: r.fingerprints,
                                            imageattr: [],
                                            msids: [],
                                            remoteCandidatesList: [],
                                            rids: [],
                                            ssrcs: a,
                                            ssrcGroups: c,
                                            rtcpFeedbackWildcards: [],
                                            payloads: i.audioCodecs,
                                            rtcp: {port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0"},
                                            setup: this.setup,
                                            direction: "sendonly",
                                            rtcpMux: !0,
                                            rtcpRsize: !0,
                                            mid: "".concat(2 * o + 1)
                                        }
                                    }), this.currentMidIndex += 2
                                }
                                this.updateBundleMids()
                            }

                            toString() {
                                return ON.exports.print(this.sessionDesc)
                            }

                            send(e, t, r, n) {
                                const {ssrcs: i, ssrcGroups: o} = MN(t, this.cname, r),
                                    s = this.findPreloadMediaDesc(i);
                                if (s) {
                                    if (wh() && this.firefoxSsrcMidMap.set(i[0].ssrcId, s.attributes.mid), n && (n.tcc || n.remb)) {
                                        const e = this.sessionDesc.mediaDescriptions.indexOf(s);
                                        return this.sessionDesc.mediaDescriptions[e] = this.mungSendMediaDesc(s, n), {
                                            mid: s.attributes.mid,
                                            needExchangeSDP: !0
                                        }
                                    }
                                    return {mid: s.attributes.mid, needExchangeSDP: !1}
                                }
                                {
                                    const t = this.findAvailableMediaIndex(e, i);
                                    let r;
                                    return -1 === t || Ih() || Ch() || Ah() ? (r = this.createOrRecycleSendMedia(e, i, o, "sendonly", n), this.updateBundleMids()) : ((r = sb(this.sessionDesc.mediaDescriptions[t])).attributes.direction = "sendonly", r.attributes.ssrcs = i, r.attributes.ssrcGroups = o, this.sessionDesc.mediaDescriptions[t] = this.mungSendMediaDesc(r, n)), wh() && this.firefoxSsrcMidMap.set(i[0].ssrcId, r.attributes.mid), {
                                        mid: r.attributes.mid,
                                        needExchangeSDP: !0
                                    }
                                }
                            }

                            batchSend(e) {
                                const t = e.map(e => {
                                    let {kind: t, ssrcMsg: r, mslabel: n} = e;
                                    return this.send(t, r, n)
                                }), r = [];
                                let n = !1;
                                return t.forEach(e => {
                                    let {mid: t, needExchangeSDP: i} = e;
                                    i && (n = !0), r.push(t)
                                }), {mids: r, needExchangeSDP: n}
                            }

                            stopSending(e) {
                                const t = this.sessionDesc.mediaDescriptions.filter(t => t.attributes.mid && -1 !== e.indexOf(t.attributes.mid));
                                if (t.length !== e.length) throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.stopSending.");
                                t.forEach(e => {
                                    "0" === e.attributes.mid || wh() || Ih() || Ch() ? e.attributes.ssrcs = [] : (e.attributes.ssrcs = [], e.attributes.direction = "inactive", e.media.port = "0")
                                }), this.updateBundleMids()
                            }

                            mute(e) {
                                const t = this.sessionDesc.mediaDescriptions.find(t => t.attributes.mid === e);
                                if (!t) throw new Error("mediaDescription not found with ".concat(e, " in remote SDP when calling RemoteSDP.mute."));
                                t.attributes.direction = "inactive"
                            }

                            unmute(e) {
                                const t = this.sessionDesc.mediaDescriptions.find(t => t.attributes.mid === e);
                                if (!t) throw new Error("mediaDescription not found with ".concat(e, " in remote SDP when calling RemoteSDP.unmute."));
                                t.attributes.direction = "sendonly"
                            }

                            muteRemote(e) {
                                const t = this.sessionDesc.mediaDescriptions.filter(t => e.includes(t.attributes.mid || ""));
                                if (t.length !== e.length) throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.");
                                t.forEach(e => {
                                    e.attributes.direction = "inactive"
                                })
                            }

                            unmuteRemote(e) {
                                const t = this.sessionDesc.mediaDescriptions.filter(t => e.includes(t.attributes.mid || ""));
                                if (t.length !== e.length) throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.");
                                t.forEach(e => {
                                    e.attributes.direction = "recvonly"
                                })
                            }

                            receive(e, t, r, n) {
                                e.forEach((e, i) => {
                                    this.createOrRecycleRecvMedia(e, [], "recvonly", t, r, n[i])
                                }), this.updateBundleMids()
                            }

                            stopReceiving(e) {
                                const t = this.sessionDesc.mediaDescriptions.filter(t => -1 !== e.indexOf(t.attributes.mid));
                                if (t.length !== e.length) throw new Error("MediaDescriptions' length doesn't match mids's length when calling RemoteSDP.receive.");
                                t.forEach(e => {
                                    e.media.port = "0", e.attributes.direction = "inactive"
                                }), this.updateBundleMids()
                            }

                            restartICE(e) {
                                e = sb(e), this._iceParameters = e, this.sessionDesc.mediaDescriptions.forEach(t => {
                                    t.attributes.iceUfrag = e.iceUfrag, t.attributes.icePwd = e.icePwd
                                })
                            }

                            predictReceivingMids(e) {
                                const t = [];
                                for (let r = 0; r < e; r++) t.push((this.currentMidIndex + r + 1).toString(10));
                                return t
                            }

                            findAvailableMediaIndex(e, t) {
                                return this.sessionDesc.mediaDescriptions.findIndex(r => {
                                    const n = r.media.mediaType === e && "0" !== r.media.port && ("sendonly" === r.attributes.direction || "sendrecv" === r.attributes.direction) && 0 === r.attributes.ssrcs.length;
                                    if (wh()) {
                                        if (n) {
                                            const e = this.firefoxSsrcMidMap.get(t[0].ssrcId);
                                            return !(e || "0" !== r.attributes.mid && "1" !== r.attributes.mid) || !(!e || e !== r.attributes.mid)
                                        }
                                        return !1
                                    }
                                    return n
                                })
                            }

                            createOrRecycleRecvMedia(e, t, r, n, i, o) {
                                const s = e._mediaStreamTrack.kind, a = this.rtpCapabilities.recv,
                                    c = this.localCapabilities.send;
                                let u = [];
                                if (s === qv.VIDEO) {
                                    var d, l;
                                    if (fm("H264_PROFILE_LEVEL_ID") && "h264" === n && (u = a.videoCodecs.filter(e => {
                                        var t, r;
                                        return ((null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLowerCase()) || "").includes(n) && (null == e || null === (r = e.fmtp) || void 0 === r ? void 0 : r.parameters["profile-level-id"]) === fm("H264_PROFILE_LEVEL_ID")
                                    })), !u || 0 === (null === (d = u) || void 0 === d ? void 0 : d.length)) {
                                        const e = c.videoCodecs.filter(e => {
                                            var t;
                                            return ((null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLowerCase()) || "").includes(n)
                                        });
                                        0 !== e.length && (u = a.videoCodecs.filter(t => e.some(e => e.payloadType === t.payloadType)))
                                    }
                                    if (fm("USE_RTX")) {
                                        const e = u.map(e => e.payloadType.toString()), t = a.videoCodecs.filter(t => {
                                            var r, n;
                                            return "rtx" === (null === (r = t.rtpMap) || void 0 === r ? void 0 : r.encodingName) && e.includes((null === (n = t.fmtp) || void 0 === n ? void 0 : n.parameters.apt) || "")
                                        });
                                        u = [...u, ...t]
                                    }
                                    0 === u.length && (em.warning("codec ".concat(n, " not included in rtpCapabilities, fallback to default payloads: ").concat(null === (l = a.videoCodecs[0].rtpMap) || void 0 === l ? void 0 : l.encodingName)), u = a.videoCodecs)
                                } else 0 === (u = a.audioCodecs.filter(e => {
                                    var t;
                                    return ((null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLowerCase()) || "").includes(i)
                                })).length && (em.warning("codec ".concat(i, " not included in rtpCapabilities, fallback to opus")), u = a.audioCodecs.filter(e => {
                                    var t;
                                    return ((null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLowerCase()) || "").includes("opus")
                                }));
                                const h = s === qv.VIDEO ? a.videoExtensions : a.audioExtensions;
                                this.currentMidIndex += 1;
                                const p = "".concat(this.currentMidIndex);
                                let f = {
                                    media: {
                                        mediaType: s,
                                        port: gP,
                                        protos: ["UDP", "TLS", "RTP", "SAVPF"],
                                        fmts: u.map(e => e.payloadType.toString(10))
                                    },
                                    connections: [{nettype: "IN", addrtype: "IP4", address: "127.0.0.1"}],
                                    bandwidths: [],
                                    attributes: {
                                        iceUfrag: this.iceParameters.iceUfrag,
                                        icePwd: this.iceParameters.icePwd,
                                        unrecognized: [],
                                        candidates: this.candidates,
                                        extmaps: h,
                                        fingerprints: this.dtlsParameters.fingerprints,
                                        imageattr: [],
                                        msids: [],
                                        remoteCandidatesList: [],
                                        rids: [],
                                        ssrcs: t,
                                        ssrcGroups: [],
                                        rtcpFeedbackWildcards: [],
                                        payloads: u,
                                        rtcp: {port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0"},
                                        setup: this.setup,
                                        direction: r,
                                        rtcpMux: !0,
                                        rtcpRsize: !0,
                                        mid: "".concat(p)
                                    }
                                };
                                f = this.mungRecvMediaDsec(f, e, o);
                                const m = this.findFirstClosedMedia(s);
                                if (m) {
                                    const e = this.sessionDesc.mediaDescriptions.indexOf(m);
                                    this.sessionDesc.mediaDescriptions[e] = f
                                } else this.sessionDesc.mediaDescriptions.push(f);
                                return f
                            }

                            createOrRecycleSendMedia(e, t, r, n, i) {
                                const o = this.rtpCapabilities.send, s = e === qv.VIDEO ? o.videoCodecs : o.audioCodecs,
                                    a = e === qv.VIDEO ? o.videoExtensions : o.audioExtensions;
                                this.currentMidIndex += 1;
                                const c = "".concat(this.currentMidIndex);
                                let u = {
                                    media: {
                                        mediaType: e,
                                        port: gP,
                                        protos: ["UDP", "TLS", "RTP", "SAVPF"],
                                        fmts: s.map(e => e.payloadType.toString(10))
                                    },
                                    connections: [{nettype: "IN", addrtype: "IP4", address: "127.0.0.1"}],
                                    bandwidths: [],
                                    attributes: {
                                        iceUfrag: this.iceParameters.iceUfrag,
                                        icePwd: this.iceParameters.icePwd,
                                        unrecognized: [],
                                        candidates: this.candidates,
                                        extmaps: a,
                                        fingerprints: this.dtlsParameters.fingerprints,
                                        imageattr: [],
                                        msids: [],
                                        remoteCandidatesList: [],
                                        rids: [],
                                        ssrcs: t,
                                        ssrcGroups: r,
                                        rtcpFeedbackWildcards: [],
                                        payloads: s,
                                        rtcp: {port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0"},
                                        setup: this.setup,
                                        direction: n,
                                        rtcpMux: !0,
                                        rtcpRsize: !0,
                                        mid: "".concat(c)
                                    }
                                };
                                u = this.mungSendMediaDesc(u, i);
                                const d = this.findFirstClosedMedia(e);
                                if (d) {
                                    const e = this.sessionDesc.mediaDescriptions.indexOf(d);
                                    this.sessionDesc.mediaDescriptions[e] = u
                                } else this.sessionDesc.mediaDescriptions.push(u);
                                return u
                            }

                            updateBundleMids() {
                                this.sessionDesc.attributes.groups[0].identificationTag = this.sessionDesc.mediaDescriptions.filter(e => "0" !== e.media.port).map(e => e.attributes.mid)
                            }

                            mungRecvMediaDsec(e, t, r) {
                                const n = sb(e);
                                return jN(n), UN(n, t), VN(n, t), FN(n), BN(n, r, this.localCapabilities.send), n
                            }

                            mungSendMediaDesc(e, t) {
                                const r = sb(e);
                                return BN(r, t, this.localCapabilities.recv), KN(r), r
                            }

                            updateRecvMedia(e, t) {
                                const r = this.sessionDesc.mediaDescriptions.findIndex(t => t.attributes.mid === e);
                                if (-1 !== r) {
                                    const e = this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[r], t);
                                    this.sessionDesc.mediaDescriptions[r] = e
                                }
                            }

                            bumpMid(e) {
                                this.currentMidIndex += e
                            }

                            findFirstClosedMedia(e) {
                                return this.sessionDesc.mediaDescriptions.find(t => wh() ? "0" === t.media.port && t.media.mediaType === e : "0" === t.media.port)
                            }

                            findPreloadMediaDesc(e) {
                                return this.sessionDesc.mediaDescriptions.find(t => {
                                    var r, n;
                                    return (null === (r = t.attributes) || void 0 === r || null === (n = r.ssrcs[0]) || void 0 === n ? void 0 : n.ssrcId) === e[0].ssrcId
                                })
                            }

                            getSSRC(e) {
                                var t;
                                return null === (t = this.sessionDesc.mediaDescriptions.find(t => t.attributes.mid === e)) || void 0 === t ? void 0 : t.attributes.ssrcs
                            }
                        }({
                            remoteIceParameters: e,
                            remoteDtlsParameters: t,
                            candidates: r,
                            remoteRTPCapabilities: n,
                            remoteSetup: i,
                            localCapabilities: this.localCapabilities,
                            cname: o
                        });
                        const s = this.remoteSDP.toString(), a = ON.exports.parse(this.initialOffer.sdp),
                            c = a.mediaDescriptions.find(e => "audio" === e.media.mediaType);
                        c && KN(c);
                        const u = ON.exports.print(a), d = this.logSDPExchange(u || "", "offer", "local", "connect");
                        await this.peerConnection.setLocalDescription({
                            type: "offer",
                            sdp: u
                        }), null == d || d(s), await this.peerConnection.setRemoteDescription({type: "answer", sdp: s});
                        const l = this.peerConnection.getTransceivers()[0];
                        if (null != l && l.receiver && this.tryBindTransportEvents(l.receiver), fm("PRELOAD_MEDIA_COUNT") > 0) {
                            this.remoteSDP.preloadRemoteMedia();
                            const e = this.remoteSDP.toString();
                            await this.peerConnection.setRemoteDescription({type: "offer", sdp: e});
                            const t = await this.peerConnection.createAnswer();
                            await this.peerConnection.setLocalDescription(t)
                        }
                    } catch (e) {
                        throw new Hf(qf.EXCHANGE_SDP_FAILED, "P2PConnection.connect failed; ".concat(e.toString()))
                    }
                }

                send(e, t, r) {
                    var n = this;
                    return RN(function* () {
                        const i = yield IN(n.mutex.lock("From P2PConnection.send"));
                        try {
                            if (!n.remoteSDP) throw new Error("Cannot call P2PConnection.send before remote SDP created");
                            const o = [];
                            e.forEach(e => {
                                const t = n.peerConnection.addTransceiver(e._mediaStreamTrack, {direction: "sendonly"});
                                o.push(t)
                            }), wh() && !0 === fm("SIMULCAST") && (yield IN(n.applySimulcastForFirefox(o, e)));
                            const s = yield IN(n.peerConnection.createOffer()),
                                a = n.remoteSDP.predictReceivingMids(e.length), c = n.mungSendOfferSDP(s.sdp, e, a),
                                u = ON.exports.parse(c), d = a.map(e => {
                                    const t = u.mediaDescriptions.find(t => t.attributes.mid === e);
                                    if (!t) throw new Error("Cannot extract ssrc from mediaDescription.");
                                    return LN(t, n.useRTX)
                                });
                            let l;
                            try {
                                l = yield d
                            } catch (i) {
                                l = [], n.remoteSDP.receive(e, t, r, l);
                                const o = n.remoteSDP.toString();
                                throw yield IN(n.peerConnection.setLocalDescription({
                                    type: "offer",
                                    sdp: c
                                })), yield IN(n.peerConnection.setRemoteDescription({
                                    type: "answer",
                                    sdp: o
                                })), yield IN(n.stopSending(a, !0)), i
                            }
                            n.remoteSDP.receive(e, t, r, l);
                            const h = n.remoteSDP.toString(), p = n.logSDPExchange(c, "offer", "local", "send");
                            return yield IN(n.peerConnection.setLocalDescription({
                                type: "offer",
                                sdp: c
                            })), yield IN(n.applySimulcastEncodings(o, e)), yield IN(n.applySendEncodings(o, e)), null == p || p(h), yield IN(n.peerConnection.setRemoteDescription({
                                type: "answer",
                                sdp: h
                            })), o.map((e, t) => {
                                const r = a[t];
                                return {localSSRC: d[t], id: r, transceiver: e}
                            })
                        } catch (e) {
                            throw e instanceof Hf ? e : new Hf(qf.EXCHANGE_SDP_FAILED, "P2PConnection.send failed; ".concat(e.toString()))
                        } finally {
                            i()
                        }
                    })()
                }

                async stopSending(e, t) {
                    const r = t ? void 0 : await this.mutex.lock("From P2PConnection.stopSending");
                    try {
                        if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.stopSending before remote SDP created");
                        const t = this.peerConnection.getTransceivers().filter(t => -1 !== e.indexOf(t.mid));
                        if (t.length !== e.length) throw new Error("Transceivers' length doesn't match mids' length when trying to call P2PConnection.stopSending.");
                        t.map(e => {
                            var t;
                            e.direction = "inactive", null === (t = e.stop) || void 0 === t || t.call(e)
                        });
                        const n = await this.peerConnection.createOffer(),
                            i = this.logSDPExchange(n.sdp || "", "offer", "local", "stopSending");
                        await this.peerConnection.setLocalDescription(n), this.remoteSDP.stopReceiving(e);
                        const o = this.remoteSDP.toString();
                        null == i || i(o), await this.peerConnection.setRemoteDescription({type: "answer", sdp: o})
                    } catch (e) {
                        throw new Hf(qf.EXCHANGE_SDP_FAILED, "P2PConnection.stopSending failed; ".concat(e.toString()))
                    } finally {
                        r && r()
                    }
                }

                async receive(e, t, r, n) {
                    try {
                        if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.receive ".concat(e, " before remoteSDP created."));
                        const {mid: i, needExchangeSDP: o} = this.remoteSDP.send(e, t, r, n);
                        if (o) {
                            const t = this.remoteSDP.toString(),
                                r = this.logSDPExchange(t, "offer", "remote", "receive");
                            await this.peerConnection.setRemoteDescription({type: "offer", sdp: t});
                            const n = await this.peerConnection.createAnswer(),
                                o = this.mungReceiveAnswerSDP(n.sdp, i, e);
                            null == r || r(o || ""), await this.peerConnection.setLocalDescription({
                                type: "answer",
                                sdp: o
                            }), em.debug("[P2PConnection] receive ".concat(e, " by exchanging SDP."))
                        } else em.debug("[P2PConnection] receive ".concat(e, " no need to exchange SDP."));
                        const s = this.peerConnection.getTransceivers().find(e => e.mid === i);
                        if (!s) throw new Error("Cannot get transceiver after setLocalDescription.");
                        return {track: s.receiver.track, id: i}
                    } catch (e) {
                        throw new Hf(qf.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(e.toString()))
                    }
                }

                async batchReceive(e) {
                    try {
                        if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.batchReceive before remoteSDP created.");
                        const {mids: t, needExchangeSDP: r} = this.remoteSDP.batchSend(e);
                        if (r) {
                            const e = this.remoteSDP.toString(),
                                t = this.logSDPExchange(e, "offer", "remote", "receive");
                            await this.peerConnection.setRemoteDescription({type: "offer", sdp: e});
                            const r = await this.peerConnection.createAnswer();
                            null == t || t(r.sdp || ""), await this.peerConnection.setLocalDescription(r), em.debug("[P2PConnection] batchReceive by exchanging SDP.")
                        } else em.debug("[P2PConnection] batchReceive no need to exchange SDP.");
                        return t.map(e => {
                            const t = this.peerConnection.getTransceivers().find(t => t.mid === e);
                            if (!t) throw new Error("Cannot get transceiver after setLocalDescription.");
                            return {track: t.receiver.track, id: e}
                        })
                    } catch (e) {
                        throw new Hf(qf.EXCHANGE_SDP_FAILED, "P2PConnection.receive failed; ".concat(e.toString()))
                    }
                }

                async stopReceiving(e) {
                    try {
                        if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.stopReceiving before remote SDP created.");
                        this.remoteSDP.stopSending(e);
                        const t = this.remoteSDP.toString(),
                            r = this.logSDPExchange(t, "offer", "remote", "stopReceiving");
                        await this.peerConnection.setRemoteDescription({type: "offer", sdp: t});
                        const n = await this.peerConnection.createAnswer();
                        null == r || r(n.sdp || ""), await this.peerConnection.setLocalDescription(n)
                    } catch (e) {
                        throw new Hf(qf.EXCHANGE_SDP_FAILED, "P2PConnection stopReceiving failed; ".concat(e.toString()))
                    }
                }

                async muteRemote(e) {
                    try {
                        if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.muteRemote mid=".concat(e, " before remote SDP created."));
                        this.remoteSDP.mute(e);
                        const t = this.remoteSDP.toString(),
                            r = this.logSDPExchange(t, "offer", "remote", "muteRemote");
                        await this.peerConnection.setRemoteDescription({type: "offer", sdp: t});
                        const n = await this.peerConnection.createAnswer();
                        null == r || r(n.sdp || ""), await this.peerConnection.setLocalDescription(n)
                    } catch (e) {
                        throw new Hf(qf.EXCHANGE_SDP_FAILED, "P2PConnection.muteRemote failed; ".concat(e.toString()))
                    }
                }

                async unmuteRemote(e) {
                    try {
                        if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.unmuteRemote mid=".concat(e, " before remote SDP created."));
                        this.remoteSDP.unmute(e);
                        const t = this.remoteSDP.toString(),
                            r = this.logSDPExchange(t, "offer", "remote", "unmuteRemote");
                        await this.peerConnection.setRemoteDescription({type: "offer", sdp: t});
                        const n = await this.peerConnection.createAnswer();
                        null == r || r(n.sdp || ""), await this.peerConnection.setLocalDescription(n)
                    } catch (e) {
                        throw new Hf(qf.EXCHANGE_SDP_FAILED, "P2PConnection.unmuteRemote failed; ".concat(e.toString()))
                    }
                }

                async muteLocal(e) {
                    try {
                        if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.muteLocal before remote SDP created.");
                        const t = this.peerConnection.getTransceivers().filter(t => t.mid && -1 !== e.indexOf(t.mid));
                        if (t.length !== e.length) throw new Error("Transceivers' length doesn't match mids' length.");
                        t.map(e => {
                            e.direction = "inactive"
                        });
                        const r = await this.peerConnection.createOffer(),
                            n = this.logSDPExchange(r.sdp || "", "offer", "local", "muteLocal");
                        await this.peerConnection.setLocalDescription(r), this.remoteSDP.muteRemote(e);
                        const i = this.remoteSDP.toString();
                        null == n || n(i), await this.peerConnection.setRemoteDescription({type: "answer", sdp: i})
                    } catch (e) {
                        throw new Hf(qf.EXCHANGE_SDP_FAILED, "P2PConnection.muteLocal failed; ".concat(e.toString()))
                    }
                }

                async unmuteLocal(e) {
                    try {
                        if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.unmuteLocal before remote SDP created.");
                        const t = this.peerConnection.getTransceivers().filter(t => t.mid && -1 !== e.indexOf(t.mid));
                        if (t.length !== e.length) throw new Error("Transceivers' length doesn't match mids' length.");
                        t.map(async (e, t) => {
                            e.direction = "sendonly"
                        });
                        const r = await this.peerConnection.createOffer(),
                            n = this.logSDPExchange(r.sdp || "", "offer", "local", "unmuteLocal");
                        await this.peerConnection.setLocalDescription(r), this.remoteSDP.unmuteRemote(e);
                        const i = this.remoteSDP.toString();
                        null == n || n(i), await this.peerConnection.setRemoteDescription({type: "answer", sdp: i})
                    } catch (e) {
                        throw new Hf(qf.EXCHANGE_SDP_FAILED, "P2PConnection.unmuteLocal failed; ".concat(e.toString()))
                    }
                }

                restartICE() {
                    var e = this;
                    return RN(function* () {
                        const t = yield IN(e.mutex.lock("From P2PConnection.restartICE"));
                        try {
                            const r = yield IN(e.peerConnection.createOffer({iceRestart: !0}));
                            if (!r.sdp) throw new Error("Cannot restartICE because restart offer SDP does not exist.");
                            const n = kN(r.sdp), {remoteIceParameters: i} = yield n.iceParameters;
                            if (!e.remoteSDP) throw new Error("Cannot restartICE before remoteSDP created.");
                            e.remoteSDP.restartICE(i);
                            const o = e.remoteSDP.toString(),
                                s = e.logSDPExchange(r.sdp || "", "offer", "local", "restartICE");
                            yield IN(e.peerConnection.setLocalDescription(r)), null == s || s(o), yield IN(e.peerConnection.setRemoteDescription({
                                type: "answer",
                                sdp: o
                            }))
                        } catch (e) {
                            em.warning("restart ICE failed, abort operation", e)
                        } finally {
                            t()
                        }
                    })()
                }

                close() {
                    var e;
                    this.peerConnection.close(), null === (e = this.onConnectionStateChange) || void 0 === e || e.call(this, "closed"), this.tryUnbindTransportEvents(), this.unbindPCEvents(), this.unbindStatsEvents(), this.removeAllListeners(), this.transportEventReceiver = void 0, this.statsFilter.destroy()
                }

                getStats() {
                    return this.statsFilter.getStats()
                }

                getRemoteVideoIsReady(e) {
                    return this.statsFilter.getVideoIsReady(e)
                }

                async updateEncoderConfig(e, t) {
                    try {
                        if (!this.remoteSDP) throw new Error("Cannot call P2PConnection.updateEncoderConfig before remote SDP created.");
                        const r = await this.peerConnection.createOffer(), n = this.mungSendOfferSDP(r.sdp, [t], [e]);
                        this.remoteSDP.updateRecvMedia(e, t);
                        const i = this.remoteSDP.toString(),
                            o = this.logSDPExchange(n, "offer", "local", "updateEncoderConfig");
                        await this.peerConnection.setLocalDescription({
                            type: "offer",
                            sdp: n
                        }), null == o || o(i), await this.peerConnection.setRemoteDescription({type: "answer", sdp: i})
                    } catch (e) {
                        throw new Hf(qf.EXCHANGE_SDP_FAILED, e.toString())
                    }
                }

                async updateSendParameters(e, t) {
                    const r = this.peerConnection.getTransceivers().filter(t => t.mid === e);
                    1 === r.length && (this.isVP8Simulcast(t) ? wh() || await this.applySimulcastEncodings(r, [t]) : await this.applySendEncodings(r, [t]))
                }

                setStatsRemoteVideoIsReady(e, t) {
                    this.statsFilter.setVideoIsReady2(e, t)
                }

                async replaceTrack(e, t) {
                    const r = this.peerConnection.getTransceivers().find(e => e.mid === t);
                    r && await r.sender.replaceTrack(e._mediaStreamTrack)
                }

                bindPCEvents() {
                    this.peerConnection.oniceconnectionstatechange = (() => {
                        var e;
                        null === (e = this.onICEConnectionStateChange) || void 0 === e || e.call(this, this.peerConnection.iceConnectionState)
                    }), this.peerConnection.onconnectionstatechange = (() => {
                        var e;
                        null === (e = this.onConnectionStateChange) || void 0 === e || e.call(this, this.peerConnection.connectionState)
                    }), this.peerConnection.onicecandidate = (e => {
                        e.candidate ? this.localCandidateCount += 1 : (this.peerConnection.onicecandidate = null, this.allCandidatesReceived = !0, em.debug("[pc-".concat(this.store.p2pId, "] local candidate count"), this.localCandidateCount))
                    }), setTimeout(() => {
                        this.allCandidatesReceived || (this.allCandidatesReceived = !0, em.debug("[pc-".concat(this.store.p2pId, "] onicecandidate timeout, local candidate count"), this.localCandidateCount))
                    }, fm("CANDIDATE_TIMEOUT"))
                }

                unbindPCEvents() {
                    this.peerConnection.oniceconnectionstatechange = null, this.peerConnection.onconnectionstatechange = null, this.peerConnection.onsignalingstatechange = null, this.peerConnection.onicecandidateerror = null, this.peerConnection.onicecandidate = null, this.peerConnection.ontrack = null
                }

                static resolvePCConfiguration(t) {
                    const r = {iceServers: []};
                    return t.iceServers ? r.iceServers = t.iceServers : t.turnServer && "off" !== t.turnServer.mode && (nv(t.turnServer.servers) ? r.iceServers = t.turnServer.servers : (r.iceServers && r.iceServers.push(...e.turnServerConfigToIceServers(t.turnServer.servers)), fm("USE_TURN_SERVER_OF_GATEWAY") && r.iceServers && t.turnServer.serversFromGateway && r.iceServers.push(...e.turnServerConfigToIceServers(t.turnServer.serversFromGateway)), fm("FORCE_TURN_TCP") ? r.iceTransportPolicy = "relay" : t.turnServer.servers.concat(t.turnServer.serversFromGateway || []).forEach(e => {
                        e.forceturn && (r.iceTransportPolicy = "relay")
                    }))), r
                }

                static turnServerConfigToIceServers(e) {
                    const t = [];
                    return e.forEach(e => {
                        e.security ? e.tcpport && t.push({
                            username: e.username,
                            credential: e.password,
                            credentialType: "password",
                            urls: "turns:".concat(MS(e.turnServerURL), ":").concat(e.tcpport, "?transport=tcp")
                        }) : (e.udpport && !fm("FORCE_TURN_TCP") && t.push({
                            username: e.username,
                            credential: e.password,
                            credentialType: "password",
                            urls: "turn:".concat(e.turnServerURL, ":").concat(e.udpport, "?transport=udp")
                        }), e.tcpport && t.push({
                            username: e.username,
                            credential: e.password,
                            credentialType: "password",
                            urls: "turn:".concat(e.turnServerURL, ":").concat(e.tcpport, "?transport=tcp")
                        }))
                    }), t
                }

                tryBindTransportEvents(e) {
                    e.transport && (this.transportEventReceiver = e, e.transport.onstatechange = (() => {
                        var t, r;
                        null !== (t = e.transport) && void 0 !== t && t.state && (null === (r = this.onDTLSTransportStateChange) || void 0 === r || r.call(this, e.transport.state))
                    }), e.transport.onerror = (e => {
                        var t;
                        null === (t = this.onDTLSTransportError) || void 0 === t || t.call(this, e.error)
                    }), e.transport.iceTransport && (e.transport.iceTransport.onstatechange = (() => {
                        var t, r, n;
                        null !== (t = e.transport) && void 0 !== t && t.iceTransport.state && (null === (r = this.onICETransportStateChange) || void 0 === r || r.call(this, null === (n = e.transport) || void 0 === n ? void 0 : n.iceTransport.state))
                    })))
                }

                tryUnbindTransportEvents() {
                    this.transportEventReceiver && this.transportEventReceiver.transport && (this.transportEventReceiver.transport.onstatechange = null, this.transportEventReceiver.transport.onerror = null, this.transportEventReceiver.transport.iceTransport && (this.transportEventReceiver.transport.iceTransport.onstatechange = null))
                }

                async applySendEncodings(e, t) {
                    try {
                        if (!og().supportSetRtpSenderParameters) return;
                        if (e.length !== t.length) return;
                        for (let c = 0; c < e.length; c++) {
                            const u = e[c], d = t[c];
                            if (d && d instanceof _A) {
                                var r, n;
                                if (this.isVP8Simulcast(d)) continue;
                                const e = {}, t = {};
                                switch (d._optimizationMode) {
                                    case"motion":
                                        e.degradationPreference = "maintain-framerate";
                                        break;
                                    case"detail":
                                        e.degradationPreference = "maintain-resolution";
                                        break;
                                    default:
                                        e.degradationPreference = "balanced"
                                }
                                var i, o, s, a;
                                if (null !== (r = d._encoderConfig) && void 0 !== r && r.bitrateMax && (t.maxBitrate = 1e3 * (null === (i = d._encoderConfig) || void 0 === i ? void 0 : i.bitrateMax)), d._hints.includes(Pv.LOW_STREAM) && (null !== (o = d._encoderConfig) && void 0 !== o && o.frameRate && (t.maxFramerate = jS(d._encoderConfig.frameRate)), null !== (s = d._encoderConfig) && void 0 !== s && s.scaleResolutionDownBy && (null === (a = d._encoderConfig) || void 0 === a ? void 0 : a.scaleResolutionDownBy) > 1 && (t.scaleResolutionDownBy = d._encoderConfig.scaleResolutionDownBy)), fm("DSCP_TYPE") && Mh()) {
                                    const e = fm("DSCP_TYPE");
                                    ["very-low", "low", "medium", "high"].includes(e) && (t.networkPriority = e)
                                }
                                const c = u.sender.getParameters(),
                                    l = null === (n = c.encodings) || void 0 === n ? void 0 : n[0];
                                wh() && !l && (e.encodings = [t]), l && Object.assign(l, t), Object.assign(c, e), await u.sender.setParameters(c)
                            }
                        }
                    } catch (e) {
                        em.debug("Apply RTPSendEncodings failed.")
                    }
                }

                mungSendOfferSDP(e, t, r) {
                    const n = ON.exports.parse(e);
                    return t.forEach((e, t) => {
                        const i = r[t], o = n.mediaDescriptions.find(e => e.attributes.mid === i);
                        o && (UN(o, e), WN(o, e, this.store.codec))
                    }), ON.exports.print(n)
                }

                mungReceiveAnswerSDP(e, t, r) {
                    const n = ON.exports.parse(e), i = n.mediaDescriptions.find(e => e.attributes.mid === t);
                    return i && r === qv.AUDIO && "audio" === i.media.mediaType && KN(i), ON.exports.print(n)
                }

                bindStatsEvents() {
                    this.statsFilter.onFirstAudioReceived = (e => {
                        var t;
                        null === (t = this.onFirstAudioReceived) || void 0 === t || t.call(this, e)
                    }), this.statsFilter.onFirstVideoReceived = (e => {
                        var t;
                        null === (t = this.onFirstVideoReceived) || void 0 === t || t.call(this, e)
                    }), this.statsFilter.onFirstAudioDecoded = (e => {
                        var t;
                        null === (t = this.onFirstAudioDecoded) || void 0 === t || t.call(this, e)
                    }), this.statsFilter.onFirstVideoDecoded = ((e, t, r) => {
                        var n;
                        null === (n = this.onFirstVideoDecoded) || void 0 === n || n.call(this, e, t, r)
                    }), this.statsFilter.onSelectedLocalCandidateChanged = ((e, t) => {
                        var r;
                        null === (r = this.onSelectedLocalCandidateChanged) || void 0 === r || r.call(this, e, t)
                    }), this.statsFilter.onSelectedRemoteCandidateChanged = ((e, t) => {
                        var r;
                        null === (r = this.onSelectedRemoteCandidateChanged) || void 0 === r || r.call(this, e, t)
                    }), this.statsFilter.onFirstVideoDecodedTimeout = (e => {
                        var t;
                        null === (t = this.onFirstVideoDecodedTimeout) || void 0 === t || t.call(this, e)
                    })
                }

                unbindStatsEvents() {
                    this.statsFilter.onFirstAudioReceived = void 0, this.statsFilter.onFirstVideoReceived = void 0, this.statsFilter.onFirstAudioDecoded = void 0, this.statsFilter.onFirstVideoDecoded = void 0, this.statsFilter.onSelectedLocalCandidateChanged = void 0, this.statsFilter.onSelectedRemoteCandidateChanged = void 0, this.statsFilter.onFirstVideoDecodedTimeout = void 0
                }

                async applySimulcastForFirefox(e, t) {
                    if (e.length === t.length) for (let s = 0; s < e.length; s++) {
                        var r, n, i, o;
                        const a = e[s], c = t[s];
                        if (c instanceof _A && !c._hints.includes(Pv.LOW_STREAM) && null !== (r = c._encoderConfig) && void 0 !== r && r.bitrateMax && (null === (n = c._encoderConfig) || void 0 === n ? void 0 : n.bitrateMax) > 200 && null !== (i = c._scalabiltyMode) && void 0 !== i && i.numSpatialLayers && (null === (o = c._scalabiltyMode) || void 0 === o ? void 0 : o.numSpatialLayers) > 1 && "vp8" === this.store.codec) {
                            const e = {}, t = {high: 1e3 * (c._encoderConfig.bitrateMax - 50), medium: 5e4};
                            e.encodings = [{
                                rid: "m",
                                active: !0,
                                maxBitrate: t.medium,
                                scaleResolutionDownBy: 4
                            }, {rid: "h", active: !0, maxBitrate: t.high}];
                            const r = a.sender.getParameters();
                            await a.sender.setParameters(Object.assign(r, e))
                        }
                    }
                }

                async applySimulcastEncodings(e, t) {
                    if (!wh() && e.length === t.length) for (let r = 0; r < e.length; r++) {
                        const n = t[r];
                        if (n instanceof _A && this.isVP8Simulcast(n)) {
                            const t = e[r], i = {}, o = {high: 1e3 * (n._encoderConfig.bitrateMax - 50), medium: 5e4};
                            i.encodings = [{
                                active: !0,
                                adaptivePtime: !1,
                                networkPriority: "high",
                                priority: "high",
                                maxBitrate: o.high
                            }, {
                                active: !0,
                                adaptivePtime: !1,
                                networkPriority: "low",
                                priority: "low",
                                maxBitrate: o.medium,
                                scaleResolutionDownBy: 4
                            }];
                            const s = t.sender.getParameters();
                            await t.sender.setParameters(Object.assign(s, i))
                        }
                    }
                }

                isVP8Simulcast(e) {
                    var t, r, n, i;
                    return !!(e instanceof _A && fm("SIMULCAST") && "vp8" === this.store.codec && !e._hints.includes(Pv.LOW_STREAM) && null !== (t = e._encoderConfig) && void 0 !== t && t.bitrateMax && (null === (r = e._encoderConfig) || void 0 === r ? void 0 : r.bitrateMax) > 200 && null !== (n = e._scalabiltyMode) && void 0 !== n && n.numSpatialLayers && (null === (i = e._scalabiltyMode) || void 0 === i ? void 0 : i.numSpatialLayers) > 1)
                }

                logSDPExchange(e, t, r, n) {
                    if (fm("SDP_LOGGING")) return em.upload("exchanging ".concat(r, " ").concat(t, " SDP during P2PConnection.").concat(n, "\n"), e), "offer" === t ? e => {
                        this.logSDPExchange(e, "answer", "local" === r ? "remote" : "local", n)
                    } : void 0
                }

                async getRemoteSSRC(e) {
                    if (!this.remoteSDP) return;
                    const t = this.remoteSDP.getSSRC(e);
                    return null == t ? void 0 : t[0].ssrcId
                }
            }).prototype, "connect", [RP], Object.getOwnPropertyDescriptor(yP.prototype, "connect"), yP.prototype), vE(yP.prototype, "receive", [RP], Object.getOwnPropertyDescriptor(yP.prototype, "receive"), yP.prototype), vE(yP.prototype, "batchReceive", [RP], Object.getOwnPropertyDescriptor(yP.prototype, "batchReceive"), yP.prototype), vE(yP.prototype, "stopReceiving", [RP], Object.getOwnPropertyDescriptor(yP.prototype, "stopReceiving"), yP.prototype), vE(yP.prototype, "muteRemote", [RP], Object.getOwnPropertyDescriptor(yP.prototype, "muteRemote"), yP.prototype), vE(yP.prototype, "unmuteRemote", [RP], Object.getOwnPropertyDescriptor(yP.prototype, "unmuteRemote"), yP.prototype), vE(yP.prototype, "muteLocal", [RP], Object.getOwnPropertyDescriptor(yP.prototype, "muteLocal"), yP.prototype), vE(yP.prototype, "unmuteLocal", [RP], Object.getOwnPropertyDescriptor(yP.prototype, "unmuteLocal"), yP.prototype), vE(yP.prototype, "close", [RP], Object.getOwnPropertyDescriptor(yP.prototype, "close"), yP.prototype), vE(yP.prototype, "updateEncoderConfig", [RP], Object.getOwnPropertyDescriptor(yP.prototype, "updateEncoderConfig"), yP.prototype), vE(yP.prototype, "updateSendParameters", [RP], Object.getOwnPropertyDescriptor(yP.prototype, "updateSendParameters"), yP.prototype), vE(yP.prototype, "replaceTrack", [RP], Object.getOwnPropertyDescriptor(yP.prototype, "replaceTrack"), yP.prototype), vE(yP.prototype, "getRemoteSSRC", [RP], Object.getOwnPropertyDescriptor(yP.prototype, "getRemoteSSRC"), yP.prototype), yP);

            function RP(e, t, r) {
                const n = e[t];
                if ("function" != typeof n) throw new Error("Cannot use mutex on object property.");
                return r.value = async function () {
                    const e = this.mutex, r = await e.lock("From P2PConnection.".concat(t));
                    try {
                        for (var i = arguments.length, o = new Array(i), s = 0; s < i; s++) o[s] = arguments[s];
                        return await n.apply(this, o)
                    } finally {
                        r()
                    }
                }, r
            }

            function IP(e, t) {
                let r = document.createElement("video"), n = document.createElement("canvas");
                r.setAttribute("style", "display:none"), n.setAttribute("style", "display:none"), r.setAttribute("muted", ""), r.muted = !0, r.setAttribute("autoplay", ""), r.autoplay = !0, r.setAttribute("playsinline", ""), n.width = jS(t.width), n.height = jS(t.height);
                const i = jS(t.framerate || 15);
                document.body.append(r), document.body.append(n);
                let o = e._mediaStreamTrack;
                r.srcObject = new MediaStream([o]), r.play();
                const s = n.getContext("2d");
                if (!s) throw new Hf(qf.UNEXPECTED_ERROR, "can not get canvas context");
                const a = og(), c = n.captureStream(a.supportRequestFrame ? 0 : i).getVideoTracks()[0],
                    u = ry(() => (() => {
                        if (r.paused && r.play(), r.videoHeight > 2 && r.videoWidth > 2) {
                            const e = r.videoWidth, t = r.videoHeight / e, i = n.width * t;
                            Math.abs(i - n.height) >= 2 && (em.debug("adjust low stream resolution", "".concat(n.width, "x").concat(n.height, " -> ").concat(n.width, "x").concat(i)), n.height = i)
                        }
                        s.drawImage(r, 0, 0, n.width, n.height), c.requestFrame && c.requestFrame(), o !== e._mediaStreamTrack && (o = e._mediaStreamTrack, r.srcObject = new MediaStream([o]))
                    })(), i), d = c.stop;
                return c.stop = (() => {
                    d.call(c), u(), r && (r.remove(), r = null), n && (n.width = 0, n.remove(), n = null), em.debug("clean low stream renderer")
                }), c
            }

            var wP, CP, AP, OP, NP, PP, DP, kP, LP, xP, MP, UP;

            function jP(e, t) {
                var r = Object.keys(e);
                if (Object.getOwnPropertySymbols) {
                    var n = Object.getOwnPropertySymbols(e);
                    t && (n = n.filter(function (t) {
                        return Object.getOwnPropertyDescriptor(e, t).enumerable
                    })), r.push.apply(r, n)
                }
                return r
            }

            function VP(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var r = null != arguments[t] ? arguments[t] : {};
                    t % 2 ? jP(Object(r), !0).forEach(function (t) {
                        Kh(e, t, r[t])
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : jP(Object(r)).forEach(function (t) {
                        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t))
                    })
                }
                return e
            }

            class FP extends GE {
                getUserId() {
                    return this._userId
                }

                constructor(e, t, r, n) {
                    super(e, "track-".concat(e.kind, "-").concat(t, "-").concat(n.clientId, "_").concat(YS(5, ""))), Kh(this, "_userId", void 0), Kh(this, "_uintId", void 0), Kh(this, "_isDestroyed", !1), Kh(this, "store", void 0), Kh(this, "processor", void 0), Kh(this, "processorContext", void 0), this._userId = t, this._uintId = r, this.store = n
                }

                _updateOriginMediaStreamTrack(e) {
                    this._originMediaStreamTrack = e, this._mediaStreamTrack = e, this._updatePlayerSource(), this.processor && this.processor.updateInput({
                        track: this._originMediaStreamTrack,
                        context: this.processorContext
                    })
                }

                _destroy() {
                    this._isDestroyed = !0, em.info("[".concat(this.getTrackId(), "] is destroyed")), this.stop(), super.close()
                }

                getProcessorStats() {
                    return this.processorContext.gatherStats()
                }

                getProcessorUsage() {
                    return this.processorContext.gatherUsage()
                }
            }

            let BP = (wP = BE({argsMap: (e, t, r) => [e.getTrackId(), "string" == typeof t ? t : "HTMLElement", r]}), CP = BE({argsMap: e => [e.getTrackId()]}), AP = BE({argsMap: (e, t) => [e.getTrackId(), t.name]}), OP = BE({argsMap: e => [e.getTrackId()]}), vE((NP = class extends FP {
                    get isPlaying() {
                        return !(!this._player || this._player.videoElementStatus !== A_.PLAYING)
                    }

                    get __className__() {
                        return "RemoteVideoTrack"
                    }

                    constructor(e, t, r, n) {
                        super(e, t, r, n), Kh(this, "_videoVisibleTimer", null), Kh(this, "_previousVideoVisibleStatus", void 0), Kh(this, "_clearPreviousVideoVisibleStatus", () => this._previousVideoVisibleStatus = void 0), Kh(this, "trackMediaType", "video"), Kh(this, "_videoWidth", void 0), Kh(this, "_videoHeight", void 0), Kh(this, "_player", void 0), Kh(this, "processorDestination", void 0), Kh(this, "processorContext", void 0), this.updateMediaStreamTrackResolution(), this.processorContext = new vS(this.getTrackId(), "remote"), this.processorDestination = new _S(this.processorContext), this.bindProcessorDestinationEvents()
                    }

                    getStats() {
                        return cb(() => {
                            em.warning("[deprecated] RemoteVideoTrack.getStats will be removed in the future, use AgoraRTCClient.getRemoteVideoStats instead")
                        }, "remoteVideoTrackGetStatsWarning"), tb(this, Nv.GET_STATS) || VP({}, dv)
                    }

                    play(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                        if ("string" == typeof e) {
                            const t = document.getElementById(e);
                            t ? e = t : (em.warning("[".concat(this.getTrackId(), '] can not find "#').concat(e, '" element, use document.body')), e = document.body)
                        }
                        em.debug("[".concat(this.getTrackId(), "] start video playback"), JSON.stringify(t));
                        const r = VP(VP({fit: "cover"}, t), {}, {trackId: this.getTrackId(), element: e});
                        this._player ? this._player.updateConfig(r) : (this._player = new uC(r), this._player.updateVideoTrack(this._mediaStreamTrack), this._player.onFirstVideoFrameDecoded = (() => {
                            this.store.subscribe(this.getUserId(), "video", void 0, void 0, Date.now()), this.emit(xv.FIRST_FRAME_DECODED)
                        })), this._player.play(this.store.sessionId || void 0), this._videoVisibleTimer && window.clearInterval(this._videoVisibleTimer), this._clearPreviousVideoVisibleStatus(), this._videoVisibleTimer = window.setInterval(() => {
                            try {
                                const e = this.getVideoElementVisibleStatus();
                                this.emit(xv.VIDEO_ELEMENT_VISIBLE_STATUS, e)
                            } catch (e) {
                            }
                        }, fm("CHECK_VIDEO_VISIBLE_INTERVAL"))
                    }

                    stop() {
                        this._player && (this._videoVisibleTimer && (window.clearInterval(this._videoVisibleTimer), this._videoVisibleTimer = null), this._clearPreviousVideoVisibleStatus(), this._player.destroy(), this._player = void 0, em.debug("[".concat(this.getTrackId(), "] stop video playback")))
                    }

                    getCurrentFrameData() {
                        return this._player ? this._player.getCurrentFrame() : new ImageData(2, 2)
                    }

                    updateMediaStreamTrackResolution() {
                        QS(this._originMediaStreamTrack).then(e => {
                            let [t, r] = e;
                            this._videoHeight = r, this._videoWidth = t
                        }).catch(XS)
                    }

                    _updatePlayerSource() {
                        em.debug("[".concat(this.getTrackId(), "] update player source track")), this._player && this._player.updateVideoTrack(this._mediaStreamTrack)
                    }

                    getVideoElementVisibleStatus() {
                        try {
                            var e, t;
                            const r = null == this || null === (e = this._player) || void 0 === e ? void 0 : e.getContainerElement(),
                                n = {
                                    track: this,
                                    element: null == this || null === (t = this._player) || void 0 === t ? void 0 : t.getVideoElement(),
                                    slot: null == r ? void 0 : r.parentElement
                                }, {element: i, slot: o} = n;
                            if (this.isPlaying && i instanceof HTMLVideoElement && o instanceof HTMLElement) {
                                const e = pA.checkOneElementVisible(i), t = Object.assign({}, e);
                                if (t.visible !== this._previousVideoVisibleStatus) {
                                    this._previousVideoVisibleStatus = t.visible;
                                    const e = WE.reportApiInvoke(null, {
                                        tag: U_.TRACER,
                                        name: M_.REMOTE_VIDEO_TRACK_GET_VIDEO_VISIBLE,
                                        options: [this.getTrackId()]
                                    });
                                    t.visible ? e.onSuccess("Video is visible") : e.onSuccess("Invisible because of ".concat(t.reason))
                                }
                                return t
                            }
                            return
                        } catch (e) {
                            throw new Hf(qf.GET_VIDEO_ELEMENT_VISIBLE_ERROR, e.message)
                        }
                    }

                    pipe(e) {
                        if (this.processor === e) return e;
                        if (e._source) throw new Hf(qf.INVALID_OPERATION, "Processor ".concat(e.name, " already piped, please call unpipe beforehand."));
                        return this.unpipe(), this.processor = e, this.processor._source = this, e.updateInput({
                            track: this._originMediaStreamTrack,
                            context: this.processorContext
                        }), e
                    }

                    unpipe() {
                        if (!this.processor) return;
                        const e = this.processor;
                        this.processor._source = void 0, this.processor = void 0, e.reset()
                    }

                    bindProcessorDestinationEvents() {
                        this.processorDestination.on(Xv.ON_TRACK, async e => {
                            e ? e !== this._mediaStreamTrack && (this._mediaStreamTrack = e, this._updatePlayerSource()) : this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource())
                        })
                    }

                    unbindProcessorDestinationEvents() {
                        this.processorDestination.removeAllListeners(Xv.ON_TRACK)
                    }

                    _destroy() {
                        super._destroy(), this.unbindProcessorDestinationEvents()
                    }
                }).prototype, "play", [wP], Object.getOwnPropertyDescriptor(NP.prototype, "play"), NP.prototype), vE(NP.prototype, "stop", [CP], Object.getOwnPropertyDescriptor(NP.prototype, "stop"), NP.prototype), vE(NP.prototype, "pipe", [AP], Object.getOwnPropertyDescriptor(NP.prototype, "pipe"), NP.prototype), vE(NP.prototype, "unpipe", [OP], Object.getOwnPropertyDescriptor(NP.prototype, "unpipe"), NP.prototype), NP),
                WP = (PP = BE({
                    argsMap: (e, t) => [e.getTrackId(), t],
                    throttleTime: 300
                }), DP = BE({argsMap: (e, t) => [e.getTrackId(), t]}), kP = BE({argsMap: e => [e.getTrackId()]}), LP = BE({argsMap: e => [e.getTrackId()]}), xP = BE({argsMap: (e, t) => [e.getTrackId(), t.name]}), MP = BE({argsMap: e => [e.getTrackId()]}), vE((UP = class extends FP {
                    get isPlaying() {
                        return this._useAudioElement ? Sy.isPlaying(this.getTrackId()) : this._source.isPlayed
                    }

                    get __className__() {
                        return "RemoteAudioTrack"
                    }

                    constructor(e, t, r, n) {
                        super(e, t, r, n), Kh(this, "trackMediaType", "audio"), Kh(this, "_source", void 0), Kh(this, "_useAudioElement", !0), Kh(this, "_volume", 100), Kh(this, "processorContext", void 0), Kh(this, "processorDestination", void 0), Kh(this, "_played", !1), Kh(this, "_bypassWebAudio", !1), fm("DISABLE_WEBAUDIO") ? (this._source = new yS, this._bypassWebAudio = !0, this._useAudioElement = !0) : (this._source = new ay(e, !0), fm("REMOTE_AUDIO_TRACK_USES_WEB_AUDIO") && (this._useAudioElement = !1)), this._source.once(tv.RECEIVE_TRACK_BUFFER, () => {
                            this.emit(xv.FIRST_FRAME_DECODED)
                        }), this.processorContext = new ES(this._source.context, this.getTrackId(), "remote"), this.processorDestination = new gS(this.processorContext), this.bindProcessorDestinationEvents(), this._source.on(tv.UPDATE_SOURCE, () => {
                            this.processor && this.processor.updateInput({
                                node: this._source.processSourceNode,
                                context: this.processorContext
                            })
                        })
                    }

                    setAudioFrameCallback(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 4096;
                        if (!e) return this._source.removeAllListeners(tv.ON_AUDIO_BUFFER), void this._source.stopGetAudioBuffer();
                        this._source.startGetAudioBuffer(t), this._source.removeAllListeners(tv.ON_AUDIO_BUFFER), this._source.on(tv.ON_AUDIO_BUFFER, t => e(t))
                    }

                    setVolume(e) {
                        this._volume = e, this._useAudioElement ? Sy.setVolume(this.getTrackId(), e) : this._source.setVolume(e / 100)
                    }

                    async setPlaybackDevice(e) {
                        if (!this._useAudioElement) throw new Hf(qf.NOT_SUPPORTED, "your browser does not support setting the audio output device");
                        await Sy.setSinkID(this.getTrackId(), e)
                    }

                    getVolumeLevel() {
                        return this._source.getAccurateVolumeLevel()
                    }

                    getStats() {
                        return cb(() => {
                            em.warning("[deprecated] RemoteAudioTrack.getStats will be removed in the future, use AgoraRTCClient.getRemoteAudioStats instead")
                        }, "remoteAudioTrackGetStatsWarning"), tb(this, Nv.GET_STATS) || VP({}, cv)
                    }

                    play() {
                        em.debug("[".concat(this.getTrackId(), "] start audio playback")), this._played = !0, this._useAudioElement ? (em.debug("[".concat(this.getTrackId(), "] use audio element to play")), Sy.play(this._mediaStreamTrack, this.getTrackId(), this._volume, this.store.sessionId || void 0)) : this._source.play()
                    }

                    stop() {
                        em.debug("[".concat(this.getTrackId(), "] stop audio playback")), this._played = !1, this._useAudioElement ? Sy.stop(this.getTrackId()) : this._source.stop()
                    }

                    _destroy() {
                        super._destroy(), this._played = !1, this.unbindProcessorDestinationEvents(), this._source.destroy()
                    }

                    _isFreeze() {
                        return this._source.isFreeze
                    }

                    _updatePlayerSource() {
                        let e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
                        em.debug("[".concat(this.getTrackId(), "] update player source track")), e && this._source.updateTrack(this._mediaStreamTrack), this._useAudioElement && Sy.updateTrack(this.getTrackId(), this._mediaStreamTrack)
                    }

                    pipe(e) {
                        if (this._bypassWebAudio) throw new Hf(qf.NOT_SUPPORTED, "can not pipe extension when WebAudio disabled");
                        if (this.processor === e) return e;
                        if (e._source) throw new Hf(qf.INVALID_OPERATION, "Processor ".concat(e.name, " already piped, please call unpipe beforehand."));
                        return this.unpipe(), this.processor = e, this.processor._source = this, e.updateInput({
                            track: this._originMediaStreamTrack,
                            node: this._source.processSourceNode,
                            context: this.processorContext
                        }), e
                    }

                    unpipe() {
                        var e;
                        if (this._bypassWebAudio) throw new Hf(qf.NOT_SUPPORTED, "can not unpipe extension when WebAudio disabled");
                        if (!this.processor) return;
                        const t = this.processor;
                        null === (e = this._source.processSourceNode) || void 0 === e || e.disconnect(), this.processor._source = !1, this.processor = void 0, t.reset()
                    }

                    bindProcessorDestinationEvents() {
                        this.processorDestination.on(Xv.ON_TRACK, async e => {
                            e ? e !== this._mediaStreamTrack && (this._mediaStreamTrack = e, this._updatePlayerSource(!1), this._source.processedNode = this._source.createMediaStreamSourceNode(e)) : this._mediaStreamTrack !== this._originMediaStreamTrack && (this._mediaStreamTrack = this._originMediaStreamTrack, this._updatePlayerSource())
                        }), this.processorDestination.on(Xv.ON_NODE, e => {
                            this._source.processedNode = e;
                            const t = !e;
                            this._useAudioElement !== t && (this._played ? (this.stop(), this._useAudioElement = t, this.play()) : this._useAudioElement = t)
                        })
                    }

                    unbindProcessorDestinationEvents() {
                        this.processorDestination.removeAllListeners(Xv.ON_TRACK), this.processorDestination.removeAllListeners(Xv.ON_NODE)
                    }
                }).prototype, "setVolume", [PP], Object.getOwnPropertyDescriptor(UP.prototype, "setVolume"), UP.prototype), vE(UP.prototype, "setPlaybackDevice", [DP], Object.getOwnPropertyDescriptor(UP.prototype, "setPlaybackDevice"), UP.prototype), vE(UP.prototype, "play", [kP], Object.getOwnPropertyDescriptor(UP.prototype, "play"), UP.prototype), vE(UP.prototype, "stop", [LP], Object.getOwnPropertyDescriptor(UP.prototype, "stop"), UP.prototype), vE(UP.prototype, "pipe", [xP], Object.getOwnPropertyDescriptor(UP.prototype, "pipe"), UP.prototype), vE(UP.prototype, "unpipe", [MP], Object.getOwnPropertyDescriptor(UP.prototype, "unpipe"), UP.prototype), UP);

            function GP(e, t) {
                var r = Object.keys(e);
                if (Object.getOwnPropertySymbols) {
                    var n = Object.getOwnPropertySymbols(e);
                    t && (n = n.filter(function (t) {
                        return Object.getOwnPropertyDescriptor(e, t).enumerable
                    })), r.push.apply(r, n)
                }
                return r
            }

            function qP(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var r = null != arguments[t] ? arguments[t] : {};
                    t % 2 ? GP(Object(r), !0).forEach(function (t) {
                        Kh(e, t, r[t])
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : GP(Object(r)).forEach(function (t) {
                        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t))
                    })
                }
                return e
            }

            const HP = "v=0\no=- 0 0 IN IP4 127.0.0.1\ns=AgoraGateway\nt=0 0\na=group:BUNDLE 0\na=msid-semantic: WMS\na=ice-lite\nm=application 9 UDP/DTLS/SCTP webrtc-datachannel\nc=IN IP4 127.0.0.1\na=mid:0\n",
                KP = "9", zP = 2e4, YP = 4e4;
            var JP;

            function XP(e, t) {
                var r = Object.keys(e);
                if (Object.getOwnPropertySymbols) {
                    var n = Object.getOwnPropertySymbols(e);
                    t && (n = n.filter(function (t) {
                        return Object.getOwnPropertyDescriptor(e, t).enumerable
                    })), r.push.apply(r, n)
                }
                return r
            }

            function QP(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var r = null != arguments[t] ? arguments[t] : {};
                    t % 2 ? XP(Object(r), !0).forEach(function (t) {
                        Kh(e, t, r[t])
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : XP(Object(r)).forEach(function (t) {
                        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t))
                    })
                }
                return e
            }

            let $P = (vE((JP = class e extends ng {
                get currentLocalDescription() {
                    return this.peerConnection.currentLocalDescription
                }

                get currentRemoteDescription() {
                    return this.peerConnection.currentRemoteDescription
                }

                get peerConnectionState() {
                    return this.peerConnection.connectionState
                }

                get iceConnectionState() {
                    return this.peerConnection.iceConnectionState
                }

                constructor(e, t, r) {
                    super(e, t), Kh(this, "store", void 0), Kh(this, "peerConnection", void 0), Kh(this, "remoteSDP", void 0), Kh(this, "initialOffer", void 0), Kh(this, "transportEventReceiver", void 0), Kh(this, "statsFilter", void 0), Kh(this, "useRTX", fm("USE_RTX")), Kh(this, "localCapabilities", void 0), Kh(this, "localCandidateCount", 0), Kh(this, "allCandidatesReceived", !1), Kh(this, "mutex", new KE("NVExtentionsConnection-mutex")), Kh(this, "rtcMedia", void 0), this.store = t, this.peerConnection = r, this.statsFilter = pP(this.peerConnection, void 0, void 0, wh() ? 1200 : void 0), this.bindPCEvents(), this.bindStatsEvents(), this.store.p2pId = this.store.p2pId + 1
                }

                async establish(e) {
                    try {
                        const t = await this.peerConnection.createOffer();
                        if (!t.sdp) throw new Error("Cannot get initialOffer.sdp when trying to establish PeerConnection.");
                        const r = kN(t.sdp), n = await GN(!this.useRTX, fm("FILTER_VIDEO_FEC"), fm("FILTER_AUDIO_FEC"));
                        return this.localCapabilities = n, this.initialOffer = t, QP(QP({}, r), {}, {
                            rtpCapabilities: n,
                            offerSDP: t.sdp
                        })
                    } catch (e) {
                        throw new Hf(qf.GET_LOCAL_CONNECTION_PARAMS_FAILED, e.toString())
                    }
                }

                async connect(e, t, r, n, i, o) {
                    try {
                        if (!this.initialOffer) throw new Error("Cannot establish NVConnection without initial offer.");
                        this.remoteSDP = new class {
                            get localCapabilities() {
                                return sb(this._localCapabilities)
                            }

                            get rtpCapabilities() {
                                return sb(this._rtpCapabilities)
                            }

                            get candidates() {
                                return sb(this._candidates)
                            }

                            get iceParameters() {
                                return sb(this._iceParameters)
                            }

                            get dtlsParameters() {
                                return sb(this._dtlsParameters)
                            }

                            constructor(e) {
                                Kh(this, "sessionDesc", void 0), Kh(this, "_localCapabilities", void 0), Kh(this, "_rtpCapabilities", void 0), Kh(this, "_candidates", void 0), Kh(this, "_iceParameters", void 0), Kh(this, "_dtlsParameters", void 0), Kh(this, "setup", void 0), Kh(this, "currentMidIndex", void 0), Kh(this, "cname", void 0), Kh(this, "firefoxSsrcMidMap", new Map), e = sb(e);
                                const {
                                    remoteIceParameters: t,
                                    remoteDtlsParameters: r,
                                    candidates: n,
                                    remoteRTPCapabilities: i,
                                    remoteSetup: o,
                                    localCapabilities: s,
                                    cname: a
                                } = e, c = ON.exports.parse(HP);
                                this._rtpCapabilities = i, this._candidates = n, this._iceParameters = t, this._dtlsParameters = r, this._localCapabilities = s, this.setup = o, this.cname = a;
                                const u = this.rtpCapabilities.send;
                                for (const e of c.mediaDescriptions) {
                                    if (e.attributes.iceUfrag = t.iceUfrag, e.attributes.icePwd = t.icePwd, e.attributes.fingerprints = r.fingerprints, e.attributes.candidates = n, e.attributes.setup = o, "application" === e.media.mediaType && (e.attributes.sctpPort = "5000"), "video" === e.media.mediaType && (e.media.fmts = u.videoCodecs.map(e => e.payloadType.toString(10)), e.attributes.payloads = u.videoCodecs, e.attributes.extmaps = u.videoExtensions, fm("PRELOAD_MEDIA_COUNT") > 0)) {
                                        const {ssrcs: t, ssrcGroups: r} = MN([{
                                            ssrcId: YP,
                                            rtx: fm("USE_RTX") ? 40001 : void 0
                                        }], this.cname);
                                        e.attributes.ssrcs = t, e.attributes.ssrcGroups = r
                                    }
                                    if ("audio" === e.media.mediaType && (e.media.fmts = u.audioCodecs.map(e => e.payloadType.toString(10)), e.attributes.payloads = u.audioCodecs, e.attributes.extmaps = u.audioExtensions, KN(e), fm("PRELOAD_MEDIA_COUNT") > 0)) {
                                        const {ssrcs: t, ssrcGroups: r} = MN([{ssrcId: zP}], this.cname);
                                        e.attributes.ssrcs = t, e.attributes.ssrcGroups = r
                                    }
                                }
                                this.sessionDesc = c, this.currentMidIndex = c.mediaDescriptions.length - 1
                            }

                            updateRemoteRTPCapabilities(e) {
                                const t = ON.exports.parse(HP);
                                this._rtpCapabilities = e;
                                const r = this.rtpCapabilities.send;
                                for (const e of t.mediaDescriptions) {
                                    if (e.attributes.iceUfrag = this._iceParameters.iceUfrag, e.attributes.icePwd = this._iceParameters.icePwd, e.attributes.fingerprints = this._dtlsParameters.fingerprints, e.attributes.candidates = this._candidates, e.attributes.setup = this.setup, "application" === e.media.mediaType && (e.attributes.sctpPort = "5000"), "video" === e.media.mediaType && (e.media.fmts = r.videoCodecs.map(e => e.payloadType.toString(10)), e.attributes.payloads = r.videoCodecs, e.attributes.extmaps = r.videoExtensions, fm("PRELOAD_MEDIA_COUNT") > 0)) {
                                        const {ssrcs: t, ssrcGroups: r} = MN([{
                                            ssrcId: YP,
                                            rtx: fm("USE_RTX") ? 40001 : void 0
                                        }], this.cname);
                                        e.attributes.ssrcs = t, e.attributes.ssrcGroups = r
                                    }
                                    if ("audio" === e.media.mediaType && (e.media.fmts = r.audioCodecs.map(e => e.payloadType.toString(10)), e.attributes.payloads = r.audioCodecs, e.attributes.extmaps = r.audioExtensions, fm("PRELOAD_MEDIA_COUNT") > 0)) {
                                        const {ssrcs: t, ssrcGroups: r} = MN([{ssrcId: zP}], this.cname);
                                        e.attributes.ssrcs = t, e.attributes.ssrcGroups = r
                                    }
                                }
                                this.sessionDesc = t, this.currentMidIndex = t.mediaDescriptions.length - 1
                            }

                            preloadRemoteMedia(e) {
                                this.rtpCapabilities;
                                const t = this.candidates, r = this.dtlsParameters, n = this.iceParameters,
                                    i = this.rtpCapabilities.send;
                                for (let o = 1; o < e; o++) {
                                    const e = 2 * o + zP, s = 2 * o + YP, {
                                        ssrcs: a,
                                        ssrcGroups: c
                                    } = MN([{ssrcId: e}], this.cname), {ssrcs: u, ssrcGroups: d} = MN([{
                                        ssrcId: s,
                                        rtx: fm("USE_RTX") ? s + 1 : void 0
                                    }], this.cname);
                                    this.sessionDesc.mediaDescriptions.push({
                                        media: {
                                            mediaType: "video",
                                            port: KP,
                                            protos: ["UDP", "TLS", "RTP", "SAVPF"],
                                            fmts: i.videoCodecs.map(e => e.payloadType.toString(10))
                                        },
                                        connections: [{nettype: "IN", addrtype: "IP4", address: "127.0.0.1"}],
                                        bandwidths: [],
                                        attributes: {
                                            iceUfrag: n.iceUfrag,
                                            icePwd: n.icePwd,
                                            unrecognized: [],
                                            candidates: t,
                                            extmaps: i.videoExtensions,
                                            fingerprints: r.fingerprints,
                                            imageattr: [],
                                            msids: [],
                                            remoteCandidatesList: [],
                                            rids: [],
                                            ssrcs: u,
                                            ssrcGroups: d,
                                            rtcpFeedbackWildcards: [],
                                            payloads: i.videoCodecs,
                                            rtcp: {port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0"},
                                            setup: this.setup,
                                            direction: "sendonly",
                                            rtcpMux: !0,
                                            rtcpRsize: !0,
                                            mid: "".concat(2 * o - 1)
                                        }
                                    }), this.sessionDesc.mediaDescriptions.push({
                                        media: {
                                            mediaType: "audio",
                                            port: KP,
                                            protos: ["UDP", "TLS", "RTP", "SAVPF"],
                                            fmts: i.audioCodecs.map(e => e.payloadType.toString(10))
                                        },
                                        connections: [{nettype: "IN", addrtype: "IP4", address: "127.0.0.1"}],
                                        bandwidths: [],
                                        attributes: {
                                            iceUfrag: n.iceUfrag,
                                            icePwd: n.icePwd,
                                            unrecognized: [],
                                            candidates: t,
                                            extmaps: i.audioExtensions,
                                            fingerprints: r.fingerprints,
                                            imageattr: [],
                                            msids: [],
                                            remoteCandidatesList: [],
                                            rids: [],
                                            ssrcs: a,
                                            ssrcGroups: c,
                                            rtcpFeedbackWildcards: [],
                                            payloads: i.audioCodecs,
                                            rtcp: {port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0"},
                                            setup: this.setup,
                                            direction: "sendonly",
                                            rtcpMux: !0,
                                            rtcpRsize: !0,
                                            mid: "".concat(2 * o)
                                        }
                                    }), this.currentMidIndex += 2
                                }
                                this.updateBundleMids()
                            }

                            toString() {
                                return ON.exports.print(this.sessionDesc)
                            }

                            send(e, t, r, n) {
                                const {ssrcs: i, ssrcGroups: o} = MN(t, this.cname, r),
                                    s = this.findPreloadMediaDesc(i);
                                if (s) {
                                    if (wh() && this.firefoxSsrcMidMap.set(i[0].ssrcId, s.attributes.mid), n && (n.tcc || n.remb)) {
                                        const e = this.sessionDesc.mediaDescriptions.indexOf(s);
                                        return this.sessionDesc.mediaDescriptions[e] = this.mungSendMediaDesc(s, n), {
                                            mid: s.attributes.mid,
                                            needExchangeSDP: !0
                                        }
                                    }
                                    return {mid: s.attributes.mid, needExchangeSDP: !1}
                                }
                                {
                                    const t = this.findAvailableMediaIndex(e, i);
                                    let r;
                                    return -1 === t || Ih() || Ch() || Ah() ? (r = this.createOrRecycleSendMedia(e, i, o, "sendonly", n), this.updateBundleMids()) : ((r = sb(this.sessionDesc.mediaDescriptions[t])).attributes.direction = "sendonly", r.attributes.ssrcs = i, r.attributes.ssrcGroups = o, this.sessionDesc.mediaDescriptions[t] = this.mungSendMediaDesc(r, n)), wh() && this.firefoxSsrcMidMap.set(i[0].ssrcId, r.attributes.mid), {
                                        mid: r.attributes.mid,
                                        needExchangeSDP: !0
                                    }
                                }
                            }

                            batchSend(e) {
                                const t = e.map(e => {
                                    let {kind: t, ssrcMsg: r, mslabel: n} = e;
                                    return this.send(t, r, n)
                                }), r = [];
                                let n = !1;
                                return t.forEach(e => {
                                    let {mid: t, needExchangeSDP: i} = e;
                                    i && (n = !0), r.push(t)
                                }), {mids: r, needExchangeSDP: n}
                            }

                            stopSending(e) {
                                const t = this.sessionDesc.mediaDescriptions.filter(t => t.attributes.mid && -1 !== e.indexOf(t.attributes.mid));
                                if (t.length !== e.length) throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.stopSending.");
                                t.forEach(e => {
                                    "0" === e.attributes.mid || wh() || Ih() || Ch() ? e.attributes.ssrcs = [] : (e.attributes.ssrcs = [], e.attributes.direction = "inactive", e.media.port = "0")
                                }), this.updateBundleMids()
                            }

                            mute(e) {
                                const t = this.sessionDesc.mediaDescriptions.find(t => t.attributes.mid === e);
                                if (!t) throw new Error("mediaDescription not found with ".concat(e, " in remote SDP when calling RemoteSDP.mute."));
                                t.attributes.direction = "inactive"
                            }

                            unmute(e) {
                                const t = this.sessionDesc.mediaDescriptions.find(t => t.attributes.mid === e);
                                if (!t) throw new Error("mediaDescription not found with ".concat(e, " in remote SDP when calling RemoteSDP.unmute."));
                                t.attributes.direction = "sendonly"
                            }

                            muteRemote(e) {
                                const t = this.sessionDesc.mediaDescriptions.filter(t => e.includes(t.attributes.mid || ""));
                                if (t.length !== e.length) throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.");
                                t.forEach(e => {
                                    e.attributes.direction = "inactive"
                                })
                            }

                            unmuteRemote(e) {
                                const t = this.sessionDesc.mediaDescriptions.filter(t => e.includes(t.attributes.mid || ""));
                                if (t.length !== e.length) throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.");
                                t.forEach(e => {
                                    e.attributes.direction = "recvonly"
                                })
                            }

                            receive(e, t, r, n) {
                                e.forEach((e, i) => {
                                    this.createOrRecycleRecvMedia(e, [], "recvonly", t, r, n[i])
                                }), this.updateBundleMids()
                            }

                            stopReceiving(e) {
                                const t = this.sessionDesc.mediaDescriptions.filter(t => -1 !== e.indexOf(t.attributes.mid));
                                if (t.length !== e.length) throw new Error("MediaDescriptions' length doesn't match mids's length when calling RemoteSDP.receive.");
                                t.forEach(e => {
                                    e.media.port = "0", e.attributes.direction = "inactive"
                                }), this.updateBundleMids()
                            }

                            restartICE(e) {
                                e = sb(e), this._iceParameters = e, this.sessionDesc.mediaDescriptions.forEach(t => {
                                    t.attributes.iceUfrag = e.iceUfrag, t.attributes.icePwd = e.icePwd
                                })
                            }

                            predictReceivingMids(e) {
                                const t = [];
                                for (let r = 0; r < e; r++) t.push((this.currentMidIndex + r + 1).toString(10));
                                return t
                            }

                            findAvailableMediaIndex(e, t) {
                                return this.sessionDesc.mediaDescriptions.findIndex(r => {
                                    const n = r.media.mediaType === e && "0" !== r.media.port && ("sendonly" === r.attributes.direction || "sendrecv" === r.attributes.direction) && 0 === r.attributes.ssrcs.length;
                                    if (wh()) {
                                        if (n) {
                                            const e = this.firefoxSsrcMidMap.get(t[0].ssrcId);
                                            return !(e || "0" !== r.attributes.mid && "1" !== r.attributes.mid) || !(!e || e !== r.attributes.mid)
                                        }
                                        return !1
                                    }
                                    return n
                                })
                            }

                            createOrRecycleRecvMedia(e, t, r, n, i, o) {
                                const s = e._mediaStreamTrack.kind, a = this.rtpCapabilities.recv,
                                    c = this.localCapabilities.send;
                                let u = [];
                                if (s === qv.VIDEO) {
                                    var d, l;
                                    if (fm("H264_PROFILE_LEVEL_ID") && "h264" === n && (u = a.videoCodecs.filter(e => {
                                        var t, r;
                                        return ((null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLowerCase()) || "").includes(n) && (null == e || null === (r = e.fmtp) || void 0 === r ? void 0 : r.parameters["profile-level-id"]) === fm("H264_PROFILE_LEVEL_ID")
                                    })), !u || 0 === (null === (d = u) || void 0 === d ? void 0 : d.length)) {
                                        const e = c.videoCodecs.filter(e => {
                                            var t;
                                            return ((null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLowerCase()) || "").includes(n)
                                        });
                                        0 !== e.length && (u = a.videoCodecs.filter(t => e.some(e => e.payloadType === t.payloadType)))
                                    }
                                    if (fm("USE_RTX")) {
                                        const e = u.map(e => e.payloadType.toString()), t = a.videoCodecs.filter(t => {
                                            var r, n;
                                            return "rtx" === (null === (r = t.rtpMap) || void 0 === r ? void 0 : r.encodingName) && e.includes((null === (n = t.fmtp) || void 0 === n ? void 0 : n.parameters.apt) || "")
                                        });
                                        u = [...u, ...t]
                                    }
                                    0 === u.length && (em.warning("codec ".concat(n, " not included in rtpCapabilities, fallback to default payloads: ").concat(null === (l = a.videoCodecs[0].rtpMap) || void 0 === l ? void 0 : l.encodingName)), u = a.videoCodecs)
                                } else 0 === (u = a.audioCodecs.filter(e => {
                                    var t;
                                    return ((null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLowerCase()) || "").includes(i)
                                })).length && (em.warning("codec ".concat(i, " not included in rtpCapabilities, fallback to opus")), u = a.audioCodecs.filter(e => {
                                    var t;
                                    return ((null === (t = e.rtpMap) || void 0 === t ? void 0 : t.encodingName.toLowerCase()) || "").includes("opus")
                                }));
                                const h = s === qv.VIDEO ? a.videoExtensions : a.audioExtensions;
                                this.currentMidIndex += 1;
                                const p = "".concat(this.currentMidIndex);
                                let f = {
                                    media: {
                                        mediaType: s,
                                        port: KP,
                                        protos: ["UDP", "TLS", "RTP", "SAVPF"],
                                        fmts: u.map(e => e.payloadType.toString(10))
                                    },
                                    connections: [{nettype: "IN", addrtype: "IP4", address: "127.0.0.1"}],
                                    bandwidths: [],
                                    attributes: {
                                        iceUfrag: this.iceParameters.iceUfrag,
                                        icePwd: this.iceParameters.icePwd,
                                        unrecognized: [],
                                        candidates: this.candidates,
                                        extmaps: h,
                                        fingerprints: this.dtlsParameters.fingerprints,
                                        imageattr: [],
                                        msids: [],
                                        remoteCandidatesList: [],
                                        rids: [],
                                        ssrcs: t,
                                        ssrcGroups: [],
                                        rtcpFeedbackWildcards: [],
                                        payloads: u,
                                        rtcp: {port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0"},
                                        setup: this.setup,
                                        direction: r,
                                        rtcpMux: !0,
                                        rtcpRsize: !0,
                                        mid: "".concat(p)
                                    }
                                };
                                f = this.mungRecvMediaDsec(f, e, o);
                                const m = this.findFirstClosedMedia(s);
                                if (m) {
                                    const e = this.sessionDesc.mediaDescriptions.indexOf(m);
                                    this.sessionDesc.mediaDescriptions[e] = f
                                } else this.sessionDesc.mediaDescriptions.push(f);
                                return f
                            }

                            createOrRecycleSendMedia(e, t, r, n, i) {
                                const o = this.rtpCapabilities.send, s = e === qv.VIDEO ? o.videoCodecs : o.audioCodecs,
                                    a = e === qv.VIDEO ? o.videoExtensions : o.audioExtensions;
                                this.currentMidIndex += 1;
                                const c = "".concat(this.currentMidIndex);
                                let u = {
                                    media: {
                                        mediaType: e,
                                        port: KP,
                                        protos: ["UDP", "TLS", "RTP", "SAVPF"],
                                        fmts: s.map(e => e.payloadType.toString(10))
                                    },
                                    connections: [{nettype: "IN", addrtype: "IP4", address: "127.0.0.1"}],
                                    bandwidths: [],
                                    attributes: {
                                        iceUfrag: this.iceParameters.iceUfrag,
                                        icePwd: this.iceParameters.icePwd,
                                        unrecognized: [],
                                        candidates: this.candidates,
                                        extmaps: a,
                                        fingerprints: this.dtlsParameters.fingerprints,
                                        imageattr: [],
                                        msids: [],
                                        remoteCandidatesList: [],
                                        rids: [],
                                        ssrcs: t,
                                        ssrcGroups: r,
                                        rtcpFeedbackWildcards: [],
                                        payloads: s,
                                        rtcp: {port: "9", netType: "IN", addressType: "IP4", address: "0.0.0.0"},
                                        setup: this.setup,
                                        direction: n,
                                        rtcpMux: !0,
                                        rtcpRsize: !0,
                                        mid: "".concat(c)
                                    }
                                };
                                u = this.mungSendMediaDesc(u, i);
                                const d = this.findFirstClosedMedia(e);
                                if (d) {
                                    const e = this.sessionDesc.mediaDescriptions.indexOf(d);
                                    this.sessionDesc.mediaDescriptions[e] = u
                                } else this.sessionDesc.mediaDescriptions.push(u);
                                return u
                            }

                            updateBundleMids() {
                                this.sessionDesc.attributes.groups[0].identificationTag = this.sessionDesc.mediaDescriptions.filter(e => "0" !== e.media.port).map(e => e.attributes.mid)
                            }

                            mungRecvMediaDsec(e, t, r) {
                                const n = sb(e);
                                return jN(n), UN(n, t), VN(n, t), FN(n), BN(n, r, this.localCapabilities.send), n
                            }

                            mungSendMediaDesc(e, t) {
                                const r = sb(e);
                                return BN(r, t, this.localCapabilities.recv), KN(r), r
                            }

                            updateRecvMedia(e, t) {
                                const r = this.sessionDesc.mediaDescriptions.findIndex(t => t.attributes.mid === e);
                                if (-1 !== r) {
                                    const e = this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[r], t);
                                    this.sessionDesc.mediaDescriptions[r] = e
                                }
                            }

                            bumpMid(e) {
                                this.currentMidIndex += e
                            }

                            findFirstClosedMedia(e) {
                                return this.sessionDesc.mediaDescriptions.find(t => wh() ? "0" === t.media.port && t.media.mediaType === e : "0" === t.media.port)
                            }

                            findPreloadMediaDesc(e) {
                                return this.sessionDesc.mediaDescriptions.find(t => {
                                    var r, n;
                                    return (null === (r = t.attributes) || void 0 === r || null === (n = r.ssrcs[0]) || void 0 === n ? void 0 : n.ssrcId) === e[0].ssrcId
                                })
                            }

                            getSSRC(e) {
                                var t;
                                return null === (t = this.sessionDesc.mediaDescriptions.find(t => t.attributes.mid === e)) || void 0 === t ? void 0 : t.attributes.ssrcs
                            }
                        }({
                            remoteIceParameters: e,
                            remoteDtlsParameters: t,
                            candidates: r,
                            remoteRTPCapabilities: n,
                            remoteSetup: i,
                            localCapabilities: HN(this.localCapabilities),
                            cname: o
                        });
                        const s = this.remoteSDP.toString(), a = ON.exports.parse(this.initialOffer.sdp),
                            c = a.mediaDescriptions.find(e => "audio" === e.media.mediaType);
                        c && KN(c);
                        const u = ON.exports.print(a), d = this.logSDPExchange(u || "", "offer", "local", "connect");
                        await this.peerConnection.setLocalDescription({
                            type: "offer",
                            sdp: u
                        }), null == d || d(s), await this.peerConnection.setRemoteDescription({type: "answer", sdp: s})
                    } catch (e) {
                        throw new Hf(qf.EXCHANGE_SDP_FAILED, "NV.connect failed; ".concat(e.toString()))
                    }
                }

                async updateRemoteConnect(e) {
                    var t, r, n;
                    null === (t = this.remoteSDP) || void 0 === t || t.updateRemoteRTPCapabilities(e), null === (r = this.remoteSDP) || void 0 === r || r.preloadRemoteMedia(2);
                    const i = null === (n = this.remoteSDP) || void 0 === n ? void 0 : n.toString();
                    await this.peerConnection.setRemoteDescription({type: "offer", sdp: i});
                    const o = await this.peerConnection.createAnswer();
                    await this.peerConnection.setLocalDescription(o), em.debug("[NVExtentionsConnection] updateRemoteRTPCapabilities by exchanging SDP.")
                }

                send(e, t, r) {
                    var n = this;
                    return RN(function* () {
                        const i = yield IN(n.mutex.lock("From NVExtentionsConnection.send"));
                        try {
                            if (!n.remoteSDP) throw new Error("Cannot call NVExtentionsConnection.send before remote SDP created");
                            const o = [];
                            e.forEach(e => {
                                const t = n.peerConnection.addTransceiver(e._mediaStreamTrack, {direction: "sendonly"});
                                o.push(t)
                            }), wh() && !0 === fm("SIMULCAST") && (yield IN(n.applySimulcastForFirefox(o, e)));
                            const s = yield IN(n.peerConnection.createOffer()),
                                a = n.remoteSDP.predictReceivingMids(e.length), c = n.mungSendOfferSDP(s.sdp, e, a),
                                u = ON.exports.parse(c), d = a.map(e => {
                                    const t = u.mediaDescriptions.find(t => t.attributes.mid === e);
                                    if (!t) throw new Error("Cannot extract ssrc from mediaDescription.");
                                    return LN(t, n.useRTX)
                                });
                            let l;
                            try {
                                l = yield d
                            } catch (i) {
                                l = [], n.remoteSDP.receive(e, t, r, l);
                                const o = n.remoteSDP.toString();
                                throw yield IN(n.peerConnection.setLocalDescription({
                                    type: "offer",
                                    sdp: c
                                })), yield IN(n.peerConnection.setRemoteDescription({
                                    type: "answer",
                                    sdp: o
                                })), yield IN(n.stopSending(a, !0)), i
                            }
                            n.remoteSDP.receive(e, t, r, l);
                            const h = n.remoteSDP.toString(), p = n.logSDPExchange(c, "offer", "local", "send");
                            return yield IN(n.peerConnection.setLocalDescription({
                                type: "offer",
                                sdp: c
                            })), yield IN(n.applySimulcastEncodings(o, e)), yield IN(n.applySendEncodings(o, e)), null == p || p(h), yield IN(n.peerConnection.setRemoteDescription({
                                type: "answer",
                                sdp: h
                            })), o.map((e, t) => {
                                const r = a[t];
                                return {localSSRC: d[t], id: r, transceiver: e}
                            })
                        } catch (e) {
                            throw e instanceof Hf ? e : new Hf(qf.EXCHANGE_SDP_FAILED, "NVExtentionsConnection.send failed; ".concat(e.toString()))
                        } finally {
                            i()
                        }
                    })()
                }

                async stopSending(e, t) {
                    const r = t ? void 0 : await this.mutex.lock("From NVExtentionsConnection.stopSending");
                    try {
                        if (!this.remoteSDP) throw new Error("Cannot call NVExtentionsConnection.stopSending before remote SDP created");
                        const t = this.peerConnection.getTransceivers().filter(t => -1 !== e.indexOf(t.mid));
                        if (t.length !== e.length) throw new Error("Transceivers' length doesn't match mids' length when trying to call NVExtentionsConnection.stopSending.");
                        t.map(e => {
                            var t;
                            e.direction = "inactive", null === (t = e.stop) || void 0 === t || t.call(e)
                        });
                        const n = await this.peerConnection.createOffer(),
                            i = this.logSDPExchange(n.sdp || "", "offer", "local", "stopSending");
                        await this.peerConnection.setLocalDescription(n), this.remoteSDP.stopReceiving(e);
                        const o = this.remoteSDP.toString();
                        null == i || i(o), await this.peerConnection.setRemoteDescription({type: "answer", sdp: o})
                    } catch (e) {
                        throw new Hf(qf.EXCHANGE_SDP_FAILED, "NVExtentionsConnection.stopSending failed; ".concat(e.toString()))
                    } finally {
                        r && r()
                    }
                }

                async receive(e, t, r, n) {
                    try {
                        if (!this.remoteSDP) throw new Error("Cannot call NVExtentionsConnection.receive ".concat(e, " before remoteSDP created."));
                        const {mid: i, needExchangeSDP: o} = this.remoteSDP.send(e, t, r, n);
                        if (o) {
                            const t = this.remoteSDP.toString(),
                                r = this.logSDPExchange(t, "offer", "remote", "receive");
                            await this.peerConnection.setRemoteDescription({type: "offer", sdp: t});
                            const n = await this.peerConnection.createAnswer(),
                                o = this.mungReceiveAnswerSDP(n.sdp, i, e);
                            null == r || r(o || ""), await this.peerConnection.setLocalDescription({
                                type: "answer",
                                sdp: o
                            }), em.debug("[NVExtentionsConnection] receive ".concat(e, " by exchanging SDP."))
                        } else em.debug("[NVExtentionsConnection] receive ".concat(e, " no need to exchange SDP."));
                        const s = this.peerConnection.getTransceivers().find(e => e.mid === i);
                        if (!s) throw new Error("Cannot get transceiver after setLocalDescription.");
                        return {track: s.receiver.track, id: i}
                    } catch (e) {
                        throw new Hf(qf.EXCHANGE_SDP_FAILED, "NVExtentionsConnection.receive failed; ".concat(e.toString()))
                    }
                }

                async batchReceive(e) {
                    try {
                        if (!this.remoteSDP) throw new Error("Cannot call NVExtentionsConnection.batchReceive before remoteSDP created.");
                        const {mids: t, needExchangeSDP: r} = this.remoteSDP.batchSend(e);
                        if (r) {
                            const e = this.remoteSDP.toString(),
                                t = this.logSDPExchange(e, "offer", "remote", "receive");
                            await this.peerConnection.setRemoteDescription({type: "offer", sdp: e});
                            const r = await this.peerConnection.createAnswer();
                            null == t || t(r.sdp || ""), await this.peerConnection.setLocalDescription(r), em.debug("[NVExtentionsConnection] batchReceive by exchanging SDP.")
                        } else em.debug("[NVExtentionsConnection] batchReceive no need to exchange SDP.");
                        return t.map(e => {
                            const t = this.peerConnection.getTransceivers().find(t => t.mid === e);
                            if (!t) throw new Error("Cannot get transceiver after setLocalDescription.");
                            return {track: t.receiver.track, id: e}
                        })
                    } catch (e) {
                        throw new Hf(qf.EXCHANGE_SDP_FAILED, "NVExtentionsConnection.receive failed; ".concat(e.toString()))
                    }
                }

                async stopReceiving(e) {
                    try {
                        if (!this.remoteSDP) throw new Error("Cannot call NVExtentionsConnection.stopReceiving before remote SDP created.");
                        this.remoteSDP.stopSending(e);
                        const t = this.remoteSDP.toString(),
                            r = this.logSDPExchange(t, "offer", "remote", "stopReceiving");
                        await this.peerConnection.setRemoteDescription({type: "offer", sdp: t});
                        const n = await this.peerConnection.createAnswer();
                        null == r || r(n.sdp || ""), await this.peerConnection.setLocalDescription(n)
                    } catch (e) {
                        throw new Hf(qf.EXCHANGE_SDP_FAILED, "NVExtentionsConnection stopReceiving failed; ".concat(e.toString()))
                    }
                }

                async muteRemote(e) {
                    try {
                        if (!this.remoteSDP) throw new Error("Cannot call NVExtentionsConnection.muteRemote mid=".concat(e, " before remote SDP created."));
                        this.remoteSDP.mute(e);
                        const t = this.remoteSDP.toString(),
                            r = this.logSDPExchange(t, "offer", "remote", "muteRemote");
                        await this.peerConnection.setRemoteDescription({type: "offer", sdp: t});
                        const n = await this.peerConnection.createAnswer();
                        null == r || r(n.sdp || ""), await this.peerConnection.setLocalDescription(n)
                    } catch (e) {
                        throw new Hf(qf.EXCHANGE_SDP_FAILED, "NVExtentionsConnection.muteRemote failed; ".concat(e.toString()))
                    }
                }

                async unmuteRemote(e) {
                    try {
                        if (!this.remoteSDP) throw new Error("Cannot call NVExtentionsConnection.unmuteRemote mid=".concat(e, " before remote SDP created."));
                        this.remoteSDP.unmute(e);
                        const t = this.remoteSDP.toString(),
                            r = this.logSDPExchange(t, "offer", "remote", "unmuteRemote");
                        await this.peerConnection.setRemoteDescription({type: "offer", sdp: t});
                        const n = await this.peerConnection.createAnswer();
                        null == r || r(n.sdp || ""), await this.peerConnection.setLocalDescription(n)
                    } catch (e) {
                        throw new Hf(qf.EXCHANGE_SDP_FAILED, "NVExtentionsConnection.unmuteRemote failed; ".concat(e.toString()))
                    }
                }

                async muteLocal(e) {
                    try {
                        if (!this.remoteSDP) throw new Error("Cannot call NVExtentionsConnection.muteLocal before remote SDP created.");
                        const t = this.peerConnection.getTransceivers().filter(t => t.mid && -1 !== e.indexOf(t.mid));
                        if (t.length !== e.length) throw new Error("Transceivers' length doesn't match mids' length.");
                        t.map(e => {
                            e.direction = "inactive"
                        });
                        const r = await this.peerConnection.createOffer(),
                            n = this.logSDPExchange(r.sdp || "", "offer", "local", "muteLocal");
                        await this.peerConnection.setLocalDescription(r), this.remoteSDP.muteRemote(e);
                        const i = this.remoteSDP.toString();
                        null == n || n(i), await this.peerConnection.setRemoteDescription({type: "answer", sdp: i})
                    } catch (e) {
                        throw new Hf(qf.EXCHANGE_SDP_FAILED, "NVExtentionsConnection.muteLocal failed; ".concat(e.toString()))
                    }
                }

                async unmuteLocal(e) {
                    try {
                        if (!this.remoteSDP) throw new Error("Cannot call NVExtentionsConnection.unmuteLocal before remote SDP created.");
                        const t = this.peerConnection.getTransceivers().filter(t => t.mid && -1 !== e.indexOf(t.mid));
                        if (t.length !== e.length) throw new Error("Transceivers' length doesn't match mids' length.");
                        t.map(async (e, t) => {
                            e.direction = "sendonly"
                        });
                        const r = await this.peerConnection.createOffer(),
                            n = this.logSDPExchange(r.sdp || "", "offer", "local", "unmuteLocal");
                        await this.peerConnection.setLocalDescription(r), this.remoteSDP.unmuteRemote(e);
                        const i = this.remoteSDP.toString();
                        null == n || n(i), await this.peerConnection.setRemoteDescription({type: "answer", sdp: i})
                    } catch (e) {
                        throw new Hf(qf.EXCHANGE_SDP_FAILED, "NVExtentionsConnection.unmuteLocal failed; ".concat(e.toString()))
                    }
                }

                restartICE() {
                    var e = this;
                    return RN(function* () {
                        const t = yield IN(e.mutex.lock("From NVExtentionsConnection.restartICE"));
                        try {
                            const r = yield IN(e.peerConnection.createOffer({iceRestart: !0}));
                            if (!r.sdp) throw new Error("Cannot restartICE because restart offer SDP does not exist.");
                            const n = kN(r.sdp), {remoteIceParameters: i} = yield n.iceParameters;
                            if (!e.remoteSDP) throw new Error("Cannot restartICE before remoteSDP created.");
                            e.remoteSDP.restartICE(i);
                            const o = e.remoteSDP.toString(),
                                s = e.logSDPExchange(r.sdp || "", "offer", "local", "restartICE");
                            yield IN(e.peerConnection.setLocalDescription(r)), null == s || s(o), yield IN(e.peerConnection.setRemoteDescription({
                                type: "answer",
                                sdp: o
                            }))
                        } catch (e) {
                            em.warning("restart ICE failed, abort operation", e)
                        } finally {
                            t()
                        }
                    })()
                }

                close() {
                    var e;
                    null === (e = this.onConnectionStateChange) || void 0 === e || e.call(this, "closed"), this.unbindPCEvents(), this.unbindStatsEvents(), this.removeAllListeners(), this.transportEventReceiver = void 0, this.statsFilter.destroy()
                }

                getStats() {
                    return this.statsFilter.getStats()
                }

                getRemoteVideoIsReady(e) {
                    return this.statsFilter.getVideoIsReady(e)
                }

                async updateEncoderConfig(e, t) {
                    try {
                        if (!this.remoteSDP) throw new Error("Cannot call NVExtentionsConnection.updateEncoderConfig before remote SDP created.");
                        const r = await this.peerConnection.createOffer(), n = this.mungSendOfferSDP(r.sdp, [t], [e]);
                        this.remoteSDP.updateRecvMedia(e, t);
                        const i = this.remoteSDP.toString(),
                            o = this.logSDPExchange(n, "offer", "local", "updateEncoderConfig");
                        await this.peerConnection.setLocalDescription({
                            type: "offer",
                            sdp: n
                        }), null == o || o(i), await this.peerConnection.setRemoteDescription({type: "answer", sdp: i})
                    } catch (e) {
                        throw new Hf(qf.EXCHANGE_SDP_FAILED, e.toString())
                    }
                }

                async updateSendParameters(e, t) {
                    const r = this.peerConnection.getTransceivers().filter(t => t.mid === e);
                    1 === r.length && (this.isVP8Simulcast(t) ? wh() || await this.applySimulcastEncodings(r, [t]) : await this.applySendEncodings(r, [t]))
                }

                setStatsRemoteVideoIsReady(e, t) {
                    this.statsFilter.setVideoIsReady2(e, t)
                }

                async replaceTrack(e, t) {
                    const r = this.peerConnection.getTransceivers().find(e => e.mid === t);
                    r && await r.sender.replaceTrack(e._mediaStreamTrack)
                }

                getP2PConnectionParams() {
                    var e;
                    if (null === (e = this.peerConnection.currentLocalDescription) || void 0 === e || !e.sdp || !this.localCapabilities) throw new Error;
                    return QP(QP({}, kN(this.peerConnection.currentLocalDescription.sdp)), {}, {rtpCapabilities: this.localCapabilities})
                }

                bindPCEvents() {
                    this.peerConnection.oniceconnectionstatechange = (() => {
                        var e;
                        null === (e = this.onICEConnectionStateChange) || void 0 === e || e.call(this, this.peerConnection.iceConnectionState)
                    }), this.peerConnection.onconnectionstatechange = (() => {
                        var e;
                        null === (e = this.onConnectionStateChange) || void 0 === e || e.call(this, this.peerConnection.connectionState)
                    }), this.peerConnection.onicecandidate = (e => {
                        e.candidate ? this.localCandidateCount += 1 : (this.peerConnection.onicecandidate = null, this.allCandidatesReceived = !0, em.debug("[pc-".concat(this.store.p2pId, "] local candidate count"), this.localCandidateCount))
                    }), setTimeout(() => {
                        this.allCandidatesReceived || (this.allCandidatesReceived = !0, em.debug("[pc-".concat(this.store.p2pId, "] onicecandidate timeout, local candidate count"), this.localCandidateCount))
                    }, fm("CANDIDATE_TIMEOUT"))
                }

                unbindPCEvents() {
                    this.peerConnection.oniceconnectionstatechange = null, this.peerConnection.onconnectionstatechange = null, this.peerConnection.onsignalingstatechange = null, this.peerConnection.onicecandidateerror = null, this.peerConnection.onicecandidate = null, this.peerConnection.ontrack = null
                }

                static resolvePCConfiguration(t) {
                    const r = {iceServers: []};
                    return t.iceServers ? r.iceServers = t.iceServers : t.turnServer && "off" !== t.turnServer.mode && (nv(t.turnServer.servers) ? r.iceServers = t.turnServer.servers : (r.iceServers && r.iceServers.push(...e.turnServerConfigToIceServers(t.turnServer.servers)), fm("USE_TURN_SERVER_OF_GATEWAY") && r.iceServers && t.turnServer.serversFromGateway && r.iceServers.push(...e.turnServerConfigToIceServers(t.turnServer.serversFromGateway)), fm("FORCE_TURN_TCP") ? r.iceTransportPolicy = "relay" : t.turnServer.servers.concat(t.turnServer.serversFromGateway || []).forEach(e => {
                        e.forceturn && (r.iceTransportPolicy = "relay")
                    }))), r
                }

                static turnServerConfigToIceServers(e) {
                    const t = [];
                    return e.forEach(e => {
                        e.security ? e.tcpport && t.push({
                            username: e.username,
                            credential: e.password,
                            credentialType: "password",
                            urls: "turns:".concat(MS(e.turnServerURL), ":").concat(e.tcpport, "?transport=tcp")
                        }) : (e.udpport && !fm("FORCE_TURN_TCP") && t.push({
                            username: e.username,
                            credential: e.password,
                            credentialType: "password",
                            urls: "turn:".concat(e.turnServerURL, ":").concat(e.udpport, "?transport=udp")
                        }), e.tcpport && t.push({
                            username: e.username,
                            credential: e.password,
                            credentialType: "password",
                            urls: "turn:".concat(e.turnServerURL, ":").concat(e.tcpport, "?transport=tcp")
                        }))
                    }), t
                }

                async applySendEncodings(e, t) {
                    try {
                        if (!og().supportSetRtpSenderParameters) return;
                        if (e.length !== t.length) return;
                        for (let c = 0; c < e.length; c++) {
                            const u = e[c], d = t[c];
                            if (d && d instanceof _A) {
                                var r, n;
                                if (this.isVP8Simulcast(d)) continue;
                                const e = {}, t = {};
                                switch (d._optimizationMode) {
                                    case"motion":
                                        e.degradationPreference = "maintain-framerate";
                                        break;
                                    case"detail":
                                        e.degradationPreference = "maintain-resolution";
                                        break;
                                    default:
                                        e.degradationPreference = "balanced"
                                }
                                var i, o, s, a;
                                if (null !== (r = d._encoderConfig) && void 0 !== r && r.bitrateMax && (t.maxBitrate = 1e3 * (null === (i = d._encoderConfig) || void 0 === i ? void 0 : i.bitrateMax)), d._hints.includes(Pv.LOW_STREAM) && (null !== (o = d._encoderConfig) && void 0 !== o && o.frameRate && (t.maxFramerate = jS(d._encoderConfig.frameRate)), null !== (s = d._encoderConfig) && void 0 !== s && s.scaleResolutionDownBy && (null === (a = d._encoderConfig) || void 0 === a ? void 0 : a.scaleResolutionDownBy) > 1 && (t.scaleResolutionDownBy = d._encoderConfig.scaleResolutionDownBy)), fm("DSCP_TYPE") && Mh()) {
                                    const e = fm("DSCP_TYPE");
                                    ["very-low", "low", "medium", "high"].includes(e) && (t.networkPriority = e)
                                }
                                const c = u.sender.getParameters(),
                                    l = null === (n = c.encodings) || void 0 === n ? void 0 : n[0];
                                wh() && !l && (e.encodings = [t]), l && Object.assign(l, t), Object.assign(c, e), await u.sender.setParameters(c)
                            }
                        }
                    } catch (e) {
                        em.debug("Apply RTPSendEncodings failed.")
                    }
                }

                mungSendOfferSDP(e, t, r) {
                    const n = ON.exports.parse(e);
                    return t.forEach((e, t) => {
                        const i = r[t], o = n.mediaDescriptions.find(e => e.attributes.mid === i);
                        o && (UN(o, e), WN(o, e, this.store.codec))
                    }), ON.exports.print(n)
                }

                mungReceiveAnswerSDP(e, t, r) {
                    const n = ON.exports.parse(e), i = n.mediaDescriptions.find(e => e.attributes.mid === t);
                    return i && r === qv.AUDIO && "audio" === i.media.mediaType && KN(i), ON.exports.print(n)
                }

                bindStatsEvents() {
                    this.statsFilter.onFirstAudioReceived = (e => {
                        var t;
                        null === (t = this.onFirstAudioReceived) || void 0 === t || t.call(this, e)
                    }), this.statsFilter.onFirstVideoReceived = (e => {
                        var t;
                        null === (t = this.onFirstVideoReceived) || void 0 === t || t.call(this, e)
                    }), this.statsFilter.onFirstAudioDecoded = (e => {
                        var t;
                        null === (t = this.onFirstAudioDecoded) || void 0 === t || t.call(this, e)
                    }), this.statsFilter.onFirstVideoDecoded = ((e, t, r) => {
                        var n;
                        null === (n = this.onFirstVideoDecoded) || void 0 === n || n.call(this, e, t, r)
                    }), this.statsFilter.onSelectedLocalCandidateChanged = ((e, t) => {
                        var r;
                        null === (r = this.onSelectedLocalCandidateChanged) || void 0 === r || r.call(this, e, t)
                    }), this.statsFilter.onSelectedRemoteCandidateChanged = ((e, t) => {
                        var r;
                        null === (r = this.onSelectedRemoteCandidateChanged) || void 0 === r || r.call(this, e, t)
                    }), this.statsFilter.onFirstVideoDecodedTimeout = (e => {
                        var t;
                        null === (t = this.onFirstVideoDecodedTimeout) || void 0 === t || t.call(this, e)
                    })
                }

                unbindStatsEvents() {
                    this.statsFilter.onFirstAudioReceived = void 0, this.statsFilter.onFirstVideoReceived = void 0, this.statsFilter.onFirstAudioDecoded = void 0, this.statsFilter.onFirstVideoDecoded = void 0, this.statsFilter.onSelectedLocalCandidateChanged = void 0, this.statsFilter.onSelectedRemoteCandidateChanged = void 0, this.statsFilter.onFirstVideoDecodedTimeout = void 0
                }

                async applySimulcastForFirefox(e, t) {
                    if (e.length === t.length) for (let s = 0; s < e.length; s++) {
                        var r, n, i, o;
                        const a = e[s], c = t[s];
                        if (c instanceof _A && !c._hints.includes(Pv.LOW_STREAM) && null !== (r = c._encoderConfig) && void 0 !== r && r.bitrateMax && (null === (n = c._encoderConfig) || void 0 === n ? void 0 : n.bitrateMax) > 200 && null !== (i = c._scalabiltyMode) && void 0 !== i && i.numSpatialLayers && (null === (o = c._scalabiltyMode) || void 0 === o ? void 0 : o.numSpatialLayers) > 1 && "vp8" === this.store.codec) {
                            const e = {}, t = {high: 1e3 * (c._encoderConfig.bitrateMax - 50), medium: 5e4};
                            e.encodings = [{
                                rid: "m",
                                active: !0,
                                maxBitrate: t.medium,
                                scaleResolutionDownBy: 4
                            }, {rid: "h", active: !0, maxBitrate: t.high}];
                            const r = a.sender.getParameters();
                            await a.sender.setParameters(Object.assign(r, e))
                        }
                    }
                }

                async applySimulcastEncodings(e, t) {
                    if (!wh() && e.length === t.length) for (let r = 0; r < e.length; r++) {
                        const n = t[r];
                        if (n instanceof _A && this.isVP8Simulcast(n)) {
                            const t = e[r], i = {}, o = {high: 1e3 * (n._encoderConfig.bitrateMax - 50), medium: 5e4};
                            i.encodings = [{
                                active: !0,
                                adaptivePtime: !1,
                                networkPriority: "high",
                                priority: "high",
                                maxBitrate: o.high
                            }, {
                                active: !0,
                                adaptivePtime: !1,
                                networkPriority: "low",
                                priority: "low",
                                maxBitrate: o.medium,
                                scaleResolutionDownBy: 4
                            }];
                            const s = t.sender.getParameters();
                            await t.sender.setParameters(Object.assign(s, i))
                        }
                    }
                }

                isVP8Simulcast(e) {
                    var t, r, n, i;
                    return !!(e instanceof _A && fm("SIMULCAST") && "vp8" === this.store.codec && !e._hints.includes(Pv.LOW_STREAM) && null !== (t = e._encoderConfig) && void 0 !== t && t.bitrateMax && (null === (r = e._encoderConfig) || void 0 === r ? void 0 : r.bitrateMax) > 200 && null !== (n = e._scalabiltyMode) && void 0 !== n && n.numSpatialLayers && (null === (i = e._scalabiltyMode) || void 0 === i ? void 0 : i.numSpatialLayers) > 1)
                }

                logSDPExchange(e, t, r, n) {
                    if (fm("SDP_LOGGING")) return em.upload("exchanging ".concat(r, " ").concat(t, " SDP during NVExtentionsConnection.").concat(n, "\n"), e), "offer" === t ? e => {
                        this.logSDPExchange(e, "answer", "local" === r ? "remote" : "local", n)
                    } : void 0
                }

                async getRemoteSSRC(e) {
                    if (!this.remoteSDP) return;
                    const t = this.remoteSDP.getSSRC(e);
                    return null == t ? void 0 : t[0].ssrcId
                }
            }).prototype, "connect", [ZP], Object.getOwnPropertyDescriptor(JP.prototype, "connect"), JP.prototype), vE(JP.prototype, "updateRemoteConnect", [ZP], Object.getOwnPropertyDescriptor(JP.prototype, "updateRemoteConnect"), JP.prototype), vE(JP.prototype, "receive", [ZP], Object.getOwnPropertyDescriptor(JP.prototype, "receive"), JP.prototype), vE(JP.prototype, "batchReceive", [ZP], Object.getOwnPropertyDescriptor(JP.prototype, "batchReceive"), JP.prototype), vE(JP.prototype, "stopReceiving", [ZP], Object.getOwnPropertyDescriptor(JP.prototype, "stopReceiving"), JP.prototype), vE(JP.prototype, "muteRemote", [ZP], Object.getOwnPropertyDescriptor(JP.prototype, "muteRemote"), JP.prototype), vE(JP.prototype, "unmuteRemote", [ZP], Object.getOwnPropertyDescriptor(JP.prototype, "unmuteRemote"), JP.prototype), vE(JP.prototype, "muteLocal", [ZP], Object.getOwnPropertyDescriptor(JP.prototype, "muteLocal"), JP.prototype), vE(JP.prototype, "unmuteLocal", [ZP], Object.getOwnPropertyDescriptor(JP.prototype, "unmuteLocal"), JP.prototype), vE(JP.prototype, "close", [ZP], Object.getOwnPropertyDescriptor(JP.prototype, "close"), JP.prototype), vE(JP.prototype, "updateEncoderConfig", [ZP], Object.getOwnPropertyDescriptor(JP.prototype, "updateEncoderConfig"), JP.prototype), vE(JP.prototype, "updateSendParameters", [ZP], Object.getOwnPropertyDescriptor(JP.prototype, "updateSendParameters"), JP.prototype), vE(JP.prototype, "replaceTrack", [ZP], Object.getOwnPropertyDescriptor(JP.prototype, "replaceTrack"), JP.prototype), vE(JP.prototype, "getRemoteSSRC", [ZP], Object.getOwnPropertyDescriptor(JP.prototype, "getRemoteSSRC"), JP.prototype), JP);

            function ZP(e, t, r) {
                const n = e[t];
                if ("function" != typeof n) throw new Error("Cannot use mutex on object property.");
                return r.value = async function () {
                    const e = this.mutex, r = await e.lock("From NVExtentionsConnection.".concat(t));
                    try {
                        for (var i = arguments.length, o = new Array(i), s = 0; s < i; s++) o[s] = arguments[s];
                        return await n.apply(this, o)
                    } finally {
                        r()
                    }
                }, r
            }

            var eD;

            function tD(e) {
                var t, r, n, i = 2;
                for ("undefined" != typeof Symbol && (r = AN, n = Symbol.iterator); i--;) {
                    if (r && null != (t = e[r])) return t.call(e);
                    if (n && null != (t = e[n])) return new rD(t.call(e));
                    r = "@@asyncIterator", n = "@@iterator"
                }
                throw new TypeError("Object is not async iterable")
            }

            function rD(e) {
                function t(e) {
                    if (Object(e) !== e) return sl.reject(new TypeError(e + " is not an object."));
                    var t = e.done;
                    return sl.resolve(e.value).then(function (e) {
                        return {value: e, done: t}
                    })
                }

                return (rD = function (e) {
                    this.s = e, this.n = e.next
                }).prototype = {
                    s: null, n: null, next: function () {
                        return t(this.n.apply(this.s, arguments))
                    }, return: function (e) {
                        var r = this.s.return;
                        return void 0 === r ? sl.resolve({value: e, done: !0}) : t(r.apply(this.s, arguments))
                    }, throw: function (e) {
                        var r = this.s.return;
                        return void 0 === r ? sl.reject(e) : t(r.apply(this.s, arguments))
                    }
                }, new rD(e)
            }

            let nD = (vE((eD = class e extends ng {
                get currentLocalDescription() {
                    return this.peerConnection.currentLocalDescription
                }

                get currentRemoteDescription() {
                    return this.peerConnection.currentRemoteDescription
                }

                get peerConnectionState() {
                    return this.peerConnection.connectionState
                }

                get iceConnectionState() {
                    return this.peerConnection.iceConnectionState
                }

                constructor(t, r) {
                    super(t, r), Kh(this, "store", void 0), Kh(this, "peerConnection", void 0), Kh(this, "cname", void 0), Kh(this, "mutex", new KE("DataChannelConnection-mutex")), Kh(this, "dataChannel", void 0), Kh(this, "_p2pConnection", void 0), Kh(this, "_nvMedia", void 0), this.store = r, this.store.dcId = this.store.dcId + 1, this.peerConnection = new RTCPeerConnection(e.resolvePCConfiguration(t), {optional: [{googDscp: !0}]}), this.dataChannel = this.peerConnection.createDataChannel("agora-signal", {
                        ordered: !1,
                        maxPacketLifeTime: 50
                    }), this.dataChannel.binaryType = "arraybuffer", this._p2pConnection = new $P(t, r, this.peerConnection), this.bindPCEvents()
                }

                async establish() {
                    var e;
                    const t = null === (e = this._nvMedia) || void 0 === e ? void 0 : e.getLocalRtpCapabilities();
                    return await this._p2pConnection.establish(t)
                }

                getP2PConnectionParams() {
                    return this._p2pConnection.getP2PConnectionParams()
                }

                async connect(e, t, r, n, i, o) {
                    return this.cname = o, await this._p2pConnection.connect(e, t, r, n, i, o), await new sl((e, t) => {
                        const n = setTimeout(() => {
                            this.closeSignal(), t(new Hf(qf.DATACHANNEL_CONNECTION_TIMEOUT, "Datachannel connection timed out, candidates: ".concat(JSON.stringify(r))))
                        }, 2e3);
                        this.dataChannel.onopen = (() => {
                            if ("open" === this.dataChannel.readyState) return clearTimeout(n), void e()
                        }), this.dataChannel.onerror = (e => {
                            this.closeSignal(), t(e)
                        })
                    }), {transmitter: this.dataChannel, close: this.closeSignal.bind(this)}
                }

                send(e, t, r) {
                    var n = this;
                    return RN(function* () {
                        const i = yield IN(n.mutex.lock("From DataChannelConnection.send"));
                        try {
                            return yield* CN(tD(n._p2pConnection.send(e, t, r)), IN)
                        } finally {
                            i()
                        }
                    })()
                }

                async stopSending(e, t) {
                    return this._p2pConnection.stopSending(e, t)
                }

                async receive(e, t, r, n) {
                    return this._nvMedia ? (em.debug("[DataChannelConnection] receive ".concat(e, " by DataChannel.")), await this._nvMedia.reveiveByRTCMedia(e, t, this.cname)) : (em.debug("[DataChannelConnection] receive ".concat(e, " by WebRTC.")), await this._p2pConnection.receive(e, t, r, n))
                }

                async batchReceive(e) {
                    return [...await this._p2pConnection.batchReceive(e)]
                }

                async stopReceiving(e) {
                    return await this._p2pConnection.stopReceiving(e)
                }

                async muteRemote(e) {
                    return await this._p2pConnection.muteRemote(e)
                }

                async unmuteRemote(e) {
                    return await this._p2pConnection.unmuteRemote(e)
                }

                async muteLocal(e) {
                    return await this._p2pConnection.muteLocal(e)
                }

                async unmuteLocal(e) {
                    return await this._p2pConnection.unmuteLocal(e)
                }

                restartICE() {
                    var e = this;
                    return RN(function* () {
                        return yield* CN(tD(e._p2pConnection.restartICE()), IN)
                    })()
                }

                close() {
                    var e;
                    null === (e = this._nvMedia) || void 0 === e || e.close(), this._p2pConnection.close(), this.unbindConnectionEvents(this._p2pConnection)
                }

                getStats() {
                    return this._p2pConnection.getStats()
                }

                getRemoteVideoIsReady(e) {
                    return this._p2pConnection.getRemoteVideoIsReady(e)
                }

                updateRemoteConnect(e) {
                    var t;
                    null === (t = this._nvMedia) || void 0 === t || t.setRemoteRtpCapabilities(e), this._p2pConnection.updateRemoteConnect(e)
                }

                async updateEncoderConfig(e, t) {
                    return await this._p2pConnection.updateEncoderConfig(e, t)
                }

                async updateSendParameters(e, t) {
                    return await this._p2pConnection.updateSendParameters(e, t)
                }

                setStatsRemoteVideoIsReady(e, t) {
                    this._p2pConnection.setStatsRemoteVideoIsReady(e, t)
                }

                async replaceTrack(e, t) {
                    return await this._p2pConnection.replaceTrack(e, t)
                }

                async getRemoteSSRC(e) {
                    return this._p2pConnection.getRemoteSSRC(e)
                }

                logSDPExchange(e, t, r, n) {
                    if (fm("SDP_LOGGING")) return em.upload("exchanging ".concat(r, " ").concat(t, " SDP during DataChannelConnection.").concat(n, "\n"), e), "offer" === t ? e => {
                        this.logSDPExchange(e, "answer", "local" === r ? "remote" : "local", n)
                    } : void 0
                }

                static resolvePCConfiguration(t) {
                    const r = {iceServers: []};
                    return t.iceServers ? r.iceServers = t.iceServers : t.turnServer && "off" !== t.turnServer.mode && (nv(t.turnServer.servers) ? r.iceServers = t.turnServer.servers : (r.iceServers && r.iceServers.push(...e.turnServerConfigToIceServers(t.turnServer.servers)), fm("USE_TURN_SERVER_OF_GATEWAY") && r.iceServers && t.turnServer.serversFromGateway && r.iceServers.push(...e.turnServerConfigToIceServers(t.turnServer.serversFromGateway)), fm("FORCE_TURN_TCP") ? r.iceTransportPolicy = "relay" : t.turnServer.servers.concat(t.turnServer.serversFromGateway || []).forEach(e => {
                        e.forceturn && (r.iceTransportPolicy = "relay")
                    }))), r
                }

                static turnServerConfigToIceServers(e) {
                    const t = [];
                    return e.forEach(e => {
                        e.security ? e.tcpport && t.push({
                            username: e.username,
                            credential: e.password,
                            credentialType: "password",
                            urls: "turns:".concat(MS(e.turnServerURL), ":").concat(e.tcpport, "?transport=tcp")
                        }) : (e.udpport && !fm("FORCE_TURN_TCP") && t.push({
                            username: e.username,
                            credential: e.password,
                            credentialType: "password",
                            urls: "turn:".concat(e.turnServerURL, ":").concat(e.udpport, "?transport=udp")
                        }), e.tcpport && t.push({
                            username: e.username,
                            credential: e.password,
                            credentialType: "password",
                            urls: "turn:".concat(e.turnServerURL, ":").concat(e.tcpport, "?transport=tcp")
                        }))
                    }), t
                }

                bindPCEvents() {
                    this._p2pConnection.onICEConnectionStateChange = (e => {
                        var t;
                        return null === (t = this.onICEConnectionStateChange) || void 0 === t ? void 0 : t.call(this, e)
                    }), this._p2pConnection.onConnectionStateChange = (e => {
                        var t;
                        return null === (t = this.onConnectionStateChange) || void 0 === t ? void 0 : t.call(this, e)
                    }), this._p2pConnection.onDTLSTransportStateChange = (e => {
                        var t;
                        return null === (t = this.onDTLSTransportStateChange) || void 0 === t ? void 0 : t.call(this, e)
                    }), this._p2pConnection.onDTLSTransportError = (e => {
                        var t;
                        return null === (t = this.onDTLSTransportError) || void 0 === t ? void 0 : t.call(this, e)
                    }), this._p2pConnection.onICETransportStateChange = (e => {
                        var t;
                        return null === (t = this.onICETransportStateChange) || void 0 === t ? void 0 : t.call(this, e)
                    }), this._p2pConnection.onFirstAudioReceived = (e => {
                        var t;
                        return null === (t = this.onFirstAudioReceived) || void 0 === t ? void 0 : t.call(this, e)
                    }), this._p2pConnection.onFirstVideoReceived = (e => {
                        var t;
                        return null === (t = this.onFirstVideoReceived) || void 0 === t ? void 0 : t.call(this, e)
                    }), this._p2pConnection.onFirstAudioDecoded = (e => {
                        var t;
                        return null === (t = this.onFirstAudioDecoded) || void 0 === t ? void 0 : t.call(this, e)
                    }), this._p2pConnection.onFirstVideoDecoded = ((e, t, r) => {
                        var n;
                        return null === (n = this.onFirstVideoDecoded) || void 0 === n ? void 0 : n.call(this, e, t, r)
                    }), this._p2pConnection.onFirstVideoDecodedTimeout = (e => {
                        var t;
                        return null === (t = this.onFirstVideoDecodedTimeout) || void 0 === t ? void 0 : t.call(this, e)
                    }), this._p2pConnection.onSelectedLocalCandidateChanged = ((e, t) => {
                        var r;
                        return null === (r = this.onSelectedLocalCandidateChanged) || void 0 === r ? void 0 : r.call(this, e, t)
                    }), this._p2pConnection.onSelectedRemoteCandidateChanged = ((e, t) => {
                        var r;
                        return null === (r = this.onSelectedRemoteCandidateChanged) || void 0 === r ? void 0 : r.call(this, e, t)
                    })
                }

                closeSignal() {
                    this.dataChannel.close(), this.peerConnection.close()
                }

                unbindConnectionEvents(e) {
                    e.onConnectionStateChange = void 0, e.onICEConnectionStateChange = void 0, e.onICETransportStateChange = void 0, e.onDTLSTransportStateChange = void 0, e.onDTLSTransportError = void 0, e.onFirstAudioDecoded = void 0, e.onFirstAudioReceived = void 0, e.onFirstVideoDecoded = void 0, e.onFirstVideoReceived = void 0, e.onSelectedLocalCandidateChanged = void 0, e.onSelectedRemoteCandidateChanged = void 0, e.onFirstVideoDecodedTimeout = void 0
                }
            }).prototype, "connect", [iD], Object.getOwnPropertyDescriptor(eD.prototype, "connect"), eD.prototype), vE(eD.prototype, "receive", [iD], Object.getOwnPropertyDescriptor(eD.prototype, "receive"), eD.prototype), vE(eD.prototype, "stopReceiving", [iD], Object.getOwnPropertyDescriptor(eD.prototype, "stopReceiving"), eD.prototype), vE(eD.prototype, "muteRemote", [iD], Object.getOwnPropertyDescriptor(eD.prototype, "muteRemote"), eD.prototype), vE(eD.prototype, "unmuteRemote", [iD], Object.getOwnPropertyDescriptor(eD.prototype, "unmuteRemote"), eD.prototype), vE(eD.prototype, "muteLocal", [iD], Object.getOwnPropertyDescriptor(eD.prototype, "muteLocal"), eD.prototype), vE(eD.prototype, "unmuteLocal", [iD], Object.getOwnPropertyDescriptor(eD.prototype, "unmuteLocal"), eD.prototype), vE(eD.prototype, "close", [iD], Object.getOwnPropertyDescriptor(eD.prototype, "close"), eD.prototype), vE(eD.prototype, "updateEncoderConfig", [iD], Object.getOwnPropertyDescriptor(eD.prototype, "updateEncoderConfig"), eD.prototype), vE(eD.prototype, "updateSendParameters", [iD], Object.getOwnPropertyDescriptor(eD.prototype, "updateSendParameters"), eD.prototype), vE(eD.prototype, "replaceTrack", [iD], Object.getOwnPropertyDescriptor(eD.prototype, "replaceTrack"), eD.prototype), vE(eD.prototype, "getRemoteSSRC", [iD], Object.getOwnPropertyDescriptor(eD.prototype, "getRemoteSSRC"), eD.prototype), eD);

            function iD(e, t, r) {
                const n = e[t];
                if ("function" != typeof n) throw new Error("Cannot use mutex on object property.");
                return r.value = async function () {
                    const e = this.mutex, r = await e.lock("From DataChannelConnection.".concat(t));
                    try {
                        for (var i = arguments.length, o = new Array(i), s = 0; s < i; s++) o[s] = arguments[s];
                        return await n.apply(this, o)
                    } finally {
                        r()
                    }
                }, r
            }

            var oD;

            function sD(e, t) {
                var r = Object.keys(e);
                if (Object.getOwnPropertySymbols) {
                    var n = Object.getOwnPropertySymbols(e);
                    t && (n = n.filter(function (t) {
                        return Object.getOwnPropertyDescriptor(e, t).enumerable
                    })), r.push.apply(r, n)
                }
                return r
            }

            function aD(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var r = null != arguments[t] ? arguments[t] : {};
                    t % 2 ? sD(Object(r), !0).forEach(function (t) {
                        Kh(e, t, r[t])
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : sD(Object(r)).forEach(function (t) {
                        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t))
                    })
                }
                return e
            }

            function cD(e) {
                var t, r, n, i = 2;
                for ("undefined" != typeof Symbol && (r = AN, n = Symbol.iterator); i--;) {
                    if (r && null != (t = e[r])) return t.call(e);
                    if (n && null != (t = e[n])) return new uD(t.call(e));
                    r = "@@asyncIterator", n = "@@iterator"
                }
                throw new TypeError("Object is not async iterable")
            }

            function uD(e) {
                function t(e) {
                    if (Object(e) !== e) return sl.reject(new TypeError(e + " is not an object."));
                    var t = e.done;
                    return sl.resolve(e.value).then(function (e) {
                        return {value: e, done: t}
                    })
                }

                return (uD = function (e) {
                    this.s = e, this.n = e.next
                }).prototype = {
                    s: null, n: null, next: function () {
                        return t(this.n.apply(this.s, arguments))
                    }, return: function (e) {
                        var r = this.s.return;
                        return void 0 === r ? sl.resolve({value: e, done: !0}) : t(r.apply(this.s, arguments))
                    }, throw: function (e) {
                        var r = this.s.return;
                        return void 0 === r ? sl.reject(e) : t(r.apply(this.s, arguments))
                    }
                }, new uD(e)
            }

            let dD = (vE((oD = class extends Wf {
                get state() {
                    return this._state
                }

                set state(e) {
                    const t = this._state;
                    this._state = e, this.emit(zv.StateChange, t, this._state)
                }

                constructor(e, t) {
                    super(), Kh(this, "store", void 0), Kh(this, "statsUploader", void 0), Kh(this, "connection", void 0), Kh(this, "localTrackMap", new Map), Kh(this, "remoteUserMap", new Map), Kh(this, "pendingLocalTracks", []), Kh(this, "pendingRemoteTracks", []), Kh(this, "statsCollector", void 0), Kh(this, "isPlanB", !1), Kh(this, "iceFailedCount", 0), Kh(this, "dtlsFailedCount", 0), Kh(this, "mutex", new KE("P2PChannel-mutex")), Kh(this, "_state", Kv.Disconnected), Kh(this, "handleMuteLocalTrack", async (e, t, r) => {
                        const n = await this.mutex.lock("Locking from P2PChannel.handleMuteLocalTrack");
                        try {
                            if (!this.connection || this.state !== Kv.Connected) return void r(new Hf(qf.INVALID_OPERATION, "Cannot call P2PChannel.handleMuteLocalTrack before connection established."));
                            const i = this.filterTobeMutedTracks(e);
                            if (0 === i.length) return void t();
                            const o = i.find(e => "videoLowTrack" === e[0]);
                            o && o[1].track._originMediaStreamTrack.stop(), await this.connection.muteLocal(i.map(e => {
                                let [, {id: t}] = e;
                                return t
                            }));
                            const s = this.createMuteMessage(i);
                            await eb(this, zv.RequestMuteLocal, s), t()
                        } catch (e) {
                            r(e)
                        } finally {
                            n()
                        }
                    }), Kh(this, "handleUnmuteLocalTrack", async (e, t, r) => {
                        const n = await this.mutex.lock("Locking from P2PChannel.handleUnmuteLocalTrack");
                        try {
                            if (!this.connection || this.state !== Kv.Connected) return void r(new Hf(qf.INVALID_OPERATION, "Cannot call P2PChannel.handleUnmuteLocalTrack before connection established."));
                            const i = this.filterTobeUnmutedTracks(e);
                            if (0 === i.length) return void t();
                            const o = i.find(e => "videoLowTrack" === e[0]);
                            if (o) {
                                const t = o[1];
                                if (t.track._originMediaStreamTrack.stop(), og().supportDualStreamEncoding) {
                                    const r = e._mediaStreamTrack.clone();
                                    t.track._mediaStreamTrack = r, t.track._originMediaStreamTrack = r
                                } else {
                                    const r = IP(e, rb(this, zv.RequestLowStreamParameter));
                                    t.track._mediaStreamTrack = r, t.track._originMediaStreamTrack = r
                                }
                                await new sl((e, r) => {
                                    this.handleReplaceTrack(t.track, e, r, !0)
                                })
                            }
                            await this.connection.unmuteLocal(i.map(e => {
                                let [, {id: t}] = e;
                                return t
                            }));
                            const s = this.createUnmuteMessage(i);
                            await eb(this, zv.RequestUnmuteLocal, s), t()
                        } catch (e) {
                            r(e)
                        } finally {
                            n()
                        }
                    }), Kh(this, "handleUpdateVideoEncoder", async (e, t, r) => {
                        const n = await this.mutex.lock("Locking from P2PChannel.handleSetVideoEncoder");
                        try {
                            const r = this.localTrackMap.get(Hv.LocalVideoTrack);
                            if (!this.connection || !r || r.track !== e || this.state !== Kv.Connected) return void t();
                            const {id: i, track: o} = r;
                            await this.connection.updateSendParameters(i, o), await this.connection.updateEncoderConfig(i, o), this.emit(zv.UpdateVideoEncoder, o), t()
                        } catch (e) {
                            r(e)
                        } finally {
                            n()
                        }
                    }), Kh(this, "handleSetOptimizationMode", async (e, t, r) => {
                        const n = await this.mutex.lock("Locking from P2PChannel.handleSetOptimizationMode");
                        try {
                            const r = this.localTrackMap.get(Hv.LocalVideoTrack);
                            if (!this.connection || !r || r.track !== e || this.state !== Kv.Connected) return;
                            const {id: i, track: o} = r;
                            await this.connection.updateSendParameters(i, o), t()
                        } catch (e) {
                            r(e)
                        } finally {
                            n()
                        }
                    }), Kh(this, "handleReplaceTrack", async (e, t, r, n) => {
                        let i;
                        em.debug("P2PChannel handleReplaceTrack for [track-id-".concat(e.getTrackId(), "]")), "boolean" == typeof n && n || (i = await this.mutex.lock("From P2PChannel.handleReplaceTrack"));
                        try {
                            var o;
                            const r = Array.from(this.localTrackMap.entries()).find(t => {
                                let [, {track: r}] = t;
                                return e === r
                            });
                            if (!this.connection || !r || this.state !== Kv.Connected) return void t();
                            if (await (null === (o = this.connection) || void 0 === o ? void 0 : o.replaceTrack(e, r[1].id)), this.isPlanB) {
                                const t = r[1];
                                t.id = e._mediaStreamTrack.id, this.localTrackMap.set(r[0], t)
                            }
                            if (r[0] === Hv.LocalVideoTrack && og().supportDualStreamEncoding) {
                                const t = this.localTrackMap.get(Hv.LocalVideoLowTrack);
                                if (t) {
                                    const r = e._mediaStreamTrack.clone();
                                    t.track._originMediaStreamTrack.stop(), t.track._mediaStreamTrack = r, t.track._originMediaStreamTrack = r, await new sl((e, r) => {
                                        this.handleReplaceTrack(t.track, e, r, !0)
                                    })
                                }
                            }
                            t()
                        } catch (e) {
                            r(e)
                        } finally {
                            var s;
                            null === (s = i) || void 0 === s || s()
                        }
                    }), Kh(this, "handleGetLocalVideoStats", e => {
                        e(this.statsCollector.getLocalVideoTrackStats())
                    }), Kh(this, "handleGetLocalAudioStats", e => {
                        e(this.statsCollector.getLocalAudioTrackStats())
                    }), Kh(this, "handleGetRemoteVideoStats", e => this.statsCollector.getRemoteVideoTrackStats(e.uid)[e.uid]), Kh(this, "handleGetRemoteAudioStats", e => this.statsCollector.getRemoteAudioTrackStats(e.uid)[e.uid]), this.store = e, this.statsCollector = t, this.statsCollector.addP2PChannel(this), this.statsUploader = new class extends Wf {
                        constructor() {
                            super(), Kh(this, "uplinkStatsUploadInterval", void 0), Kh(this, "uplinkStatsUploadSlowInterval", void 0), Kh(this, "uplinkRelatedStatsUploadInterval", void 0), Kh(this, "uplinkDenoiserStatsUploadInterval", void 0), Kh(this, "transportStatsUploadInterval", void 0), Kh(this, "uplinkExtensionStatsUploadInterval", void 0), Kh(this, "downlinkExtensionStatsUploadInterval", void 0), Kh(this, "extensionUsageStatsUploadInterval", void 0), Kh(this, "downlinkStatsUploadInterval", void 0), Kh(this, "downlinkStatsUploadSlowInterval", void 0), Kh(this, "downlinkRelatedStatsUploadInterval", void 0), Kh(this, "lastStats", void 0), Kh(this, "uploadUnplinkStarted", !1), Kh(this, "uploadDownlinkStarted", !1), Kh(this, "uploadTransportStarted", !1), Kh(this, "uploadExtensionUsageStarted", !1), Kh(this, "requestStats", void 0), Kh(this, "requestLocalMedia", void 0), Kh(this, "requestRemoteMedia", void 0), Kh(this, "requestAllTracks", void 0), Kh(this, "requestVideoIsReady", void 0), Kh(this, "requestUpload", void 0)
                        }

                        startUploadTransportStats() {
                            this.uploadTransportStarted || (this.uploadTransportStarted = !0, this.transportStatsUploadInterval && window.clearInterval(this.transportStatsUploadInterval), this.transportStatsUploadInterval = window.setInterval(() => {
                                var e;
                                const t = null === (e = this.requestStats) || void 0 === e ? void 0 : e.call(this);
                                t && this.uploadTransportStats(t)
                            }, 6e3))
                        }

                        startUploadExtensionUsageStats() {
                            if (this.uploadExtensionUsageStarted) return;
                            this.uploadExtensionUsageStarted = !0, this.extensionUsageStatsUploadInterval && window.clearInterval(this.extensionUsageStatsUploadInterval);
                            const e = new Map;
                            this.extensionUsageStatsUploadInterval = window.setInterval(async () => {
                                var t, r, n;
                                const i = Date.now(), o = {
                                    connectionInterval: fm("EXTENSION_USAGE_UPLOAD_INTERVAL") / 1e3,
                                    details: [],
                                    lts: i
                                };
                                let s = [];
                                const a = (null === (t = this.requestAllTracks) || void 0 === t ? void 0 : t.call(this)) || [];
                                for (const e of a) !e.muted && e.enabled && (s = s.concat(await e.getProcessorUsage()));
                                const c = (null === (r = this.requestRemoteMedia) || void 0 === r ? void 0 : r.call(this)) || [];
                                for (const [e, t] of c) t.has(qv.VIDEO) && e.videoTrack && (s = s.concat(await e.videoTrack.getProcessorUsage())), t.has(qv.AUDIO) && e.audioTrack && (s = s.concat(await e.audioTrack.getProcessorUsage()));
                                if (0 === s.length) return;
                                o.details = function (e, t) {
                                    const r = {};
                                    for (const {id: s, value: a, level: c, direction: u} of e) {
                                        var n;
                                        const e = null !== (n = t.get(s)) && void 0 !== n ? n : 0,
                                            d = 2 === a ? e + fm("EXTENSION_USAGE_UPLOAD_INTERVAL") / 1e3 : e;
                                        var i, o;
                                        t.set(s, d), r[s] ? (2 === a && (r[s].value = a), c > r[s].level && (r[s].level = c), "remote" === u && (r[s].remoteUidCount += 1), r[s].totalTs = null !== (i = t.get(s)) && void 0 !== i ? i : 0) : r[s] = {
                                            value: a,
                                            level: c,
                                            remoteUidCount: "local" === u ? 0 : 1,
                                            totalTs: null !== (o = t.get(s)) && void 0 !== o ? o : 0
                                        }
                                    }
                                    return Object.keys(r).map(e => {
                                        const {level: t, value: n, totalTs: i} = r[e];
                                        return {id: e, level: t, value: n, totalTs: i}
                                    })
                                }(s, e);
                                const u = Date.now(), d = u > i ? u : i + 1;
                                null === (n = this.requestUpload) || void 0 === n || n.call(this, $_.EXTENSION_USAGE_STATS, {
                                    usageStats: o,
                                    sendTs: d
                                })
                            }, fm("EXTENSION_USAGE_UPLOAD_INTERVAL"))
                        }

                        startUploadUplinkStats() {
                            this.uploadUnplinkStarted || (this.uploadUnplinkStarted = !0, this.uplinkStatsUploadInterval && window.clearInterval(this.uplinkStatsUploadInterval), this.uplinkStatsUploadInterval = window.setInterval(() => {
                                var e;
                                const t = null === (e = this.requestStats) || void 0 === e ? void 0 : e.call(this);
                                t && (this.uploadUplinkStats(t, this.lastStats), this.lastStats = t)
                            }, 3e3), this.uplinkStatsUploadSlowInterval && window.clearInterval(this.uplinkStatsUploadSlowInterval), this.uplinkStatsUploadSlowInterval = window.setInterval(() => {
                                var e;
                                const t = null === (e = this.requestStats) || void 0 === e ? void 0 : e.call(this);
                                t && this.uploadSlowUplinkStats(t)
                            }, 6e4), this.uplinkRelatedStatsUploadInterval && window.clearInterval(this.uplinkRelatedStatsUploadInterval), this.uplinkRelatedStatsUploadInterval = window.setInterval(() => {
                                var e;
                                const t = null === (e = this.requestStats) || void 0 === e ? void 0 : e.call(this);
                                t && this.uploadRelatedUplinkStats(t, this.lastStats), this.lastStats = t
                            }, 1e3), this.uplinkDenoiserStatsUploadInterval && window.clearInterval(this.uplinkDenoiserStatsUploadInterval), this.uplinkDenoiserStatsUploadInterval = window.setInterval(() => {
                                var e;
                                const t = null === (e = this.requestAllTracks) || void 0 === e ? void 0 : e.call(this);
                                t && this.uploadDenoiserStats(t)
                            }, 2e3), this.uplinkExtensionStatsUploadInterval && window.clearInterval(this.uplinkExtensionStatsUploadInterval), this.uplinkExtensionStatsUploadInterval = window.setInterval(() => {
                                var e;
                                const t = null === (e = this.requestAllTracks) || void 0 === e ? void 0 : e.call(this);
                                t && this.uploadExtensionStats(t)
                            }, 2e3))
                        }

                        uploadTransportStats(e) {
                            ob(() => {
                                var t;
                                null === (t = this.requestUpload) || void 0 === t || t.call(this, $_.TRANSPORT_STATS, function (e) {
                                    const t = {connectionType: 100};
                                    if ("relay" === e.selectedCandidatePair.localCandidate.candidateType) {
                                        const r = e.selectedCandidatePair.localCandidate.relayProtocol;
                                        "udp" === r && (t.connectionType = 101), "tcp" === r && (t.connectionType = 103), "tls" === r && (t.connectionType = 104)
                                    }
                                    return t
                                }(e))
                            })
                        }

                        uploadUplinkStats(e, t) {
                            var r;
                            ((null === (r = this.requestLocalMedia) || void 0 === r ? void 0 : r.call(this)) || []).forEach(r => {
                                let [n, {track: i, ssrcs: o}] = r;
                                switch (n) {
                                    case Hv.LocalVideoLowTrack:
                                    case Hv.LocalVideoTrack: {
                                        const r = function (e, t, r) {
                                            var n;
                                            const i = t.videoSend.find(t => t.ssrc === e);
                                            if (!i) return null;
                                            const o = {
                                                id: YS(10, ""),
                                                timestamp: new Date(t.timestamp).toISOString(),
                                                mediaType: "video",
                                                type: "ssrc",
                                                ssrc: i.ssrc.toString()
                                            };
                                            switch (o.A_vstd = r._originMediaStreamTrack && !r._originMediaStreamTrack.enabled || r._mediaStreamTrack && !r._mediaStreamTrack.enabled ? "1" : "0", i.sentFrame && (o.A_fhs = i.sentFrame.height.toString(), o.A_frs = i.sentFrame.frameRate.toString(), o.A_fws = i.sentFrame.width.toString()), i.adaptionChangeReason) {
                                                case"none":
                                                    o.A_ac = "0";
                                                    break;
                                                case"cpu":
                                                    o.A_ac = "1";
                                                    break;
                                                case"bandwidth":
                                                    o.A_ac = "2";
                                                    break;
                                                case"other":
                                                    o.A_ac = "3"
                                            }
                                            return o.A_lvps = O_[r._player ? r._player.videoElementStatus : "uninit"].toString(), o.A_nr = null === (n = i.nacksCount) || void 0 === n ? void 0 : n.toString(), i.avgEncodeMs && (o.A_aem = i.avgEncodeMs.toFixed(0).toString()), o
                                        }(o[0].ssrcId, e, i), s = FS(o[0].ssrcId, e, t);
                                        r && ob(() => {
                                            var e;
                                            return null === (e = this.requestUpload) || void 0 === e ? void 0 : e.call(this, $_.PUBLISH_STATS, {
                                                stream_type: n === Hv.LocalVideoLowTrack ? "low" : "high",
                                                stats: qP(qP({}, r), s)
                                            })
                                        });
                                        const a = function (e) {
                                            const t = {
                                                id: "bweforvideo",
                                                timestamp: new Date(e.timestamp).toISOString(),
                                                type: "VideoBwe"
                                            };
                                            return e.bitrate.retransmit && (t.A_rb = e.bitrate.retransmit.toString()), e.bitrate.targetEncoded && (t.A_teb = e.bitrate.targetEncoded.toString()), t.A_aeb = e.bitrate.actualEncoded.toString(), t.A_tb = e.bitrate.transmit.toString(), void 0 !== e.sendBandwidth && (t.A_asb = e.sendBandwidth.toString()), t
                                        }(e);
                                        a && setTimeout(() => {
                                            var e;
                                            return null === (e = this.requestUpload) || void 0 === e ? void 0 : e.call(this, $_.PUBLISH_STATS, {
                                                stream_type: n === Hv.LocalVideoLowTrack ? "low" : "high",
                                                stats: a
                                            })
                                        }, 1e3);
                                        break
                                    }
                                    case Hv.LocalAudioTrack: {
                                        const t = function (e, t, r) {
                                            const n = t.audioSend.find(t => t.ssrc === e);
                                            if (!n) return null;
                                            const i = {
                                                id: YS(10, ""),
                                                timestamp: new Date(t.timestamp).toISOString(),
                                                mediaType: "audio",
                                                type: "ssrc",
                                                ssrc: n.ssrc.toString()
                                            };
                                            return i.A_astd = r._originMediaStreamTrack.enabled && r._mediaStreamTrack.enabled ? "0" : "1", n.inputLevel ? i.A_ail = Math.round(100 * n.inputLevel).toString() : i.A_ail = Math.round(100 * r._source.getAccurateVolumeLevel()).toString(), i.A_apil = Math.round(100 * r._source.getAccurateVolumeLevel()).toString(), n.aecReturnLoss && (i.A_ecrl = Math.round(n.aecReturnLoss).toString()), n.aecReturnLossEnhancement && (i.A_ecrle = Math.round(n.aecReturnLossEnhancement).toString()), i
                                        }(o[0].ssrcId, e, i);
                                        t && ob(() => {
                                            var e;
                                            return null === (e = this.requestUpload) || void 0 === e ? void 0 : e.call(this, $_.PUBLISH_STATS, {
                                                stream_type: "high",
                                                stats: t
                                            })
                                        });
                                        break
                                    }
                                }
                            })
                        }

                        uploadSlowUplinkStats(e) {
                            var t;
                            ((null === (t = this.requestLocalMedia) || void 0 === t ? void 0 : t.call(this)) || []).filter(e => {
                                let [t] = e;
                                return t === Hv.LocalVideoLowTrack || t === Hv.LocalVideoTrack
                            }).forEach(t => {
                                let [r, {ssrcs: n}] = t;
                                const i = FS(n[0].ssrcId, e);
                                i && ob(() => {
                                    var e;
                                    return null === (e = this.requestUpload) || void 0 === e ? void 0 : e.call(this, $_.PUBLISH_STATS, {
                                        stream_type: r === Hv.LocalVideoLowTrack ? "low" : "high",
                                        stats: i
                                    })
                                })
                            })
                        }

                        uploadRelatedUplinkStats(e, t) {
                            var r;
                            ((null === (r = this.requestLocalMedia) || void 0 === r ? void 0 : r.call(this)) || []).filter(e => {
                                let [t] = e;
                                return t === Hv.LocalVideoLowTrack || t === Hv.LocalVideoTrack
                            }).forEach(t => {
                                let [r, {ssrcs: n}] = t;
                                const i = function (e, t) {
                                    const r = t.videoSend.find(t => t.ssrc === e);
                                    return r ? {
                                        mediaType: "video",
                                        isVideoMute: !1,
                                        frameRateInput: r.inputFrame && r.inputFrame.frameRate.toString(),
                                        frameRateSent: r.sentFrame && r.sentFrame.frameRate.toString(),
                                        googRtt: r.rttMs.toString(),
                                        qpSumPerFrame: Math.floor(r.qpSumPerFrame).toString()
                                    } : null
                                }(n[0].ssrcId, e);
                                i && ob(() => {
                                    var e;
                                    null === (e = this.requestUpload) || void 0 === e || e.call(this, $_.PUBLISH_RELATED_STATS, {
                                        stream_type: r === Hv.LocalVideoLowTrack ? "low" : "high",
                                        stats: i
                                    })
                                })
                            })
                        }

                        uploadDenoiserStats(e) {
                            for (let i = 0; i < e.length; i++) {
                                const o = e[i];
                                if (o instanceof IS) {
                                    var t, r, n;
                                    const e = null === (t = (r = o._external).getDenoiserStats) || void 0 === t ? void 0 : t.call(r);
                                    return void (e && (null === (n = this.requestUpload) || void 0 === n || n.call(this, $_.DENOISER_STATS, e)))
                                }
                            }
                        }

                        uploadExtensionStats(e) {
                            for (let t = 0; t < e.length; t++) e[t].getProcessorStats().forEach(e => {
                                var t;
                                null === (t = this.requestUpload) || void 0 === t || t.call(this, e.type, e.stats)
                            })
                        }

                        stopUploadUplinkStats() {
                            this.uploadUnplinkStarted && (this.uploadUnplinkStarted = !1, this.uplinkStatsUploadInterval && window.clearInterval(this.uplinkStatsUploadInterval), this.uplinkRelatedStatsUploadInterval && window.clearInterval(this.uplinkRelatedStatsUploadInterval), this.uplinkDenoiserStatsUploadInterval && window.clearInterval(this.uplinkDenoiserStatsUploadInterval), this.uplinkStatsUploadInterval = void 0, this.uplinkRelatedStatsUploadInterval = void 0, this.uplinkDenoiserStatsUploadInterval = void 0)
                        }

                        startUploadDownlinkStats() {
                            if (this.uploadDownlinkStarted) return;
                            let e;
                            this.uploadDownlinkStarted = !0, this.downlinkStatsUploadInterval && window.clearInterval(this.downlinkStatsUploadInterval), this.downlinkStatsUploadInterval = window.setInterval(() => {
                                var t;
                                const r = null === (t = this.requestStats) || void 0 === t ? void 0 : t.call(this);
                                r && (this.uploadDownlinkStats(r, e), e = r)
                            }, 3e3), this.downlinkStatsUploadSlowInterval && window.clearInterval(this.downlinkStatsUploadSlowInterval), this.downlinkStatsUploadSlowInterval = window.setInterval(() => {
                                var e;
                                const t = null === (e = this.requestStats) || void 0 === e ? void 0 : e.call(this);
                                t && this.uploadSlowDownlinkStats(t)
                            }, 6e4), this.downlinkRelatedStatsUploadInterval && window.clearInterval(this.downlinkRelatedStatsUploadInterval), this.downlinkRelatedStatsUploadInterval = window.setInterval(() => {
                                var e;
                                const t = null === (e = this.requestStats) || void 0 === e ? void 0 : e.call(this);
                                t && (this.uploadRelatedDownlinkStats(t, this.lastStats), this.lastStats = t)
                            }, 1e3), this.downlinkExtensionStatsUploadInterval && window.clearInterval(this.downlinkExtensionStatsUploadInterval), this.downlinkExtensionStatsUploadInterval = window.setInterval(() => {
                                var e;
                                const t = null === (e = this.requestRemoteMedia) || void 0 === e ? void 0 : e.call(this);
                                t && this.uploadDownlinkExtensionStats(t)
                            }, 2e3)
                        }

                        uploadDownlinkStats(e, t) {
                            var r;
                            ((null === (r = this.requestRemoteMedia) || void 0 === r ? void 0 : r.call(this)) || []).forEach(r => {
                                let [n, i] = r;
                                if (i.has(qv.VIDEO) && n.videoTrack) {
                                    const r = n.videoTrack ? function (e, t, r, n) {
                                        const i = t.videoRecv.find(t => t.ssrc === e);
                                        if (!i) return null;
                                        const o = {
                                            id: YS(10, ""),
                                            timestamp: new Date(t.timestamp).toISOString(),
                                            mediaType: "video",
                                            type: "ssrc",
                                            ssrc: i.ssrc.toString()
                                        };
                                        var s, a;
                                        if (o.bytesReceived = i.bytes.toString(), o.packetsLost = i.packetsLost.toString(), o.packetsReceived = i.packets.toString(), i.framesRateFirefox && (o.A_frr = i.framesRateFirefox.toString()), i.receivedFrame ? (o.A_frr = i.receivedFrame.frameRate.toString(), o.A_fhr = i.receivedFrame.height.toString(), o.A_fwr = i.receivedFrame.width.toString()) : (o.A_fhr = null === (s = n._videoHeight) || void 0 === s ? void 0 : s.toString(), o.A_fwr = null === (a = n._videoWidth) || void 0 === a ? void 0 : a.toString()), o.A_frd = i.decodeFrameRate.toString(), i.outputFrame && (o.A_fro = i.outputFrame.frameRate.toString()), void 0 !== i.jitterBufferMs && (o.A_jbm = Math.floor(i.jitterBufferMs).toString()), void 0 !== i.currentDelayMs && (o.A_cdm = Math.floor(i.currentDelayMs).toString()), o.A_fs = i.firsCount.toString(), o.A_ns = i.nacksCount.toString(), o.A_ps = i.plisCount.toString(), n && (o.A_vrtd = n._originMediaStreamTrack.enabled && n._mediaStreamTrack.enabled ? "0" : "1"), n._player && n._player.freezeTimeCounterList.length > 0 && (o.A_vrft = Math.round(n._player.freezeTimeCounterList.splice(0, 1)[0]).toString()), n._player && n._player.renderFreezeAccTime > 0 && (o.A_vrrft = Math.round(n._player.renderFreezeAccTime).toString(), n._player.renderFreezeAccTime = 0), o.A_rvps = O_[n._player ? n._player.videoElementStatus : "uninit"].toString(), r) {
                                            const t = r.videoRecv.find(t => t.ssrc === e);
                                            if (t && void 0 !== i.totalInterFrameDelay && void 0 !== i.totalSquaredInterFrameDelay && void 0 !== t.totalInterFrameDelay && void 0 !== t.totalSquaredInterFrameDelay) {
                                                const e = i.totalInterFrameDelay - t.totalInterFrameDelay,
                                                    r = i.totalSquaredInterFrameDelay - t.totalSquaredInterFrameDelay,
                                                    n = i.framesDecodeCount - t.framesDecodeCount, s = e / n * 1e3,
                                                    a = Math.round(1e3 * Math.sqrt((r - Math.pow(e, 2) / n) / n));
                                                !isNaN(a) && s + a > Math.max(3 * s, s + 150) && (o.A_ifdsd = a.toString())
                                            }
                                        }
                                        return o
                                    }(n._videoSSRC, e, t, n.videoTrack) : void 0;
                                    r && ob(() => {
                                        var e;
                                        return null === (e = this.requestUpload) || void 0 === e ? void 0 : e.call(this, $_.SUBSCRIBE_STATS, {
                                            stream_id: n.uid,
                                            stats: r
                                        })
                                    })
                                }
                                if (i.has(qv.AUDIO) && n.audioTrack) {
                                    const r = n.audioTrack ? function (e, t, r, n) {
                                        const i = t.audioRecv.find(t => t.ssrc === e);
                                        if (!i) return null;
                                        const o = {
                                            id: YS(10, ""),
                                            timestamp: new Date(t.timestamp).toISOString(),
                                            mediaType: "audio",
                                            type: "ssrc",
                                            ssrc: i.ssrc.toString()
                                        };
                                        if (o.bytesReceived = i.bytes.toString(), o.packetsLost = i.packetsLost.toString(), o.packetsReceived = i.packets.toString(), i.outputLevel ? o.A_aol = Math.round(100 * i.outputLevel).toString() : o.A_aol = Math.round(100 * n._source.getAccurateVolumeLevel()).toString(), o.A_apol = Math.round(100 * n._source.getAccurateVolumeLevel()).toString(), n && (o.A_artd = n._originMediaStreamTrack.enabled && n._mediaStreamTrack.enabled ? "0" : "1"), o.A_jr = i.jitterMs.toString(), o.A_jbm = Math.floor(i.jitterBufferMs).toString(), o.A_cdm = Math.floor(i.jitterBufferMs).toString(), o.A_raps = O_[Sy.getPlayerState(n.getTrackId())].toString(), r) {
                                            const t = r.audioRecv.find(t => t.ssrc === e);
                                            if (t) {
                                                const e = i.concealedSamples - t.concealedSamples;
                                                e > 0 && (o.A_cs = Math.round(e).toString())
                                            }
                                        }
                                        return o
                                    }(n._audioSSRC, e, t, n.audioTrack) : void 0;
                                    r && ob(() => {
                                        var e;
                                        return null === (e = this.requestUpload) || void 0 === e ? void 0 : e.call(this, $_.SUBSCRIBE_STATS, {
                                            stream_id: n.uid,
                                            stats: r
                                        })
                                    })
                                }
                            })
                        }

                        uploadSlowDownlinkStats(e) {
                        }

                        uploadRelatedDownlinkStats(e, t) {
                            var r;
                            ((null === (r = this.requestRemoteMedia) || void 0 === r ? void 0 : r.call(this)) || []).forEach(r => {
                                let [n, i] = r;
                                if (i.has(qv.VIDEO) && n.videoTrack) {
                                    var o;
                                    const r = !0 === (n._videoSSRC && (null === (o = this.requestVideoIsReady) || void 0 === o ? void 0 : o.call(this, n._videoSSRC)) || !1),
                                        i = function (e, t, r, n, i, o) {
                                            const s = r.videoRecv.find(t => t.ssrc === e),
                                                a = i ? i.videoRecv.find(t => t.ssrc === e) : void 0;
                                            if (!s) return null;
                                            const c = kS.isRemoteVideoFreeze(o, s, a) && t, u = {
                                                mediaType: "video",
                                                isVideoMute: !1,
                                                peerId: n,
                                                frameRateReceived: s.receivedFrame && s.receivedFrame.frameRate.toString(),
                                                frameRateDecoded: s.decodedFrame && s.decodedFrame.frameRate.toString(),
                                                isFreeze: c,
                                                bytesReceived: s.bytes.toString(),
                                                packetsReceived: s.packets.toString(),
                                                packetsLost: s.packetsLost.toString(),
                                                qpSumPerFrame: Math.floor(s.qpSumPerFrame).toString()
                                            };
                                            return s.framesRateFirefox && (u.frameRateDecoded = s.framesRateFirefox.toString(), u.frameRateReceived = s.framesRateFirefox.toString()), u
                                        }(n._videoSSRC, r, e, n.uid, t, n.videoTrack);
                                    i && ob(() => {
                                        var e;
                                        null === (e = this.requestUpload) || void 0 === e || e.call(this, $_.SUBSCRIBE_RELATED_STATS, {
                                            stream_id: n.uid,
                                            stats: i
                                        })
                                    })
                                }
                                if (i.has(qv.AUDIO) && n.audioTrack) {
                                    const t = function (e, t, r, n) {
                                        const i = t.audioRecv.find(t => t.ssrc === e);
                                        if (!i) return null;
                                        const o = kS.isRemoteAudioFreeze(n);
                                        return {
                                            mediaType: "audio",
                                            isAudioMute: !1,
                                            peerId: r,
                                            googJitterReceived: i.jitterMs.toString(),
                                            isFreeze: o,
                                            bytesReceived: i.bytes.toString(),
                                            packetsReceived: i.packets.toString(),
                                            packetsLost: i.packetsLost.toString(),
                                            frameReceived: i.receivedFrames.toString(),
                                            frameDropped: i.droppedFrames.toString()
                                        }
                                    }(n._audioSSRC, e, n.uid, n.audioTrack);
                                    t && ob(() => {
                                        var e;
                                        null === (e = this.requestUpload) || void 0 === e || e.call(this, $_.SUBSCRIBE_RELATED_STATS, {
                                            stream_id: n.uid,
                                            stats: t
                                        })
                                    })
                                }
                            })
                        }

                        stopUploadDownlinkStats() {
                            this.uploadDownlinkStarted && (this.uploadDownlinkStarted = !1, this.downlinkStatsUploadInterval && window.clearInterval(this.downlinkStatsUploadInterval), this.downlinkRelatedStatsUploadInterval && window.clearInterval(this.downlinkRelatedStatsUploadInterval), this.downlinkStatsUploadInterval = void 0, this.downlinkRelatedStatsUploadInterval = void 0)
                        }

                        stopUploadTransportStats() {
                            this.uploadTransportStarted && (this.uploadTransportStarted = !1, this.transportStatsUploadInterval && window.clearInterval(this.transportStatsUploadInterval), this.transportStatsUploadInterval = void 0)
                        }

                        stopUploadExtensionUsageStats() {
                            this.uploadExtensionUsageStarted && (this.uploadExtensionUsageStarted = !1, this.extensionUsageStatsUploadInterval && window.clearInterval(this.extensionUsageStatsUploadInterval), this.extensionUsageStatsUploadInterval = void 0)
                        }

                        uploadDownlinkExtensionStats(e) {
                            e.forEach(e => {
                                let [t, r] = e;
                                r.has(qv.VIDEO) && t.videoTrack && t.videoTrack.getProcessorStats().forEach(e => {
                                    var t;
                                    null === (t = this.requestUpload) || void 0 === t || t.call(this, e.type, e.stats)
                                }), r.has(qv.AUDIO) && t.audioTrack && t.audioTrack.getProcessorStats().forEach(e => {
                                    var t;
                                    null === (t = this.requestUpload) || void 0 === t || t.call(this, e.type, e.stats)
                                })
                            })
                        }
                    }, this.bindStatsUploaderEvents(), this.isPlanB = !og().supportUnifiedPlan || fm("CHROME_FORCE_PLAN_B") && Mh()
                }

                async startP2PConnection(e, t) {
                    return this.state = Kv.New, this.connection = t ? new nD(e, this.store) : this.isPlanB ? new _P(e, this.store) : new TP(e, this.store), this.bindConnectionEvents(this.connection), this.connection.establish()
                }

                async connect(e, t, r, n, i, o) {
                    if (!this.connection) throw new Hf(qf.UNEXPECTED_ERROR, "Cannot P2PChannel.connect before P2PChannel.startP2PConnection .");
                    this.connection instanceof nD ? this.connection.updateRemoteConnect(n) : (this.store.peerConnectionStart(), await this.connection.connect(e, t, r, n, i, o), this.statsUploader.startUploadTransportStats(), this.statsUploader.startUploadExtensionUsageStats(), this.state = Kv.Connected)
                }

                async preConnect(e, t, r, n, i, o) {
                    if (!this.connection) throw new Hf(qf.UNEXPECTED_ERROR, "Cannot P2PChannel.connect before P2PChannel.startP2PConnection .");
                    this.store.peerConnectionStart();
                    const s = await this.connection.connect(e, t, r, n, i, o);
                    return this.statsUploader.startUploadTransportStats(), this.statsUploader.startUploadExtensionUsageStats(), this.state = Kv.Connected, s
                }

                getEstablishParams() {
                    if (this.connection instanceof nD) return this.connection.getP2PConnectionParams();
                    throw new Error("Only DataChannelConnection needs to obtain establishParams")
                }

                publish(e, t, r) {
                    var n = this;
                    return RN(function* () {
                        const i = yield IN(n.mutex.lock("From P2PChannel.publish"));
                        try {
                            if (!n.connection || n.state !== Kv.Connected) {
                                if (n.state === Kv.Disconnected) throw new Hf(qf.UNEXPECTED_ERROR, "PeerConnection already disconnected.");
                                n.throwIfTrackTypeNotMatch(e);
                                const t = e.filter(e => -1 === n.pendingLocalTracks.indexOf(e));
                                return void (n.pendingLocalTracks = n.pendingLocalTracks.concat(t))
                            }
                            n.store.pubId = n.store.pubId + 1, NS.markPublishStart(n.store.clientId, n.store.pubId);
                            const o = n.filterTobePublishedTracks(e, t, r);
                            if (0 === o.length) return void (yield IN(n.tryToUnmuteAudio(e)));
                            yield* CN(cD(n.doPublish(n.connection, o)), IN)
                        } finally {
                            i()
                        }
                    })()
                }

                doPublish(e, t) {
                    var r = this;
                    return RN(function* () {
                        t.forEach(e => {
                            let {track: t, type: n} = e;
                            const i = Date.now();
                            r.store.publish(t.getTrackId(), n === Hv.LocalAudioTrack ? "audio" : "video", i)
                        }), r.bindLocalTrackEvents(t);
                        const n = yield IN(e.send(t.map(e => {
                                let {track: t} = e;
                                return t
                            }), r.store.codec, r.store.audioCodec)), i = (yield IN(n.next())).value,
                            o = r.createGatewayPublishMessage(t, i);
                        let s;
                        try {
                            s = yield o
                        } catch (e) {
                            throw n.throw(e), (null == e ? void 0 : e.code) === qf.WS_ABORT && t.forEach(e => {
                                let {track: t} = e;
                                -1 === r.pendingLocalTracks.indexOf(t) && r.pendingLocalTracks.push(t)
                            }), r.unbindLocalTrackEvents(t), e
                        }
                        const a = r.mapPubResToRemoteConfig(o, s), c = (yield IN(n.next(a))).value;
                        t.forEach(e => {
                            let {type: t} = e;
                            r.statsCollector.addLocalStats(t)
                        }), r.assignLocalTracks(t, c), r.statsUploader.startUploadUplinkStats(), t.forEach(e => {
                            let {track: t, type: n} = e;
                            const i = Date.now();
                            r.store.publish(t.getTrackId(), n === Hv.LocalAudioTrack ? "audio" : "video", void 0, i)
                        })
                    })()
                }

                publishLowStream(e) {
                    var t = this;
                    return RN(function* () {
                        if (!t.connection || t.state !== Kv.Connected) return;
                        const r = yield IN(t.mutex.lock("Locking from P2PChannel.publishLowStream"));
                        try {
                            const i = t.localTrackMap.get(Hv.LocalVideoTrack);
                            if (!i) throw new Hf(qf.UNEXPECTED_ERROR, "Could not find high stream");
                            if (t.localTrackMap.has(Hv.LocalVideoLowTrack)) throw new Hf(qf.UNEXPECTED_ERROR, "[".concat(t.store.clientId, "] Can't publish low stream when stream already publish"));
                            const o = [{track: t.getLowVideoTrack(i.track, e), type: Hv.LocalVideoLowTrack}];
                            if (yield* CN(cD(t.doPublish(t.connection, o)), IN), i.track.muted || !i.track.enabled) {
                                var n;
                                const e = null === (n = t.localTrackMap.get(Hv.LocalVideoLowTrack)) || void 0 === n ? void 0 : n.id;
                                void 0 !== e && (yield IN(t.connection.muteLocal([e])))
                            }
                        } finally {
                            r()
                        }
                    })()
                }

                async republish() {
                    this.pendingLocalTracks.length > 0 && (em.debug("Emit P2PChannelEvents.RequestRePublish to republish tracks."), await ZS(this, zv.RequestRePublish, this.pendingLocalTracks), this.emit(zv.MediaReconnectEnd, this.store.uid), this.pendingLocalTracks = [])
                }

                async reSubscribe(e) {
                    for (let e = this.pendingRemoteTracks.length - 1; e >= 0; e--) {
                        const {user: t, kind: r} = this.pendingRemoteTracks[e];
                        (r !== qv.AUDIO || t._audio_added_ && t._audioSSRC) && (r !== qv.VIDEO || t._video_added_ && t._videoSSRC) || this.pendingRemoteTracks.splice(e, 1)
                    }
                    if (e) await ZS(this, zv.RequestReSubscribe, this.pendingRemoteTracks); else for (const {
                        user: e,
                        kind: t
                    } of this.pendingRemoteTracks) await this.subscribe(e, t, t === qv.VIDEO ? e._videoSSRC : e._audioSSRC);
                    this.pendingRemoteTracks.forEach(e => {
                        let {user: t} = e;
                        this.emit(zv.MediaReconnectEnd, t.uid)
                    }), this.pendingRemoteTracks = []
                }

                async unpublish(e) {
                    if (!this.connection || this.state !== Kv.Connected) return void e.forEach(e => {
                        const t = this.pendingLocalTracks.indexOf(e);
                        -1 !== t && this.pendingLocalTracks.splice(t, 1)
                    });
                    const t = this.filterTobeUnpublishedTracks(e);
                    if (0 === t.length) return;
                    const r = t.find(e => "videoLowTrack" === e[0]);
                    return r && r[1].track.close(), this.doUnpublish(this.connection, t)
                }

                async unpublishLowStream() {
                    if (!this.connection || this.state !== Kv.Connected) return;
                    const e = this.localTrackMap.get(Hv.LocalVideoLowTrack);
                    if (!e) return;
                    e.track.close();
                    const t = [[Hv.LocalVideoLowTrack, e]];
                    return this.doUnpublish(this.connection, t)
                }

                async doUnpublish(e, t) {
                    const r = this.createGatewayUnpublishMessage(t);
                    return await e.stopSending(t.map(e => {
                        let [, {id: t}] = e;
                        return t
                    })), this.withdrawLocalTracks(t), this.unbindLocalTrackEvents(t.map(e => {
                        let [t, {track: r}] = e;
                        return {type: t, track: r}
                    })), t.forEach(e => {
                        let [t] = e;
                        this.statsCollector.removeLocalStats(t)
                    }), 0 === this.localTrackMap.size && this.statsUploader.stopUploadUplinkStats(), r
                }

                async subscribe(e, t, r, n, i) {
                    var o;
                    if (!this.connection || this.state !== Kv.Connected) throw new Hf(qf.INVALID_OPERATION, "Cannot subscribe remote user when peerConnection disconnected.");
                    if (null !== (o = this.remoteUserMap.get(e)) && void 0 !== o && o.has(t)) return;
                    let s, a;
                    if (i) {
                        const r = i.find(e => {
                            let {stream_type: r} = e;
                            return r === t
                        });
                        if (!r) throw new Hf(qf.UNEXPECTED_ERROR, "Cannot subscribe to remote ".concat(t, " for user: ").concat(e.uid, " because subscribe answer from gateway does not contain stream_type: ").concat(t, "."));
                        const n = await this.connection.receive(t, r.ssrcs, String(e._uintid), r.attributes);
                        s = n.track, a = n.id
                    } else {
                        const i = await this.connection.receive(t, [{ssrcId: r, rtx: n}], String(e._uintid), void 0);
                        s = i.track, a = i.id
                    }
                    t === qv.AUDIO ? (e._audioTrack ? e._audioTrack._updateOriginMediaStreamTrack(s) : (e._audioTrack = new WP(s, e.uid, e._uintid, this.store), em.info("[".concat(this.store.p2pId, "] create remote audio track: ").concat(e._audioTrack.getTrackId()))), this.bindRemoteTrackEvents(e, e._audioTrack)) : (e._videoTrack ? e._videoTrack._updateOriginMediaStreamTrack(s) : (e._videoTrack = new BP(s, e.uid, e._uintid, this.store), em.info("[".concat(this.store.p2pId, "] create remote video track: ").concat(e._videoTrack.getTrackId()))), this.bindRemoteTrackEvents(e, e._videoTrack));
                    const c = this.remoteUserMap.get(e);
                    c ? c.set(t, a) : this.remoteUserMap.set(e, new Map([[t, a]])), this.statsCollector.addRemoteStats(e.uid), this.statsUploader.startUploadDownlinkStats();
                    const u = this.pendingRemoteTracks.findIndex(r => {
                        let {user: n, kind: i} = r;
                        return n.uid === e.uid && t === i
                    });
                    -1 !== u && (this.pendingRemoteTracks.splice(u, 1), this.emit(zv.MediaReconnectEnd, e.uid))
                }

                async massSubscribe(e) {
                    return this.massSubscribeNoLock(e)
                }

                async massSubscribeNoLock(e) {
                    if (!this.connection || this.state !== Kv.Connected) throw new Hf(qf.INVALID_OPERATION, "Cannot subscribeAll remote users when peerConnection disconnected.");
                    e = e.filter(e => {
                        var t;
                        let {user: r, mediaType: n} = e;
                        return !(null !== (t = this.remoteUserMap.get(r)) && void 0 !== t && t.has(n))
                    });
                    const t = await this.connection.batchReceive(e.map(e => {
                        let {user: t, mediaType: r, ssrcId: n, rtxSsrcId: i} = e;
                        return {kind: r, ssrcMsg: [{ssrcId: n, rtx: i}], mslabel: String(t._uintid)}
                    }));
                    e.forEach((e, r) => {
                        let {user: n, mediaType: i} = e;
                        const {track: o, id: s} = t[r];
                        i === qv.AUDIO ? (n._audioTrack ? n._audioTrack._updateOriginMediaStreamTrack(o) : (n._audioTrack = new WP(o, n.uid, n._uintid, this.store), em.info("[".concat(this.store.p2pId, "] create remote audio track: ").concat(n._audioTrack.getTrackId()))), this.bindRemoteTrackEvents(n, n._audioTrack)) : (n._videoTrack ? n._videoTrack._updateOriginMediaStreamTrack(o) : (n._videoTrack = new BP(o, n.uid, n._uintid, this.store), em.info("[".concat(this.store.p2pId, "] create remote video track: ").concat(n._videoTrack.getTrackId()))), this.bindRemoteTrackEvents(n, n._videoTrack));
                        const a = this.remoteUserMap.get(n);
                        a ? a.set(i, s) : this.remoteUserMap.set(n, new Map([[i, s]])), this.statsCollector.addRemoteStats(n.uid), this.statsUploader.startUploadDownlinkStats();
                        const c = this.pendingRemoteTracks.findIndex(e => {
                            let {user: t, kind: r} = e;
                            return t.uid === n.uid && i === r
                        });
                        -1 !== c && (this.pendingRemoteTracks.splice(c, 1), this.emit(zv.MediaReconnectEnd, n.uid))
                    })
                }

                async unsubscribe(e, t, r) {
                    const n = this.pendingRemoteTracks.filter(r => {
                        let {user: n, kind: i} = r;
                        return void 0 !== t ? n.uid === e.uid && t === i : n.uid === e.uid
                    });
                    if (n.forEach(e => {
                        const t = this.pendingRemoteTracks.indexOf(e);
                        this.pendingRemoteTracks.splice(t, 1)
                    }), this.connection || r || n.forEach(t => {
                        let {kind: r} = t;
                        var n;
                        if (r === qv.AUDIO) null === (n = e._audioTrack) || void 0 === n || n._destroy(), e._audioTrack = void 0; else if (r === qv.VIDEO) {
                            var i;
                            null === (i = e._videoTrack) || void 0 === i || i._destroy(), e._videoTrack = void 0
                        }
                    }), !this.connection) return;
                    const i = this.filterTobeUnSubscribedTracks(e, t);
                    if (0 === i.length) return;
                    await this.connection.stopReceiving(i.map(e => {
                        let [, {id: t}] = e;
                        return t
                    }));
                    const o = this.createUnsubscribeMessage(i);
                    return this.withdrawRemoteTracks(i), 0 === this.remoteUserMap.size && this.statsUploader.stopUploadDownlinkStats(), i.forEach(e => {
                        let [t, {kind: n}] = e;
                        var i, o;
                        if (n === qv.VIDEO && t._videoSSRC && (null === (i = this.connection) || void 0 === i || i.setStatsRemoteVideoIsReady(t._videoSSRC, !1)), n === qv.VIDEO) this.unbindRemoteTrackEvents(t._videoTrack), r || (null === (o = t._videoTrack) || void 0 === o || o._destroy(), t._videoTrack = void 0); else if (n === qv.AUDIO) {
                            var s;
                            this.unbindRemoteTrackEvents(t._audioTrack), r || (null === (s = t._audioTrack) || void 0 === s || s._destroy(), t._audioTrack = void 0)
                        }
                    }), o
                }

                async massUnsubscribe(e) {
                    return this.massUnsubscribeNoLock(e)
                }

                async massUnsubscribeNoLock(e) {
                    let t = [];
                    for (const {user: r, mediaType: n} of e) {
                        const e = this.pendingRemoteTracks.filter(e => {
                            let {user: t, kind: i} = e;
                            return void 0 !== n ? t.uid === r.uid && n === i : t.uid === r.uid
                        });
                        e.forEach(e => {
                            const t = this.pendingRemoteTracks.indexOf(e);
                            this.pendingRemoteTracks.splice(t, 1)
                        }), t = t.concat(e)
                    }
                    if (!this.connection) return void t.forEach(e => {
                        let {user: t, kind: r} = e;
                        var n;
                        if (r === qv.AUDIO) null === (n = t._audioTrack) || void 0 === n || n._destroy(), t._audioTrack = void 0; else if (r === qv.VIDEO) {
                            var i;
                            null === (i = t._videoTrack) || void 0 === i || i._destroy(), t._videoTrack = void 0
                        }
                    });
                    const r = Kr(e).call(e, (e, t) => {
                        let {user: r, mediaType: n} = t;
                        const i = this.filterTobeUnSubscribedTracks(r, n);
                        return e.concat(i)
                    }, []);
                    if (0 === r.length) return;
                    await this.connection.stopReceiving(r.map(e => {
                        let [, {id: t}] = e;
                        return t
                    }));
                    const n = this.createUnsubscribeAllMessage(r);
                    return this.withdrawRemoteTracks(r), 0 === this.remoteUserMap.size && this.statsUploader.stopUploadDownlinkStats(), r.forEach(e => {
                        let [t, {kind: r}] = e;
                        var n, i;
                        if (r === qv.VIDEO && t._videoSSRC && (null === (n = this.connection) || void 0 === n || n.setStatsRemoteVideoIsReady(t._videoSSRC, !1)), r === qv.VIDEO) this.unbindRemoteTrackEvents(t._videoTrack), null === (i = t._videoTrack) || void 0 === i || i._destroy(), t._videoTrack = void 0; else if (r === qv.AUDIO) {
                            var o;
                            this.unbindRemoteTrackEvents(t._audioTrack), null === (o = t._audioTrack) || void 0 === o || o._destroy(), t._audioTrack = void 0
                        }
                    }), n
                }

                async muteRemote(e, t) {
                    if (!this.connection) return;
                    const r = this.remoteUserMap.get(e);
                    if (!r) return void em.warning("P2PChannel.muteRemote has no remote user ".concat(e.uid, "."));
                    if (!r.get(t)) return void em.warning("P2PChannel.muteRemote has no remote user ".concat(e.uid, " media type ").concat(t, "."));
                    const n = t === qv.VIDEO ? e._videoSSRC : e._audioSSRC;
                    void 0 !== n && this.connection.setStatsRemoteVideoIsReady(n, !1)
                }

                async unmuteRemote(e, t) {
                    return this.unmuteRemoteNoLock(e, t)
                }

                async unmuteRemoteNoLock(e, t) {
                    if (!this.connection) return;
                    const r = this.remoteUserMap.get(e);
                    r ? r.get(t) || em.warning("P2PChannel.unmuteRemote has no remote user ".concat(e.uid, " media type ").concat(t, ".")) : em.warning("P2PChannel.unmuteRemote has no remote user ".concat(e.uid, "."))
                }

                getAllTracks(e) {
                    const t = this.localTrackMap.get(Hv.LocalAudioTrack);
                    if ((null == t ? void 0 : t.track) instanceof CS) {
                        const r = t.track;
                        return Array.from(this.localTrackMap.entries()).filter(e => {
                            let [t] = e;
                            return t !== Hv.LocalAudioTrack
                        }).filter(t => {
                            let [r] = t;
                            return !(e && r === Hv.LocalVideoLowTrack)
                        }).map(e => {
                            let [, {track: t}] = e;
                            return t
                        }).concat(r.trackList)
                    }
                    return Array.from(this.localTrackMap.entries()).filter(t => {
                        let [r] = t;
                        return !(e && r === Hv.LocalVideoLowTrack)
                    }).map(e => {
                        let [, {track: t}] = e;
                        return t
                    })
                }

                reportPublishEvent(e, t, r, n, i) {
                    if (e) {
                        const r = this.localTrackMap.get(Hv.LocalAudioTrack),
                            o = n ? this.localTrackMap.get(Hv.LocalVideoLowTrack) : this.localTrackMap.get(Hv.LocalVideoTrack);
                        WE.publish(this.store.sessionId, {
                            eventElapse: NS.measureFromPublishStart(this.store.clientId, this.store.pubId),
                            succ: e,
                            ec: t,
                            audioName: null == r ? void 0 : r.track.getTrackLabel(),
                            videoName: null == o ? void 0 : o.track.getTrackLabel(),
                            screenshare: -1 !== (null == o ? void 0 : o.track._hints.indexOf(Pv.SCREEN_TRACK)),
                            audio: !!r,
                            video: !!o,
                            p2pid: this.store.p2pId,
                            publishRequestid: this.store.pubId,
                            extend: i
                        })
                    } else {
                        var o;
                        r || (r = []);
                        const s = r.find(e => e instanceof RS),
                            a = n ? null === (o = this.localTrackMap.get(Hv.LocalVideoTrack)) || void 0 === o ? void 0 : o.track : r.find(e => e instanceof _A);
                        WE.publish(this.store.sessionId, {
                            eventElapse: NS.measureFromPublishStart(this.store.clientId, this.store.pubId),
                            succ: e,
                            ec: t,
                            audioName: null == s ? void 0 : s.getTrackLabel(),
                            videoName: null == a ? void 0 : a.getTrackLabel(),
                            screenshare: -1 !== (null == a ? void 0 : a._hints.indexOf(Pv.SCREEN_TRACK)),
                            audio: !!s,
                            video: !!a,
                            p2pid: this.store.p2pId,
                            publishRequestid: this.store.pubId,
                            extend: i
                        })
                    }
                }

                reportSubscribeEvent(e, t, r, n) {
                    const i = n === qv.VIDEO ? r._videoSSRC : r._audioSSRC;
                    i && WE.subscribe(this.store.sessionId, {
                        succ: e,
                        ec: t,
                        video: n === qv.VIDEO,
                        audio: n === qv.AUDIO,
                        peerid: r.uid,
                        subscribeRequestid: n === qv.VIDEO ? r._videoSSRC : r._audioSSRC,
                        p2pid: this.store.p2pId,
                        eventElapse: NS.measureFromSubscribeStart(this.store.clientId, i)
                    })
                }

                reset() {
                    em.debug("P2PChannel.reset"), this.mutex = new KE("P2PChannel-mutex"), this.connection && (this.connection.close(), this.unbindConnectionEvents(this.connection), this.connection = void 0), this.statsUploader.stopUploadUplinkStats(), this.statsUploader.stopUploadDownlinkStats(), this.statsUploader.stopUploadTransportStats(), this.statsUploader.stopUploadExtensionUsageStats(), this.unbindLocalTrackEvents(), this.unbindAllRemoteTrackEvents(), this.localTrackMap.clear(), this.remoteUserMap.clear(), this.statsCollector.removeRemoteStats(), this.statsCollector.removeLocalStats(), this.iceFailedCount = 0, this.dtlsFailedCount = 0, this.pendingLocalTracks = [], this.pendingRemoteTracks = [], this.state = Kv.Disconnected
                }

                getStats() {
                    var e;
                    return null === (e = this.connection) || void 0 === e ? void 0 : e.getStats()
                }

                getRemoteVideoIsReady(e) {
                    var t;
                    return (null === (t = this.connection) || void 0 === t ? void 0 : t.getRemoteVideoIsReady(e)) || !1
                }

                getLocalAudioVolume() {
                    const e = this.localTrackMap.get(Hv.LocalAudioTrack);
                    if (e) return e.track.getVolumeLevel()
                }

                getLocalVideoSize() {
                    const e = this.localTrackMap.get(Hv.LocalVideoTrack);
                    if (e) return {width: e.track._videoWidth || 0, height: e.track._videoHeight || 0}
                }

                getEncoderConfig(e) {
                    const t = this.localTrackMap.get(e);
                    return t && t.track instanceof _A || t && t.track instanceof RS ? t.track._encoderConfig : void 0
                }

                getLocalMedia(e) {
                    return this.localTrackMap.get(e)
                }

                hasLocalMedia() {
                    return this.localTrackMap.size > 0
                }

                hasRemoteMedia(e, t) {
                    if (!e) return this.remoteUserMap.size > 0;
                    const r = this.remoteUserMap.get(e);
                    return !!r && (!t || r.has(t))
                }

                async hasRemoteMediaWithLock(e, t) {
                    if (!e) return this.remoteUserMap.size > 0;
                    const r = this.remoteUserMap.get(e);
                    return !!r && (!t || r.has(t))
                }

                getRemoteMedia(e) {
                    var t;
                    const r = Array.from(IE(t = this.remoteUserMap).call(t)).find(t => t.uid === e);
                    return r ? {
                        audioTrack: r.audioTrack,
                        audioSSRC: r._audioSSRC,
                        videoTrack: r.videoTrack,
                        videoSSRC: r._videoSSRC
                    } : {}
                }

                getAudioLevels() {
                    let e = Array.from(this.remoteUserMap.entries()).map(e => {
                        let [t] = e;
                        return {
                            uid: t.uid,
                            level: t.audioTrack ? 100 * t.audioTrack._source.getAccurateVolumeLevel() : 0
                        }
                    });
                    const t = this.localTrackMap.get(Hv.LocalAudioTrack);
                    return t && e.push({
                        level: 100 * t.track._source.getAccurateVolumeLevel(),
                        uid: this.store.uid
                    }), e = m_(e).call(e, (e, t) => e.level - t.level)
                }

                async disconnectForReconnect() {
                    this.connection && (em.debug("P2PChannel.disconnectForReconnect closing P2PConnection"), this.state = Kv.Reconnecting, this.connection.close(), this.unbindConnectionEvents(this.connection), this.connection = void 0, 0 !== this.localTrackMap.size && (Array.from(this.localTrackMap.entries()).forEach(e => {
                        let [t, {track: r}] = e;
                        switch (t) {
                            case Hv.LocalVideoTrack:
                                r._hints.includes(Pv.LOW_STREAM) ? r.close() : this.pendingLocalTracks.push(r);
                                break;
                            case Hv.LocalAudioTrack:
                                r instanceof CS ? this.pendingLocalTracks = this.pendingLocalTracks.concat(r.trackList) : this.pendingLocalTracks.push(r);
                                break;
                            case Hv.LocalVideoLowTrack:
                        }
                    }), this.emit(zv.MediaReconnectStart, this.store.uid)), this.unbindLocalTrackEvents(), this.localTrackMap.clear(), 0 !== this.remoteUserMap.size && Array.from(this.remoteUserMap.entries()).forEach(e => {
                        let [t, r] = e;
                        Array.from(IE(r).call(r)).forEach(e => {
                            this.setPendingRemoteMedia(t, e)
                        }), this.emit(zv.MediaReconnectStart, t.uid)
                    }), this.unbindAllRemoteTrackEvents(), this.remoteUserMap.clear(), this.statsUploader.stopUploadUplinkStats(), this.statsUploader.stopUploadDownlinkStats(), this.statsUploader.stopUploadTransportStats(), em.debug("P2PChannel disconnected, waiting to reconnect."))
                }

                hasPendingRemoteMedia(e, t) {
                    for (const r of this.pendingRemoteTracks) {
                        const {user: n, kind: i} = r;
                        if ((e instanceof gA ? e.uid : e) === n.uid && t === i) return !0
                    }
                    return !1
                }

                setPendingRemoteMedia(e, t) {
                    this.hasPendingRemoteMedia(e, t) || this.pendingRemoteTracks.push({user: e, kind: t})
                }

                restartICE() {
                    var e = this;
                    return RN(function* () {
                        if (!e.connection) throw new Error;
                        const t = yield IN(e.mutex.lock("From P2PChannel.restartICE"));
                        try {
                            yield* CN(cD(e.connection.restartICE()), IN)
                        } finally {
                            t()
                        }
                    })()
                }

                getUplinkNetworkQuality() {
                    if (!this.connection) return 0;
                    const e = this.connection.getStats(), t = this.localTrackMap.get(Hv.LocalVideoTrack),
                        r = this.localTrackMap.get(Hv.LocalAudioTrack),
                        n = e.videoSend.find(e => e.ssrc === (null == t ? void 0 : t.ssrcs[0].ssrcId)),
                        i = e.audioSend.find(e => e.ssrc === (null == r ? void 0 : r.ssrcs[0].ssrcId));
                    if (!n || !i) return 1;
                    const o = tb(this, zv.NeedSignalRTT), s = n ? n.rttMs : void 0, a = i ? i.rttMs : void 0,
                        c = s && a ? (s + a) / 2 : s || a, u = (c && o ? (c + o) / 2 : c || o) || 0,
                        d = 100 * e.sendPacketLossRate * .7 / 50 + .3 * u / 1500,
                        l = d < .17 ? 1 : d < .36 ? 2 : d < .59 ? 3 : d < .1 ? 4 : 5, h = null == t ? void 0 : t.track;
                    if (h && h._encoderConfig && -1 === h._hints.indexOf(Pv.SCREEN_TRACK)) {
                        const t = h._encoderConfig.bitrateMax, r = e.bitrate.actualEncoded;
                        if (t && r) {
                            const e = (1e3 * t - r) / (1e3 * t);
                            return Sm[e < .15 ? 0 : e < .3 ? 1 : e < .45 ? 2 : e < .6 ? 3 : 4][l]
                        }
                    }
                    return l
                }

                getDownlinkNetworkQuality() {
                    if (!this.connection) return 0;
                    const e = this.connection.getStats();
                    let t = 0;
                    return Array.from(this.remoteUserMap.entries()).forEach(r => {
                        let [n] = r;
                        const i = n._audioSSRC, o = n._videoSSRC, s = e.audioRecv.find(e => e.ssrc === i),
                            a = e.videoRecv.find(e => e.ssrc === o);
                        if (!s && !a) return void (t += 1);
                        const c = tb(this, zv.NeedSignalRTT), u = e.rtt, d = (u && c ? (u + c) / 2 : u || c) || 0,
                            l = s ? s.jitterMs : void 0, h = e.recvPacketLossRate;
                        let p = .7 * h * 100 / 50 + .3 * d / 1500;
                        l && (p = .6 * h * 100 / 50 + .2 * d / 1500 + .2 * l / 400), t += p < .1 ? 1 : p < .17 ? 2 : p < .36 ? 3 : p < .59 ? 4 : 5
                    }), this.remoteUserMap.size > 0 ? Math.round(t / this.remoteUserMap.size) : t
                }

                async muteLocalTrack(e) {
                    return new sl((t, r) => {
                        this.handleMuteLocalTrack(e, t, r)
                    })
                }

                filterTobePublishedTracks(e, t, r) {
                    const n = [], i = og(), o = this.getAllTracks();
                    e = ib(e = e.filter(e => -1 === o.indexOf(e)));
                    let s = !1, a = !1;
                    for (const o of e) {
                        if (o instanceof _A && (this.localTrackMap.has(Hv.LocalVideoTrack) || s ? new Hf(qf.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS).throw() : (n.push({
                            track: o,
                            type: Hv.LocalVideoTrack
                        }), s = !0), t)) {
                            const e = this.getLowVideoTrack(o, r);
                            n.push({track: e, type: Hv.LocalVideoLowTrack})
                        }
                        if (o instanceof RS) {
                            const e = this.localTrackMap.get(Hv.LocalAudioTrack);
                            if (e) {
                                if (!(e.track instanceof CS)) throw new Hf(qf.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser does not support audio mixing");
                                if (o._bypassWebAudio) throw new Hf(qf.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio");
                                e.track.addAudioTrack(o), this.bindLocalAudioTrackEvents(o, !0)
                            } else if (a) {
                                const e = n.find(e => {
                                    let {type: t} = e;
                                    return t === Hv.LocalAudioTrack
                                });
                                if (!(e.track instanceof CS)) throw new Hf(qf.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser does not support audio mixing");
                                if (o._bypassWebAudio) throw new Hf(qf.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio");
                                e.track.addAudioTrack(o)
                            } else {
                                if (!i.webAudioMediaStreamDest || o instanceof CS || o._bypassWebAudio) n.push({
                                    track: o,
                                    type: Hv.LocalAudioTrack
                                }); else {
                                    const e = new CS;
                                    e.addAudioTrack(o), n.push({track: e, type: Hv.LocalAudioTrack})
                                }
                                a = !0
                            }
                        }
                    }
                    return n
                }

                filterTobeUnpublishedTracks(e) {
                    const t = [], r = this.getAllTracks();
                    e = ib(e = e.filter(e => -1 !== r.indexOf(e)));
                    for (const r of e) {
                        if (r instanceof RS) {
                            const e = this.localTrackMap.get(Hv.LocalAudioTrack);
                            if (!e) continue;
                            e.track instanceof CS ? (e.track.removeAudioTrack(r), this.unbindLocalAudioTrackEvents(r), 0 === e.track.trackList.length && (t.push([Hv.LocalAudioTrack, e]), e.track.close())) : t.push([Hv.LocalAudioTrack, e])
                        }
                        if (r instanceof _A) {
                            const e = this.localTrackMap.get(Hv.LocalVideoTrack);
                            if (!e) continue;
                            t.push([Hv.LocalVideoTrack, e]);
                            const r = this.localTrackMap.get(Hv.LocalVideoLowTrack);
                            r && t.push([Hv.LocalVideoLowTrack, r])
                        }
                    }
                    return t
                }

                bindLocalTrackEvents(e) {
                    e.forEach(e => {
                        let {track: t, type: r} = e;
                        switch (r) {
                            case Hv.LocalVideoTrack:
                                t.addListener(Nv.GET_STATS, this.handleGetLocalVideoStats), t.addListener(Nv.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), t.addListener(Nv.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), t.addListener(Nv.NEED_UPDATE_VIDEO_ENCODER, this.handleUpdateVideoEncoder), t.addListener(Nv.SET_OPTIMIZATION_MODE, this.handleSetOptimizationMode), t.addListener(Nv.NEED_REPLACE_TRACK, this.handleReplaceTrack), t.addListener(Nv.NEED_MUTE_TRACK, this.handleMuteLocalTrack), t.addListener(Nv.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
                                break;
                            case Hv.LocalAudioTrack:
                                this.bindLocalAudioTrackEvents(t);
                                break;
                            case Hv.LocalVideoLowTrack:
                        }
                    })
                }

                bindLocalAudioTrackEvents(e, t) {
                    e instanceof CS ? e.trackList.forEach(e => {
                        e.addListener(Nv.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e.addListener(Nv.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e.addListener(Nv.GET_STATS, this.handleGetLocalAudioStats), e.addListener(Nv.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e.addListener(Nv.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack)
                    }) : (e.addListener(Nv.GET_STATS, this.handleGetLocalAudioStats), e.addListener(Nv.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e.addListener(Nv.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e.addListener(Nv.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e.addListener(Nv.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack), t || e.addListener(Nv.NEED_REPLACE_TRACK, this.handleReplaceTrack))
                }

                unbindLocalTrackEvents(e) {
                    e || (e = Array.from(this.localTrackMap.entries()).map(e => {
                        let [t, {track: r}] = e;
                        return {track: r, type: t}
                    })), e.forEach(e => {
                        let {track: t, type: r} = e;
                        switch (r) {
                            case Hv.LocalVideoTrack:
                                t.off(Nv.GET_STATS, this.handleGetLocalVideoStats), t.off(Nv.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), t.off(Nv.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), t.off(Nv.NEED_UPDATE_VIDEO_ENCODER, this.handleUpdateVideoEncoder), t.off(Nv.SET_OPTIMIZATION_MODE, this.handleSetOptimizationMode), t.off(Nv.NEED_REPLACE_TRACK, this.handleReplaceTrack), t.off(Nv.NEED_MUTE_TRACK, this.handleMuteLocalTrack), t.off(Nv.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack);
                                break;
                            case Hv.LocalAudioTrack:
                                this.unbindLocalAudioTrackEvents(t);
                                break;
                            case Hv.LocalVideoLowTrack:
                        }
                    })
                }

                unbindLocalAudioTrackEvents(e) {
                    e instanceof CS ? e.trackList.forEach(e => {
                        e.off(Nv.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e.off(Nv.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e.off(Nv.GET_STATS, this.handleGetLocalAudioStats), e.off(Nv.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e.off(Nv.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack)
                    }) : (e.off(Nv.GET_STATS, this.handleGetLocalAudioStats), e.off(Nv.NEED_DISABLE_TRACK, this.handleMuteLocalTrack), e.off(Nv.NEED_ENABLE_TRACK, this.handleUnmuteLocalTrack), e.off(Nv.NEED_REPLACE_TRACK, this.handleReplaceTrack), e.off(Nv.NEED_MUTE_TRACK, this.handleMuteLocalTrack), e.off(Nv.NEED_UNMUTE_TRACK, this.handleUnmuteLocalTrack))
                }

                bindRemoteTrackEvents(e, t) {
                    t instanceof BP && t.addListener(Nv.GET_STATS, t => {
                        t(this.handleGetRemoteVideoStats(e))
                    }), t instanceof WP && t.addListener(Nv.GET_STATS, t => {
                        t(this.handleGetRemoteAudioStats(e))
                    })
                }

                unbindRemoteTrackEvents(e) {
                    e && e.removeAllListeners(Nv.GET_STATS)
                }

                unbindAllRemoteTrackEvents() {
                    Array.from(this.remoteUserMap.entries()).forEach(e => {
                        let [t, r] = e;
                        r.has(qv.AUDIO) && this.unbindRemoteTrackEvents(t._audioTrack), r.has(qv.VIDEO) && this.unbindRemoteTrackEvents(t._videoTrack)
                    })
                }

                createGatewayPublishMessage(e, t) {
                    return e.map((e, r) => {
                        let n, i, {track: o, type: s} = e;
                        switch (s) {
                            case Hv.LocalAudioTrack:
                                n = Cv.Audio, i = {
                                    dtx: o instanceof IS && o._config.DTX,
                                    hq: !1,
                                    lq: !1,
                                    stereo: !1,
                                    speech: !1
                                };
                                break;
                            case Hv.LocalVideoTrack:
                                n = o._hints.includes(Pv.SCREEN_TRACK) ? Cv.Screen : Cv.High, i = aD(aD({}, VS(o)), {}, {codec: this.store.codec});
                                break;
                            case Hv.LocalVideoLowTrack:
                                n = Cv.Low, i = aD(aD({}, VS(o)), {}, {codec: this.store.codec})
                        }
                        return {stream_type: n, attributes: i, ssrcs: t[r]}
                    })
                }

                createGatewayUnpublishMessage(e) {
                    return e.map(e => {
                        let t, [r, {track: n, ssrcs: i, id: o}] = e;
                        switch (r) {
                            case Hv.LocalVideoTrack:
                                t = n._hints.includes(Pv.SCREEN_TRACK) ? Cv.Screen : Cv.High;
                                break;
                            case Hv.LocalAudioTrack:
                                t = Cv.Audio;
                                break;
                            case Hv.LocalVideoLowTrack:
                                t = Cv.Low
                        }
                        return {stream_type: t, ssrcs: i, mid: o}
                    })
                }

                assignLocalTracks(e, t) {
                    e.forEach((e, r) => {
                        let {track: n, type: i} = e;
                        this.localTrackMap.set(i, {track: n, id: t[r].id, ssrcs: t[r].localSSRC})
                    })
                }

                withdrawLocalTracks(e) {
                    e.forEach(e => {
                        let [t] = e;
                        this.localTrackMap.delete(t)
                    })
                }

                bindConnectionEvents(e) {
                    e.onConnectionStateChange = (async t => {
                        if (em.info("[p2pId: ".concat(this.store.p2pId, "]: P2PConnection.onConnectionStateChange(").concat(t, ")")), this.emit(zv.PeerConnectionStateChange, t), "connected" !== t || this.store.keyMetrics.peerConnectionEnd || this.store.peerConnectionEnd(), "disconnected" === t && "disconnected" === e.iceConnectionState) return setTimeout(() => {
                            "disconnected" === e.iceConnectionState && fm("ICE_RESTART") && "CONNECTED" === tb(this, zv.QueryClientConnectionState) && this.emit(zv.RequestRestartICE)
                        }, 800), void setTimeout(() => {
                            "disconnected" === e.peerConnectionState && (em.debug("P2PConnection disconnected timeout 4000ms, force reconnect"), setTimeout(() => this.emit(zv.P2PLost), 0), this.iceFailedCount += 1, this.requestReconnect())
                        }, 4e3);
                        "failed" === t && (em.debug("P2PConnection state failed, force reconnect"), setTimeout(() => this.emit(zv.P2PLost), 0), this.iceFailedCount += 1, await this.requestReconnect())
                    }), e.onICEConnectionStateChange = (e => {
                        "connected" !== e || this.store.keyMetrics.iceConnectionEnd || this.store.iceConnectionEnd(), em.info("[p2pId: ".concat(this.store.p2pId, "]: P2PConnection.onICEConnectionStateChange(").concat(e, ")")), WE.reportApiInvoke(this.store.sessionId, {
                            name: "ICEConnectionStateChange",
                            options: e,
                            tag: U_.TRACER
                        }).onSuccess(), this.emit(zv.IceConnectionStateChange, e)
                    }), e.onICETransportStateChange = (e => {
                        em.info("[p2pId: ".concat(this.store.p2pId, "]: P2PConnection.onICETransportStateChange(").concat(e, ")"))
                    }), e.onDTLSTransportStateChange = (e => {
                        em.info("[p2pId: ".concat(this.store.p2pId, "]: P2PConnection.onDTLSTransportStateChange(").concat(e, ")"))
                    }), e.onDTLSTransportError = (e => {
                        em.info("[p2pId: ".concat(this.store.p2pId, "]: P2PConnection.onDTLSTransportError(").concat(e, ")"))
                    }), e.onFirstAudioDecoded = (e => {
                        var t;
                        const r = Array.from(IE(t = this.remoteUserMap).call(t)).find(t => t._audioSSRC === e);
                        var n;
                        r && (this.store.subscribe(r.uid, "audio", void 0, void 0, void 0, Date.now()), null === (n = r.audioTrack) || void 0 === n || n.emit(xv.FIRST_FRAME_DECODED), WE.firstRemoteFrame(this.store.sessionId, D_.FIRST_AUDIO_DECODE, k_.FIRST_AUDIO_DECODE, {
                            peer: r._uintid,
                            subscribeElapse: NS.measureFromSubscribeStart(this.store.clientId, e),
                            subscribeRequestid: e,
                            p2pid: this.store.p2pId
                        }))
                    }), e.onFirstAudioReceived = (e => {
                        var t;
                        const r = Array.from(IE(t = this.remoteUserMap).call(t)).find(t => t._audioSSRC === e);
                        r && WE.firstRemoteFrame(this.store.sessionId, D_.FIRST_AUDIO_RECEIVED, k_.FIRST_AUDIO_RECEIVED, {
                            peer: r._uintid,
                            subscribeElapse: NS.measureFromSubscribeStart(this.store.clientId, e),
                            subscribeRequestid: e,
                            p2pid: this.store.p2pId
                        })
                    }), e.onFirstVideoDecoded = ((e, t, r) => {
                        this.reportVideoFirstFrameDecoded(e, t, r)
                    }), e.onFirstVideoReceived = (e => {
                        var t;
                        const r = Array.from(IE(t = this.remoteUserMap).call(t)).find(t => t._videoSSRC === e);
                        r && WE.firstRemoteFrame(this.store.sessionId, D_.FIRST_VIDEO_RECEIVED, k_.FIRST_VIDEO_RECEIVED, {
                            peer: r._uintid,
                            subscribeElapse: NS.measureFromSubscribeStart(this.store.clientId, e),
                            subscribeRequestid: e,
                            p2pid: this.store.p2pId
                        })
                    }), e.onSelectedLocalCandidateChanged = ((e, t) => {
                        const r = "relay" === e.candidateType, n = "relay" === t.candidateType;
                        "unknown" !== t.candidateType && r === n || this.emit(zv.ConnectionTypeChange, r), em.info("[p2pId: ".concat(this.store.p2pId, "]: P2PConnection.SelectedLocalCandidateChanged(").concat(JSON.stringify(GS(t)), " -> ").concat(JSON.stringify(GS(e)), ")"))
                    }), e.onSelectedRemoteCandidateChanged = ((e, t) => {
                        em.info("[p2pId: ".concat(this.store.p2pId, "]: P2PConnection.SelectedRemoteCandidateChanged(").concat(JSON.stringify(GS(t)), " -> ").concat(JSON.stringify(GS(e)), ")"))
                    }), e.onFirstVideoDecodedTimeout = (e => {
                        this.reportVideoFirstFrameDecoded(e, void 0, void 0, !0)
                    })
                }

                unbindConnectionEvents(e) {
                    e.onConnectionStateChange = void 0, e.onICEConnectionStateChange = void 0, e.onICETransportStateChange = void 0, e.onDTLSTransportStateChange = void 0, e.onDTLSTransportError = void 0, e.onFirstAudioDecoded = void 0, e.onFirstAudioReceived = void 0, e.onFirstVideoDecoded = void 0, e.onFirstVideoReceived = void 0, e.onSelectedLocalCandidateChanged = void 0, e.onSelectedRemoteCandidateChanged = void 0, e.onFirstVideoDecodedTimeout = void 0
                }

                filterTobeMutedTracks(e) {
                    const t = [];
                    if (-1 === this.getAllTracks().indexOf(e)) return t;
                    const r = this.localTrackMap.get(Hv.LocalAudioTrack);
                    if (e instanceof RS && (null == r ? void 0 : r.track) instanceof CS) return r.track.isActive || t.push([Hv.LocalAudioTrack, r]), t;
                    const n = Array.from(this.localTrackMap.entries()).find(t => {
                        let [, {track: r}] = t;
                        return e === r
                    });
                    if (n && (t.push(n), n[0] === Hv.LocalVideoTrack)) {
                        const e = this.localTrackMap.get(Hv.LocalVideoLowTrack);
                        e && t.push([Hv.LocalVideoLowTrack, e])
                    }
                    return t
                }

                filterTobeUnmutedTracks(e) {
                    const t = [], r = this.localTrackMap.get(Hv.LocalAudioTrack);
                    if (e instanceof RS && (null == r ? void 0 : r.track) instanceof CS) return r.track.isActive && t.push([Hv.LocalAudioTrack, r]), t;
                    const n = Array.from(this.localTrackMap.entries()).find(t => {
                        let [, {track: r}] = t;
                        return e === r
                    });
                    if (n) if (n[0] === Hv.LocalVideoTrack) {
                        t.push(n);
                        const e = this.localTrackMap.get(Hv.LocalVideoLowTrack);
                        e && t.push([Hv.LocalVideoLowTrack, e])
                    } else t.push(n);
                    return t
                }

                createMuteMessage(e) {
                    return e.map(e => {
                        let t, [r, {track: n, ssrcs: i, id: o}] = e;
                        switch (r) {
                            case Hv.LocalAudioTrack:
                                t = Cv.Audio;
                                break;
                            case Hv.LocalVideoTrack:
                                t = n._hints.includes(Pv.SCREEN_TRACK) ? Cv.Screen : Cv.High;
                                break;
                            case Hv.LocalVideoLowTrack:
                                t = Cv.Low
                        }
                        return {stream_type: t, ssrcs: i, mid: o}
                    })
                }

                createUnmuteMessage(e) {
                    return e.map(e => {
                        let t, [r, {track: n, ssrcs: i, id: o}] = e;
                        switch (r) {
                            case Hv.LocalAudioTrack:
                                t = Cv.Audio;
                                break;
                            case Hv.LocalVideoTrack:
                                t = n._hints.includes(Pv.SCREEN_TRACK) ? Cv.Screen : Cv.High;
                                break;
                            case Hv.LocalVideoLowTrack:
                                t = Cv.Low
                        }
                        return {stream_type: t, ssrcs: i, mid: o}
                    })
                }

                filterTobeUnSubscribedTracks(e, t) {
                    const r = [], n = this.remoteUserMap.get(e);
                    if (!n) return r;
                    if (t) {
                        const i = n.get(t);
                        if (!i) return r;
                        r.push([e, {kind: t, id: i}])
                    } else Array.from(n.entries()).forEach(t => {
                        let [n, i] = t;
                        r.push([e, {kind: n, id: i}])
                    });
                    return r
                }

                createUnsubscribeMessage(e) {
                    const t = [];
                    return e.forEach(e => {
                        let [r, {kind: n, id: i}] = e;
                        switch (n) {
                            case qv.VIDEO:
                                return void (r._videoSSRC && t.push({stream_type: qv.VIDEO, ssrcId: r._videoSSRC}));
                            case qv.AUDIO:
                                return void (r._audioSSRC && t.push({stream_type: qv.AUDIO, ssrcId: r._audioSSRC}))
                        }
                    }), t
                }

                createUnsubscribeAllMessage(e) {
                    const t = new Map;
                    return e.forEach(e => {
                        let [r, {kind: n}] = e;
                        if (t.has(r)) {
                            let e = t.get(r);
                            n === qv.VIDEO ? e |= Ov.Video : e |= Ov.Audio, t.set(r, e)
                        } else n === qv.VIDEO ? t.set(r, Ov.Video) : t.set(r, Ov.Audio)
                    }), {
                        users: Array.from(t.entries()).map(e => {
                            let [t, r] = e;
                            return {stream_id: t.uid, stream_type: r}
                        })
                    }
                }

                withdrawRemoteTracks(e) {
                    e.forEach(e => {
                        let [t, {kind: r}] = e;
                        const n = this.remoteUserMap.get(t);
                        n && (n.delete(r), 0 === Array.from(n.entries()).length && this.remoteUserMap.delete(t))
                    })
                }

                async updateBitrateLimit(e) {
                    const t = this.localTrackMap.get(Hv.LocalVideoTrack),
                        r = this.localTrackMap.get(Hv.LocalVideoLowTrack);
                    t && await t.track.setBitrateLimit(e.uplink), r && e.low_stream_uplink && await r.track.setBitrateLimit({
                        max_bitrate: e.low_stream_uplink.bitrate,
                        min_bitrate: e.low_stream_uplink.bitrate || 0
                    })
                }

                isP2PDisconnected() {
                    return !this.connection || "connected" !== this.connection.peerConnectionState
                }

                mapPubResToRemoteConfig(e, t) {
                    return e.map((e, r) => {
                        var n;
                        let {stream_type: i} = e;
                        return null === (n = t.find(e => {
                            let {stream_type: t} = e;
                            return i === t
                        })) || void 0 === n ? void 0 : n.attributes
                    })
                }

                async tryToUnmuteAudio(e) {
                    for (let r = 0; r < e.length; r++) if (e[r] instanceof RS) {
                        var t;
                        const n = this.filterTobeUnmutedTracks(e[r]);
                        if (0 === n.length) continue;
                        await (null === (t = this.connection) || void 0 === t ? void 0 : t.unmuteLocal(n.map(e => {
                            let [, {id: t}] = e;
                            return t
                        })));
                        const i = this.createUnmuteMessage(n);
                        return void await eb(this, zv.RequestUnmuteLocal, i)
                    }
                }

                bindStatsUploaderEvents() {
                    this.statsUploader.requestStats = (() => this.getStats()), this.statsUploader.requestLocalMedia = (() => Array.from(this.localTrackMap.entries())), this.statsUploader.requestRemoteMedia = (() => Array.from(this.remoteUserMap.entries())), this.statsUploader.requestVideoIsReady = (e => {
                        var t;
                        return !(null === (t = this.connection) || void 0 === t || !t.getRemoteVideoIsReady(e))
                    }), this.statsUploader.requestUpload = ((e, t) => this.emit(zv.RequestUploadStats, e, t)), this.statsUploader.requestAllTracks = (() => this.getAllTracks())
                }

                unbindStatsUploaderEvents() {
                    this.statsUploader.requestStats = void 0, this.statsUploader.requestLocalMedia = void 0, this.statsUploader.requestRemoteMedia = void 0, this.statsUploader.requestVideoIsReady = void 0
                }

                async requestReconnect() {
                    this.dtlsFailedCount += 1, await zS(zf(this.dtlsFailedCount, Kf)), this.emit(zv.RequestReconnect)
                }

                async reconnectP2P() {
                    const e = Array.from(this.localTrackMap.entries()), t = this.createGatewayUnpublishMessage(e);
                    Array.from(this.remoteUserMap.entries()), t.length > 0 && await ZS(this, zv.RequestUnpublishForReconnectPC, t), this.disconnectForReconnect(), this.emit(zv.RequestReconnectPC)
                }

                canPublishLowStream() {
                    return this.localTrackMap.has(Hv.LocalVideoTrack) || this.pendingLocalTracks.some(e => e instanceof _A)
                }

                throwIfTrackTypeNotMatch(e) {
                    if (e.filter(e => e instanceof _A).length > 1) throw new Hf(qf.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS);
                    if (e.filter(e => e instanceof RS).length > 1 && (e.some(e => e instanceof RS && e._bypassWebAudio) || !og().webAudioMediaStreamDest)) throw new Hf(qf.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser doesn't support MediaStreamDestNode");
                    for (const t of e) {
                        if (t instanceof _A && this.pendingLocalTracks.some(e => e instanceof _A)) throw new Hf(qf.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS);
                        if (t instanceof RS && this.pendingLocalTracks.some(e => e instanceof RS) && (!og().webAudioMediaStreamDest || t._bypassWebAudio || this.pendingLocalTracks.some(e => e instanceof RS && e._bypassWebAudio))) throw new Hf(qf.NOT_SUPPORTED, "cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser doesn't support MediaStreamDestNode")
                    }
                }

                getLowVideoTrack(e, t) {
                    const r = og().supportDualStreamEncoding,
                        n = aD(aD({}, {width: 160, height: 120, framerate: 15, bitrate: 50}), t);
                    let i;
                    i = r ? e._mediaStreamTrack.clone() : IP(e, n);
                    const o = YS(8, "track-low-"), s = new _A(i, aD(aD({}, r && {
                        scaleResolutionDownBy: function (e, t) {
                            const r = t._videoWidth || t.getMediaStreamTrack(!0).getSettings().width;
                            return r || em.warning("cannot get original video track's width, default scale down 4 times for low stream"), r ? r / jS(e.width) : 4
                        }(n, e)
                    }), {}, {
                        frameRate: n.framerate,
                        bitrateMax: n.bitrate,
                        bitrateMin: n.bitrate
                    }), void 0, void 0, o);
                    return s._hints.push(Pv.LOW_STREAM), e.addListener(Nv.NEED_CLOSE, () => {
                        s.close()
                    }), s
                }

                async globalLock() {
                    return this.mutex.lock("From P2PChannel.globalLock")
                }

                reportVideoFirstFrameDecoded(e, t, r, n) {
                    var i;
                    const o = Array.from(IE(i = this.remoteUserMap).call(i)).find(t => t._videoSSRC === e);
                    if (o) {
                        n || this.store.subscribe(o.uid, "video", void 0, void 0, void 0, void 0, Date.now());
                        const i = this.store.keyMetrics,
                            s = i.subscribe.find(e => e.userId === o.uid && "video" === e.type);
                        WE.firstRemoteVideoDecode(this.store.sessionId, D_.FIRST_VIDEO_DECODE, k_.FIRST_VIDEO_DECODE, {
                            peer: o._uintid,
                            videowidth: t,
                            videoheight: r,
                            subscribeElapse: NS.measureFromSubscribeStart(this.store.clientId, e),
                            subscribeRequestid: e,
                            p2pid: this.store.p2pId,
                            apEnd: i.requestAPEnd || 0,
                            apStart: i.requestAPStart || 0,
                            joinGwEnd: i.joinGatewayEnd || 0,
                            joinGwStart: i.joinGatewayStart || 0,
                            pcEnd: i.peerConnectionEnd || 0,
                            pcStart: i.peerConnectionStart || 0,
                            subscriberEnd: (null == s ? void 0 : s.subscribeEnd) || 0,
                            subscriberStart: (null == s ? void 0 : s.subscribeStart) || 0,
                            videoAddNotify: (null == s ? void 0 : s.streamAdded) || 0,
                            state: n ? 1 : 0
                        })
                    }
                }

                async remoteMediaSsrcChanged(e, t, r) {
                    if (!this.connection) return !1;
                    const n = this.remoteUserMap.get(e);
                    if (!n) return !1;
                    const i = n.get(t);
                    if (!i) return !1;
                    const o = await this.connection.getRemoteSSRC(i);
                    return void 0 !== o && o !== r
                }
            }).prototype, "startP2PConnection", [lD], Object.getOwnPropertyDescriptor(oD.prototype, "startP2PConnection"), oD.prototype), vE(oD.prototype, "connect", [lD], Object.getOwnPropertyDescriptor(oD.prototype, "connect"), oD.prototype), vE(oD.prototype, "preConnect", [lD], Object.getOwnPropertyDescriptor(oD.prototype, "preConnect"), oD.prototype), vE(oD.prototype, "unpublish", [lD], Object.getOwnPropertyDescriptor(oD.prototype, "unpublish"), oD.prototype), vE(oD.prototype, "unpublishLowStream", [lD], Object.getOwnPropertyDescriptor(oD.prototype, "unpublishLowStream"), oD.prototype), vE(oD.prototype, "subscribe", [lD], Object.getOwnPropertyDescriptor(oD.prototype, "subscribe"), oD.prototype), vE(oD.prototype, "massSubscribe", [lD], Object.getOwnPropertyDescriptor(oD.prototype, "massSubscribe"), oD.prototype), vE(oD.prototype, "unsubscribe", [lD], Object.getOwnPropertyDescriptor(oD.prototype, "unsubscribe"), oD.prototype), vE(oD.prototype, "massUnsubscribe", [lD], Object.getOwnPropertyDescriptor(oD.prototype, "massUnsubscribe"), oD.prototype), vE(oD.prototype, "muteRemote", [lD], Object.getOwnPropertyDescriptor(oD.prototype, "muteRemote"), oD.prototype), vE(oD.prototype, "unmuteRemote", [lD], Object.getOwnPropertyDescriptor(oD.prototype, "unmuteRemote"), oD.prototype), vE(oD.prototype, "hasRemoteMediaWithLock", [lD], Object.getOwnPropertyDescriptor(oD.prototype, "hasRemoteMediaWithLock"), oD.prototype), vE(oD.prototype, "disconnectForReconnect", [lD], Object.getOwnPropertyDescriptor(oD.prototype, "disconnectForReconnect"), oD.prototype), vE(oD.prototype, "updateBitrateLimit", [lD], Object.getOwnPropertyDescriptor(oD.prototype, "updateBitrateLimit"), oD.prototype), vE(oD.prototype, "remoteMediaSsrcChanged", [lD], Object.getOwnPropertyDescriptor(oD.prototype, "remoteMediaSsrcChanged"), oD.prototype), oD);

            function lD(e, t, r) {
                const n = e[t];
                if ("function" != typeof n) throw new Error("Cannot use mutex on object property.");
                return r.value = async function () {
                    const e = this.mutex, r = await e.lock("From P2PChannel.".concat(t));
                    try {
                        for (var i = arguments.length, o = new Array(i), s = 0; s < i; s++) o[s] = arguments[s];
                        return await n.apply(this, o)
                    } finally {
                        r()
                    }
                }, r
            }

            function hD(e) {
                return "Minified Redux error #" + e + "; visit https://redux.js.org/Errors?code=" + e + " for the full message or use the non-minified dev environment for full errors. "
            }

            var pD, fD = "function" == typeof Symbol && Symbol.observable || "@@observable", mD = function () {
                return Math.random().toString(36).substring(7).split("").join(".")
            }, _D = {
                INIT: "@@redux/INIT" + mD(), REPLACE: "@@redux/REPLACE" + mD(), PROBE_UNKNOWN_ACTION: function () {
                    return "@@redux/PROBE_UNKNOWN_ACTION" + mD()
                }
            };

            function vD(e, t, r) {
                var n;
                if ("function" == typeof t && "function" == typeof r || "function" == typeof r && "function" == typeof arguments[3]) throw new Error(hD(0));
                if ("function" == typeof t && void 0 === r && (r = t, t = void 0), void 0 !== r) {
                    if ("function" != typeof r) throw new Error(hD(1));
                    return r(vD)(e, t)
                }
                if ("function" != typeof e) throw new Error(hD(2));
                var i = e, o = t, s = [], a = s, c = !1;

                function u() {
                    a === s && (a = s.slice())
                }

                function d() {
                    if (c) throw new Error(hD(3));
                    return o
                }

                function l(e) {
                    if ("function" != typeof e) throw new Error(hD(4));
                    if (c) throw new Error(hD(5));
                    var t = !0;
                    return u(), a.push(e), function () {
                        if (t) {
                            if (c) throw new Error(hD(6));
                            t = !1, u();
                            var r = a.indexOf(e);
                            a.splice(r, 1), s = null
                        }
                    }
                }

                function h(e) {
                    if (!function (e) {
                        if ("object" != typeof e || null === e) return !1;
                        for (var t = e; null !== Object.getPrototypeOf(t);) t = Object.getPrototypeOf(t);
                        return Object.getPrototypeOf(e) === t
                    }(e)) throw new Error(hD(7));
                    if (void 0 === e.type) throw new Error(hD(8));
                    if (c) throw new Error(hD(9));
                    try {
                        c = !0, o = i(o, e)
                    } finally {
                        c = !1
                    }
                    for (var t = s = a, r = 0; r < t.length; r++) (0, t[r])();
                    return e
                }

                return h({type: _D.INIT}), (n = {
                    dispatch: h, subscribe: l, getState: d, replaceReducer: function (e) {
                        if ("function" != typeof e) throw new Error(hD(10));
                        i = e, h({type: _D.REPLACE})
                    }
                })[fD] = function () {
                    var e, t = l;
                    return (e = {
                        subscribe: function (e) {
                            if ("object" != typeof e || null === e) throw new Error(hD(11));

                            function r() {
                                e.next && e.next(d())
                            }

                            return r(), {unsubscribe: t(r)}
                        }
                    })[fD] = function () {
                        return this
                    }, e
                }, n
            }

            function gD(e, t) {
                var r = Object.keys(e);
                if (Object.getOwnPropertySymbols) {
                    var n = Object.getOwnPropertySymbols(e);
                    t && (n = n.filter(function (t) {
                        return Object.getOwnPropertyDescriptor(e, t).enumerable
                    })), r.push.apply(r, n)
                }
                return r
            }

            function ED(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var r = null != arguments[t] ? arguments[t] : {};
                    t % 2 ? gD(Object(r), !0).forEach(function (t) {
                        Kh(e, t, r[t])
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : gD(Object(r)).forEach(function (t) {
                        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t))
                    })
                }
                return e
            }

            let yD;
            !function (e) {
                e.SET_SESSION_ID = "SET_SESSION_ID", e.SET_P2P_ID = "SET_P2P_id", e.SET_DC_ID = "SET_DC_id", e.SET_UID = "SET_UID", e.SET_PUB_ID = "SET_PUB_ID", e.SET_CLOUD_PROXY_SERVER_MODE = "SET_CLOUD_PROXY_SERVER_MODE", e.KEY_METRIC_CLIENT_CREATED = "KEY_METRIC_CLIENT_CREATED", e.KEY_METRIC_JOIN_START = "KEY_METRIC_JOIN_START", e.AVOID_JOIN_START = "AVOID_JOIN_START", e.KEY_METRIC_JOIN_END = "KEY_METRIC_JOIN_END", e.KEY_METRIC_REQUEST_AP_START = "KEY_METRIC_REQUEST_AP_START", e.KEY_METRIC_REQUEST_AP_END = "KEY_METRIC_REQUEST_AP_END", e.KEY_METRIC_JOIN_GATEWAY_START = "KEY_METRIC_JOIN_GATEWAY_START", e.KEY_METRIC_JOIN_GATEWAY_END = "KEY_METRIC_JOIN_GATEWAY_END", e.KEY_METRIC_PEER_CONNECTION_START = "KEY_METRIC_PEER_CONNECTION_START", e.KEY_METRIC_PEER_CONNECTION_END = "KEY_METRIC_PEER_CONNECTION_END", e.KEY_METRIC_ICE_CONNECTION_END = "KEY_METRIC_ICE_CONNECTION_END", e.KEY_METRIC_SIGNAL_CHANNEL_OPEN = "KEY_METRIC_SIGNAL_CHANNEL_OPEN", e.KEY_METRIC_PUBLISH = "KEY_METRIC_PUBLISH", e.KEY_METRIC_SUBSCRIBE = "KEY_METRIC_SUBSCRIBE", e.RECORD_JOIN_CHANNEL_SERVICE = "RECORD_JOIN_CHANNEL_SERVICE", e.RESET_JOIN_CHANNEL_SERVICE_RECORDS = "RESET_JOIN_CHANNEL_SERVICE_RECORDS", e.RESET_KEY_METRICS = "RESET_KEY_METRICS"
            }(pD || (pD = {}));
            const SD = () => void 0 !== window.isSecureContext;

            function bD(e) {
                let t = {};
                e:for (; !LD(e);) {
                    let r = qD(e);
                    switch (r >>> 3) {
                        case 0:
                            break e;
                        case 1:
                            t.requestId = UD(e, qD(e));
                            break;
                        case 2:
                            t.requestType = qD(e) >>> 0;
                            break;
                        case 3:
                            t.scorePorn = WD(e);
                            break;
                        case 4:
                            t.scoreSexy = WD(e);
                            break;
                        case 5:
                            t.scoreNeutral = WD(e);
                            break;
                        case 6:
                            t.requestScene = qD(e) >>> 0;
                            break;
                        case 7:
                            t.scene = qD(e) >>> 0;
                            break;
                        default:
                            ID(e, 7 & r)
                    }
                }
                return t
            }

            function TD(e, t) {
                let r = e.service;
                void 0 !== r && (HD(t, 8), HD(t, r));
                let n = e.vendor;
                void 0 !== n && (HD(t, 16), HD(t, n));
                let i = e.token;
                void 0 !== i && (HD(t, 26), jD(t, i));
                let o = e.callbackUrl;
                void 0 !== o && (HD(t, 34), jD(t, o))
            }

            function RD(e) {
                let t = qD(e), r = e.limit;
                return e.limit = e.offset + t, r
            }

            function ID(e, t) {
                switch (t) {
                    case 0:
                        for (; 128 & FD(e);) ;
                        break;
                    case 2:
                        kD(e, qD(e));
                        break;
                    case 5:
                        kD(e, 4);
                        break;
                    case 1:
                        kD(e, 8);
                        break;
                    default:
                        throw new Error("Unimplemented type: " + t)
                }
            }

            let wD = new Float32Array(1);
            new Uint8Array(wD.buffer);
            let CD = new Float64Array(1), AD = new Uint8Array(CD.buffer);

            function OD(e) {
                return {low: e |= 0, high: e >> 31, unsigned: e >= 0}
            }

            let ND = [];

            function PD() {
                const e = ND.pop();
                return e ? (e.offset = e.limit = 0, e) : {bytes: new Uint8Array(64), offset: 0, limit: 0}
            }

            function DD(e) {
                ND.push(e)
            }

            function kD(e, t) {
                if (e.offset + t > e.limit) throw new Error("Skip past limit");
                e.offset += t
            }

            function LD(e) {
                return e.offset >= e.limit
            }

            function xD(e, t) {
                let r = e.bytes, n = e.offset, i = e.limit, o = n + t;
                if (o > r.length) {
                    let t = new Uint8Array(2 * o);
                    t.set(r), e.bytes = t
                }
                return e.offset = o, o > i && (e.limit = o), n
            }

            function MD(e, t) {
                let r = e.offset;
                if (r + t > e.limit) throw new Error("Read past limit");
                return e.offset += t, r
            }

            function UD(e, t) {
                let r = MD(e, t), n = String.fromCharCode, i = e.bytes, o = "", s = "";
                for (let e = 0; e < t; e++) {
                    let a, c, u, d, l = i[e + r];
                    0 == (128 & l) ? s += n(l) : 192 == (224 & l) ? e + 1 >= t ? s += o : 128 != (192 & (a = i[e + r + 1])) ? s += o : (d = (31 & l) << 6 | 63 & a) < 128 ? s += o : (s += n(d), e++) : 224 == (240 & l) ? e + 2 >= t ? s += o : (a = i[e + r + 1], c = i[e + r + 2], 32896 != (49344 & (a | c << 8)) ? s += o : (d = (15 & l) << 12 | (63 & a) << 6 | 63 & c) < 2048 || d >= 55296 && d <= 57343 ? s += o : (s += n(d), e += 2)) : 240 == (248 & l) ? e + 3 >= t ? s += o : (a = i[e + r + 1], c = i[e + r + 2], u = i[e + r + 3], 8421504 != (12632256 & (a | c << 8 | u << 16)) ? s += o : (d = (7 & l) << 18 | (63 & a) << 12 | (63 & c) << 6 | 63 & u) < 65536 || d > 1114111 ? s += o : (s += n(55296 + ((d -= 65536) >> 10), 56320 + (1023 & d)), e += 3)) : s += o
                }
                return s
            }

            function jD(e, t) {
                let r = t.length, n = 0;
                for (let e = 0; e < r; e++) {
                    let i = t.charCodeAt(e);
                    i >= 55296 && i <= 56319 && e + 1 < r && (i = (i << 10) + t.charCodeAt(++e) - 56613888), n += i < 128 ? 1 : i < 2048 ? 2 : i < 65536 ? 3 : 4
                }
                HD(e, n);
                let i = xD(e, n), o = e.bytes;
                for (let e = 0; e < r; e++) {
                    let n = t.charCodeAt(e);
                    n >= 55296 && n <= 56319 && e + 1 < r && (n = (n << 10) + t.charCodeAt(++e) - 56613888), n < 128 ? o[i++] = n : (n < 2048 ? o[i++] = n >> 6 & 31 | 192 : (n < 65536 ? o[i++] = n >> 12 & 15 | 224 : (o[i++] = n >> 18 & 7 | 240, o[i++] = n >> 12 & 63 | 128), o[i++] = n >> 6 & 63 | 128), o[i++] = 63 & n | 128)
                }
            }

            function VD(e, t) {
                let r = xD(e, t.limit), n = e.bytes, i = t.bytes;
                for (let e = 0, o = t.limit; e < o; e++) n[e + r] = i[e]
            }

            function FD(e) {
                return e.bytes[MD(e, 1)]
            }

            function BD(e, t) {
                let r = xD(e, 1);
                e.bytes[r] = t
            }

            function WD(e) {
                let t = MD(e, 8), r = e.bytes;
                return AD[0] = r[t++], AD[1] = r[t++], AD[2] = r[t++], AD[3] = r[t++], AD[4] = r[t++], AD[5] = r[t++], AD[6] = r[t++], AD[7] = r[t++], CD[0]
            }

            function GD(e, t) {
                let r = xD(e, 8), n = e.bytes;
                CD[0] = t, n[r++] = AD[0], n[r++] = AD[1], n[r++] = AD[2], n[r++] = AD[3], n[r++] = AD[4], n[r++] = AD[5], n[r++] = AD[6], n[r++] = AD[7]
            }

            function qD(e) {
                let t, r = 0, n = 0;
                do {
                    t = FD(e), r < 32 && (n |= (127 & t) << r), r += 7
                } while (128 & t);
                return n
            }

            function HD(e, t) {
                for (t >>>= 0; t >= 128;) BD(e, 127 & t | 128), t >>>= 7;
                BD(e, t)
            }

            function KD(e, t) {
                let r = t.low >>> 0, n = (t.low >>> 28 | t.high << 4) >>> 0, i = t.high >>> 24,
                    o = 0 === i ? 0 === n ? r < 16384 ? r < 128 ? 1 : 2 : r < 1 << 21 ? 3 : 4 : n < 16384 ? n < 128 ? 5 : 6 : n < 1 << 21 ? 7 : 8 : i < 128 ? 9 : 10,
                    s = xD(e, o), a = e.bytes;
                switch (o) {
                    case 10:
                        a[s + 9] = i >>> 7 & 1;
                    case 9:
                        a[s + 8] = 9 !== o ? 128 | i : 127 & i;
                    case 8:
                        a[s + 7] = 8 !== o ? n >>> 21 | 128 : n >>> 21 & 127;
                    case 7:
                        a[s + 6] = 7 !== o ? n >>> 14 | 128 : n >>> 14 & 127;
                    case 6:
                        a[s + 5] = 6 !== o ? n >>> 7 | 128 : n >>> 7 & 127;
                    case 5:
                        a[s + 4] = 5 !== o ? 128 | n : 127 & n;
                    case 4:
                        a[s + 3] = 4 !== o ? r >>> 21 | 128 : r >>> 21 & 127;
                    case 3:
                        a[s + 2] = 3 !== o ? r >>> 14 | 128 : r >>> 14 & 127;
                    case 2:
                        a[s + 1] = 2 !== o ? r >>> 7 | 128 : r >>> 7 & 127;
                    case 1:
                        a[s] = 1 !== o ? 128 | r : 127 & r
                }
            }

            var zD = {};
            Object.defineProperty(zD, "__esModule", {value: !0});
            var YD = function () {
                function e() {
                    this._dataLength = 0, this._bufferLength = 0, this._state = new Int32Array(4), this._buffer = new ArrayBuffer(68), this._buffer8 = new Uint8Array(this._buffer, 0, 68), this._buffer32 = new Uint32Array(this._buffer, 0, 17), this.start()
                }

                return e.hashStr = function (e, t) {
                    return void 0 === t && (t = !1), this.onePassHasher.start().appendStr(e).end(t)
                }, e.hashAsciiStr = function (e, t) {
                    return void 0 === t && (t = !1), this.onePassHasher.start().appendAsciiStr(e).end(t)
                }, e._hex = function (t) {
                    var r, n, i, o, s = e.hexChars, a = e.hexOut;
                    for (o = 0; o < 4; o += 1) for (n = 8 * o, r = t[o], i = 0; i < 8; i += 2) a[n + 1 + i] = s.charAt(15 & r), r >>>= 4, a[n + 0 + i] = s.charAt(15 & r), r >>>= 4;
                    return a.join("")
                }, e._md5cycle = function (e, t) {
                    var r = e[0], n = e[1], i = e[2], o = e[3];
                    n = ((n += ((i = ((i += ((o = ((o += ((r = ((r += (n & i | ~n & o) + t[0] - 680876936 | 0) << 7 | r >>> 25) + n | 0) & n | ~r & i) + t[1] - 389564586 | 0) << 12 | o >>> 20) + r | 0) & r | ~o & n) + t[2] + 606105819 | 0) << 17 | i >>> 15) + o | 0) & o | ~i & r) + t[3] - 1044525330 | 0) << 22 | n >>> 10) + i | 0, n = ((n += ((i = ((i += ((o = ((o += ((r = ((r += (n & i | ~n & o) + t[4] - 176418897 | 0) << 7 | r >>> 25) + n | 0) & n | ~r & i) + t[5] + 1200080426 | 0) << 12 | o >>> 20) + r | 0) & r | ~o & n) + t[6] - 1473231341 | 0) << 17 | i >>> 15) + o | 0) & o | ~i & r) + t[7] - 45705983 | 0) << 22 | n >>> 10) + i | 0, n = ((n += ((i = ((i += ((o = ((o += ((r = ((r += (n & i | ~n & o) + t[8] + 1770035416 | 0) << 7 | r >>> 25) + n | 0) & n | ~r & i) + t[9] - 1958414417 | 0) << 12 | o >>> 20) + r | 0) & r | ~o & n) + t[10] - 42063 | 0) << 17 | i >>> 15) + o | 0) & o | ~i & r) + t[11] - 1990404162 | 0) << 22 | n >>> 10) + i | 0, n = ((n += ((i = ((i += ((o = ((o += ((r = ((r += (n & i | ~n & o) + t[12] + 1804603682 | 0) << 7 | r >>> 25) + n | 0) & n | ~r & i) + t[13] - 40341101 | 0) << 12 | o >>> 20) + r | 0) & r | ~o & n) + t[14] - 1502002290 | 0) << 17 | i >>> 15) + o | 0) & o | ~i & r) + t[15] + 1236535329 | 0) << 22 | n >>> 10) + i | 0, n = ((n += ((i = ((i += ((o = ((o += ((r = ((r += (n & o | i & ~o) + t[1] - 165796510 | 0) << 5 | r >>> 27) + n | 0) & i | n & ~i) + t[6] - 1069501632 | 0) << 9 | o >>> 23) + r | 0) & n | r & ~n) + t[11] + 643717713 | 0) << 14 | i >>> 18) + o | 0) & r | o & ~r) + t[0] - 373897302 | 0) << 20 | n >>> 12) + i | 0, n = ((n += ((i = ((i += ((o = ((o += ((r = ((r += (n & o | i & ~o) + t[5] - 701558691 | 0) << 5 | r >>> 27) + n | 0) & i | n & ~i) + t[10] + 38016083 | 0) << 9 | o >>> 23) + r | 0) & n | r & ~n) + t[15] - 660478335 | 0) << 14 | i >>> 18) + o | 0) & r | o & ~r) + t[4] - 405537848 | 0) << 20 | n >>> 12) + i | 0, n = ((n += ((i = ((i += ((o = ((o += ((r = ((r += (n & o | i & ~o) + t[9] + 568446438 | 0) << 5 | r >>> 27) + n | 0) & i | n & ~i) + t[14] - 1019803690 | 0) << 9 | o >>> 23) + r | 0) & n | r & ~n) + t[3] - 187363961 | 0) << 14 | i >>> 18) + o | 0) & r | o & ~r) + t[8] + 1163531501 | 0) << 20 | n >>> 12) + i | 0, n = ((n += ((i = ((i += ((o = ((o += ((r = ((r += (n & o | i & ~o) + t[13] - 1444681467 | 0) << 5 | r >>> 27) + n | 0) & i | n & ~i) + t[2] - 51403784 | 0) << 9 | o >>> 23) + r | 0) & n | r & ~n) + t[7] + 1735328473 | 0) << 14 | i >>> 18) + o | 0) & r | o & ~r) + t[12] - 1926607734 | 0) << 20 | n >>> 12) + i | 0, n = ((n += ((i = ((i += ((o = ((o += ((r = ((r += (n ^ i ^ o) + t[5] - 378558 | 0) << 4 | r >>> 28) + n | 0) ^ n ^ i) + t[8] - 2022574463 | 0) << 11 | o >>> 21) + r | 0) ^ r ^ n) + t[11] + 1839030562 | 0) << 16 | i >>> 16) + o | 0) ^ o ^ r) + t[14] - 35309556 | 0) << 23 | n >>> 9) + i | 0, n = ((n += ((i = ((i += ((o = ((o += ((r = ((r += (n ^ i ^ o) + t[1] - 1530992060 | 0) << 4 | r >>> 28) + n | 0) ^ n ^ i) + t[4] + 1272893353 | 0) << 11 | o >>> 21) + r | 0) ^ r ^ n) + t[7] - 155497632 | 0) << 16 | i >>> 16) + o | 0) ^ o ^ r) + t[10] - 1094730640 | 0) << 23 | n >>> 9) + i | 0, n = ((n += ((i = ((i += ((o = ((o += ((r = ((r += (n ^ i ^ o) + t[13] + 681279174 | 0) << 4 | r >>> 28) + n | 0) ^ n ^ i) + t[0] - 358537222 | 0) << 11 | o >>> 21) + r | 0) ^ r ^ n) + t[3] - 722521979 | 0) << 16 | i >>> 16) + o | 0) ^ o ^ r) + t[6] + 76029189 | 0) << 23 | n >>> 9) + i | 0, n = ((n += ((i = ((i += ((o = ((o += ((r = ((r += (n ^ i ^ o) + t[9] - 640364487 | 0) << 4 | r >>> 28) + n | 0) ^ n ^ i) + t[12] - 421815835 | 0) << 11 | o >>> 21) + r | 0) ^ r ^ n) + t[15] + 530742520 | 0) << 16 | i >>> 16) + o | 0) ^ o ^ r) + t[2] - 995338651 | 0) << 23 | n >>> 9) + i | 0, n = ((n += ((o = ((o += (n ^ ((r = ((r += (i ^ (n | ~o)) + t[0] - 198630844 | 0) << 6 | r >>> 26) + n | 0) | ~i)) + t[7] + 1126891415 | 0) << 10 | o >>> 22) + r | 0) ^ ((i = ((i += (r ^ (o | ~n)) + t[14] - 1416354905 | 0) << 15 | i >>> 17) + o | 0) | ~r)) + t[5] - 57434055 | 0) << 21 | n >>> 11) + i | 0, n = ((n += ((o = ((o += (n ^ ((r = ((r += (i ^ (n | ~o)) + t[12] + 1700485571 | 0) << 6 | r >>> 26) + n | 0) | ~i)) + t[3] - 1894986606 | 0) << 10 | o >>> 22) + r | 0) ^ ((i = ((i += (r ^ (o | ~n)) + t[10] - 1051523 | 0) << 15 | i >>> 17) + o | 0) | ~r)) + t[1] - 2054922799 | 0) << 21 | n >>> 11) + i | 0, n = ((n += ((o = ((o += (n ^ ((r = ((r += (i ^ (n | ~o)) + t[8] + 1873313359 | 0) << 6 | r >>> 26) + n | 0) | ~i)) + t[15] - 30611744 | 0) << 10 | o >>> 22) + r | 0) ^ ((i = ((i += (r ^ (o | ~n)) + t[6] - 1560198380 | 0) << 15 | i >>> 17) + o | 0) | ~r)) + t[13] + 1309151649 | 0) << 21 | n >>> 11) + i | 0, n = ((n += ((o = ((o += (n ^ ((r = ((r += (i ^ (n | ~o)) + t[4] - 145523070 | 0) << 6 | r >>> 26) + n | 0) | ~i)) + t[11] - 1120210379 | 0) << 10 | o >>> 22) + r | 0) ^ ((i = ((i += (r ^ (o | ~n)) + t[2] + 718787259 | 0) << 15 | i >>> 17) + o | 0) | ~r)) + t[9] - 343485551 | 0) << 21 | n >>> 11) + i | 0, e[0] = r + e[0] | 0, e[1] = n + e[1] | 0, e[2] = i + e[2] | 0, e[3] = o + e[3] | 0
                }, e.prototype.start = function () {
                    return this._dataLength = 0, this._bufferLength = 0, this._state.set(e.stateIdentity), this
                }, e.prototype.appendStr = function (t) {
                    var r, n, i = this._buffer8, o = this._buffer32, s = this._bufferLength;
                    for (n = 0; n < t.length; n += 1) {
                        if ((r = t.charCodeAt(n)) < 128) i[s++] = r; else if (r < 2048) i[s++] = 192 + (r >>> 6), i[s++] = 63 & r | 128; else if (r < 55296 || r > 56319) i[s++] = 224 + (r >>> 12), i[s++] = r >>> 6 & 63 | 128, i[s++] = 63 & r | 128; else {
                            if ((r = 1024 * (r - 55296) + (t.charCodeAt(++n) - 56320) + 65536) > 1114111) throw new Error("Unicode standard supports code points up to U+10FFFF");
                            i[s++] = 240 + (r >>> 18), i[s++] = r >>> 12 & 63 | 128, i[s++] = r >>> 6 & 63 | 128, i[s++] = 63 & r | 128
                        }
                        s >= 64 && (this._dataLength += 64, e._md5cycle(this._state, o), s -= 64, o[0] = o[16])
                    }
                    return this._bufferLength = s, this
                }, e.prototype.appendAsciiStr = function (t) {
                    for (var r, n = this._buffer8, i = this._buffer32, o = this._bufferLength, s = 0; ;) {
                        for (r = Math.min(t.length - s, 64 - o); r--;) n[o++] = t.charCodeAt(s++);
                        if (o < 64) break;
                        this._dataLength += 64, e._md5cycle(this._state, i), o = 0
                    }
                    return this._bufferLength = o, this
                }, e.prototype.appendByteArray = function (t) {
                    for (var r, n = this._buffer8, i = this._buffer32, o = this._bufferLength, s = 0; ;) {
                        for (r = Math.min(t.length - s, 64 - o); r--;) n[o++] = t[s++];
                        if (o < 64) break;
                        this._dataLength += 64, e._md5cycle(this._state, i), o = 0
                    }
                    return this._bufferLength = o, this
                }, e.prototype.getState = function () {
                    var e = this._state;
                    return {
                        buffer: String.fromCharCode.apply(null, Array.from(this._buffer8)),
                        buflen: this._bufferLength,
                        length: this._dataLength,
                        state: [e[0], e[1], e[2], e[3]]
                    }
                }, e.prototype.setState = function (e) {
                    var t, r = e.buffer, n = e.state, i = this._state;
                    for (this._dataLength = e.length, this._bufferLength = e.buflen, i[0] = n[0], i[1] = n[1], i[2] = n[2], i[3] = n[3], t = 0; t < r.length; t += 1) this._buffer8[t] = r.charCodeAt(t)
                }, e.prototype.end = function (t) {
                    void 0 === t && (t = !1);
                    var r = this._bufferLength, n = this._buffer8, i = this._buffer32, o = 1 + (r >> 2);
                    this._dataLength += r;
                    var s = 8 * this._dataLength;
                    if (n[r] = 128, n[r + 1] = n[r + 2] = n[r + 3] = 0, i.set(e.buffer32Identity.subarray(o), o), r > 55 && (e._md5cycle(this._state, i), i.set(e.buffer32Identity)), s <= 4294967295) i[14] = s; else {
                        var a = s.toString(16).match(/(.*?)(.{0,8})$/);
                        if (null === a) return;
                        var c = parseInt(a[2], 16), u = parseInt(a[1], 16) || 0;
                        i[14] = c, i[15] = u
                    }
                    return e._md5cycle(this._state, i), t ? this._state : e._hex(this._state)
                }, e.stateIdentity = new Int32Array([1732584193, -271733879, -1732584194, 271733878]), e.buffer32Identity = new Int32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), e.hexChars = "0123456789abcdef", e.hexOut = [], e.onePassHasher = new e, e
            }(), JD = zD.Md5 = YD;
            if ("5d41402abc4b2a76b9719d911017c592" !== YD.hashStr("hello")) throw new Error("Md5 self test failed.");
            const XD = async (e, t, r) => await (async (e, t, r) => {
                const n = "" + t + r, i = new Uint8Array(JD.hashStr(n, !0).buffer).slice(0, 16), o = i.slice(0, 12),
                    s = await window.crypto.subtle.importKey("raw", i, "AES-GCM", !0, ["encrypt"]);
                return new Uint8Array(await window.crypto.subtle.encrypt({name: "AES-GCM", iv: o}, s, e))
            })(e.buffer, t, r);

            function QD(e, t) {
                var r = Object.keys(e);
                if (Object.getOwnPropertySymbols) {
                    var n = Object.getOwnPropertySymbols(e);
                    t && (n = n.filter(function (t) {
                        return Object.getOwnPropertyDescriptor(e, t).enumerable
                    })), r.push.apply(r, n)
                }
                return r
            }

            const $D = new Map([["moderation", 1], ["supervise", 2]]);

            class ZD extends Wf {
                get connectionState() {
                    return this._connectionState
                }

                set connectionState(e) {
                    if (this._connectionState === e) return;
                    const t = this._connectionState;
                    this._connectionState = e, this.emit(eg.CONNECTION_STATE_CHANGE, t, e)
                }

                get inspectType() {
                    return this._inspectType
                }

                set inspectType(e) {
                    var t;
                    this._inspectMode = Kr(t = e.map(e => $D.get(e) || 0)).call(t, (e, t) => e + t), this._inspectType = e
                }

                get quality() {
                    return this._quality
                }

                set quality(e) {
                    this._quality = e > 1 ? 1 : e < .1 ? .1 : e, this.qualityTimer && (window.clearTimeout(this.qualityTimer), this.qualityTimer = null), this._quality >= 1 || (this.qualityTimer = window.setTimeout(() => {
                        this.quality = this._quality / this.qualityRatio
                    }, 6e4))
                }

                constructor(e) {
                    super(), Kh(this, "name", "AgoraRTCVideoContentInspect"), Kh(this, "_connectionState", $v.CONNECTING), Kh(this, "_innerConnectionState", void 0), Kh(this, "sequence", 0), Kh(this, "inspectStartTime", void 0), Kh(this, "workerManagerConnection", void 0), Kh(this, "workerConnection", void 0), Kh(this, "workerMessageLengthLimit", void 0), Kh(this, "inspectIntervalMinimum", void 0), Kh(this, "qualityRatio", void 0), Kh(this, "_connectInfo", void 0), Kh(this, "_cancelTokenSource", Bf.CancelToken.source()), Kh(this, "_retryConfig", void 0), Kh(this, "wmSequence", 0), Kh(this, "inspectInterval", void 0), Kh(this, "inspectTimer", null), Kh(this, "ossFilePrefix", void 0), Kh(this, "extraInfo", void 0), Kh(this, "_inspectType", void 0), Kh(this, "_inspectMode", void 0), Kh(this, "_quality", 1), Kh(this, "qualityTimer", null), Kh(this, "_inspectId", void 0), Kh(this, "_needWorkUrlOnly", !1), Kh(this, "inspectImage", () => {
                        if (this.connectionState !== $v.CONNECTED) throw new Hf(qf.OPERATION_ABORTED, "content inspect service connection status is ".concat(this.connectionState));
                        this.inspectTimer && (window.clearInterval(this.inspectTimer), this.inspectTimer = null), this.inspectTimer = window.setInterval(() => {
                            this.connectionState === $v.CONNECTED ? this.requestToInspectImage() : em.debug("[".concat(this._inspectId, "] Inspect State is not connected , "), this.connectionState)
                        }, this.inspectInterval < this.inspectIntervalMinimum ? this.inspectIntervalMinimum : this.inspectInterval), this.requestToInspectImage()
                    }), this._inspectId = YS(5, "inspect-"), this.workerMessageLengthLimit = fm("VIDEO_INSPECT_WORKER_MESSAGE_LENGTH_LIMIT"), this.inspectIntervalMinimum = fm("VIDEO_INSPECT_INTERVAL_MINIMUM"), this.qualityRatio = fm("VIDEO_INSPECT_QUALITY_RATIO"), this.inspectInterval = e.interval, this.ossFilePrefix = e.ossFilePrefix, this.extraInfo = e.extraInfo, this.inspectType = e.inspectType, this.inspectStartTime = Number(Date.now()), this.workerManagerConnection = new lw("worker-manager-" + this._inspectId, Kf), this.on(eg.STATE_CHANGE, (e, t) => {
                        this._innerConnectionState = e, em.debug("[".concat(this._inspectId, "] Inspect operation :").concat(Zv[e], " ").concat(t || ""))
                    }), this.handleWorkerManagerEvents(), this.workerConnection = new lw("worker-" + this._inspectId, Kf), this.handleWorkerEvents()
                }

                async init(e, t) {
                    this.emit(eg.STATE_CHANGE, Zv.CONNECT_AP), this._connectInfo = e;
                    const r = this._cancelTokenSource.token;
                    return this._retryConfig = t, new sl((n, i) => {
                        this.on(eg.CONNECTION_STATE_CHANGE, (e, t) => {
                            t === $v.CONNECTED && n()
                        }), this.requestAP(e, r, t).then(e => {
                            this.connectWorkerManager(e)
                        }).catch(e => {
                            i(e)
                        })
                    })
                }

                async requestAP(e, t, r) {
                    const n = fm("WEBCS_DOMAIN").map(e => "https://".concat(e, "/api/v1")),
                        i = await function (e, t, r, n) {
                            let {appId: i, areaCode: o, cname: s, sid: a, token: c, uid: u} = t;
                            Uw++;
                            const d = "image_moderation_api", l = {
                                service_name: d,
                                json_body: JSON.stringify({
                                    appId: i,
                                    areaCode: o,
                                    cname: s,
                                    command: "allocateEdge",
                                    requestId: Uw,
                                    seq: Uw,
                                    sid: a,
                                    token: c,
                                    ts: Date.now(),
                                    uid: u + ""
                                })
                            };
                            let h, p, f = e[0];
                            return Yf(async () => {
                                h = Date.now();
                                const e = await NE(f, {
                                    data: l,
                                    cancelToken: r,
                                    headers: {"X-Packet-Service-Type": "0", "X-Packet-URI": "61"},
                                    params: {action: "wrtc_gateway"}
                                });
                                if (p = Date.now() - h, 0 !== e.code) {
                                    const t = new Hf(qf.UNEXPECTED_RESPONSE, "image inspect ap error, code" + e.code, {
                                        retry: !0,
                                        responseTime: p
                                    });
                                    throw em.error(t.toString()), t
                                }
                                const t = JSON.parse(e.json_body);
                                if (200 !== t.code) {
                                    const e = new Hf(qf.UNEXPECTED_RESPONSE, "image inspect ap error, code: ".concat(t.code, ", reason: ").concat(t.reason), {
                                        code: t.code,
                                        responseTime: p
                                    });
                                    throw em.error(e.toString()), e
                                }
                                if (!t.servers || !Array.isArray(t.servers) || 0 === t.servers.length) {
                                    const e = new Hf(qf.UNEXPECTED_RESPONSE, "image inspect ap empty server", {
                                        code: t.code,
                                        responseTime: p
                                    });
                                    throw em.error(e.toString()), e
                                }
                                const n = fm("VIDEO_INSPECT_WORKER_MANAGER_HOST"),
                                    i = fm("VIDEO_INSPECT_WORKER_MANAGER_PORT");
                                return {
                                    addressList: t.servers.map(e => {
                                        let {address: t, wss: r} = e;
                                        if (t && r) return "wss://".concat(t.replace(/\./g, "-"), ".").concat(n, ":").concat(i || r)
                                    }).filter(e => !!e), workerToken: t.workerToken, vid: t.vid, responseTime: p
                                }
                            }, (t, r) => (WE.apworkerEvent(a, {
                                success: !0,
                                sc: 200,
                                serviceName: d,
                                responseDetail: JSON.stringify(t.addressList),
                                firstSuccess: 0 === r,
                                responseTime: p,
                                serverIp: e[r % e.length]
                            }), !1), (t, r) => (WE.apworkerEvent(a, {
                                success: !1,
                                sc: t.data && t.data.code || 200,
                                serviceName: d,
                                responseTime: p,
                                serverIp: e[r % e.length]
                            }), !!(t.code !== qf.OPERATION_ABORTED && t.code !== qf.UNEXPECTED_RESPONSE || t.data && t.data.retry) && (f = e[(r + 1) % e.length], !0)), n)
                        }(n, e, t, r);
                    this.emit(eg.STATE_CHANGE, Zv.AP_CONNECTED);
                    const {addressList: o} = i;
                    return this.wmSequence++, o
                }

                async connectWorkerManager(e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                    this._needWorkUrlOnly = t, this.emit(eg.STATE_CHANGE, Zv.CONNECT_WORKER_MANAGER), await this.workerManagerConnection.init(e, 1e4)
                }

                async connectWorker(e) {
                    await this.workerConnection.init([e])
                }

                handleWorkerManagerEvents() {
                    this.workerManagerConnection.on(lv.CONNECTED, async () => {
                        this.emit(eg.STATE_CHANGE, Zv.WORKER_MANAGER_CONNECTED, this.workerManagerConnection.url), this.workerManagerConnection.sendMessage({
                            appId: this._connectInfo.appId,
                            cname: this._connectInfo.cname,
                            uid: this._connectInfo.uid + "",
                            sdkVersion: "4.16.0",
                            sid: this._connectInfo.sid,
                            seq: this.wmSequence,
                            ts: Number(Date.now()),
                            requestId: Math.floor(1e12 * Math.random()),
                            allocate: !0,
                            clientRequest: {command: "join"}
                        }, !0)
                    }), this.workerManagerConnection.on(lv.CLOSED, () => {
                        this._innerConnectionState < Zv.GET_WORKER_MANAGER_RESPONSE && em.debug("[".concat(this._inspectId, "] Inspect worker manager is closed before connecting worker"))
                    }), this.workerManagerConnection.on(lv.FAILED, () => {
                        this._innerConnectionState < Zv.GET_WORKER_MANAGER_RESPONSE && em.debug("[".concat(this._inspectId, "] Connecting inspect worker manager is failed before connecting worker"))
                    }), this.workerManagerConnection.on(lv.RECONNECTING, () => {
                        this._innerConnectionState < Zv.GET_WORKER_MANAGER_RESPONSE && em.debug("[".concat(this._inspectId, "] Inspect worker manager is reconnecting before connecting worker"))
                    }), this.workerManagerConnection.on(lv.ON_MESSAGE, async e => {
                        this.emit(eg.STATE_CHANGE, Zv.GET_WORKER_MANAGER_RESPONSE);
                        const t = this.workerManagerConnection.url;
                        this.workerManagerConnection.close();
                        const r = JSON.parse(e.data);
                        if (200 !== r.code) throw em.error("[".concat(this._inspectId, "] Unexpected code ").concat(r.code, " from worker manager")), new Hf(qf.UNEXPECTED_RESPONSE, "response code of worker is unexpected", r);
                        if (!(r.serverResponse && r.serverResponse.portWss && t)) throw em.error("[".concat(this._inspectId, "] Unexpected content from worker manager : ").concat(JSON.stringify(r))), new Hf(qf.UNEXPECTED_RESPONSE, "response content of worker is unexpected", r);
                        {
                            const e = fm("VIDEO_INSPECT_WORKER_PORT") || r.serverResponse.portWss,
                                n = t.replace(/:\d+\/?$/, ":".concat(e));
                            this.emit(eg.STATE_CHANGE, Zv.CONNECT_WORKER, n), this._needWorkUrlOnly ? this.emit(eg.REQUEST_NEW_WORKER_URL, n) : await this.connectWorker(n)
                        }
                    }), this.workerManagerConnection.on(lv.WILL_RECONNECT, (e, t) => {
                        t(e)
                    }), this.workerManagerConnection.on(lv.REQUEST_NEW_URLS, (e, t) => {
                        this.requestAP(this._connectInfo, this._cancelTokenSource.token, this._retryConfig).then(e).catch(t)
                    })
                }

                handleWorkerEvents() {
                    this.workerConnection.on(lv.CONNECTED, async () => {
                        this.emit(eg.STATE_CHANGE, Zv.WORKER_CONNECTED, this.workerConnection.url), this.connectionState = $v.CONNECTED
                    }), this.workerConnection.on(lv.ON_MESSAGE, async e => {
                        if (e.data instanceof ArrayBuffer) {
                            const r = function (e) {
                                return function (e) {
                                    let t = {};
                                    e:for (; !LD(e);) {
                                        let r = qD(e);
                                        switch (r >>> 3) {
                                            case 0:
                                                break e;
                                            case 1:
                                                t.code = qD(e);
                                                break;
                                            case 2:
                                                t.msg = UD(e, qD(e));
                                                break;
                                            case 3: {
                                                let r = RD(e);
                                                t.data = bD(e), e.limit = r;
                                                break
                                            }
                                            default:
                                                ID(e, 7 & r)
                                        }
                                    }
                                    return t
                                }({bytes: t = e, offset: 0, limit: t.length});
                                var t
                            }(new Uint8Array(e.data));
                            if (fm("SHOW_VIDEO_INSPECT_WORKER_MESSAGE") && em.debug("[".concat(this._inspectId, "] Response message for worker of inspect content "), JSON.stringify(r)), 200 === r.code) {
                                if (Array.isArray(this.inspectType) && 1 === this.inspectType.length && "supervise" === this.inspectType[0]) return void this.emit(eg.INSPECT_RESULT, void 0, void 0);
                                if (r.data && r.data.scorePorn && r.data.scoreSexy && r.data.scoreNeutral) {
                                    var t;
                                    const e = {
                                            porn: r.data.scorePorn,
                                            sexy: r.data.scoreSexy,
                                            neutral: r.data.scoreNeutral
                                        }, n = Kr(t = Object.keys(e)).call(t, (t, r) => e[t] > e[r] ? t : r, "porn"),
                                        i = Object.keys(e).find(e => e === n);
                                    this.emit(eg.INSPECT_RESULT, i)
                                } else this.emit(eg.INSPECT_RESULT, void 0, new Hf(qf.UNEXPECTED_RESPONSE, r.code + "", "There is an unexpected data on message"))
                            } else this.emit(eg.INSPECT_RESULT, void 0, new Hf(qf.UNEXPECTED_RESPONSE, r.code + "", r.msg))
                        } else em.error("[".concat(this._inspectId, "] Unexpected message type from worker")), this.emit(eg.INSPECT_RESULT, void 0, new Hf(qf.UNEXPECTED_RESPONSE, "invalid worker message type"))
                    }), this.workerConnection.on(lv.CLOSED, () => {
                        this.connectionState = $v.CLOSED
                    }), this.workerConnection.on(lv.FAILED, () => {
                        this.connectionState = $v.CLOSED
                    }), this.workerConnection.on(lv.RECONNECTING, () => {
                        this.connectionState = this.connectionState === $v.CONNECTED ? $v.RECONNECTING : $v.CONNECTING
                    }), this.workerConnection.on(lv.WILL_RECONNECT, (e, t) => {
                        "recover" === e && t(e), t("tryNext")
                    }), this.workerConnection.on(lv.REQUEST_NEW_URLS, (e, t) => {
                        this.workerManagerConnection.close(), this.once(eg.REQUEST_NEW_WORKER_URL, t => {
                            e([t])
                        }), this.requestAP(this._connectInfo, this._cancelTokenSource.token, this._retryConfig).then(e => {
                            this.connectWorkerManager(e, !0)
                        }).catch(e => {
                            t(e)
                        })
                    })
                }

                static intToLong(e) {
                    return {low: e |= 0, high: e >> 31, unsigned: e >= 0}
                }

                async requestToInspectImage() {
                    this.sequence++;
                    const e = tb(this, eg.CLIENT_LOCAL_VIDEO_TRACK), t = {
                        appId: this._connectInfo.appId,
                        cname: this._connectInfo.cname,
                        cid: this._connectInfo.cid,
                        sid: this._connectInfo.sid,
                        uid: this._connectInfo.uid,
                        vid: this._connectInfo.vid
                    };
                    if (e) {
                        if (!e.isPlaying) return void this.emit(eg.INSPECT_RESULT, void 0, new Hf(qf.INVALID_OPERATION, "Only the track being played can be inspected"));
                        const r = await this.generateRequestData(e, t);
                        this.workerConnection.sendMessage(r, !0, !0)
                    } else this.emit(eg.INSPECT_RESULT, void 0, new Hf(qf.INVALID_OPERATION, "Only the track being published can be inspected"))
                }

                async generateRequestData(e, t) {
                    let {appId: r, cname: n, cid: i, vid: o, sid: s, uid: a} = t;
                    const c = Date.now(), u = await e.getCurrentFrameImage("image/jpeg", this.quality),
                        d = await XD(u, r, n), l = this.sequence + "-" + i + "-" + a + "-" + c + "-" + YS(12, ""), h = {
                            appId: r,
                            cid: i,
                            cname: n,
                            deviceId: "",
                            elapse: ZD.intToLong(Number(c - this.inspectStartTime)),
                            fileSize: d.byteLength,
                            jpgEncryption: 2,
                            height: u.height,
                            width: u.width,
                            jpg: d,
                            networkType: 6,
                            osType: 7,
                            requestId: l,
                            sdkVersion: "4.16.0",
                            sequence: this.sequence,
                            sid: s,
                            timestamp: ZD.intToLong(c),
                            uid: a,
                            vid: o,
                            service: this._inspectMode,
                            callbackData: this.extraInfo,
                            ossFilePrefix: this.ossFilePrefix
                        };
                    void 0 === this.extraInfo && delete h.callbackData, void 0 === this.ossFilePrefix && delete h.ossFilePrefix;
                    const p = function (e) {
                        let t = PD();
                        return function (e, t) {
                            let r = e.appId;
                            void 0 !== r && (HD(t, 10), jD(t, r));
                            let n = e.cid;
                            void 0 !== n && (HD(t, 16), HD(t, n));
                            let i = e.cname;
                            void 0 !== i && (HD(t, 26), jD(t, i));
                            let o = e.deviceId;
                            void 0 !== o && (HD(t, 34), jD(t, o));
                            let s = e.elapse;
                            void 0 !== s && (HD(t, 40), KD(t, s));
                            let a = e.fileSize;
                            void 0 !== a && (HD(t, 48), KD(t, OD(a)));
                            let c = e.height;
                            void 0 !== c && (HD(t, 56), KD(t, OD(c)));
                            let u = e.jpg;
                            void 0 !== u && (HD(t, 66), HD(t, u.length), function (e, t) {
                                let r = xD(e, t.length);
                                e.bytes.set(t, r)
                            }(t, u));
                            let d = e.networkType;
                            void 0 !== d && (HD(t, 72), KD(t, OD(d)));
                            let l = e.osType;
                            void 0 !== l && (HD(t, 80), KD(t, OD(l)));
                            let h = e.requestId;
                            void 0 !== h && (HD(t, 90), jD(t, h));
                            let p = e.sdkVersion;
                            void 0 !== p && (HD(t, 98), jD(t, p));
                            let f = e.sequence;
                            void 0 !== f && (HD(t, 104), KD(t, OD(f)));
                            let m = e.sid;
                            void 0 !== m && (HD(t, 114), jD(t, m));
                            let _ = e.timestamp;
                            void 0 !== _ && (HD(t, 120), KD(t, _));
                            let v = e.uid;
                            void 0 !== v && (HD(t, 128), HD(t, v));
                            let g = e.vid;
                            void 0 !== g && (HD(t, 136), HD(t, g));
                            let E = e.width;
                            void 0 !== E && (HD(t, 144), KD(t, OD(E)));
                            let y = e.service;
                            void 0 !== y && (HD(t, 152), HD(t, y));
                            let S = e.callbackData;
                            void 0 !== S && (HD(t, 162), jD(t, S));
                            let b = e.jpgEncryption;
                            void 0 !== b && (HD(t, 168), HD(t, b));
                            let T = e.requestType;
                            void 0 !== T && (HD(t, 176), HD(t, T));
                            let R = e.scorePorn;
                            void 0 !== R && (HD(t, 185), GD(t, R));
                            let I = e.scoreSexy;
                            void 0 !== I && (HD(t, 193), GD(t, I));
                            let w = e.scoreNeutral;
                            void 0 !== w && (HD(t, 201), GD(t, w));
                            let C = e.scene;
                            void 0 !== C && (HD(t, 208), HD(t, C));
                            let A = e.ossFilePrefix;
                            void 0 !== A && (HD(t, 218), jD(t, A));
                            let O = e.serviceVendor;
                            if (void 0 !== O) for (let e of O) {
                                HD(t, 226);
                                let r = PD();
                                TD(e, r), HD(t, r.limit), VD(t, r), DD(r)
                            }
                        }(e, t), function (e) {
                            let t = e.bytes, r = e.limit;
                            return t.length === r ? t : t.subarray(0, r)
                        }(t)
                    }(h);
                    if (p.byteLength < this.workerMessageLengthLimit) {
                        if (fm("SHOW_VIDEO_INSPECT_WORKER_MESSAGE")) {
                            const e = function (e) {
                                for (var t = 1; t < arguments.length; t++) {
                                    var r = null != arguments[t] ? arguments[t] : {};
                                    t % 2 ? QD(Object(r), !0).forEach(function (t) {
                                        Kh(e, t, r[t])
                                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : QD(Object(r)).forEach(function (t) {
                                        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t))
                                    })
                                }
                                return e
                            }({}, h);
                            delete e.jpg, em.debug("[".concat(this._inspectId, "] Request message for worker of inspect content "), JSON.stringify(e))
                        }
                        return p
                    }
                    {
                        const t = this.quality * this.qualityRatio;
                        return this.quality = t, await this.generateRequestData(e, {
                            appId: r,
                            cname: n,
                            cid: i,
                            vid: o,
                            sid: s,
                            uid: a
                        })
                    }
                }

                close() {
                    this._cancelTokenSource.cancel(), this._cancelTokenSource = Bf.CancelToken.source(), this.workerManagerConnection && this.workerManagerConnection.close(), this.workerConnection && this.workerConnection.close(), this.inspectTimer && window.clearInterval(this.inspectTimer), this.inspectTimer = null, this.connectionState = $v.CLOSED, this.emit(eg.STATE_CHANGE, Zv.CLOSED)
                }
            }

            var ek, tk, rk, nk, ik, ok, sk, ak, ck, uk, dk, lk, hk, pk, fk, mk, _k, vk, gk, Ek, yk, Sk, bk, Tk, Rk, Ik,
                wk, Ck, Ak, Ok, Nk, Pk, Dk, kk, Lk, xk, Mk, Uk, jk;

            function Vk(e, t) {
                var r = Object.keys(e);
                if (Object.getOwnPropertySymbols) {
                    var n = Object.getOwnPropertySymbols(e);
                    t && (n = n.filter(function (t) {
                        return Object.getOwnPropertyDescriptor(e, t).enumerable
                    })), r.push.apply(r, n)
                }
                return r
            }

            function Fk(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var r = null != arguments[t] ? arguments[t] : {};
                    t % 2 ? Vk(Object(r), !0).forEach(function (t) {
                        Kh(e, t, r[t])
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : Vk(Object(r)).forEach(function (t) {
                        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t))
                    })
                }
                return e
            }

            let Bk = (ek = BE(), tk = BE({argsMap: (e, t) => (Array.isArray(t) || (t = [t]), t.map(e => e ? Object(e).toString() : "null"))}), rk = BE({argsMap: (e, t) => (t || (t = []), Array.isArray(t) || (t = [t]), t.map(e => e.getTrackId()))}), nk = BE({argsMap: (e, t, r) => [t.uid, r]}), ik = BE({
                argsMap: (e, t) => t.map(e => {
                    let {user: t, mediaType: r} = e;
                    return [null == t ? void 0 : t.uid, r]
                })
            }), ok = BE({argsMap: (e, t, r) => [t.uid, r]}), sk = BE({
                argsMap: (e, t) => t.map(e => {
                    let {user: t, mediaType: r} = e;
                    return {uid: null == t ? void 0 : t.uid, mediaType: r}
                })
            }), ak = BE(), ck = BE(), uk = BE(), dk = BE(), lk = BE(), hk = BE(), pk = BE(), fk = BE(), mk = BE(), _k = BE(), vk = BE(), gk = BE(), Ek = BE(), yk = BE(), Sk = BE({argsMap: (e, t) => [t]}), bk = BE(), Tk = BE(), Rk = BE(), Ik = BE(), wk = BE(), Ck = BE(), Ak = BE(), Ok = BE(), Nk = BE(), Pk = BE(), Dk = BE({argsMap: (e, t) => (Array.isArray(t) || (t = [t]), [JSON.stringify(t)])}), kk = BE(), Lk = BE(), xk = BE(), Mk = BE({reportResult: !0}), Uk = BE(), vE((jk = class extends Wf {
                get connectionState() {
                    return this._gateway.state
                }

                get remoteUsers() {
                    return this._users
                }

                get localTracks() {
                    return this._p2pChannel.getAllTracks(!0)
                }

                get uid() {
                    return this._uid
                }

                get channelName() {
                    return this._channelName
                }

                get isStringUID() {
                    return !!this._joinInfo && !!this._joinInfo.stringUid
                }

                get __className__() {
                    return "Client"
                }

                constructor(e) {
                    let t;
                    if (super(), Kh(this, "store", void 0), Kh(this, "_uid", void 0), Kh(this, "_channelName", void 0), Kh(this, "_uintUid", void 0), Kh(this, "_users", []), Kh(this, "_codec", void 0), Kh(this, "_mode", void 0), Kh(this, "_config", void 0), Kh(this, "_clientId", void 0), Kh(this, "_appId", void 0), Kh(this, "_sessionId", null), Kh(this, "_key", void 0), Kh(this, "_joinInfo", void 0), Kh(this, "_gateway", void 0), Kh(this, "_statsCollector", void 0), Kh(this, "_configDistribute", void 0), Kh(this, "_leaveMutex", new KE("client-leave")), Kh(this, "_publishMutex", new KE("client-publish")), Kh(this, "_renewTokenMutex", new KE("client-renewtoken")), Kh(this, "_subscribeMutex", new KE("client-subscribe")), Kh(this, "_encryptionMode", "none"), Kh(this, "_encryptionSecret", null), Kh(this, "_encryptionSalt", null), Kh(this, "_proxyServer", void 0), Kh(this, "_turnServer", {
                        servers: [],
                        mode: "auto"
                    }), Kh(this, "_cloudProxyServerMode", "disabled"), Kh(this, "_isDualStreamEnabled", !1), Kh(this, "_defaultStreamFallbackType", void 0), Kh(this, "_lowStreamParameter", void 0), Kh(this, "_streamFallbackTypeCacheMap", new Map), Kh(this, "_remoteStreamTypeCacheMap", new Map), Kh(this, "_axiosCancelSource", Bf.CancelToken.source()), Kh(this, "_audioVolumeIndicationInterval", void 0), Kh(this, "_networkQualityInterval", void 0), Kh(this, "_userOfflineTimeout", void 0), Kh(this, "_streamRemovedTimeout", void 0), Kh(this, "_injectStreamingClient", void 0), Kh(this, "_liveTranscodeStreamingClient", void 0), Kh(this, "_liveRawStreamingClient", void 0), Kh(this, "_channelMediaRelayClient", void 0), Kh(this, "_networkQualitySensitivity", "normal"), Kh(this, "_p2pChannel", void 0), Kh(this, "_useLocalAccessPoint", !1), Kh(this, "_setLocalAPVersion", void 0), Kh(this, "_joinAndNotLeaveYet", !1), Kh(this, "_numberOfJoinCount", 0), Kh(this, "_remoteDefaultVideoStreamType", void 0), Kh(this, "_inspect", void 0), Kh(this, "_license", void 0), Kh(this, "_handleLocalTrackEnable", (e, t, r) => {
                        this.publish(e, !1).then(t).catch(r)
                    }), Kh(this, "_handleLocalTrackDisable", (e, t, r) => {
                        this.unpublish(e).then(t).catch(r)
                    }), Kh(this, "_handleUserOnline", e => {
                        this.isStringUID && "string" != typeof e.uid && em.error("[".concat(this._clientId, "] StringUID is Mixed with UintUID"));
                        const t = this._users.find(t => t.uid === e.uid);
                        if (t) t._trust_in_room_ = !0; else {
                            const t = new gA(e.uid, e.uint_id || e.uid);
                            this._users.push(t), em.debug("[".concat(this._clientId, "] user online"), e.uid), this.emit(z_.USER_JOINED, t)
                        }
                    }), Kh(this, "_handleUserOffline", e => {
                        const t = this._users.find(t => t.uid === e.uid);
                        t && (this._handleRemoveStream(e), nb(this._users, t), this._remoteStreamTypeCacheMap.delete(t.uid), this._streamFallbackTypeCacheMap.delete(t.uid), em.debug("[".concat(this._clientId, "] user offline"), e.uid, "reason:", e.reason), this.emit(z_.USER_LEAVED, t, e.reason))
                    }), Kh(this, "_handleAddAudioOrVideoStream", (e, t, r, n, i, o, s) => {
                        const a = this._users.find(e => e.uid === t);
                        if (!a) return void em.error("[".concat(this._clientId, "] can not find target user!(on_add_stream)"));
                        em.debug("[".concat(this._clientId, "] stream added with uid ").concat(t, ", type ").concat(e)), this.store.subscribe(a.uid, e, void 0, void 0, void 0, Date.now());
                        const c = "audio" === e ? a.hasAudio : a.hasVideo;
                        a._uintid || (a._uintid = i || t), "audio" === e ? a._trust_audio_stream_added_state_ = !0 : a._trust_video_stream_added_state_ = !0, "audio" === e ? (a._audio_added_ = !0, void 0 !== r && (a._audioSSRC = r), void 0 !== n && (a._cname = n), o && (a._audioOrtc = o)) : (a._video_added_ = !0, void 0 !== r && (a._videoSSRC = r), void 0 !== n && (a._cname = n), void 0 !== s && (a._rtxSsrcId = s), o && (a._videoOrtc = o)), ("audio" === e ? a.hasAudio : a.hasVideo) && !c && (em.info("[".concat(this._clientId, "] remote user ").concat(a.uid, " published ").concat(e)), this.emit(z_.USER_PUBLISHED, a, e)), "video" === e ? WE.onGatewayStream(this._sessionId, D_.ON_ADD_VIDEO_STREAM, k_.ON_ADD_VIDEO_STREAM, {peer: i || t}) : WE.onGatewayStream(this._sessionId, D_.ON_ADD_AUDIO_STREAM, k_.ON_ADD_AUDIO_STREAM, {peer: i || t}), this._p2pChannel.remoteMediaSsrcChanged(a, e, r).then(t => {
                            if (t) return em.debug("[".concat(this._clientId, "] resubscribe ").concat(e, " for user ").concat(a.uid, " after rejoin because SSRC id changed.")), this._p2pChannel.unsubscribe(a, e, !0).then(() => this._subscribe(a, e, !0).catch(e => {
                                em.error("[".concat(this._clientId, "] resubscribe error"), e.toString())
                            }))
                        }), this._p2pChannel.hasPendingRemoteMedia(a, e) && (em.debug("[".concat(this._clientId, "] resubscribe ").concat(e, " for user ").concat(a.uid, " after reconnect.")), this._subscribe(a, e, !0).catch(e => {
                            em.error("[".concat(this._clientId, "] resubscribe error"), e.toString())
                        }))
                    }), Kh(this, "_handleRemoveStream", e => {
                        const t = this._users.find(t => t.uid === e.uid);
                        if (!t) return void em.warning("[".concat(this._clientId, "] can not find target user!(on_remove_stream)"));
                        em.debug("[".concat(this._clientId, "] stream removed with uid ").concat(e.uid));
                        let r = () => {
                        };
                        t.hasAudio && t.hasVideo ? r = (() => {
                            em.info("[".concat(this._clientId, "] remote user ").concat(t.uid, " unpublished audio track")), this.emit(z_.USER_UNPUBLISHED, t, "audio"), em.info("[".concat(this._clientId, "] remote user ").concat(t.uid, " unpublished video track")), this.emit(z_.USER_UNPUBLISHED, t, "video")
                        }) : t.hasVideo ? r = (() => {
                            em.info("[".concat(this._clientId, "] remote user ").concat(t.uid, " unpublished video track")), this.emit(z_.USER_UNPUBLISHED, t, "video")
                        }) : t.hasAudio && (r = (() => {
                            em.info("[".concat(this._clientId, "] remote user ").concat(t.uid, " unpublished audio track")), this.emit(z_.USER_UNPUBLISHED, t, "audio")
                        })), t._trust_audio_stream_added_state_ = !0, t._trust_video_stream_added_state_ = !0, t._audio_added_ = !1, t._video_added_ = !1, this._p2pChannel.unsubscribe(t).then(e => {
                            if (e) return this._gateway.unsubscribe(e, t.uid)
                        }), t._audioSSRC = void 0, t._videoSSRC = void 0, t._audioOrtc = void 0, t._videoOrtc = void 0, t._rtxSsrcId = void 0, WE.onGatewayStream(this._sessionId, D_.ON_REMOVE_STREAM, k_.ON_REMOVE_STREAM, {peer: e.uint_id || e.uid}), r()
                    }), Kh(this, "_handleSetStreamLocalEnable", (e, t, r) => {
                        const n = this._users.find(e => e.uid === t);
                        if (!n) return void em.error("[".concat(this._clientId, "] can not find target user!(disable_local)"));
                        em.debug("[".concat(this._clientId, "] local ").concat(e, " ").concat(r ? "enabled" : "disabled", " with uid ").concat(t));
                        const i = "audio" === e ? n.hasAudio : n.hasVideo;
                        if ("audio" === e) {
                            n._trust_audio_enabled_state_ = !0;
                            const e = n._audio_enabled_;
                            if (n._audio_enabled_ = r, n._audio_enabled_ === e) return;
                            {
                                const e = n._audio_enabled_ ? "enable-local-audio" : "disable-local-audio";
                                em.debug("[".concat(this._clientId, "] user-info-updated, uid: ").concat(t, ", msg: ").concat(e)), this.emit(z_.USER_INFO_UPDATED, t, e)
                            }
                        } else {
                            n._trust_video_enabled_state_ = !0;
                            const e = n._video_enabled_;
                            if (n._video_enabled_ = r, n._video_enabled_ === e) return;
                            {
                                const e = n._video_enabled_ ? "enable-local-video" : "disable-local-video";
                                em.debug("[".concat(this._clientId, "] user-info-update, uid: ").concat(t, ", msg: ").concat(e)), this.emit(z_.USER_INFO_UPDATED, t, e)
                            }
                        }
                        const o = "audio" === e ? n.hasAudio : n.hasVideo;
                        return i !== o ? !i && o ? (em.info("[".concat(this._clientId, "] remote user ").concat(t, " published ").concat(e)), void this.emit(z_.USER_PUBLISHED, n, e)) : ("video" === e && n._videoTrack && n._videoTrack._destroy(), "audio" === e && n._audioTrack, this._p2pChannel.muteRemote(n, e), em.info("[".concat(this._clientId, "] remote user ").concat(t, " unpublished ").concat(e)), void this.emit(z_.USER_UNPUBLISHED, n, e)) : void 0
                    }), Kh(this, "_handleMuteStream", (e, t, r) => {
                        em.debug("[".concat(this._clientId, "] receive mute message"), e, t, r);
                        const n = this._users.find(t => t.uid === e);
                        if (!n) return void em.warning("[".concat(this._clientId, "] can not find remote user, ignore mute event, uid: ").concat(e));
                        const i = "audio" === t ? n.hasAudio : n.hasVideo;
                        if ("audio" === t) {
                            n._trust_audio_mute_state_ = !0;
                            const t = n._audio_muted_;
                            if (n._audio_muted_ = r, n._audio_muted_ === t) return;
                            {
                                const t = n._audio_muted_ ? "mute-audio" : "unmute-audio";
                                em.debug("[".concat(this._clientId, "] user-info-update, uid: ").concat(e, ", msg: ").concat(t)), this.emit(z_.USER_INFO_UPDATED, e, t)
                            }
                        } else {
                            n._trust_video_mute_state_ = !0;
                            const t = n._video_muted_;
                            if (n._video_muted_ = r, n._video_muted_ === t) return;
                            {
                                const t = n._video_muted_ ? "mute-video" : "unmute-video";
                                em.debug("[".concat(this._clientId, "] user-info-update, uid: ").concat(e, ", msg: ").concat(t)), this.emit(z_.USER_INFO_UPDATED, e, t)
                            }
                        }
                        const o = "audio" === t ? n.hasAudio : n.hasVideo;
                        if (i !== o) {
                            if (!i && o) return ("audio" === t ? n._audioSSRC : n._videoSSRC) ? (em.info("[".concat(this._clientId, "] remote user ").concat(e, " published ").concat(t)), void this.emit(z_.USER_PUBLISHED, n, t)) : void em.warning("[".concat(this._clientId, "] remote user ").concat(e, " receive ").concat(t, " unmute message  before add stream message, ").concat(t, " SSRC doesn't exist yet."));
                            "video" === t && n._videoTrack && n._videoTrack._destroy(), "audio" === t && n._audioTrack, this._p2pChannel.muteRemote(n, t), em.info("[".concat(this._clientId, "] remote user ").concat(e, " unpublished ").concat(t)), this.emit(z_.USER_UNPUBLISHED, n, t)
                        }
                    }), Kh(this, "_handleP2PLost", async e => {
                        em.debug("[".concat(this._clientId, "] receive p2p lost"), e), parseInt(e.p2pid, 10) === this.store.p2pId ? await this._p2pChannel.requestReconnect() : em.warning("P2PLost stream not found", e)
                    }), Kh(this, "_handleTokenWillExpire", () => {
                        em.debug("[".concat(this._clientId, "] received message onTokenPrivilegeWillExpire")), this.emit(z_.ON_TOKEN_PRIVILEGE_WILL_EXPIRE)
                    }), Kh(this, "_handleBeforeUnload", e => {
                        "beforeunload" === e.type && void 0 !== e.returnValue && "" !== e.returnValue || (this.leave(), em.info("[".concat(this._clientId, "] auto leave onbeforeunload or pagehide")))
                    }), Kh(this, "_handleUpdateNetworkQuality", () => {
                        if ("normal" === this._networkQualitySensitivity) return;
                        if (navigator && void 0 !== navigator.onLine && !navigator.onLine) return void this.emit(z_.NETWORK_QUALITY, {
                            downlinkNetworkQuality: 6,
                            uplinkNetworkQuality: 6
                        });
                        const e = {downlinkNetworkQuality: 0, uplinkNetworkQuality: 0};
                        e.uplinkNetworkQuality = this._p2pChannel.getUplinkNetworkQuality(), e.downlinkNetworkQuality = this._p2pChannel.getDownlinkNetworkQuality(), this.emit(z_.NETWORK_QUALITY, e)
                    }), this._codec = e.codec, this._mode = e.mode, this._clientId = YS(5, "client-"), this.store = new class {
                        constructor(e, t, r, n) {
                            Kh(this, "store", void 0), Kh(this, "reducer", void 0);
                            const i = {
                                codec: e,
                                audioCodec: t,
                                mode: r,
                                clientId: n,
                                sessionId: null,
                                p2pId: 0,
                                dcId: 0,
                                pubId: 0,
                                subId: 0,
                                avoidJoinStart: 0,
                                keyMetrics: {publish: [], subscribe: []},
                                joinChannelServiceRecords: [],
                                cloudProxyServerMode: "disabled"
                            };
                            this.reducer = function () {
                                let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : i,
                                    t = arguments.length > 1 ? arguments[1] : void 0;
                                switch (t.type) {
                                    case pD.SET_SESSION_ID:
                                        return ED(ED({}, e), {}, {sessionId: t.sessionId});
                                    case pD.SET_P2P_ID:
                                        return ED(ED({}, e), {}, {p2pId: t.p2pId});
                                    case pD.SET_UID:
                                        return ED(ED({}, e), {}, {uid: t.uid});
                                    case pD.SET_PUB_ID:
                                        return ED(ED({}, e), {}, {pubId: t.pubId});
                                    case pD.KEY_METRIC_CLIENT_CREATED:
                                        return ED(ED({}, e), {}, {keyMetrics: ED(ED({}, e.keyMetrics), {}, {clientCreated: t.metric})});
                                    case pD.KEY_METRIC_JOIN_START:
                                        return ED(ED({}, e), {}, {keyMetrics: ED(ED({}, e.keyMetrics), {}, {joinStart: t.metric})});
                                    case pD.AVOID_JOIN_START:
                                        return ED(ED({}, e), {}, {avoidJoinStart: t.avoidJoinStart});
                                    case pD.KEY_METRIC_JOIN_END:
                                        return ED(ED({}, e), {}, {keyMetrics: ED(ED({}, e.keyMetrics), {}, {joinEnd: t.metric})});
                                    case pD.KEY_METRIC_REQUEST_AP_START:
                                        return ED(ED({}, e), {}, {keyMetrics: ED(ED({}, e.keyMetrics), {}, {requestAPStart: t.metric})});
                                    case pD.KEY_METRIC_REQUEST_AP_END:
                                        return ED(ED({}, e), {}, {keyMetrics: ED(ED({}, e.keyMetrics), {}, {requestAPEnd: t.metric})});
                                    case pD.KEY_METRIC_JOIN_GATEWAY_START:
                                        return ED(ED({}, e), {}, {keyMetrics: ED(ED({}, e.keyMetrics), {}, {joinGatewayStart: t.metric})});
                                    case pD.KEY_METRIC_JOIN_GATEWAY_END:
                                        return ED(ED({}, e), {}, {keyMetrics: ED(ED({}, e.keyMetrics), {}, {joinGatewayEnd: t.metric})});
                                    case pD.KEY_METRIC_PEER_CONNECTION_START:
                                        return ED(ED({}, e), {}, {keyMetrics: ED(ED({}, e.keyMetrics), {}, {peerConnectionStart: t.metric})});
                                    case pD.KEY_METRIC_PEER_CONNECTION_END:
                                        return ED(ED({}, e), {}, {keyMetrics: ED(ED({}, e.keyMetrics), {}, {peerConnectionEnd: t.metric})});
                                    case pD.KEY_METRIC_SIGNAL_CHANNEL_OPEN:
                                        return ED(ED({}, e), {}, {keyMetrics: ED(ED({}, e.keyMetrics), {}, {signalChannelOpen: t.metric})});
                                    case pD.KEY_METRIC_ICE_CONNECTION_END:
                                        return ED(ED({}, e), {}, {keyMetrics: ED(ED({}, e.keyMetrics), {}, {iceConnectionEnd: t.metric})});
                                    case pD.KEY_METRIC_PUBLISH: {
                                        const r = e.keyMetrics.publish,
                                            n = r.findIndex(e => e.trackId === t.metric.trackId);
                                        return -1 !== n ? (r[n] = ED(ED({}, r[n]), t.metric), ED(ED({}, e), {}, {keyMetrics: ED(ED({}, e.keyMetrics), {}, {publish: [...r]})})) : ED(ED({}, e), {}, {keyMetrics: ED(ED({}, e.keyMetrics), {}, {publish: [...e.keyMetrics.publish, t.metric]})})
                                    }
                                    case pD.KEY_METRIC_SUBSCRIBE: {
                                        const r = e.keyMetrics.subscribe,
                                            n = r.findIndex(e => e.userId === t.metric.userId && e.type === t.metric.type);
                                        return -1 !== n ? (r[n] = ED(ED({}, r[n]), t.metric), ED(ED({}, e), {}, {keyMetrics: ED(ED({}, e.keyMetrics), {}, {subscribe: [...r]})})) : ED(ED({}, e), {}, {keyMetrics: ED(ED({}, e.keyMetrics), {}, {subscribe: [...e.keyMetrics.subscribe, t.metric]})})
                                    }
                                    case pD.SET_CLOUD_PROXY_SERVER_MODE:
                                        return e.cloudProxyServerMode = t.mode, e;
                                    case pD.RECORD_JOIN_CHANNEL_SERVICE:
                                        return "number" != typeof t.index ? e.joinChannelServiceRecords = [...e.joinChannelServiceRecords, t.record] : (e.joinChannelServiceRecords[t.index] = ED(ED({}, e.joinChannelServiceRecords[t.index]), t.record), e.joinChannelServiceRecords = [...e.joinChannelServiceRecords]), e;
                                    case pD.RESET_JOIN_CHANNEL_SERVICE_RECORDS:
                                        return e.joinChannelServiceRecords = [], e;
                                    case pD.RESET_KEY_METRICS:
                                        return e.keyMetrics = {publish: [], subscribe: []}, e;
                                    default:
                                        return e
                                }
                            }, this.store = vD(this.reducer)
                        }

                        set sessionId(e) {
                            this.store.dispatch({type: pD.SET_SESSION_ID, sessionId: e})
                        }

                        get sessionId() {
                            return this.store.getState().sessionId
                        }

                        get codec() {
                            return this.store.getState().codec
                        }

                        get audioCodec() {
                            return this.store.getState().audioCodec
                        }

                        get clientId() {
                            return this.store.getState().clientId
                        }

                        set p2pId(e) {
                            this.store.dispatch({type: pD.SET_P2P_ID, p2pId: e})
                        }

                        get p2pId() {
                            return this.store.getState().p2pId
                        }

                        set dcId(e) {
                            this.store.dispatch({type: pD.SET_DC_ID, dcId: e})
                        }

                        get dcId() {
                            return this.store.getState().dcId
                        }

                        set uid(e) {
                            this.store.dispatch({type: pD.SET_UID, uid: e})
                        }

                        get uid() {
                            return this.store.getState().uid
                        }

                        set pubId(e) {
                            this.store.dispatch({type: pD.SET_PUB_ID, pubId: e})
                        }

                        get pubId() {
                            return this.store.getState().pubId
                        }

                        set cloudProxyServerMode(e) {
                            this.store.dispatch({type: pD.SET_CLOUD_PROXY_SERVER_MODE, mode: e})
                        }

                        get cloudProxyServerMode() {
                            return this.store.getState().cloudProxyServerMode
                        }

                        clientCreated() {
                            this.store.dispatch({type: pD.KEY_METRIC_CLIENT_CREATED, metric: Date.now()})
                        }

                        joinStart() {
                            this.store.dispatch({type: pD.KEY_METRIC_JOIN_START, metric: Date.now()})
                        }

                        joinEnd() {
                            this.store.dispatch({type: pD.KEY_METRIC_JOIN_END, metric: Date.now()})
                        }

                        requestAPStart() {
                            this.store.dispatch({type: pD.KEY_METRIC_REQUEST_AP_START, metric: Date.now()})
                        }

                        requestAPEnd() {
                            this.store.dispatch({type: pD.KEY_METRIC_REQUEST_AP_END, metric: Date.now()})
                        }

                        joinGatewayStart() {
                            this.store.dispatch({type: pD.KEY_METRIC_JOIN_GATEWAY_START, metric: Date.now()})
                        }

                        joinGatewayEnd() {
                            this.store.dispatch({type: pD.KEY_METRIC_JOIN_GATEWAY_END, metric: Date.now()})
                        }

                        peerConnectionStart() {
                            this.store.dispatch({type: pD.KEY_METRIC_PEER_CONNECTION_START, metric: Date.now()})
                        }

                        peerConnectionEnd() {
                            this.store.dispatch({type: pD.KEY_METRIC_PEER_CONNECTION_END, metric: Date.now()})
                        }

                        signalChannelOpen() {
                            this.store.dispatch({type: pD.KEY_METRIC_SIGNAL_CHANNEL_OPEN, metric: Date.now()})
                        }

                        iceConnectionEnd() {
                            this.store.dispatch({type: pD.KEY_METRIC_ICE_CONNECTION_END, metric: Date.now()})
                        }

                        publish(e, t, r, n) {
                            this.store.dispatch({
                                type: pD.KEY_METRIC_PUBLISH,
                                metric: ED(ED({trackId: e, type: t}, r && {publishStart: r}), n && {publishEnd: n})
                            })
                        }

                        subscribe(e, t, r, n, i, o, s) {
                            this.store.dispatch({
                                type: pD.KEY_METRIC_SUBSCRIBE,
                                metric: ED(ED(ED(ED(ED({
                                    userId: e,
                                    type: t
                                }, r && {subscribeStart: r}), n && {subscribeEnd: n}), i && {firstFrame: i}), o && {streamAdded: o}), s && {firstDecoded: s})
                            })
                        }

                        massSubscribe(e, t, r, n) {
                            e.forEach(e => {
                                this.store.dispatch({
                                    type: pD.KEY_METRIC_SUBSCRIBE,
                                    metric: ED(ED(ED({
                                        userId: e.userId,
                                        type: e.type
                                    }, t && {subscribeStart: t}), r && {subscribeEnd: r}), n && {firstFrame: n})
                                })
                            })
                        }

                        get keyMetrics() {
                            return this.store.getState().keyMetrics
                        }

                        recordJoinChannelService(e, t) {
                            "gateway" === e.service && Array.isArray(e.urls) && (e.urls = e.urls.map(e => e.replace(/(\d+)-\d+-\d+-(\d+)/, "$1-*-*-$2")));
                            try {
                                return "number" != typeof t ? (this.store.dispatch({
                                    type: pD.RECORD_JOIN_CHANNEL_SERVICE,
                                    record: ED(ED({}, e), {}, {
                                        sessionId: this.sessionId,
                                        cloudProxyMode: this.cloudProxyServerMode,
                                        uid: this.uid
                                    })
                                }), this.store.getState().joinChannelServiceRecords.length - 1) : (t < 0 || t >= this.store.getState().joinChannelServiceRecords.length || this.store.dispatch({
                                    type: pD.RECORD_JOIN_CHANNEL_SERVICE,
                                    record: e,
                                    index: t
                                }), t)
                            } catch (e) {
                                return 0
                            }
                        }

                        resetJoinChannelServiceRecords() {
                            this.store.dispatch({type: pD.RESET_JOIN_CHANNEL_SERVICE_RECORDS})
                        }

                        resetKeyMetrics() {
                            this.store.dispatch({type: pD.RESET_KEY_METRICS})
                        }

                        get joinChannelServiceRecords() {
                            try {
                                return this.store.getState().joinChannelServiceRecords
                            } catch (e) {
                                return []
                            }
                        }

                        get avoidJoinStart() {
                            return this.store.getState().avoidJoinStart
                        }

                        set avoidJoinStart(e) {
                            this.store.dispatch({type: pD.AVOID_JOIN_START, avoidJoinStart: e})
                        }
                    }(e.codec, e.audioCodec, e.mode, this._clientId), this.store.clientCreated(), e.proxyServer && this.setProxyServer(e.proxyServer, !0), e.turnServer && this.setTurnServer(e.turnServer, !0), em.info("[".concat(this._clientId, "] Initializing AgoraRTC client v").concat(rm, " build: ").concat(tm, ", mode: ").concat(this._mode, ", codec: ").concat(this._codec)), e.clientRoleOptions) try {
                        ov(e.clientRoleOptions), t = Object.assign({}, e.clientRoleOptions)
                    } catch (e) {
                        em.warning("[".concat(this._clientId, "] ").concat(e.toString()))
                    }
                    this._statsCollector = new kS(this.store), this._statsCollector.onStatsException = ((e, t, r) => {
                        em.debug("[".concat(this._clientId, "] receive exception msg, code: ").concat(e, ", msg: ").concat(t, ", uid: ").concat(r)), this.emit(z_.EXCEPTION, {
                            code: e,
                            msg: t,
                            uid: r
                        })
                    }), this._statsCollector.onUploadPublishDuration = ((e, t, r, n) => {
                        const i = this._users.find(t => t.uid === e);
                        i && WE.peerPublishStatus(this._sessionId, {
                            subscribeElapse: n,
                            audioPublishDuration: t,
                            videoPublishDuration: r,
                            peer: i._uintid
                        })
                    }), this._gateway = new class extends Wf {
                        get state() {
                            return this._state
                        }

                        set state(e) {
                            if (e === this._state) return;
                            const t = this._state;
                            this._state = e, "DISCONNECTED" === e && this._disconnectedReason ? this.emit(Av.CONNECTION_STATE_CHANGE, e, t, this._disconnectedReason) : this.emit(Av.CONNECTION_STATE_CHANGE, e, t)
                        }

                        get joinGatewayStartTime() {
                            return this._joinGatewayStartTime
                        }

                        set joinGatewayStartTime(e) {
                            em.debug("[".concat(this.store.clientId, "] set joinGatewayStartTime at ").concat(e)), this._joinGatewayStartTime = e
                        }

                        constructor(e, t) {
                            super(), Kh(this, "store", void 0), Kh(this, "joinInfo", void 0), Kh(this, "key", void 0), Kh(this, "signal", void 0), Kh(this, "role", void 0), Kh(this, "inChannelInfo", {
                                joinAt: null,
                                duration: 0
                            }), Kh(this, "spec", void 0), Kh(this, "_state", "DISCONNECTED"), Kh(this, "_statsCollector", void 0), Kh(this, "_disconnectedReason", void 0), Kh(this, "isSignalRecover", !1), Kh(this, "hasChangeBGPAddress", !1), Kh(this, "trafficStatsInterval", void 0), Kh(this, "networkQualityInterval", void 0), Kh(this, "_joinGatewayStartTime", 0), Kh(this, "_signalTimeout", !1), Kh(this, "_clientRoleOptions", void 0), Kh(this, "_isProactiveJoin", !1), this.store = e, this.spec = t;
                            const r = og().supportDataChannel && fm("SIGNAL_CHANNEL");
                            this.signal = r ? new bw(Rw(Rw({}, t), {}, {retryConfig: t.websocketRetryConfig}), e) : new pw(Rw(Rw({}, t), {}, {retryConfig: t.websocketRetryConfig}), e), this._statsCollector = t.statsCollector, this.role = t.role || "audience", this._clientRoleOptions = t.clientRoleOptions, this.handleSignalEvents()
                        }

                        async join(e, t, r) {
                            if (this.signal instanceof bw) {
                                let t = !1;
                                "disabled" !== e.cloudProxyServer ? (em.debug("[".concat(this.store.clientId, "] Dc is not supported, because cloudProxyServer are not supported (").concat(e.cloudProxyServer, ")")), t = !0) : "".concat(e.apResponse.cid, "_").concat(e.apResponse.cert).length > 255 || "".concat(e.apResponse.cid, "_").concat(e.apResponse.cert).length < 22 ? (em.debug("[".concat(this.store.clientId, "] Dc is not supported, because ticket length is incorrect, it has to be between 22 and 255")), t = !0) : e.apResponse.addresses.some(e => e.fingerprint) || fm("FINGERPRINT") || (em.debug("[".concat(this.store.clientId, "] Dc is not supported, because fingerprint does not exist")), t = !0), t && this.resetSignal()
                            }
                            this.store.joinGatewayStart(), "disabled" !== e.cloudProxyServer && (this.hasChangeBGPAddress = !0);
                            const n = Date.now();
                            let i = Iw.get(e.cname);
                            if (i || (i = new Map, Iw.set(e.cname, i)), this._isProactiveJoin = !0, i.has(e.uid)) {
                                const t = new Hf(qf.UID_CONFLICT);
                                throw WE.joinGateway(e.sid, {
                                    lts: n,
                                    succ: !1,
                                    ec: t.message,
                                    addr: null,
                                    uid: e.uid,
                                    cid: e.cid,
                                    firstSuccess: this._isProactiveJoin,
                                    avoidJoinStartTime: this.store.avoidJoinStart,
                                    isProxy: !!e.proxyServer,
                                    signalChannel: this.signal instanceof bw ? "1" : "0"
                                }), this._isProactiveJoin = !1, t
                            }
                            i.set(e.uid, !0), this.joinInfo = e, this.key = t;
                            let o = 0;
                            this.joinGatewayStartTime = n;
                            const s = e.proxyServer;
                            try {
                                let a;
                                if (em.debug("[".concat(this.store.clientId, "] use ").concat(this.signal instanceof bw ? "datachannel" : "websocket", " join uid ").concat(o)), this.signal instanceof bw) a = await this.signal.init(e.apResponse.addresses, r); else {
                                    const t = e.proxyServer, n = t ? e.gatewayAddrs.map(e => {
                                        const r = e.address.split(":");
                                        return "wss://".concat(t, "/ws/?h=").concat(r[0], "&p=").concat(r[1])
                                    }) : e.gatewayAddrs.map(e => "wss://".concat(e.address));
                                    a = await this.signal.init(n, r)
                                }
                                o = a.uid, em.debug("[".concat(this.store.clientId, "] ").concat(this.signal instanceof bw ? "datachannel" : "websocket", " join uid ").concat(o, " cost ").concat(Date.now() - this.joinGatewayStartTime))
                            } catch (t) {
                                if (t && t.code === qf.INIT_WEBSOCKET_TIMEOUT) throw em.warning("[".concat(this.store.clientId, "] User join failed"), t.toString()), t;
                                if (t && t.code === qf.INIT_DATACHANNEL_TIMEOUT) throw em.warning("[".concat(this.store.clientId, "] User join datachannel failed"), t.toString()), this.resetSignal(), t;
                                throw em.error("[".concat(this.store.clientId, "] User join failed"), t.toString()), WE.joinGateway(e.sid, {
                                    lts: n,
                                    succ: !1,
                                    ec: t.message,
                                    addr: this.signal.url,
                                    uid: e.uid,
                                    cid: e.cid,
                                    firstSuccess: this._isProactiveJoin,
                                    avoidJoinStartTime: this.store.avoidJoinStart,
                                    isProxy: !!s,
                                    signalChannel: this.signal instanceof bw ? "1" : "0"
                                }), this._isProactiveJoin = !1, i.delete(e.uid), this.signal.close(), t
                            }
                            return this.state = "CONNECTED", this.inChannelInfo.joinAt = Date.now(), em.debug("[".concat(this.store.clientId, "] Connected to gateway server")), this.trafficStatsInterval = window.setInterval(() => {
                                this.updateTrafficStats().catch(e => {
                                    em.warning("[".concat(this.store.clientId, "] get traffic stats error"), e.toString())
                                })
                            }, 3e3), this.networkQualityInterval = window.setInterval(() => {
                                navigator && void 0 !== navigator.onLine && !navigator.onLine ? this.emit(Av.NETWORK_QUALITY, {
                                    downlinkNetworkQuality: 6,
                                    uplinkNetworkQuality: 6
                                }) : this._signalTimeout ? this.emit(Av.NETWORK_QUALITY, {
                                    downlinkNetworkQuality: 5,
                                    uplinkNetworkQuality: 5
                                }) : "CONNECTED" === this.state && this._statsCollector.trafficStats ? this.emit(Av.NETWORK_QUALITY, {
                                    uplinkNetworkQuality: BS(this._statsCollector.trafficStats.B_unq),
                                    downlinkNetworkQuality: BS(this._statsCollector.trafficStats.B_dnq)
                                }) : this.emit(Av.NETWORK_QUALITY, {uplinkNetworkQuality: 0, downlinkNetworkQuality: 0})
                            }, 2e3), this.store.joinGatewayEnd(), o
                        }

                        async leave() {
                            let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
                                t = arguments.length > 1 ? arguments[1] : void 0;
                            if ("DISCONNECTED" !== this.state) {
                                t !== K_.FALLBACK && (this.state = "DISCONNECTING");
                                try {
                                    e || this.signal.connectionState !== J_.CONNECTED || await function (e, t) {
                                        return sl.race([e, function (e) {
                                            const t = new Hf(qf.TIMEOUT, "timeout");
                                            return new sl((r, n) => {
                                                window.setTimeout(() => n(t), e)
                                            })
                                        }(3e3)])
                                    }(this.signal.request(Q_.LEAVE, void 0, !0))
                                } catch (e) {
                                    em.warning("[".concat(this.store.clientId, "] leave request failed, ignore"), e)
                                }
                                this.signal.close(t), t !== K_.FALLBACK && (this.state = "DISCONNECTED"), this.reset()
                            }
                        }

                        async publish(e, t, r) {
                            if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state) throw new Hf(qf.INVALID_OPERATION, "can not publish when connection state is ".concat(this.state));
                            const n = {
                                state: "offer",
                                p2p_id: this.store.p2pId,
                                ortc: t,
                                mode: this.spec.mode,
                                extend: fm("PUB_EXTEND"),
                                tcc: !!fm("PUBLISH_TCC")
                            };
                            try {
                                return (await this.signal.request(Q_.PUBLISH, n, !0))._message
                            } catch (n) {
                                if (r && n.data && n.data.code === q_.ERR_PUBLISH_REQUEST_INVALID) return em.warning("[".concat(this.store.clientId, "] receive publish error code, retry"), n.toString()), await this.tryUnpubBeforeRepub(e, t), this.publish(e, t, !1);
                                throw n
                            }
                        }

                        async unpublish(e, t) {
                            try {
                                if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state) throw new Hf(qf.INVALID_OPERATION, "can not publish when connection state is ".concat(this.state));
                                await this.signal.request(Q_.UNPUBLISH, {stream_id: t, ortc: e}, !0)
                            } catch (e) {
                                em.warning("unpublish warning: ", e)
                            }
                        }

                        async subscribe(e, t, r) {
                            if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state) throw new Hf(qf.INVALID_OPERATION, "can not subscribe when connection state is ".concat(this.state));
                            const n = {
                                stream_id: e,
                                stream_type: t.stream_type,
                                mode: this.spec.mode,
                                codec: this.spec.codec,
                                p2p_id: this.store.p2pId,
                                tcc: !!fm("SUBSCRIBE_TCC"),
                                extend: fm("SUB_EXTEND"),
                                ssrcId: t.ssrcId
                            };
                            try {
                                return (await this.signal.request(Q_.SUBSCRIBE, n, !0))._message
                            } catch (n) {
                                if (r && n.data && n.data.code === q_.ERR_SUBSCRIBE_REQUEST_INVALID) return em.warning("[".concat(this.store.clientId, "] receiver subscribe error code, retry"), n.toString()), await this.tryUnsubBeforeResub(e, t), await this.subscribe(e, t, !1);
                                throw n
                            }
                        }

                        async subscribeAll(e, t) {
                            if ("CONNECTED" !== this.state && "RECONNECTING" !== this.state) throw new Hf(qf.INVALID_OPERATION, "can not massSubscribe when connection state is ".concat(this.state));
                            const r = {p2p_id: this.store.p2pId, users: e, dtx: !1};
                            try {
                                return await this.signal.request(Q_.SUBSCRIBE_STREAMS, r, !0)
                            } catch (r) {
                                if (t && r.data && r.data.code === q_.ERR_SUBSCRIBE_REQUEST_INVALID) return em.warning("[".concat(this.store.clientId, "] receiver massSubscribe error code, retry"), r.toString()), await this.tryMassUnsubBeforeResub(e), await this.subscribeAll(e, !1);
                                throw r
                            }
                        }

                        async setVideoProfile(e) {
                            const t = function (e) {
                                if (!(e.bitrateMax && e.bitrateMin && e.frameRate && e.height && e.width)) return;
                                let t = e.frameRate, r = e.width, n = e.height, i = !0;
                                return "number" != typeof t && ((t = t.exact || t.ideal || t.max || t.min || 0) || (i = !1)), "number" != typeof r && ((r = r.exact || r.ideal || r.max || r.min || 0) || (i = !1)), "number" != typeof n && (n = n.exact || n.ideal || n.max || n.min || 0, t || (i = !1)), i ? {
                                    stream_type: 0,
                                    width: r,
                                    height: n,
                                    fps: t,
                                    start_bps: 1e3 * e.bitrateMax,
                                    min_bps: 1e3 * e.bitrateMin,
                                    target_bps: 1e3 * e.bitrateMax
                                } : void 0
                            }(e);
                            if (t) return this.signal.request(Q_.SET_VIDEO_PROFILE, t);
                            em.debug("[".concat(this.store.clientId, "] encoder config is not complete, do not report to gateway"))
                        }

                        async unsubscribe(e, t) {
                            try {
                                await this.signal.request(Q_.UNSUBSCRIBE, {
                                    p2p_id: this.store.p2pId,
                                    ortc: e,
                                    stream_id: t
                                }, !0)
                            } catch (e) {
                                em.warning("unsubscribe warning: ", e)
                            }
                        }

                        async massUnsubscribe(e) {
                            try {
                                await this.signal.request(Q_.UNSUBSCRIBE_STREAMS, e, !0)
                            } catch (e) {
                                em.warning("unsubscribeAll warning: ", e)
                            }
                        }

                        async reconnectPC(e) {
                            const {iceParameters: t, dtlsParameters: r, rtpCapabilities: n} = e;
                            return {
                                gatewayEstablishParams: await this.signal.request(Q_.CONNECT_PC, {
                                    p2p_id: this.store.p2pId,
                                    stream_id: this.store.uid,
                                    ortc: {iceParameters: t, dtlsParameters: r, rtpCapabilities: n}
                                }, !0), gatewayAddress: this.getCurrentGatewayAddress()
                            }
                        }

                        getGatewayInfo() {
                            return this.signal.request(Q_.GATEWAY_INFO)
                        }

                        renewToken(e) {
                            return this.signal.request(Q_.RENEW_TOKEN, e)
                        }

                        async setClientRole(e, t) {
                            if (t && (this._clientRoleOptions = Object.assign({}, t)), "CONNECTED" !== this.state) return void (this.role = e);
                            let r = void 0;
                            r = "audience" === e ? this._clientRoleOptions && this._clientRoleOptions.level ? this._clientRoleOptions.level : 2 : 0, await this.signal.request(Q_.SET_CLIENT_ROLE, {
                                role: e,
                                level: r,
                                client_ts: Date.now()
                            }), this.role = e
                        }

                        async setRemoteVideoStreamType(e, t) {
                            await this.signal.request(Q_.SWITCH_VIDEO_STREAM, {stream_id: e, stream_type: t})
                        }

                        async setDefaultRemoteVideoStreamType(e) {
                            await this.signal.request(Q_.DEFAULT_VIDEO_STREAM, {stream_type: e})
                        }

                        async setStreamFallbackOption(e, t) {
                            await this.signal.request(Q_.SET_FALLBACK_OPTION, {stream_id: e, fallback_type: t})
                        }

                        async pickSVCLayer(e, t) {
                            await this.signal.request(Q_.PICK_SVC_LAYER, {
                                stream_id: e,
                                spatial_layer: t.spatialLayer,
                                temporal_layer: t.temporalLayer
                            })
                        }

                        getInChannelInfo() {
                            return this.inChannelInfo.joinAt && (this.inChannelInfo.duration = Date.now() - this.inChannelInfo.joinAt), Rw({}, this.inChannelInfo)
                        }

                        async getGatewayVersion() {
                            return (await this.signal.request(Q_.GATEWAY_INFO)).version
                        }

                        reset() {
                            if (this.inChannelInfo.joinAt && (this.inChannelInfo.duration = Date.now() - this.inChannelInfo.joinAt, this.inChannelInfo.joinAt = null), this.trafficStatsInterval && (window.clearInterval(this.trafficStatsInterval), this.trafficStatsInterval = void 0), this.joinInfo) {
                                const e = Iw.get(this.joinInfo.cname);
                                e && e.delete(this.joinInfo.uid)
                            }
                            this.joinInfo = void 0, this.key = void 0, this.networkQualityInterval && (window.clearInterval(this.networkQualityInterval), this.networkQualityInterval = void 0)
                        }

                        updateTurnConfigFromSignal() {
                            if (!this.joinInfo) return;
                            const e = function (e) {
                                let t;
                                return (t = e.startsWith("dc") ? e.match(/(dc\:\/\/)?([^:]+):(\d+)/) : e.match(/(wss\:\/\/)?([^:]+):(\d+)/)) ? {
                                    username: im.username,
                                    password: im.password,
                                    turnServerURL: t[2],
                                    tcpport: parseInt(t[3]) + 30,
                                    udpport: parseInt(t[3]) + 30,
                                    forceturn: !1
                                } : null
                            }(("disabled" === this.joinInfo.cloudProxyServer ? this.signal.url : this.joinInfo.gatewayAddrs[this.signal.currentURLIndex].address) || "");
                            this.joinInfo.turnServer.serversFromGateway = [], e && "off" !== this.joinInfo.turnServer.mode && "disabled" === this.joinInfo.cloudProxyServer && this.joinInfo.turnServer.serversFromGateway.push(Rw(Rw({}, im), {}, {
                                turnServerURL: e.turnServerURL,
                                tcpport: e.tcpport,
                                udpport: e.udpport,
                                username: this.joinInfo.uid.toString(),
                                password: this.joinInfo.token
                            }))
                        }

                        async updateTrafficStats() {
                            if ("CONNECTED" !== this.state) return;
                            const e = await this.signal.request(Q_.TRAFFIC_STATS, void 0, !0);
                            e.timestamp = Date.now(), e.peer_delay.forEach(e => {
                                const t = this._statsCollector.trafficStats && this._statsCollector.trafficStats.peer_delay.find(t => t.peer_uid === e.peer_uid);
                                t && t.B_st !== e.B_st && ob(() => {
                                    this.emit(Av.STREAM_TYPE_CHANGE, e.peer_uid, e.B_st)
                                })
                            }), this._statsCollector.updateTrafficStats(e)
                        }

                        getJoinMessage(e) {
                            if (!this.joinInfo || !this.key) throw new Hf(qf.UNEXPECTED_ERROR, "can not generate join message, no join info");
                            const t = Object.assign({}, this.joinInfo.apResponse);
                            let r = fm("REPORT_APP_SCENARIO");
                            if ("string" != typeof r) try {
                                r = JSON.stringify(r)
                            } catch (e) {
                                r = void 0
                            }
                            r && r.length > 128 && (r = void 0);
                            const n = Rw({
                                license: this.joinInfo.license,
                                p2p_id: this.store.p2pId,
                                session_id: this.joinInfo.sid,
                                app_id: this.joinInfo.appId,
                                channel_key: this.key,
                                channel_name: this.joinInfo.cname,
                                sdk_version: rm,
                                browser: navigator.userAgent,
                                process_id: fm("PROCESS_ID"),
                                mode: this.spec.mode,
                                codec: this.spec.codec,
                                role: this.role,
                                has_changed_gateway: this.hasChangeBGPAddress,
                                ap_response: t,
                                extend: fm("JOIN_EXTEND"),
                                details: {
                                    6: this.joinInfo.stringUid,
                                    cservice_map: "proxy3" === this.joinInfo.cloudProxyServer ? "1" : "proxy5" === this.joinInfo.cloudProxyServer ? "2" : void 0
                                },
                                features: {rejoin: !0},
                                optionalInfo: this.joinInfo.optionalInfo,
                                appScenario: r,
                                attributes: {
                                    userAttributes: {
                                        enablePublishedUserList: fm("ENABLE_PUBLISHED_USER_LIST"),
                                        maxSubscription: fm("MAX_SUBSCRIPTION"),
                                        subscribeAudioFilterTopN: "number" == typeof fm("SUBSCRIBE_AUDIO_FILTER_TOPN") ? fm("SUBSCRIBE_AUDIO_FILTER_TOPN") : void 0,
                                        enablePublishAudioFilter: "boolean" == typeof fm("ENABLE_PUBLISH_AUDIO_FILTER") ? fm("ENABLE_PUBLISH_AUDIO_FILTER") : void 0,
                                        enableUserLicenseCheck: "boolean" == typeof fm("ENABLE_USER_LICENSE_CHECK") ? fm("ENABLE_USER_LICENSE_CHECK") : void 0
                                    }
                                },
                                join_ts: this.joinGatewayStartTime
                            }, e);
                            return this.joinInfo.stringUid && (n.string_uid = this.joinInfo.stringUid), this.joinInfo.aesmode && this.joinInfo.aespassword && (n.aes_mode = this.joinInfo.aesmode, fm("ENCRYPT_AES") ? (n.aes_secret = this.joinInfo.aespassword, n.aes_encrypt = !0) : n.aes_secret = this.joinInfo.aespassword, this.joinInfo.aessalt && (n.aes_salt = this.joinInfo.aessalt)), t.addresses[this.signal.websocket.currentURLIndex] && (n.ap_response.ticket = t.addresses[this.signal.websocket.currentURLIndex].ticket, delete t.addresses), void 0 !== this.joinInfo.defaultVideoStream && (n.default_video_stream = this.joinInfo.defaultVideoStream), n
                        }

                        getRejoinMessage() {
                            if (!this.joinInfo) throw new Hf(qf.UNEXPECTED_ERROR, "can not generate rejoin message, no join info");
                            return {
                                session_id: this.joinInfo.sid,
                                channel_name: this.joinInfo.cname,
                                cid: this.joinInfo.cid,
                                uid: this.joinInfo.uid,
                                vid: Number(this.joinInfo.vid)
                            }
                        }

                        handleSignalEvents() {
                            this.signal.on(X_.WS_RECONNECT_WAITTING_FINISH, e => {
                                ["tryNext", "recover"].includes(e) && this.joinInfo && WE.adjustSessionStartTime(this.joinInfo.sid)
                            }), this.signal.on(X_.WS_RECONNECT_CREATE_CONNECTION, e => {
                                this.joinGatewayStartTime = Date.now()
                            }), this.signal.on(X_.WS_RECONNECTING, e => {
                                this.joinInfo && WE.WebSocketQuit(this.joinInfo.sid, {
                                    lts: Date.now(),
                                    succ: -1,
                                    cname: this.joinInfo.cname,
                                    uid: this.joinInfo.uid,
                                    cid: this.joinInfo.cid,
                                    errorCode: e || Y_.NETWORK_ERROR
                                }), this.joinInfo && (this.state = "RECONNECTING", WE.sessionInit(this.joinInfo.sid, {
                                    lts: (new Date).getTime(),
                                    extend: this.isSignalRecover ? {recover: !0} : {rejoin: !0},
                                    cname: this.joinInfo.cname,
                                    appid: this.joinInfo.appId,
                                    mode: this.spec.mode
                                }), this.isSignalRecover = !1, this.joinGatewayStartTime = Date.now())
                            }), this.signal.on(X_.WS_CLOSED, e => {
                                let t;
                                switch (e) {
                                    case K_.LEAVE:
                                        t = Y_.LEAVE;
                                        break;
                                    case K_.UID_BANNED:
                                    case K_.IP_BANNED:
                                    case K_.CHANNEL_BANNED:
                                    case K_.SERVER_ERROR:
                                        t = Y_.SERVER_ERROR;
                                        break;
                                    case K_.FALLBACK:
                                        t = Y_.FALLBACK;
                                        break;
                                    case K_.LICENSE_MISSING:
                                    case K_.LICENSE_EXPIRED:
                                    case K_.LICENSE_MINUTES_EXCEEDED:
                                    case K_.LICENSE_PERIOD_INVALID:
                                    case K_.LICENSE_MULTIPLE_SDK_SERVICE:
                                    case K_.LICENSE_ILLEGAL:
                                        t = e;
                                        break;
                                    default:
                                        t = Y_.NETWORK_ERROR
                                }
                                em.debug("[signal] websocket closed, reason: ".concat(t || "undefined -> " + Y_.NETWORK_ERROR)), this.joinInfo && WE.WebSocketQuit(this.joinInfo.sid, {
                                    lts: Date.now(),
                                    succ: e === K_.LEAVE ? 1 : -1,
                                    cname: this.joinInfo.cname,
                                    uid: this.joinInfo.uid,
                                    cid: this.joinInfo.cid,
                                    errorCode: t
                                }), this._disconnectedReason = e, e !== K_.FALLBACK && (this.state = "DISCONNECTED"), this.reset()
                            }), this.signal.on(X_.WS_CONNECTED, () => {
                                if (this.updateTurnConfigFromSignal(), this.state = "CONNECTED", this.joinInfo && ("audience" === this.role && this._clientRoleOptions && this._clientRoleOptions.level && (em.debug("[".concat(this.store.clientId, "] patch to send set client role, role: ").concat(this.role, ", mode: ").concat(this.spec.mode, ", level: ").concat(this._clientRoleOptions && this._clientRoleOptions.level)), this.setClientRole(this.role, this._clientRoleOptions)), WE.joinGateway(this.joinInfo.sid, {
                                    lts: this.joinGatewayStartTime,
                                    succ: !0,
                                    ec: null,
                                    vid: this.joinInfo.vid,
                                    addr: this.signal.url,
                                    uid: this.joinInfo.uid,
                                    cid: this.joinInfo.cid,
                                    firstSuccess: this._isProactiveJoin,
                                    avoidJoinStartTime: this.store.avoidJoinStart,
                                    isProxy: !!this.joinInfo.proxyServer,
                                    signalChannel: this.signal instanceof bw ? "1" : "0"
                                }), this._isProactiveJoin = !1, this.joinInfo.useLocalAccessPoint && 1 === this.joinInfo.setLocalAPVersion)) {
                                    const e = this.signal.url && this.signal.url.match(/wss\:\/\/([^:]+):(\d+)/);
                                    if (!e) return void em.error("[".concat(this.store.clientId, "] set local access point after joined failed: ").concat(e));
                                    pm("EVENT_REPORT_DOMAIN", e[1]), pm("EVENT_REPORT_BACKUP_DOMAIN", e[1]), pm("LOG_UPLOAD_SERVER", "".concat(e[1], ":6444"))
                                }
                            }), this.signal.on(Z_.ON_UPLINK_STATS, e => {
                                this._statsCollector.updateUplinkStats(e)
                            }), this.signal.on(X_.REQUEST_RECOVER, (e, t, r) => {
                                if (!this.joinInfo) return r(new Hf(qf.UNEXPECTED_ERROR, "gateway: can not recover, no join info"));
                                e && (this.joinInfo.multiIP = e, this.hasChangeBGPAddress = !0), this.isSignalRecover = !0, ZS(this, Av.REQUEST_NEW_GATEWAY_LIST).then(t).catch(r)
                            }), this.signal.on(X_.REQUEST_JOIN_INFO, async e => {
                                var t;
                                this.updateTurnConfigFromSignal();
                                const {
                                    iceParameters: r,
                                    dtlsParameters: n,
                                    rtpCapabilities: i
                                } = await ZS(this, Av.REQUEST_P2P_CONNECTION_PARAMS, {turnServer: null === (t = this.joinInfo) || void 0 === t ? void 0 : t.turnServer});
                                e(this.getJoinMessage({
                                    ortc: {
                                        iceParameters: r,
                                        dtlsParameters: n,
                                        rtpCapabilities: i,
                                        version: "2"
                                    }
                                }))
                            }), this.signal.on(X_.REQUEST_REJOIN_INFO, e => {
                                e(this.getRejoinMessage())
                            }), this.signal.on(X_.REPORT_JOIN_GATEWAY, (e, t) => {
                                this.joinInfo && (WE.joinGateway(this.joinInfo.sid, {
                                    lts: this.joinGatewayStartTime,
                                    succ: !1,
                                    ec: e,
                                    addr: t,
                                    uid: this.joinInfo.uid,
                                    cid: this.joinInfo.cid,
                                    firstSuccess: this._isProactiveJoin,
                                    avoidJoinStartTime: this.store.avoidJoinStart,
                                    isProxy: !!this.joinInfo.proxyServer,
                                    signalChannel: this.signal instanceof bw ? "1" : "0"
                                }), this._isProactiveJoin = !1)
                            }), this.signal.on(X_.IS_P2P_DISCONNECTED, e => {
                                e(rb(this, Av.IS_P2P_DISCONNECTED))
                            }), this.signal.on(X_.DISCONNECT_P2P, () => {
                                this.emit(Av.DISCONNECT_P2P)
                            }), this.signal.on(X_.NEED_RENEW_SESSION, () => {
                                this.emit(Av.NEED_RENEW_SESSION)
                            }), this.signal.on(X_.REQUEST_SUCCESS, () => {
                                this._signalTimeout = !1
                            }), this.signal.on(X_.REQUEST_TIMEOUT, () => {
                                this._signalTimeout = !0
                            }), this.signal.on(X_.JOIN_RESPONSE, e => {
                                const t = this.getCurrentGatewayAddress();
                                this.emit(Av.JOIN_RESPONSE, e, t)
                            }), this.signal.on(X_.DATACHANNEL_PRECONNECT, async (e, t, r) => {
                                this.updateTurnConfigFromSignal();
                                const n = this.getCurrentGatewayAddress();
                                return ZS(this, Av.DATACHANNEL_PRECONNECT, e, n).then(t).catch(r)
                            }), this.signal.on(X_.DATACHANNEL_CONNECTING, async e => {
                                const {
                                    iceParameters: t,
                                    dtlsParameters: r,
                                    rtpCapabilities: n
                                } = await ZS(this, Av.REQUEST_DC_CONNECTION_PARAMS);
                                e(this.getJoinMessage({
                                    ortc: {
                                        iceParameters: t,
                                        dtlsParameters: r,
                                        rtpCapabilities: n,
                                        version: "2"
                                    }
                                }))
                            }), this.signal.on(X_.DATACHANNEL_FAILBACK, () => {
                                em.warning("[".concat(this.store.clientId, "] User join datachannel failed")), this.reset(), this.resetSignal(), this.emit(Av.DATACHANNEL_FAILBACK)
                            })
                        }

                        async tryUnsubBeforeResub(e, t) {
                            try {
                                await this.signal.request(Q_.UNSUBSCRIBE, {
                                    p2p_id: this.store.p2pId,
                                    stream_id: e,
                                    ortc: [t]
                                }, !0)
                            } catch (e) {
                                throw em.warning("unsubscribe warning", e), e
                            }
                        }

                        async tryUnpubBeforeRepub(e, t) {
                            try {
                                await this.signal.request(Q_.UNPUBLISH, {stream_id: e, ortc: t}, !0)
                            } catch (e) {
                                throw em.warning("unpublish warning: ", e), e
                            }
                        }

                        async tryMassUnsubBeforeResub(e) {
                            const t = {users: e.map(e => ({stream_id: e.stream_id, stream_type: e.stream_type}))};
                            try {
                                await this.signal.request(Q_.UNSUBSCRIBE_STREAMS, t, !0)
                            } catch (e) {
                                throw em.warning("massUnsubscribe warning", e), e
                            }
                        }

                        async muteLocal(e, t) {
                            const r = {
                                action: e.find(e => e.stream_type === Cv.Audio) ? "mute_local_audio" : "mute_local_video",
                                p2p_id: this.store.p2pId,
                                ortc: e,
                                stream_id: t
                            };
                            try {
                                await this.signal.request(Q_.CONTROL, r, !0, !0)
                            } catch (e) {
                                throw em.warning("gateway unmuteLocal warning: ", e), e
                            }
                        }

                        async unmuteLocal(e, t) {
                            const r = {
                                action: e.find(e => e.stream_type === Cv.Audio) ? "unmute_local_audio" : "unmute_local_video",
                                p2p_id: this.store.p2pId,
                                ortc: e,
                                stream_id: t
                            };
                            try {
                                await this.signal.request(Q_.CONTROL, r, !0, !0)
                            } catch (e) {
                                throw em.warning("gateway muteLocal warning: ", e), e
                            }
                        }

                        uploadStats(e, t) {
                            this.signal.upload(e, t)
                        }

                        getSignalRTT() {
                            return this.signal.rtt
                        }

                        async restartICE(e) {
                            const t = {p2p_id: this.store.p2pId, stream_id: this.store.uid, ortc: e};
                            try {
                                return await this.signal.request(Q_.RESTART_ICE, t, !0)
                            } catch (e) {
                                throw em.warning("P2PChannel.restartICE warning: ", e), e
                            }
                        }

                        reconnect() {
                            "CONNECTED" === this.state && this.signal.reconnect(void 0, Y_.P2P_FAILED)
                        }

                        getCurrentGatewayAddress() {
                            var e;
                            if (!fm("GATEWAY_WSS_ADDRESS")) return null !== (e = this.joinInfo) && void 0 !== e && e.gatewayAddrs ? this.joinInfo.gatewayAddrs[this.signal.currentURLIndex] : void 0
                        }

                        async setPublishAudioFilterEnabled(e) {
                            await this.signal.request(Q_.SET_PARAMETER, {enablePublishAudioFilter: e})
                        }

                        resetSignal() {
                            this.signal && (this.signal.removeAllListeners(), this.signal.close(K_.FALLBACK)), this.signal = new pw(Rw(Rw({}, this.spec), {}, {retryConfig: this.spec.websocketRetryConfig}), this.store), this.handleSignalEvents(), this.emit(Av.RESET_CONNECTION_EVENTS)
                        }
                    }(this.store, {
                        clientId: this._clientId,
                        mode: this._mode,
                        codec: this._codec,
                        websocketRetryConfig: e.websocketRetryConfig || Kf,
                        httpRetryConfig: e.httpRetryConfig || Kf,
                        forceWaitGatewayResponse: void 0 === e.forceWaitGatewayResponse || e.forceWaitGatewayResponse,
                        statsCollector: this._statsCollector,
                        role: e.role,
                        clientRoleOptions: t
                    }), this._config = e, this._configDistribute = new class extends Wf {
                        constructor() {
                            super(), Kh(this, "configs", void 0), Kh(this, "joinInfo", void 0), Kh(this, "cancelToken", void 0), Kh(this, "retryConfig", {
                                timeout: 3e3,
                                timeoutFactor: 1.5,
                                maxRetryCount: 1,
                                maxRetryTimeout: 1e4
                            }), Kh(this, "interval", void 0), Kh(this, "mutex", new KE("config-distribute")), Kh(this, "mutableParamsRead", !1)
                        }

                        startGetConfigDistribute(e, t) {
                            this.joinInfo = e, this.cancelToken = t, this.interval && this.stopGetConfigDistribute(), fm("ENABLE_CONFIG_DISTRIBUTE") && (this.updateConfigDistribute(), this.interval = window.setInterval(() => {
                                this.updateConfigDistribute()
                            }, fm("CONFIG_DISTRIBUTE_INTERVAL")))
                        }

                        stopGetConfigDistribute() {
                            this.interval && clearInterval(this.interval), this.interval = void 0, this.joinInfo = void 0, this.cancelToken = void 0
                        }

                        async awaitConfigDistributeComplete() {
                            this.mutex.isLocked && (await this.mutex.lock())()
                        }

                        async updateConfigDistribute() {
                            if (this.mutableParamsRead || (this.mutableParamsRead = !0, WE.reportApiInvoke(null, {
                                options: void 0,
                                name: M_.LOAD_CONFIG_FROM_LOCALSTORAGE,
                                tag: U_.TRACER
                            }).onSuccess(JSON.stringify(_m))), !this.joinInfo || !this.cancelToken || !this.retryConfig) return void em.debug("[config-distribute] get config distribute interrupted have no joininfo");
                            let e;
                            const t = await this.mutex.lock();
                            try {
                                e = await async function (e, t, r) {
                                    const n = fm("CDS_AP").slice(0, fm("AJAX_REQUEST_CONCURRENT")).map(t => e.proxyServer ? "https://".concat(e.proxyServer, "/ap/?url=").concat(t + "/api/v1") : "https://".concat(t, "/api/v1?action=config")).map(n => (function (e, t, r, n) {
                                        const i = Sh(), o = {
                                            flag: 64,
                                            cipher_method: 0,
                                            features: {
                                                device: i.name,
                                                system: i.os,
                                                system_general: navigator.userAgent,
                                                vendor: t.appId,
                                                version: rm,
                                                cname: t.cname,
                                                sid: t.sid,
                                                session_id: t.sid,
                                                detail: "",
                                                proxyServer: t.proxyServer
                                            }
                                        };
                                        return Yf(() => NE(e, {
                                            data: o,
                                            timeout: 1e3,
                                            cancelToken: r,
                                            headers: {"X-Packet-Service-Type": 0, "X-Packet-URI": 54}
                                        }), void 0, e => e.code !== qf.OPERATION_ABORTED, n)
                                    })(n, e, t, r));
                                    let i = null, o = null, s = {};
                                    try {
                                        i = await $S(n)
                                    } catch (e) {
                                        if (e.code === qf.OPERATION_ABORTED) throw e;
                                        o = e
                                    }
                                    if (n.forEach(e => e.cancel()), WE.reportApiInvoke(e.sid, {
                                        name: M_.REQUEST_CONFIG_DISTRIBUTE,
                                        options: {error: o, res: i}
                                    }).onSuccess(), i && i.test_tags) try {
                                        s = function (e) {
                                            if (!e.test_tags) return {};
                                            const t = e.test_tags, r = Object.keys(t), n = {};
                                            return r.forEach(e => {
                                                var r;
                                                const i = nh(r = e.slice(4)).call(r), o = JSON.parse(t[e])[1];
                                                n[i] = o
                                            }), n
                                        }(i)
                                    } catch (e) {
                                    }
                                    return s
                                }(this.joinInfo, this.cancelToken, this.retryConfig), em.debug("[config-distribute] get config distribute", JSON.stringify(e)), e.limit_bitrate && this.handleBitrateLimit(e.limit_bitrate), this.cacheGlobalParameterConfig(e), this.configs = e
                            } catch (e) {
                                const t = new Hf(qf.NETWORK_RESPONSE_ERROR, e);
                                em.warning("[config-distribute] ".concat(t.toString()))
                            } finally {
                                t()
                            }
                        }

                        getBitrateLimit() {
                            return this.configs ? this.configs.limit_bitrate : void 0
                        }

                        handleBitrateLimit(e) {
                            var t;
                            (t = e) && t.uplink && t.id && void 0 !== t.uplink.max_bitrate && void 0 !== t.uplink.min_bitrate && (this.configs && this.configs.limit_bitrate ? this.configs && this.configs.limit_bitrate && this.configs.limit_bitrate.id !== e.id && this.emit(Wv.UPDATE_BITRATE_LIMIT, e) : this.emit(Wv.UPDATE_BITRATE_LIMIT, e))
                        }

                        getLowStreamConfigDistribute() {
                            return this.configs && this.configs.limit_bitrate && Jw({}, this.configs.limit_bitrate.low_stream_uplink)
                        }

                        cacheGlobalParameterConfig(e) {
                            var t;
                            const r = m_(t = Object.keys(e).filter(e => /^webrtc_ng_global_parameter/.test(e))).call(t);
                            for (let t = 0; t < r.length; t++) for (let n = r.length - 1; n > t; n--) {
                                const t = r[n];
                                if ("number" == typeof e[t].__priority) {
                                    const i = e[t].__priority, o = r[n - 1];
                                    if ("number" == typeof e[o].__priority) {
                                        if (!(i > e[o].__priority)) continue;
                                        {
                                            const e = t;
                                            r[n] = r[n - 1], r[n - 1] = e
                                        }
                                    } else {
                                        const e = t;
                                        r[n] = r[n - 1], r[n - 1] = e
                                    }
                                }
                            }
                            const n = {};
                            r.forEach(t => {
                                const r = e[t], i = r.__expires;
                                Object.keys(r).forEach(e => {
                                    "__priority" === e || "__expires" === e || Object.prototype.hasOwnProperty.call(n, e) || (n[e] = Jw({value: r[e]}, i && {expires: i}))
                                })
                            });
                            try {
                                const t = JSON.stringify(n), r = window.btoa(t);
                                window.localStorage.setItem("websdk_ng_global_parameter", r), em.debug("Caching global parameters ".concat(t))
                            } catch (e) {
                                em.error("Error caching global parameters:", e.message)
                            }
                        }
                    }, this._p2pChannel = new dD(this.store, this._statsCollector), this._handleP2PChannelEvents(), this._handleGatewayEvents(), this._handleGatewaySignalEvents()
                }

                async join(e, t, r, n, i) {
                    const o = ++this._numberOfJoinCount;
                    this.store.joinStart(), n && (this.store.uid = n);
                    const s = "HTTPS" === (yD || yD || (yD = (window.location.protocol.split(":")[0] || "").toUpperCase())),
                        a = SD() ? window.isSecureContext : "Browser Not Support";
                    if (!SD() && !s || !window.isSecureContext) {
                        const e = "The website must be running in a secure context (About secure context: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts ), otherwise the media collection will be restricted by the browser";
                        em.warning(e)
                    }
                    const c = JS();
                    "DISCONNECTED" === this.connectionState && (this.store.avoidJoinStart = Math.round(Date.now()), em.debug("[".concat(this._clientId, "] set avoidJoinStart to ").concat(this.store.avoidJoinStart)));
                    const u = WE.reportApiInvoke(c, {
                        name: M_.JOIN,
                        options: [e, t, r, n],
                        states: {isHttps: s, isSecureContext: a},
                        tag: U_.TRACER
                    });
                    WE.setAppId(e);
                    try {
                        if (!r && null !== r) throw new Hf(qf.INVALID_PARAMS, "Invalid token: ".concat(r, ". If you don not use token, set it to null"));
                        r && y_(r, "token", 1, 2047), y_(e, "appid", 1, 2047), b_(t), n && T_(n), i && y_(i, "optionalInfo", 1, 2047)
                    } catch (e) {
                        throw u.onError(e), e
                    }
                    if (em.info("[".concat(this._clientId, "] start join channel ").concat(t, ", join number: ").concat(o)), this._leaveMutex.isLocked && (em.debug("[".concat(this._clientId, "] join: waiting leave operation")), (await this._leaveMutex.lock())(), em.debug("[".concat(this._clientId, "] join: continue"))), this._joinAndNotLeaveYet = !0, "DISCONNECTED" !== this.connectionState) {
                        const e = new Hf(qf.INVALID_OPERATION, "[".concat(this._clientId, "] Client already in connecting/connected state"));
                        throw u.onError(e), e
                    }
                    this._sessionId || (this._sessionId = c, this.store.sessionId = this._sessionId), this._gateway.state = "CONNECTING";
                    const d = Fk({
                        clientId: this._clientId,
                        appId: e,
                        sid: this._sessionId,
                        cname: t,
                        uid: "string" != typeof n ? n : null,
                        turnServer: this._turnServer,
                        proxyServer: this._proxyServer,
                        token: r || e,
                        cloudProxyServer: this._cloudProxyServerMode,
                        optionalInfo: i,
                        license: this._license,
                        useLocalAccessPoint: this._useLocalAccessPoint
                    }, void 0 !== this._remoteDefaultVideoStreamType && {defaultVideoStream: this._remoteDefaultVideoStreamType});
                    if (this._useLocalAccessPoint && (d.setLocalAPVersion = this._setLocalAPVersion), "string" == typeof n && (d.stringUid = n, this._uintUid ? (d.uid = this._uintUid, this._uintUid = void 0) : d.uid = 0), "none" !== this._encryptionMode && this._encryptionSecret) {
                        if (d.aesmode = this._encryptionMode, d.aespassword = await (async e => {
                            const t = ub("MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDCMnXAHkKIGAM+x4N22gCI+Wyu\nSTM9ztkT3uYslTT2PuKmZfPzhH6kVdO7PTjGCOZnAsyb3oTtWat0KcxQ4jxvqQV+\nHvYl3iI1Yd4vl2c3qRMJPLtRDfNxa2Mcxgq7e9aEUibzdd0st+OJAy3tOj/Y0aVy\nxQiYDz3vqa6bP29adwIDAQAB"),
                                r = await window.crypto.subtle.importKey("spki", t, {
                                    name: "RSA-OAEP",
                                    hash: "SHA-256"
                                }, !0, ["encrypt"]), n = ME(e),
                                i = await window.crypto.subtle.encrypt({name: "RSA-OAEP"}, r, n);
                            return db(new Uint8Array(i))
                        })(this._encryptionSecret), !this._joinAndNotLeaveYet) throw new Hf(qf.INVALID_OPERATION, "[".concat(this._clientId, "] Client already left"));
                        this._encryptionSalt && (d.aessalt = this._encryptionSalt)
                    }
                    this._startSession(this._sessionId, {channel: t, appId: e});
                    const l = this._sessionId;
                    setTimeout(() => {
                        "CONNECTING" === this.connectionState && l === this._sessionId && WE.joinChannelTimeout(this._sessionId, 5)
                    }, 5e3);
                    try {
                        let n;
                        const i = d.cloudProxyServer;
                        if (["proxy3", "proxy4", "proxy5"].includes(i)) {
                            const e = fm("PROXY_SERVER_TYPE3");
                            Array.isArray(e) ? d.proxyServer = e[0] : d.proxyServer = e
                        }
                        if (WE.setProxyServer(d.proxyServer), em.setProxyServer(d.proxyServer), this.store.requestAPStart(), d.stringUid && !d.uid) {
                            const e = await Hw(d.stringUid, d, this._axiosCancelSource.token, this._config.httpRetryConfig || Kf, this.store);
                            em.debug("getUserAccount Success ".concat(d.stringUid, " => ").concat(e)), d.uid = e, n = await qw(d, this._axiosCancelSource.token, this._config.httpRetryConfig || Kf, !0, this.store)
                        } else n = await qw(d, this._axiosCancelSource.token, this._config.httpRetryConfig || Kf, !0, this.store);
                        if (!this._joinAndNotLeaveYet) throw new Hf(qf.INVALID_OPERATION, "[".concat(this._clientId, "] Client already left"));
                        this.store.requestAPEnd(), setTimeout(() => {
                            this._configDistribute.startGetConfigDistribute(d, this._axiosCancelSource.token), this._configDistribute.on(Wv.UPDATE_BITRATE_LIMIT, e => {
                                this._p2pChannel.updateBitrateLimit(e)
                            })
                        }, 0), this._key = r || e;
                        const o = n.gatewayInfo;
                        this._joinInfo = Fk(Fk({}, d), {}, {
                            cid: o.cid,
                            uid: d.uid ? d.uid : o.uid,
                            vid: o.vid,
                            apResponse: o.res,
                            uni_lbs_ip: o.uni_lbs_ip,
                            gatewayAddrs: o.gatewayAddrs
                        });
                        const s = await this._joinGateway();
                        if (!this._joinAndNotLeaveYet) throw new Hf(qf.INVALID_OPERATION, "[".concat(this._clientId, "] Client already left"));
                        u.onSuccess(s), this._appId = e, this._channelName = d.cname, this._uid = s, this.store.uid = s, setTimeout(() => {
                            this._networkQualityInterval && window.clearInterval(this._networkQualityInterval), this._networkQualityInterval = window.setInterval(this._handleUpdateNetworkQuality, 2e3), window.addEventListener(Ih() ? "beforeunload" : "pagehide", this._handleBeforeUnload)
                        }, 0);
                        const a = d.stringUid ? "string uid: ".concat(d.stringUid, ",uid: ").concat(d.uid) : "uid: ".concat(this._uid);
                        return em.info("[".concat(this._clientId, "] Joining channel success: channel: ").concat(t, ",").concat(a)), setTimeout(() => {
                            em.startUpload()
                        }, 5e3), this.store.joinEnd(), h = this, bm.includes(h) || bm.push(h), s
                    } catch (e) {
                        const t = Array.isArray(e) ? e[0] : e;
                        throw em.error("[".concat(this._clientId, "] join number: ").concat(o, ", Joining channel failed, rollback"), t), t.code !== qf.OPERATION_ABORTED && this._numberOfJoinCount === o && (this._gateway.state = "DISCONNECTED", this._reset()), u.onError(t), t
                    }
                    var h
                }

                _joinGateway() {
                    if (!this._joinInfo || !this._key) throw new Hf(qf.INVALID_OPERATION);
                    return this._gateway.join(this._joinInfo, this._key, !("disabled" !== this._joinInfo.cloudProxyServer || this._joinInfo.proxyServer || !fm("JOIN_WITH_FALLBACK_SIGNAL_PROXY"))).then(e => e).catch(e => {
                        if (e.code === qf.INIT_WEBSOCKET_TIMEOUT) return this._gateway.leave(!0, K_.FALLBACK), e;
                        if (e.code === qf.INIT_DATACHANNEL_TIMEOUT) return this._gateway.leave(!0, K_.FALLBACK), e;
                        throw e
                    }).then(e => {
                        if (e instanceof Hf) {
                            if (e.code === qf.INIT_WEBSOCKET_TIMEOUT) {
                                if (em.info("[".concat(this._clientId, "] join timeout, fallback to proxy")), !this._joinInfo || !this._key) throw new Hf(qf.INVALID_OPERATION);
                                this._joinInfo.cloudProxyServer = "fallback", this._cloudProxyServerMode = "fallback", this.store.cloudProxyServerMode = "fallback";
                                const e = fm("PROXY_SERVER_TYPE3");
                                if (Array.isArray(e)) if (this._joinInfo.apUrl) {
                                    const t = new iw(this._joinInfo.apUrl).host.split("."),
                                        r = t.slice(t.length - 2).join(".");
                                    e.forEach(e => {
                                        this._joinInfo && e.includes(r) && (this._joinInfo.proxyServer = e)
                                    }), this._joinInfo.proxyServer || (this._joinInfo.proxyServer = e[0])
                                } else this._joinInfo.proxyServer = e[0]; else this._joinInfo.proxyServer = e;
                                const t = fm("LOG_UPLOAD_SERVER").match(/.+:(\d{1,5})$/);
                                return t && t[1] && "443" !== t[1] && em.setProxyServer(this._joinInfo.proxyServer), "443" !== fm("STATS_COLLECTOR_PORT").toString() && WE.setProxyServer(this._joinInfo.proxyServer), WE.reportApiInvoke(this._sessionId, {
                                    name: M_.JOIN_FALLBACK_TO_PROXY,
                                    options: [this._joinInfo.proxyServer],
                                    tag: U_.TRACER
                                }).onSuccess(), this.emit(z_.JOIN_FALLBACK_TO_PROXY, this._joinInfo.proxyServer), this._gateway.join(this._joinInfo, this._key)
                            }
                            if (em.info("[".concat(this._clientId, "] join by datachannel timeout, fallback to websocket")), !this._joinInfo || !this._key) throw new Hf(qf.INVALID_OPERATION);
                            return WE.reportApiInvoke(this._sessionId, {
                                name: M_.DATACHANNEL_FAILBACK,
                                options: [this.store.clientId],
                                tag: U_.TRACER
                            }).onSuccess(), this._joinGateway()
                        }
                        return e
                    }).then(e => e)
                }

                async leave() {
                    em.info("[".concat(this._clientId, "] Leaving channel")), window.removeEventListener(Ih() ? "beforeunload" : "pagehide", this._handleBeforeUnload), this._reset(), function (e) {
                        const t = bm.indexOf(e);
                        -1 !== t && bm.splice(t, 1)
                    }(this);
                    const e = await this._leaveMutex.lock();
                    if ("DISCONNECTED" === this.connectionState) return em.info("[".concat(this._clientId, "] Leaving channel repeated, success")), void e();
                    await this._gateway.leave("CONNECTED" !== this.connectionState), em.info("[".concat(this._clientId, "] Leaving channel success")), this._joinAndNotLeaveYet = !1, this.store.resetJoinChannelServiceRecords(), e()
                }

                async publish(e) {
                    let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                    if (Array.isArray(e) || (e = [e]), 0 === e.length) throw new Hf(qf.INVALID_PARAMS, "track list is empty");
                    if ("audience" === this._gateway.role) throw new Hf(qf.INVALID_OPERATION, "audience can not publish stream");
                    for (const r of e) {
                        if (!(r instanceof YE)) throw new Hf(qf.INVALID_PARAMS, "parameter is not local track");
                        if (!r._enabled && t) throw new Hf(qf.TRACK_IS_DISABLED, "can not publish a disabled track: ".concat(r.getTrackId()))
                    }
                    em.info("[".concat(this._clientId, "] Publishing tracks, id ").concat(e.map(e => "".concat(e.getTrackId(), " ")))), await this._configDistribute.awaitConfigDistributeComplete(), t && e.forEach(e => {
                        const t = this._configDistribute.getBitrateLimit();
                        e instanceof _A && t && e.setBitrateLimit(t.uplink)
                    });
                    const r = await this._publishMutex.lock();
                    try {
                        await this._publishHighStream(e), em.info("[".concat(this._clientId, "] Publish success, id ").concat(e.map(e => "".concat(e.getTrackId(), " "))))
                    } catch (e) {
                        throw em.error("[".concat(this._clientId, "] publish error"), e.toString()), e
                    } finally {
                        r()
                    }
                }

                async unpublish(e) {
                    if (!this._joinInfo || void 0 === this._uid) throw new Hf(qf.INVALID_OPERATION, "Can't unpublish stream, haven't joined yet!");
                    e ? Array.isArray(e) || (e = [e]) : e = this._p2pChannel.getAllTracks(!0), em.info("[".concat(this._clientId, "] Unpublish tracks, tracks ").concat(e.map(e => "".concat(e.getTrackId(), " ")), " "));
                    const t = await this._publishMutex.lock();
                    try {
                        const r = await this._p2pChannel.unpublish(e);
                        r && await this._gateway.unpublish(r, this._uid), em.info("[".concat(this._clientId, "] Unpublish success,tracks ").concat(e.map(e => "".concat(e.getTrackId()))))
                    } catch (e) {
                        throw em.error("[".concat(this._clientId, "] unpublish error"), e.toString()), e
                    } finally {
                        t && t()
                    }
                }

                async subscribe(e, t) {
                    return this._subscribe(e, t)
                }

                async _subscribe(e, t, r) {
                    if (v_(t, "mediaType", ["audio", "video"]), !this._joinInfo) throw new Hf(qf.INVALID_OPERATION, "Can't subscribe stream, not joined");
                    if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState) throw new Hf(qf.INVALID_OPERATION, "Can't subscribe stream in ".concat(this.connectionState, " state"));
                    if (!this._users.find(t => t === e)) {
                        const t = new Hf(qf.INVALID_REMOTE_USER, "user is not in the channel");
                        throw em.error("[".concat(this._clientId, "] can not subscribe ").concat(e.uid, ", this user is not in the channel")), t
                    }
                    if (!e.hasAudio && !e.hasVideo) {
                        const t = new Hf(qf.INVALID_REMOTE_USER, "user is not published");
                        throw em.error("[".concat(this._clientId, "] can not subscribe ").concat(e.uid, ", user is not published")), t
                    }
                    if (!(r || ("audio" !== t || e.hasAudio && void 0 !== e._audioSSRC) && ("video" !== t || e.hasVideo && void 0 !== e._videoSSRC))) {
                        const r = new Hf(qf.REMOTE_USER_IS_NOT_PUBLISHED);
                        throw em.error("[".concat(this._clientId, "] can not subscribe ").concat(e.uid, " with mediaType ").concat(t, ", remote track is not published")), r
                    }
                    const n = "audio" === t ? e._audioSSRC : e._videoSSRC,
                        i = "audio" === t ? e._audioOrtc : e._videoOrtc, o = "video" === t ? e._rtxSsrcId : void 0,
                        s = {stream_type: "audio" === t ? qv.AUDIO : qv.VIDEO, ssrcId: n},
                        a = await this._subscribeMutex.lock();
                    em.info("[".concat(this._clientId, "] subscribe user ").concat(e.uid, ", mediaType: ").concat(t));
                    try {
                        if (await this._p2pChannel.hasRemoteMediaWithLock(e, t)) await this._p2pChannel.unmuteRemote(e, t); else try {
                            NS.markSubscribeStart(this.store.clientId, n), this.store.subscribe(e.uid, t, Date.now()), await this._p2pChannel.subscribe(e, t, n, o, i);
                            try {
                                await this._gateway.subscribe(e.uid, s, !0)
                            } catch (r) {
                                if ((null == r ? void 0 : r.code) !== qf.WS_ABORT) throw await this._p2pChannel.unsubscribe(e, t), r;
                                await this._p2pChannel.unsubscribe(e, t, !0), this._p2pChannel.setPendingRemoteMedia(e, t)
                            }
                            this.store.subscribe(e.uid, t, void 0, Date.now()), this._p2pChannel.reportSubscribeEvent(!0, null, e, t)
                        } catch (r) {
                            throw this._p2pChannel.reportSubscribeEvent(!1, null == r ? void 0 : r.code, e, t), r
                        }
                        em.info("[".concat(this._clientId, "] subscribe success user ").concat(e.uid, ", mediaType: ").concat(t)), this._defaultStreamFallbackType && this.setStreamFallbackOption(e.uid, this._defaultStreamFallbackType).catch(e => {
                            em.warning("[".concat(this._clientId, "] auto set fallback failed"), e)
                        });
                        const c = "audio" === t ? e._audioTrack : e._videoTrack;
                        if (!c) throw new Hf(qf.UNEXPECTED_ERROR, "can not find remote track in user object");
                        return c
                    } catch (t) {
                        throw em.error("[".concat(this._clientId, "] subscribe user ").concat(e.uid, " error"), t), t
                    } finally {
                        a()
                    }
                }

                async massSubscribe(e) {
                    if (S_(e, "subscribeList"), !this._joinInfo) throw new Hf(qf.INVALID_OPERATION, "Can't subscribe stream, not joined");
                    if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState) throw new Hf(qf.INVALID_OPERATION, "Can't subscribe stream in ".concat(this.connectionState, " state"));
                    const t = Date.now(), r = new Map, n = await this._subscribeMutex.lock();
                    em.info("[".concat(this._clientId, "]start massSubscribe user ").concat(e.map(e => {
                        let {user: t, mediaType: r} = e;
                        return "user: ".concat(null == t ? void 0 : t.uid, ", mediaType: ").concat(r)
                    }).join("; ")));
                    const i = (e = [...e]).map(e => {
                        let {user: t, mediaType: r} = e;
                        return {user: t, mediaType: r}
                    }), o = await this._p2pChannel.globalLock();
                    try {
                        var s;
                        for (let t = e.length - 1; t >= 0; t--) {
                            const n = e[t], {user: o, mediaType: s} = n;
                            if (v_(s, "mediaType", ["audio", "video"]), !o) {
                                const e = new Hf(qf.INVALID_PARAMS, "user property does not exist in subscribeList item");
                                throw em.error("[".concat(this._clientId, "] user property does not exist in subscribeList item")), e
                            }
                            if (!this._users.find(e => e === o)) {
                                const r = new Hf(qf.INVALID_REMOTE_USER, "user is not in the channel");
                                em.error("[".concat(this._clientId, "] can not massSubscribe ").concat(o.uid, ", this user is not in the channel")), i[t].error = r, e.splice(t, 1);
                                continue
                            }
                            if ("audio" === s && (!o.hasAudio || void 0 === o._audioSSRC) || "video" === s && (!o.hasVideo || void 0 === o._videoSSRC)) {
                                const r = new Hf(qf.REMOTE_USER_IS_NOT_PUBLISHED);
                                em.error("[".concat(this._clientId, "] can not subscribe ").concat(o.uid, " with mediaType ").concat(s, ", remote user is not published")), i[t].error = r, e.splice(t, 1);
                                continue
                            }
                            const a = Ov.Video | Ov.LwoVideo, c = r.get(o);
                            if (c) {
                                if ("video" === s ? c & a : c & Ov.Audio) {
                                    e.splice(t, 1), em.warning("repeat massSubscribe user:".concat(o.uid, ", mediaType:").concat(s, " twice"));
                                    continue
                                }
                                r.set(o, c | ("video" === s ? a : Ov.Audio))
                            } else r.set(o, "video" === s ? a : Ov.Audio)
                        }
                        for (let t = e.length - 1; t >= 0; t--) {
                            const n = e[t], {user: i, mediaType: o} = n, s = Ov.Video | Ov.LwoVideo;
                            if (this._p2pChannel.hasRemoteMedia(i, o)) {
                                await this._p2pChannel.unmuteRemoteNoLock(i, o);
                                const n = r.get(i);
                                r.set(i, "video" === o ? n ^ s : n ^ Ov.Audio), e.splice(t, 1)
                            }
                        }
                        this.store.massSubscribe(e.map(e => ({userId: e.user.uid, type: e.mediaType})), t);
                        const a = Kr(s = Array.from(r.entries())).call(s, (e, t) => {
                            let [r, n] = t;
                            if (0 === n) return e;
                            const i = {stream_id: r.uid, stream_type: n};
                            return n & Ov.Audio && (i.audio_ssrc = r._audioSSRC), n & Ov.Video && (i.video_ssrc = r._videoSSRC), e.push(i), e
                        }, []);
                        try {
                            e.length > 0 && await this._p2pChannel.massSubscribeNoLock(e.map(e => {
                                let {user: t, mediaType: r} = e;
                                return {
                                    user: t,
                                    mediaType: r,
                                    ssrcId: r === qv.VIDEO ? t._videoSSRC : t._audioSSRC,
                                    rtxSsrcId: t._rtxSsrcId
                                }
                            }));
                            const r = new Map;
                            if (a.length > 0) {
                                const e = await this._gateway.subscribeAll(a, !0);
                                ((null == e ? void 0 : e.users) || []).forEach(e => {
                                    let {stream_id: t, video_error_code: n, audio_error_code: i, error_code: o} = e;
                                    (n || i || o) && r.set(t, {video_error_code: n, audio_error_code: i, error_code: o})
                                })
                            }
                            if (Array.from(r.entries()).length > 0) {
                                const e = Array.from(r.entries()).map(e => {
                                    let t, [r, n] = e;
                                    return n.error_code || n.video_error_code && n.audio_error_code ? t = void 0 : n.video_error_code ? t = qv.VIDEO : n.audio_error_code && (t = qv.AUDIO), {
                                        user: this.remoteUsers.find(e => e.uid === r),
                                        mediaType: t
                                    }
                                });
                                await this._p2pChannel.massUnsubscribeNoLock(e)
                            }
                            for (const e of i) {
                                const t = r.get(e.user.uid);
                                if (t) {
                                    const r = t.error_code || "audio" === e.mediaType && t.audio_error_code || "video" === e.mediaType && t.video_error_code;
                                    if (r) {
                                        const t = cw(r);
                                        em.error("user:".concat(e.user.uid, " mediaType:").concat(e.mediaType, " has massSubscribe error ").concat(t.desc)), e.error = new Hf(qf.SUBSCRIBE_FAILED, "code ".concat(r, ": ").concat(t.desc))
                                    }
                                }
                                e.error || ("video" === e.mediaType ? e.track = e.user.videoTrack : e.track = e.user.audioTrack)
                            }
                            return this.store.massSubscribe(i.filter(e => !e.error).map(e => ({
                                userId: e.user.uid,
                                type: e.mediaType
                            })), void 0, Date.now()), i.forEach(e => {
                                var r;
                                WE.subscribe(this.store.sessionId, {
                                    succ: !!e.error,
                                    ec: (null === (r = e.error) || void 0 === r ? void 0 : r.code) || null,
                                    video: e.mediaType === qv.VIDEO,
                                    audio: e.mediaType === qv.AUDIO,
                                    peerid: e.user.uid,
                                    subscribeRequestid: e.mediaType === qv.VIDEO ? e.user._videoSSRC : e.user._audioSSRC,
                                    p2pid: this.store.p2pId,
                                    eventElapse: Math.floor(performance.now() - t)
                                }, !0)
                            }), em.info("[".concat(this._clientId, "] massSubscribe success ").concat(e.map(e => {
                                let {user: t, mediaType: r} = e;
                                return "user: ".concat(null == t ? void 0 : t.uid, ", mediaType: ").concat(r)
                            }).join("; "))), i
                        } catch (t) {
                            throw await this._p2pChannel.massUnsubscribeNoLock(e), t
                        }
                    } finally {
                        o(), n()
                    }
                }

                async unsubscribe(e, t) {
                    if (t && v_(t, "mediaType", ["audio", "video"]), !this._joinInfo) throw new Hf(qf.INVALID_OPERATION, "Can't unsubscribe stream, haven't joined yet!");
                    if (!this._users.find(t => t === e)) {
                        const t = new Hf(qf.INVALID_REMOTE_USER, "user is not in the channel");
                        throw em.error("[".concat(this._clientId, "] can not unsubscribe ").concat(e.uid, ", user is not in the channel")), t
                    }
                    em.info("[".concat(this._clientId, "] unsubscribe uid: ").concat(e.uid, ", mediaType: ").concat(t));
                    try {
                        const r = await this._p2pChannel.unsubscribe(e, t);
                        r && await this._gateway.unsubscribe(r, e.uid), em.info("[".concat(this._clientId, "] unsubscribe success uid: ").concat(e.uid, ", mediaType: ").concat(t))
                    } catch (t) {
                        if (t.code === qf.DISCONNECT_P2P) return void em.warning("disconnecting p2p, abort unsubscribe request.");
                        throw em.error("[".concat(this._clientId, "] unsubscribe user ").concat(e.uid, " error"), t.toString()), t
                    }
                }

                async massUnsubscribe(e) {
                    if (S_(e, "unsubscribeList"), !this._joinInfo) throw new Hf(qf.INVALID_OPERATION, "Can't unsubscribeAll stream, haven't joined yet!");
                    em.info("[".concat(this._clientId, "] start massUnsubscribe ").concat(e.map(e => {
                        let {user: t, mediaType: r} = e;
                        return "user: ".concat(null == t ? void 0 : t.uid, ", mediaType: ").concat(r, ";")
                    }).join())), e = [...e];
                    const t = new Map;
                    for (let r = e.length - 1; r >= 0; r--) {
                        const {user: n, mediaType: i} = e[r];
                        if (!n) {
                            const e = new Hf(qf.INVALID_PARAMS, "user property does not exist in unsubscribeList item");
                            throw em.error("[".concat(this._clientId, "] user property does not exist in unsubscribeList item")), e
                        }
                        if (v_(i, "mediaType", ["video", "audio", void 0]), !this._users.find(e => e === n)) {
                            em.warning("[".concat(this._clientId, "] can not unsubscribe ").concat(n.uid, ", user is not in the channel")), e.splice(r, 1);
                            continue
                        }
                        const o = Ov.Video | Ov.LwoVideo;
                        if (t.has(n)) {
                            const s = t.get(n);
                            let a;
                            switch (i) {
                                case"video":
                                    a = s & o;
                                    break;
                                case"audio":
                                    a = s & Ov.Audio;
                                    break;
                                default:
                                    a = s & (Ov.Audio | o)
                            }
                            if (a) {
                                em.warning("repeat massUnsubscribe user:".concat(n.uid, ",mediaType:").concat(i, " twice.")), e.splice(r, 1);
                                continue
                            }
                            i ? "audio" === i ? t.set(n, s | Ov.Audio) : "video" === i && t.set(n, s | o) : t.set(n, s | Ov.Audio | o)
                        } else i ? "audio" === i ? t.set(n, Ov.Audio) : "video" === i && t.set(n, o) : t.set(n, Ov.Audio | o)
                    }
                    try {
                        const t = await this._p2pChannel.massUnsubscribe(e);
                        t && await this._gateway.massUnsubscribe(t), em.info("[".concat(this._clientId, "] massUnsubscribe success ").concat(e.map(e => {
                            let {user: t, mediaType: r} = e;
                            return "user: ".concat(null == t ? void 0 : t.uid, ", mediaType: ").concat(r, ";")
                        }).join()))
                    } catch (e) {
                        if (e.code === qf.DISCONNECT_P2P) return void em.warning("disconnecting p2p, abort unsubscribe request.");
                        throw em.error("[".concat(this._clientId, "] massUnsubscribe error"), e.toString()), e
                    }
                }

                setLowStreamParameter(e) {
                    !function (e) {
                        if (!e) throw new Hf(qf.INVALID_PARAMS);
                        R_(e.width) || E_(e.width, "streamParameter.width"), R_(e.height) || E_(e.height, "streamParameter.height"), R_(e.framerate) || E_(e.framerate, "streamParameter.framerate"), R_(e.bitrate) || g_(e.bitrate, "streamParameter.bitrate")
                    }(e), (!e.width && e.height || e.width && !e.height) && em.warning("[".concat(this._clientId, "] The width and height parameters take effect only when both are set")), em.info("[".concat(this._clientId, "] set low stream parameter to"), JSON.stringify(e));
                    const t = this._configDistribute.getLowStreamConfigDistribute();
                    t && t.bitrate && e.bitrate && t.bitrate < e.bitrate && (e.bitrate = t.bitrate), this._lowStreamParameter = e
                }

                async enableDualStream() {
                    if (!og().supportDualStream) throw WE.streamSwitch(this._sessionId, {
                        lts: Date.now(),
                        isdual: !0,
                        succ: !1
                    }), new Hf(qf.NOT_SUPPORTED, "Your browser is not support dual stream");
                    if (this._isDualStreamEnabled) throw new Hf(qf.INVALID_OPERATION, "Dual stream is already enabled");
                    if (this._p2pChannel.canPublishLowStream()) try {
                        await this._publishLowStream()
                    } catch (e) {
                        throw WE.streamSwitch(this._sessionId, {lts: Date.now(), isdual: !0, succ: !1}), e
                    }
                    this._isDualStreamEnabled = !0, WE.streamSwitch(this._sessionId, {
                        lts: Date.now(),
                        isdual: !0,
                        succ: !0
                    }), em.info("[".concat(this._clientId, "] enable dual stream"))
                }

                async disableDualStream() {
                    if (this._isDualStreamEnabled) {
                        if (!this._joinInfo) throw new Hf(qf.INVALID_OPERATION, "Can't publish stream, haven't joined yet!");
                        if (this._p2pChannel.getLocalMedia(Hv.LocalVideoLowTrack)) try {
                            const e = await this._p2pChannel.unpublishLowStream();
                            e && await this._gateway.unpublish(e, this._joinInfo.stringUid || this._joinInfo.uid)
                        } catch (e) {
                            throw WE.streamSwitch(this._sessionId, {lts: Date.now(), isdual: !1, succ: !1}), e
                        }
                        this._isDualStreamEnabled = !1, WE.streamSwitch(this._sessionId, {
                            lts: Date.now(),
                            isdual: !1,
                            succ: !0
                        }), em.info("[".concat(this._clientId, "] disable dual stream"))
                    }
                }

                async setClientRole(e, t) {
                    if (function (e) {
                        v_(e, "role", ["audience", "host"])
                    }(e), t && ov(t), "rtc" === this._mode) throw em.warning("[".concat(this._clientId, "]rtc mode can not use setClientRole")), new Hf(qf.INVALID_OPERATION, "rtc mode can not use setClientRole");
                    if (t && t.level && "host" === e) throw new Hf(qf.INVALID_OPERATION, "host mode can not set audience latency level");
                    if ("audience" === e && this._p2pChannel.hasLocalMedia()) throw new Hf(qf.INVALID_OPERATION, "can not set client role to audience when publishing stream");
                    await this._gateway.setClientRole(e, t), em.info("[".concat(this._clientId, "] set client role to ").concat(e, ", level: ").concat(t && t.level))
                }

                setProxyServer(e, t) {
                    if (y_(e, "proxyServer"), !t) {
                        if ("DISCONNECTED" !== this.connectionState) throw new Hf(qf.INVALID_OPERATION, "Set proxy server before join channel");
                        if ("disabled" !== this._cloudProxyServerMode || this._useLocalAccessPoint) throw new Hf(qf.INVALID_OPERATION, "You have already set the proxy")
                    }
                    this._proxyServer = e, WE.setProxyServer(this._proxyServer), em.setProxyServer(this._proxyServer), em.info("[".concat(this._clientId, "] Set proxy server ").concat(t ? "by initialize call" : "", " success."))
                }

                setTurnServer(e, t) {
                    if (Array.isArray(e) || (e = [e]), !t) {
                        if ("DISCONNECTED" !== this.connectionState) throw new Hf(qf.INVALID_OPERATION, "Set turn server before join channel");
                        if ("disabled" !== this._cloudProxyServerMode || this._useLocalAccessPoint) throw new Hf(qf.INVALID_OPERATION, "You have already set the proxy")
                    }
                    if (nv(e)) return this._turnServer = {
                        servers: e,
                        mode: "original-manual"
                    }, void em.info("[".concat(this._clientId, "] Set original turnserver ").concat(t ? "by initialize call" : "", " success: ").concat(e.map(e => e.urls).join(","), "."));
                    e.forEach(e => iv(e)), this._turnServer = {
                        servers: e,
                        mode: "manual"
                    }, em.info("[".concat(this._clientId, "] Set turnserver ").concat(t ? "by initialize call" : "", " success."))
                }

                setLicense(e) {
                    if ("DISCONNECTED" !== this.connectionState) throw new Hf(qf.INVALID_OPERATION, "you should set license before join channel");
                    if (y_(e, "license", 32, 32), !/^[A-Za-z\d]+$/.test(e)) throw new Hf(qf.INVALID_PARAMS, "license should only contains characters from A-Z a-z 0-9");
                    this._license = e, em.info("[".concat(this._clientId, "] set license success"), e)
                }

                startProxyServer(e) {
                    if ("DISCONNECTED" !== this.connectionState) throw new Hf(qf.INVALID_OPERATION, "Start proxy server before join channel");
                    if (this._proxyServer || "manual" === this._turnServer.mode || this._useLocalAccessPoint) throw new Hf(qf.INVALID_OPERATION, "You have already set the proxy");
                    const t = [3, 4, 5];
                    let r;
                    switch (void 0 === e && (e = 3), e) {
                        case 1:
                        case 2:
                            throw new Hf(qf.NOT_SUPPORTED, "proxy mode 1/2 has been deprecated and not supported.");
                        case 3:
                            r = "proxy3";
                            break;
                        case 4:
                            r = "proxy4";
                            break;
                        case 5:
                            r = "proxy5";
                            break;
                        default:
                            throw new Hf(qf.INVALID_PARAMS, "proxy server mode must be ".concat(t.join("|")))
                    }
                    this._cloudProxyServerMode = r, this.store.cloudProxyServerMode = r, em.info("[".concat(this._clientId, "] set cloud proxy server mode to"), this._cloudProxyServerMode)
                }

                stopProxyServer() {
                    if ("DISCONNECTED" !== this.connectionState) throw new Hf(qf.INVALID_OPERATION, "Stop proxy server after leave channel");
                    WE.setProxyServer(), em.setProxyServer(), this._cloudProxyServerMode = "disabled", this.store.cloudProxyServerMode = "disabled", em.info("[".concat(this._clientId, "] set cloud proxy server mode to"), this._cloudProxyServerMode), this._proxyServer = void 0, this._turnServer = {
                        mode: "auto",
                        servers: []
                    }
                }

                setLocalAccessPointsV2(e) {
                    if (!e.accessPoints) throw new Hf(qf.INVALID_PARAMS, "accessPoints is required.");
                    S_(e.accessPoints.serverList, "accessPoints.serverList"), y_(e.accessPoints.domain, "accessPoints.domain");
                    const t = (e, t) => {
                        g_(e, t, 0, 65535, !0)
                    };
                    let r = 443;
                    if (e.accessPoints.port && (t(e.accessPoints.port, "accessPoints.port"), r = e.accessPoints.port), this._proxyServer || "disabled" !== this._cloudProxyServerMode) throw new Hf(qf.INVALID_OPERATION, "set local access point failed, You have already set the cloud proxy");
                    fm("CLOSE_AFB_FOR_LOCAL_AP") && (pm("JOIN_WITH_FALLBACK_SIGNAL_PROXY", !1), pm("JOIN_WITH_FALLBACK_MEDIA_PROXY", !1));
                    const n = /^((\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.){3}(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])$/,
                        i = e.accessPoints.domain,
                        o = e.accessPoints.serverList.map(e => n.test(e) ? "".concat(e.replace(/\./g, "-"), ".").concat(i) : e),
                        s = o.map(e => "".concat(e, ":").concat(r));
                    this._useLocalAccessPoint = !0, this._setLocalAPVersion = 2, pm("WEBCS_DOMAIN", s), pm("WEBCS_DOMAIN_BACKUP_LIST", s), pm("GATEWAY_DOMAINS", [i]), e.report && e.report.hostname && Array.isArray(e.report.hostname) && e.report.hostname.length ? (S_(e.report.hostname, "report.hostname"), pm("EVENT_REPORT_DOMAIN", e.report.hostname[0]), pm("EVENT_REPORT_BACKUP_DOMAIN", e.report.hostname[1] || e.report.hostname[0])) : (pm("EVENT_REPORT_DOMAIN", o[0]), pm("EVENT_REPORT_BACKUP_DOMAIN", o[1] || o[0]));
                    let a = 6443;
                    e.report && e.report.port && (t(e.report.port, "report.port"), a = e.report.port), pm("STATS_COLLECTOR_PORT", a), e.report ? pm("ENABLE_EVENT_REPORT", !0) : pm("ENABLE_EVENT_REPORT", !1);
                    let c = "";
                    e.log && e.log.hostname && Array.isArray(e.log.hostname) && e.log.hostname.length ? (S_(e.log.hostname, "log.hostname"), c = e.log.hostname[0]) : c = o[0];
                    let u = 6444;
                    e.log && e.log.port && (t(e.log.port, "log.port"), u = e.log.port), pm("LOG_UPLOAD_SERVER", "".concat(c, ":").concat(u));
                    let d = [];
                    e.cds && e.cds.hostname && Array.isArray(e.cds.hostname) && e.cds.hostname.length ? (S_(e.cds.hostname, "cds.hostname"), d = e.cds.hostname) : d = o;
                    let l = 443;
                    e.cds && e.cds.port && (t(e.cds.port, "cds.port"), l = e.cds.port), pm("CDS_AP", d.map(e => "".concat(e, ":").concat(l))), e.cds ? pm("ENABLE_CONFIG_DISTRIBUTE", !0) : pm("ENABLE_CONFIG_DISTRIBUTE", !1), em.info("set local access point v2 success")
                }

                setLocalAccessPoints(e, t) {
                    if (S_(e, "serverList"), y_(t, "domain"), this._proxyServer || "disabled" !== this._cloudProxyServerMode) throw new Hf(qf.INVALID_OPERATION, "set local access point failed, You have already set the cloud proxy");
                    const r = /^(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])$/;
                    e = e.map(e => r.test(e) ? "".concat(e.replace(/\./g, "-"), ".").concat(t) : e), this._useLocalAccessPoint = !0, this._setLocalAPVersion = 1, pm("WEBCS_DOMAIN", e), pm("WEBCS_DOMAIN_BACKUP_LIST", e), pm("GATEWAY_DOMAINS", [t]), pm("EVENT_REPORT_DOMAIN", e[0]), pm("EVENT_REPORT_BACKUP_DOMAIN", e[1] || e[0]), pm("LOG_UPLOAD_SERVER", "".concat(e[0], ":6444")), em.info("set local access point success")
                }

                async setRemoteDefaultVideoStreamType(e) {
                    if (v_(e, "streamType", [0, 1]), this._remoteDefaultVideoStreamType = e, this._joinInfo) try {
                        await this._gateway.setDefaultRemoteVideoStreamType(e), this._joinInfo.defaultVideoStream = this._remoteDefaultVideoStreamType
                    } catch (e) {
                        throw em.error("[".concat(this._clientId, "] set default remote video stream type error"), e.toString()), e
                    } else em.debug("haven't joined yet, cache remoteDefaultVideoStreamType ".concat(e))
                }

                async setRemoteVideoStreamType(e, t) {
                    v_(t, "streamType", [0, 1]);
                    try {
                        await this._gateway.setRemoteVideoStreamType(e, t), setTimeout(() => {
                            const t = this._users.find(t => t.uid === e);
                            t && t.videoTrack && t.videoTrack.updateMediaStreamTrackResolution()
                        }, 2e3)
                    } catch (e) {
                        throw em.error("[".concat(this._clientId, "] set remote video stream type error"), e.toString()), e
                    }
                    em.info("[".concat(this._clientId, "] set remote ").concat(e, " video stream type to ").concat(t)), this._remoteStreamTypeCacheMap.set(e, t)
                }

                async setStreamFallbackOption(e, t) {
                    v_(t, "fallbackType", [0, 1, 2]);
                    try {
                        await this._gateway.setStreamFallbackOption(e, t)
                    } catch (e) {
                        throw em.error("[".concat(this._clientId, "] set stream fallback option"), e.toString()), e
                    }
                    em.info("[".concat(this._clientId, "] set remote ").concat(e, " stream fallback type to ").concat(t)), this._streamFallbackTypeCacheMap.set(e, t)
                }

                setEncryptionConfig(e, t, r) {
                    if (function (e) {
                        v_(e, "encryptionMode", ["aes-128-xts", "aes-256-xts", "aes-128-ecb", "sm4-128-ecb", "aes-128-gcm", "aes-256-gcm", "aes-128-gcm2", "aes-256-gcm2", "none"])
                    }(e), y_(t, "secret"), ["aes-128-gcm2", "aes-256-gcm2"].includes(e)) {
                        if (!r || !(r instanceof Uint8Array && 32 === r.length)) throw new Hf(qf.INVALID_PARAMS, "salt must be an Uint8Array and exactly equal to 32 bytes")
                    } else if (r) throw new Hf(qf.INVALID_PARAMS, "current encrypt mode does not need salt");
                    new RegExp("^(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[!@#$%^&*,.<>?/:;'\"|{}\\[\\]])(?=.{8,})").test(t) || em.warning("The secret is not strong:\n      The secret must contain at least 1 lowercase alphabetical character,\n      The secret must contain at least 1 uppercase alphabetical character,\n      The secret must contain at least 1 numeric character,\n      The secret must contain at least one special character,\n      The secret must be eight characters or longer.\n      "), this._encryptionMode = e, this._encryptionSecret = t, r && (this._encryptionSalt = db(r))
                }

                async renewToken(e) {
                    if (y_(e, "token", 1, 2047), !this._key || !this._joinInfo) throw new Hf(qf.INVALID_OPERATION, "renewToken should not be called before user join");
                    const t = this._key;
                    this._key = e, this._joinInfo && (this._joinInfo.token = e);
                    const r = await this._renewTokenMutex.lock();
                    try {
                        if (fm("USE_NEW_TOKEN")) {
                            em.debug("start renew token with ticket from unilbs");
                            const t = await async function (e, t, r) {
                                let n = null;
                                const i = [], o = async o => {
                                    const s = fm(o ? "WEBCS_DOMAIN_BACKUP_LIST" : "WEBCS_DOMAIN").map(t => e.proxyServer ? "https://".concat(e.proxyServer, "/ap/?url=").concat(t + "/api/v2/transpond/webrtc?v=2") : "https://".concat(t, "/api/v2/transpond/webrtc?v=2"));
                                    return o && (await zS(1e3), null !== n) ? n : await pb({
                                        fragementLength: fm("FRAGEMENT_LENGTH"),
                                        referenceList: s,
                                        asyncMapHandler: n => (em.debug("[".concat(e.clientId, "] update ticket, Connect to ").concat(o ? "backup" : "", " choose_server:"), n), function (e, t, r, n) {
                                            const [i] = Mw(t, [sg.CHOOSE_SERVER]);
                                            let o = DE.networkState;
                                            return Yf(async () => {
                                                o && DE.networkState === Yv.OFFLINE && DE.onlineWaiter && await sl.race([DE.onlineWaiter, zS(n && n.maxRetryTimeout || Kf.maxRetryTimeout)]), o = DE.networkState;
                                                const t = await NE(e, {
                                                    data: i,
                                                    cancelToken: r,
                                                    headers: {"Content-Type": "multipart/form-data;"}
                                                }, !0);
                                                return Lw(t, e)
                                            }, () => !1, e => e.code !== qf.OPERATION_ABORTED && (e.code === qf.UPDATE_TICKET_FAILED ? e.data.retry : (em.warning("[".concat(t.clientId, "] update ticket network error, retry"), e), !0)), n)
                                        }(n, e, t, r)),
                                        allFailedhandler: e => {
                                            throw e[0]
                                        },
                                        promisesCollector: i
                                    })
                                };
                                try {
                                    return n = await $S([o(!1), o(!0)]), i.length && i.forEach(e => e.cancel && "function" == typeof e.cancel && e.cancel()), n
                                } catch (e) {
                                    throw e[0]
                                }
                            }(this._joinInfo, this._axiosCancelSource.token, this._config.httpRetryConfig || Kf);
                            em.debug("[".concat(this._clientId, "] get ticket from unilbs success")), await this._gateway.renewToken({
                                token: e,
                                ticket: t
                            })
                        } else em.debug("start renew token without ticket"), await this._gateway.renewToken({token: e});
                        em.debug("[".concat(this._clientId, "] renewToken success"))
                    } catch (e) {
                        throw this._key = t, this._joinInfo.token = t, em.error("[".concat(this._clientId, "] renewToken failed"), e.toString()), e
                    } finally {
                        r()
                    }
                }

                enableAudioVolumeIndicator() {
                    this._audioVolumeIndicationInterval ? em.warning("you have already enabled audio volume indicator!") : this._audioVolumeIndicationInterval = window.setInterval(() => {
                        const e = this._p2pChannel.getAudioLevels();
                        this.emit(z_.VOLUME_INDICATOR, e)
                    }, fm("AUDIO_VOLUME_INDICATION_INTERVAL") || 2e3)
                }

                getRTCStats() {
                    const e = this._statsCollector.getRTCStats(), t = this._gateway.getInChannelInfo();
                    return e.Duration = Math.round(t.duration / 1e3), e
                }

                async startLiveStreaming(e, t) {
                    if (!t) {
                        if ("h264" !== this._codec) throw new Hf(qf.LIVE_STREAMING_INVALID_RAW_STREAM, "raw streaming is only support h264");
                        if (!this._p2pChannel.hasLocalMedia()) throw new Hf(qf.LIVE_STREAMING_INVALID_RAW_STREAM, "can not find stream to raw streaming")
                    }
                    if (this._liveRawStreamingClient && this._liveRawStreamingClient.hasUrl(e) || this._liveTranscodeStreamingClient && this._liveTranscodeStreamingClient.hasUrl(e)) throw new Hf(qf.LIVE_STREAMING_TASK_CONFLICT);
                    const r = t ? hv.TRANSCODE : hv.RAW;
                    return this._createLiveStreamingClient(r).startLiveStreamingTask(e, r)
                }

                setLiveTranscoding(e) {
                    return this._createLiveStreamingClient(hv.TRANSCODE).setTranscodingConfig(e)
                }

                async stopLiveStreaming(e) {
                    const t = [this._liveRawStreamingClient, this._liveTranscodeStreamingClient].filter(t => t && t.hasUrl(e));
                    if (!t.length) throw new Hf(qf.INVALID_PARAMS, "can not find live streaming url to stop");
                    await sl.all(t.map(t => t && t.stopLiveStreamingTask(e)))
                }

                async addInjectStreamUrl(e, t) {
                    if (!this._joinInfo) throw new Hf(qf.INVALID_OPERATION, "can not addInjectStreamUrl, no joininfo");
                    const r = this._createLiveStreamingClient(hv.INJECT);
                    r.setInjectStreamConfig(t, 0), await r.startLiveStreamingTask(e, hv.INJECT)
                }

                async removeInjectStreamUrl() {
                    var e;
                    const t = this._createLiveStreamingClient(hv.INJECT),
                        r = Array.from(pS(e = t.streamingTasks).call(e)).find(e => e.mode === hv.INJECT);
                    if (!this._joinInfo || !r) throw new Hf(qf.INVALID_OPERATION, "can remove addInjectStreamUrl, no joininfo or inject task");
                    await t.stopLiveStreamingTask(r.url)
                }

                async startChannelMediaRelay(e) {
                    rC(e);
                    const t = this._createChannelMediaRelayClient();
                    await t.startChannelMediaRelay(e)
                }

                async updateChannelMediaRelay(e) {
                    rC(e);
                    const t = this._createChannelMediaRelayClient();
                    await t.updateChannelMediaRelay(e)
                }

                async stopChannelMediaRelay() {
                    const e = this._createChannelMediaRelayClient();
                    await e.stopChannelMediaRelay()
                }

                sendStreamMessage(e) {
                    let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                    if (!this._joinInfo) throw new Hf(qf.INVALID_OPERATION, "can not send data stream, not joined");
                    if ("string" == typeof e && (e = (new TextEncoder).encode(e)), new Blob([e]).size > 1024) throw new Hf(qf.INVALID_PARAMS, "stream message out of range.");
                    return this._gateway.signal.request(Q_.DATA_STREAM, {payload: db(e)}, !t)
                }

                sendMetadata(e) {
                    if (!this._joinInfo) throw new Hf(qf.INVALID_OPERATION, "can not send metadata, not joined");
                    if (new Blob([e]).size > 1024) throw new Hf(qf.METADATA_OUT_OF_RANGE);
                    return this._gateway.signal.request(Q_.SEND_METADATA, {
                        session_id: this._joinInfo.sid,
                        metadata: db(e)
                    })
                }

                async sendCustomReportMessage(e) {
                    if (Array.isArray(e) || (e = [e]), e.forEach(N_), !this._joinInfo) throw new Hf(qf.INVALID_OPERATION, "can not send custom report, not joined");
                    await WE.sendCustomReportMessage(this._joinInfo.sid, e)
                }

                getLocalAudioStats() {
                    return this._statsCollector.getLocalAudioTrackStats()
                }

                getRemoteAudioStats() {
                    return this._statsCollector.getRemoteAudioTrackStats()
                }

                getLocalVideoStats() {
                    return this._statsCollector.getLocalVideoTrackStats()
                }

                getRemoteVideoStats() {
                    return this._statsCollector.getRemoteVideoTrackStats()
                }

                getRemoteNetworkQuality() {
                    return this._statsCollector.getRemoteNetworkQualityStats()
                }

                async pickSVCLayer(e, t) {
                    v_(t.spatialLayer, "spatialLayer", [0, 1, 2, 3]), v_(t.temporalLayer, "temporalLayer", [0, 1, 2, 3]);
                    try {
                        await this._gateway.pickSVCLayer(e, t)
                    } catch (e) {
                        throw em.error("[".concat(this._clientId, "] pick SVC layer failed"), e.toString()), e
                    }
                }

                _reset() {
                    if (em.debug("[".concat(this._clientId, "] reset client")), this._axiosCancelSource.cancel(), this._axiosCancelSource = Bf.CancelToken.source(), this._streamFallbackTypeCacheMap = new Map, this._remoteStreamTypeCacheMap = new Map, this._configDistribute.stopGetConfigDistribute(), this._joinInfo = void 0, this._proxyServer = void 0, this._defaultStreamFallbackType = void 0, this._sessionId = null, this.store.sessionId = null, this._statsCollector.reset(), this._key = void 0, this._appId = void 0, this._uid = void 0, this.store.uid = void 0, this._channelName = void 0, this._encryptionMode = "none", this._encryptionSecret = null, this._encryptionSalt = null, this._users.forEach(e => {
                        e._audioTrack && e._audioTrack._destroy(), e._videoTrack && e._videoTrack._destroy()
                    }), this._users = [], this._audioVolumeIndicationInterval && (window.clearInterval(this._audioVolumeIndicationInterval), this._audioVolumeIndicationInterval = void 0), "fallback" === this._cloudProxyServerMode && (this._cloudProxyServerMode = "disabled", this.store.cloudProxyServerMode = "disabled"), this._p2pChannel.reset(), this._publishMutex = new KE("client-publish"), this._subscribeMutex = new KE("client-subscribe"), this._networkQualityInterval && (window.clearInterval(this._networkQualityInterval), this._networkQualityInterval = void 0), this._injectStreamingClient && (this._injectStreamingClient.terminate(), this._injectStreamingClient.removeAllListeners(), this._injectStreamingClient = void 0), this._liveRawStreamingClient && (this._liveRawStreamingClient.terminate(), this._liveRawStreamingClient.removeAllListeners(), this._liveRawStreamingClient = void 0), this._liveTranscodeStreamingClient && (this._liveTranscodeStreamingClient.terminate(), this._liveTranscodeStreamingClient.removeAllListeners(), this._liveTranscodeStreamingClient = void 0), this._channelMediaRelayClient && (this._channelMediaRelayClient.dispose(), this._channelMediaRelayClient = void 0), this._inspect) try {
                        this._inspect.close(), this._inspect = void 0
                    } catch (e) {
                    }
                }

                _startSession(e, t) {
                    const r = e || JS();
                    e ? em.debug("[".concat(this._clientId, "] new Session ").concat(r)) : em.debug("[".concat(this._clientId, "] renewSession ").concat(this._sessionId, " => ").concat(r)), this._sessionId = r, this.store.sessionId = r, t ? WE.sessionInit(this._sessionId, {
                        lts: (new Date).getTime(),
                        cname: t.channel,
                        appid: t.appId,
                        mode: this._mode
                    }) : this._joinInfo ? WE.sessionInit(this._sessionId, {
                        lts: (new Date).getTime(),
                        cname: this._joinInfo.cname,
                        appid: this._joinInfo.appId,
                        mode: this._mode
                    }) : this._gateway.joinInfo && WE.sessionInit(this._sessionId, {
                        lts: (new Date).getTime(),
                        cname: this._gateway.joinInfo.cname,
                        appid: this._gateway.joinInfo.appId,
                        mode: this._mode
                    }), this._joinInfo && (this._joinInfo.sid = r), this._gateway.joinInfo && (this._gateway.joinInfo.sid = r)
                }

                async _publishHighStream(e) {
                    if (!this._joinInfo || void 0 === this._uid) throw new Hf(qf.INVALID_OPERATION, "Can't publish stream, haven't joined yet!");
                    if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState) throw new Hf(qf.INVALID_OPERATION, "can not publish stream in ".concat(this.connectionState, " state"));
                    if ("auto" === this._turnServer.mode && fm("FORCE_TURN") && !fm("TURN_ENABLE_TCP") && !fm("TURN_ENABLE_UDP")) throw new Hf(qf.UNEXPECTED_ERROR, "force TURN With No TURN Configuration");
                    em.debug("[".concat(this._clientId, "] publish high stream"));
                    try {
                        const r = await this._p2pChannel.publish(e, this._isDualStreamEnabled, this._lowStreamParameter),
                            n = (await r.next()).value;
                        if (n) {
                            var t;
                            let i;
                            try {
                                i = await this._gateway.publish(this._uid, n, !0)
                            } catch (e) {
                                if (e.code !== qf.DISCONNECT_P2P) throw r.throw(e), e
                            }
                            await r.next((null === (t = i) || void 0 === t ? void 0 : t.ortc) || [])
                        }
                        this._p2pChannel.reportPublishEvent(!0, null);
                        for (const t of e) t instanceof _A && t._encoderConfig && this._gateway.setVideoProfile(t._encoderConfig), !t.muted && t.enabled || await this._p2pChannel.muteLocalTrack(t)
                    } catch (t) {
                        if (this._p2pChannel.reportPublishEvent(!1, null == t ? void 0 : t.code, e), (null == t ? void 0 : t.code) === qf.WS_ABORT) return;
                        throw t
                    }
                }

                async _publishLowStream() {
                    if (!this._joinInfo || void 0 === this._uid) throw new Hf(qf.INVALID_OPERATION, "Can't publish stream, haven't joined yet!");
                    if ("CONNECTED" !== this.connectionState && "RECONNECTING" !== this.connectionState) throw new Hf(qf.INVALID_OPERATION, "can not publish stream in ".concat(this.connectionState, " state"));
                    em.debug("[".concat(this._clientId, "] publish low stream"));
                    const e = this._configDistribute.getLowStreamConfigDistribute();
                    e && e.bitrate && (this._lowStreamParameter || (this._lowStreamParameter = {
                        width: 160,
                        height: 120,
                        framerate: 15,
                        bitrate: 50
                    }), this._lowStreamParameter && this._lowStreamParameter.bitrate && e.bitrate < this._lowStreamParameter.bitrate && (this._lowStreamParameter.bitrate = e.bitrate));
                    try {
                        const r = await this._p2pChannel.publishLowStream(this._lowStreamParameter),
                            n = (await r.next()).value;
                        if (n) {
                            var t;
                            let e;
                            try {
                                e = await this._gateway.publish(this._uid, n, !0)
                            } catch (t) {
                                if (t.code !== qf.DISCONNECT_P2P) throw r.throw(t), t
                            }
                            r.next((null === (t = e) || void 0 === t ? void 0 : t.ortc) || []), this._p2pChannel.reportPublishEvent(!0, null, void 0, !0)
                        }
                    } catch (e) {
                        if (this._p2pChannel.reportPublishEvent(!1, null == e ? void 0 : e.code, void 0, !0), (null == e ? void 0 : e.code) === qf.WS_ABORT) return;
                        throw e
                    }
                }

                _createLiveStreamingClient(e) {
                    if (!this._joinInfo || !this._appId) return new Hf(qf.INVALID_OPERATION, "can not create live streaming client, please join channel first").throw();
                    const t = () => new class extends Wf {
                            constructor(e) {
                                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Kf,
                                    r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Kf;
                                super(), Kh(this, "onLiveStreamWarning", void 0), Kh(this, "onLiveStreamError", void 0), Kh(this, "onInjectStatusChange", void 0), Kh(this, "spec", void 0), Kh(this, "retryTimeout", 1e4), Kh(this, "connection", void 0), Kh(this, "httpRetryConfig", void 0), Kh(this, "wsRetryConfig", void 0), Kh(this, "streamingTasks", new Map), Kh(this, "isStartingStreamingTask", !1), Kh(this, "taskMutex", new KE("live-streaming")), Kh(this, "cancelToken", Bf.CancelToken.source()), Kh(this, "transcodingConfig", void 0), Kh(this, "injectConfig", eC({}, gv)), Kh(this, "injectLoopTimes", 0), Kh(this, "uapResponse", void 0), Kh(this, "lastTaskId", 1), Kh(this, "statusError", new Map), this.spec = e, this.httpRetryConfig = r, this.wsRetryConfig = t
                            }

                            async setTranscodingConfig(e) {
                                const t = eC(eC({}, vv), e);
                                66 !== t.videoCodecProfile && 77 !== t.videoCodecProfile && 100 !== t.videoCodecProfile && (em.debug("[".concat(this.spec.clientId, "] set transcoding config, fix video codec profile: ").concat(t.videoCodecProfile, " -> 100")), t.videoCodecProfile = 100), t.transcodingUsers || (t.transcodingUsers = t.userConfigs), t.transcodingUsers && (t.transcodingUsers = t.transcodingUsers.map(e => eC(eC(eC({}, fv), e), {}, {zOrder: e.zOrder ? e.zOrder + 1 : 1}))), function (e) {
                                    R_(e.width) || g_(e.width, "config.width", 0, 1e4), R_(e.height) || g_(e.height, "config.height", 0, 1e4), R_(e.videoBitrate) || g_(e.videoBitrate, "config.videoBitrate", 1, 1e6), R_(e.videoFrameRate) || g_(e.videoFrameRate, "config.videoFrameRate"), R_(e.lowLatency) || __(e.lowLatency, "config.lowLatency"), R_(e.audioSampleRate) || v_(e.audioSampleRate, "config.audioSampleRate", [32e3, 44100, 48e3]), R_(e.audioBitrate) || g_(e.audioBitrate, "config.audioBitrate", 1, 128), R_(e.audioChannels) || v_(e.audioChannels, "config.audioChannels", [1, 2, 3, 4, 5]), R_(e.videoGop) || g_(e.videoGop, "config.videoGop"), R_(e.videoCodecProfile) || v_(e.videoCodecProfile, "config.videoCodecProfile", [66, 77, 100]), R_(e.userCount) || g_(e.userCount, "config.userCount", 0, 17), R_(e.backgroundColor) || g_(e.backgroundColor, "config.backgroundColor", 0, 16777215), R_(e.userConfigExtraInfo) || y_(e.userConfigExtraInfo, "config.userConfigExtraInfo", 0, 4096, !1), e.transcodingUsers && !R_(e.transcodingUsers) && (S_(e.transcodingUsers, "config.transcodingUsers"), e.transcodingUsers.forEach((e, t) => {
                                        T_(e.uid), R_(e.x) || g_(e.x, "transcodingUser[".concat(t, "].x"), 0, 1e4), R_(e.y) || g_(e.y, "transcodingUser[".concat(t, "].y"), 0, 1e4), R_(e.width) || g_(e.width, "transcodingUser[".concat(t, "].width"), 0, 1e4), R_(e.height) || g_(e.height, "transcodingUser[".concat(t, "].height"), 0, 1e4), R_(e.zOrder) || g_(e.zOrder - 1, "transcodingUser[".concat(t, "].zOrder"), 0, 100), R_(e.alpha) || g_(e.alpha, "transcodingUser[".concat(t, "].alpha"), 0, 1, !1)
                                    })), R_(e.watermark) || _v(e.watermark, "watermark"), R_(e.backgroundImage) || _v(e.backgroundImage, "backgroundImage"), e.images && !R_(e.images) && (S_(e.images, "config.images"), e.images.forEach((e, t) => {
                                        _v(e, "images[".concat(t, "]"))
                                    }))
                                }(t);
                                const r = [];
                                t.images && r.push(...t.images.map(e => eC(eC(eC({}, mv), e), {}, {zOrder: 255}))), t.backgroundImage && (r.push(eC(eC(eC({}, mv), t.backgroundImage), {}, {zOrder: 0})), delete t.backgroundImage), t.watermark && (r.push(eC(eC(eC({}, mv), t.watermark), {}, {zOrder: 255})), delete t.watermark), t.images = r, t.transcodingUsers && (t.userConfigs = t.transcodingUsers.map(e => eC({}, e)), t.userCount = t.transcodingUsers.length, delete t.transcodingUsers);
                                const n = (t.userConfigs || []).map(e => "number" == typeof e.uid ? sl.resolve(e.uid) : Hw(e.uid, this.spec, this.cancelToken.token, this.httpRetryConfig));
                                if ((await sl.all(n)).forEach((e, r) => {
                                    t.userConfigs && t.userConfigs[r] && (t.userConfigs[r].uid = e)
                                }), this.transcodingConfig = t, this.connection) try {
                                    var i;
                                    const t = await this.connection.request("request", {
                                        clientRequest: {
                                            command: "UpdateTranscoding",
                                            transcodingConfig: this.transcodingConfig
                                        }
                                    }, !1, {
                                        command: "UpdateTranscoding",
                                        workerType: 1,
                                        requestByUser: !0,
                                        tid: Array.from(pS(i = this.streamingTasks).call(i)).map(e => e.taskId).join("#")
                                    });
                                    em.debug("[".concat(this.spec.clientId, "] update live transcoding config success, code: ").concat(t.code, ", config:"), JSON.stringify(this.transcodingConfig))
                                } catch (e) {
                                    if (!e.data || !e.data.retry) throw e;
                                    e.data.changeAddress && this.connection.tryNextAddress(), this.streamingTasks.forEach(t => {
                                        em.warning("[".concat(this.spec.clientId, "] live streaming receive error"), e.toString(), "try to republish", t.url), this.startLiveStreamingTask(t.url, t.mode, e).then(() => {
                                            em.debug("[".concat(this.spec.clientId, "] live streaming republish ").concat(t.url, " success"))
                                        }).catch(e => {
                                            em.error("[".concat(this.spec.clientId, "] live streaming republish failed"), t.url, e.toString()), this.onLiveStreamError && this.onLiveStreamError(t.url, e)
                                        })
                                    })
                                }
                            }

                            setInjectStreamConfig(e, t) {
                                this.injectConfig = Object.assign({}, this.injectConfig, e), this.injectLoopTimes = t
                            }

                            async startLiveStreamingTask(e, t, r) {
                                var n;
                                if (Array.from(pS(n = this.streamingTasks).call(n)).find(e => e.mode === hv.INJECT) && t === hv.INJECT) return new Hf(qf.LIVE_STREAMING_TASK_CONFLICT, "inject stream over limit").throw();
                                if (!this.transcodingConfig && t === hv.TRANSCODE) throw new Hf(qf.INVALID_OPERATION, "[LiveStreaming] no transcoding config found, can not start transcoding streaming task");
                                let i = {
                                    command: "PublishStream",
                                    ts: Date.now(),
                                    url: e,
                                    uid: this.spec.uid.toString(),
                                    autoDestroyTime: 100,
                                    acceptImageTimeout: !0
                                };
                                em.debug("[".concat(this.spec.clientId, "] start live streaming ").concat(e, ", mode: ").concat(t));
                                const o = await this.taskMutex.lock();
                                if (!this.connection && r) return void o();
                                if (this.streamingTasks.get(e) && !r) return o(), new Hf(qf.LIVE_STREAMING_TASK_CONFLICT).throw();
                                try {
                                    this.connection || (this.connection = await this.connect(t))
                                } catch (e) {
                                    throw o(), e
                                }
                                switch (t) {
                                    case hv.TRANSCODE:
                                        i.transcodingConfig = eC({}, this.transcodingConfig);
                                        break;
                                    case hv.RAW:
                                        break;
                                    case hv.INJECT:
                                        i = {
                                            cname: this.spec.cname,
                                            command: "InjectStream",
                                            sid: this.spec.sid,
                                            transcodingConfig: this.injectConfig,
                                            ts: Date.now(),
                                            url: e,
                                            loopTimes: this.injectLoopTimes
                                        }
                                }
                                this.uapResponse && this.uapResponse.vid && (i.vid = this.uapResponse.vid), this.isStartingStreamingTask = !0;
                                const s = this.lastTaskId++;
                                try {
                                    const a = new sl((t, n) => {
                                        zS(this.retryTimeout).then(() => {
                                            if (r) return n(r);
                                            const t = this.statusError.get(e);
                                            return t ? (this.statusError.delete(e), n(t)) : void 0
                                        })
                                    }), c = await sl.race([this.connection.request("request", {clientRequest: i}, !0, {
                                        url: e,
                                        command: "PublishStream",
                                        workerType: t === hv.TRANSCODE ? 1 : 2,
                                        requestByUser: !r,
                                        tid: s.toString()
                                    }), a]);
                                    this.isStartingStreamingTask = !1, em.debug("[".concat(this.spec.clientId, "] live streaming started, code: ").concat(c.code)), this.streamingTasks.set(e, {
                                        clientRequest: i,
                                        mode: t,
                                        url: e,
                                        taskId: s
                                    }), o()
                                } catch (n) {
                                    if (o(), this.isStartingStreamingTask = !1, !n.data || !n.data.retry || r) throw n;
                                    return n.data.changeAddress ? (this.connection.tryNextAddress(), await this.startLiveStreamingTask(e, t, n)) : await this.startLiveStreamingTask(e, t, n)
                                }
                            }

                            stopLiveStreamingTask(e) {
                                return new sl((t, r) => {
                                    const n = this.streamingTasks.get(e);
                                    if (!n || !this.connection) return new Hf(qf.UNEXPECTED_ERROR, "can not find streaming task to stop").throw();
                                    const i = n.mode;
                                    n.abortTask = (() => {
                                        em.debug("[".concat(this.spec.clientId, "] stop live streaming success(worker exception)")), this.streamingTasks.delete(e), t()
                                    }), this.connection.request("request", {
                                        clientRequest: {
                                            command: i === hv.INJECT ? "UninjectStream" : "UnpublishStream",
                                            url: n.url
                                        }
                                    }, !1, {
                                        url: e,
                                        command: "UnPublishStream",
                                        workerType: i === hv.TRANSCODE ? 1 : 2,
                                        requestByUser: !0,
                                        tid: (this.lastTaskId++).toString()
                                    }).then(r => {
                                        em.debug("[".concat(this.spec.clientId, "] stop live streaming success, code: ").concat(r.code)), this.streamingTasks.delete(e), 0 === this.streamingTasks.size && i !== hv.INJECT && (this.connection && this.connection.close(), this.connection = void 0), t(), i === hv.INJECT && this.onInjectStatusChange && this.onInjectStatusChange(pv.INJECT_STREAM_STATUS_STOP_SUCCESS, this.spec.uid, e)
                                    }).catch(r)
                                })
                            }

                            async controlInjectStream(e, t, r, n) {
                                const i = this.streamingTasks.get(e);
                                if (!i || !this.connection || i.mode !== hv.INJECT) throw new Hf(qf.INVALID_OPERATION, "can not find inject stream task to control");
                                return (await this.connection.request("request", {
                                    clientRequest: {
                                        command: "ControlStream",
                                        url: e,
                                        control: t,
                                        audioVolume: r,
                                        position: n
                                    }
                                })).serverResponse
                            }

                            resetAllTask() {
                                var e;
                                const t = Array.from(pS(e = this.streamingTasks).call(e));
                                this.terminate();
                                for (const e of t) this.startLiveStreamingTask(e.url, e.mode).catch(t => {
                                    this.onLiveStreamError && this.onLiveStreamError(e.url, t)
                                })
                            }

                            terminate() {
                                this.cancelToken && this.cancelToken.cancel(), this.streamingTasks = new Map, this.isStartingStreamingTask = !1, this.statusError = new Map, this.cancelToken = Bf.CancelToken.source(), this.uapResponse = void 0, this.connection && this.connection.close(), this.connection = void 0
                            }

                            async connect(e) {
                                if (this.connection) throw new Hf(qf.UNEXPECTED_ERROR, "live streaming connection has already connected");
                                const t = await ZS(this, yv.REQUEST_WORKER_MANAGER_LIST, e);
                                return this.uapResponse = t, this.connection = new $w(t.workerToken, this.spec, this.wsRetryConfig, e), this.connection.on(Ev.WARNING, (e, t) => this.onLiveStreamWarning && this.onLiveStreamWarning(t, e)), this.connection.on(Ev.PUBLISH_STREAM_STATUS, e => this.handlePublishStreamServer(e)), this.connection.on(Ev.INJECT_STREAM_STATUS, e => this.handleInjectStreamServerStatus(e)), this.connection.on(Ev.REQUEST_NEW_ADDRESS, (t, r) => {
                                    if (!this.connection) return r(new Hf(qf.UNEXPECTED_ERROR, "can not get new live streaming address list"));
                                    ZS(this, yv.REQUEST_WORKER_MANAGER_LIST, e).then(e => {
                                        this.uapResponse = e, t(e.addressList)
                                    }).catch(r)
                                }), await this.connection.init(t.addressList), this.connection
                            }

                            handlePublishStreamServer(e) {
                                const t = e.serverStatus && e.serverStatus.url || "empty_url",
                                    r = this.streamingTasks.get(t), n = e.reason;
                                switch (e.code) {
                                    case Sv.PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN:
                                    case Sv.PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT:
                                    case Sv.PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE:
                                    case Sv.PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH: {
                                        const n = new Hf(qf.LIVE_STREAMING_CDN_ERROR, "", {code: e.code});
                                        if (r) return em.error(n.toString()), this.onLiveStreamError && this.onLiveStreamError(t, n);
                                        if (!this.isStartingStreamingTask) return;
                                        this.statusError.set(t, n)
                                    }
                                    case Sv.LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE: {
                                        const e = new Hf(qf.LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE, n);
                                        return this.onLiveStreamWarning && this.onLiveStreamWarning(t, e)
                                    }
                                    case Sv.LIVE_STREAM_RESPONSE_WORKER_LOST:
                                    case Sv.LIVE_STREAM_RESPONSE_WORKER_QUIT: {
                                        var i;
                                        if (!this.connection) return;
                                        this.connection.tryNextAddress();
                                        const t = Array.from(pS(i = this.streamingTasks).call(i));
                                        for (const r of t) r.abortTask ? r.abortTask() : (em.warning("[".concat(this.spec.clientId, "] publish stream status code"), e.code, "try to republish", r.url), this.startLiveStreamingTask(r.url, r.mode, new Hf(qf.LIVE_STREAMING_INTERNAL_SERVER_ERROR, "", {code: e.code})).then(() => {
                                            em.debug("[".concat(this.spec.clientId, "] republish live stream success"), r.url)
                                        }).catch(e => {
                                            em.error(e.toString()), this.onLiveStreamError && this.onLiveStreamError(r.url, e)
                                        }));
                                        return
                                    }
                                }
                            }

                            handleInjectStreamServerStatus(e) {
                                const t = Number(e.uid), r = e.serverStatus && e.serverStatus.url;
                                switch (e.code) {
                                    case 200:
                                        return void (this.onInjectStatusChange && this.onInjectStatusChange(pv.INJECT_STREAM_STATUS_START_SUCCESS, t, r));
                                    case 451:
                                        return this.onInjectStatusChange && this.onInjectStatusChange(pv.INJECT_STREAM_STATUS_START_ALREADY_EXISTS, t, r), void this.streamingTasks.delete(r);
                                    case 453:
                                        return this.onInjectStatusChange && this.onInjectStatusChange(pv.INJECT_STREAM_STATUS_START_UNAUTHORIZED, t, r), void this.streamingTasks.delete(r);
                                    case 470:
                                        return this.onInjectStatusChange && this.onInjectStatusChange(pv.INJECT_STREAM_STATUS_BROKEN, t, r), void this.streamingTasks.delete(r);
                                    case 499:
                                        return this.onInjectStatusChange && this.onInjectStatusChange(pv.INJECT_STREAM_STATUS_START_TIMEOUT, t, r), void this.streamingTasks.delete(r);
                                    default:
                                        return void em.debug("inject stream server status", e)
                                }
                            }

                            hasUrl(e) {
                                return this.streamingTasks.has(e)
                            }
                        }(this._joinInfo, this._config.websocketRetryConfig || Kf, this._config.httpRetryConfig || Kf),
                        r = e => {
                            e.onLiveStreamError = ((e, t) => {
                                WE.reportApiInvoke(this._sessionId, {
                                    name: M_.ON_LIVE_STREAM_ERROR,
                                    options: [e, t],
                                    tag: U_.TRACER
                                }).onSuccess(), this.emit(z_.LIVE_STREAMING_ERROR, e, t)
                            }), e.onLiveStreamWarning = ((e, t) => {
                                WE.reportApiInvoke(this._sessionId, {
                                    name: M_.ON_LIVE_STREAM_WARNING,
                                    options: [e, t],
                                    tag: U_.TRACER
                                }).onSuccess(), this.emit(z_.LIVE_STREAMING_WARNING, e, t)
                            }), e.on(yv.REQUEST_WORKER_MANAGER_LIST, (e, t, r) => {
                                if (!this._joinInfo) return r(new Hf(qf.INVALID_OPERATION, "can not find join info to get worker manager"));
                                zw(e, this._joinInfo, this._axiosCancelSource.token, Kf).then(t).catch(r)
                            })
                        };
                    switch (e) {
                        case hv.RAW:
                            return this._liveRawStreamingClient || (this._liveRawStreamingClient = t(), r(this._liveRawStreamingClient)), this._liveRawStreamingClient;
                        case hv.TRANSCODE:
                            return this._liveTranscodeStreamingClient || (this._liveTranscodeStreamingClient = t(), r(this._liveTranscodeStreamingClient)), this._liveTranscodeStreamingClient;
                        case hv.INJECT:
                            return this._injectStreamingClient || (this._injectStreamingClient = t(), this._injectStreamingClient.on(yv.REQUEST_WORKER_MANAGER_LIST, (e, t, r) => {
                                if (!this._joinInfo) return r(new Hf(qf.INVALID_OPERATION, "can not find join info to get worker manager"));
                                zw(e, this._joinInfo, this._axiosCancelSource.token, Kf).then(t).catch(r)
                            }), this._injectStreamingClient.onInjectStatusChange = ((e, t, r) => {
                                this.emit(z_.INJECT_STREAM_STATUS, e, t, r)
                            })), this._injectStreamingClient
                    }
                }

                _createChannelMediaRelayClient() {
                    return this._joinInfo ? (this._channelMediaRelayClient || (this._channelMediaRelayClient = new class extends Wf {
                        set state(e) {
                            e !== this._state && (e !== Iv.RELAY_STATE_FAILURE && (this.errorCode = wv.RELAY_OK), this.emit("state", e, this.errorCode), this._state = e)
                        }

                        get state() {
                            return this._state
                        }

                        constructor(e, t, r, n) {
                            super(), Kh(this, "joinInfo", void 0), Kh(this, "sid", void 0), Kh(this, "clientId", void 0), Kh(this, "cancelToken", Bf.CancelToken.source()), Kh(this, "workerToken", void 0), Kh(this, "requestId", 0), Kh(this, "signal", void 0), Kh(this, "prevChannelMediaConfig", void 0), Kh(this, "httpRetryConfig", void 0), Kh(this, "_state", Iv.RELAY_STATE_IDLE), Kh(this, "errorCode", wv.RELAY_OK), Kh(this, "onStatus", e => {
                                em.debug("[".concat(this.clientId, "] ChannelMediaStatus: ").concat(JSON.stringify(e))), e && e.command && ("onAudioPacketReceived" === e.command && this.emit("event", Rv.PACKET_RECEIVED_AUDIO_FROM_SRC), "onVideoPacketReceived" === e.command && this.emit("event", Rv.PACKET_RECEIVED_VIDEO_FROM_SRC), "onSrcTokenPrivilegeDidExpire" === e.command && (this.errorCode = wv.SRC_TOKEN_EXPIRED, this.state = Iv.RELAY_STATE_FAILURE), "onDestTokenPrivilegeDidExpire" === e.command && (this.errorCode = wv.DEST_TOKEN_EXPIRED, this.state = Iv.RELAY_STATE_FAILURE))
                            }), Kh(this, "onReconnect", async () => {
                                em.debug("[".concat(this.clientId, "] ChannelMediaSocket disconnect, reconnecting")), this.emit("event", Rv.NETWORK_DISCONNECTED), this.state = Iv.RELAY_STATE_IDLE, this.prevChannelMediaConfig && this.sendStartRelayMessage(this.prevChannelMediaConfig).catch(e => {
                                    this.state !== Iv.RELAY_STATE_IDLE && (em.error("auto restart channel media relay failed", e.toString()), this.errorCode = wv.SERVER_CONNECTION_LOST, this.state = Iv.RELAY_STATE_FAILURE)
                                })
                            }), this.joinInfo = e, this.clientId = t, this.sid = JS(), this.signal = new nC(this.joinInfo, this.clientId, r), this.httpRetryConfig = n
                        }

                        async startChannelMediaRelay(e) {
                            if (this.state !== Iv.RELAY_STATE_IDLE) throw new Hf(qf.INVALID_OPERATION);
                            this.state = Iv.RELAY_STATE_CONNECTING, await this.connect(), em.debug("[".concat(this.clientId, "] startChannelMediaRelay: connect success"));
                            try {
                                await this.sendStartRelayMessage(e)
                            } catch (e) {
                                if (e.data && e.data.serverResponse && "SetSourceChannel" === e.data.serverResponse.command) throw new Hf(qf.CROSS_CHANNEL_FAILED_JOIN_SRC);
                                if (e.data && e.data.serverResponse && "SetDestChannelStatus" === e.serverResponse.command) throw new Hf(qf.CROSS_CHANNEL_FAILED_JOIN_DEST);
                                if (e.data && e.data.serverResponse && "StartPacketTransfer" === e.serverResponse.command) throw new Hf(qf.CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST);
                                throw e
                            }
                            this.prevChannelMediaConfig = e
                        }

                        async updateChannelMediaRelay(e) {
                            if (this.state !== Iv.RELAY_STATE_RUNNING) throw new Hf(qf.INVALID_OPERATION);
                            await this.sendUpdateMessage(e), this.prevChannelMediaConfig = e
                        }

                        async stopChannelMediaRelay() {
                            await this.sendStopRelayMessage(), em.debug("[".concat(this.clientId, "] stopChannelMediaRelay: send stop message success")), this.state = Iv.RELAY_STATE_IDLE, this.dispose()
                        }

                        dispose() {
                            em.debug("[".concat(this.clientId, "] disposeChannelMediaRelay")), this.cancelToken.cancel(), this.cancelToken = Bf.CancelToken.source(), this.state = Iv.RELAY_STATE_IDLE, this.emit("dispose"), this.signal.dispose(), this.prevChannelMediaConfig = void 0
                        }

                        async connect() {
                            const e = await async function (e, t, r) {
                                const n = fm("UAP_AP").slice(0, fm("AJAX_REQUEST_CONCURRENT")).map(t => e.proxyServer ? "https://".concat(e.proxyServer, "/ap/?url=").concat(t + "/api/v1?action=uap") : "https://".concat(t, "/api/v1?action=uap")).map(n => (function (e, t, r, n) {
                                    const i = {
                                        command: "convergeAllocateEdge",
                                        sid: t.sid,
                                        appId: t.appId,
                                        token: t.token,
                                        ts: Date.now(),
                                        version: rm,
                                        cname: t.cname,
                                        uid: t.uid.toString(),
                                        requestId: Ow,
                                        seq: Ow
                                    };
                                    Ow += 1;
                                    const o = {service_name: "tele_channel", json_body: JSON.stringify(i)};
                                    return Yf(async () => {
                                        const t = await NE(e, {
                                            data: o,
                                            cancelToken: r,
                                            headers: {"X-Packet-Service-Type": 0, "X-Packet-URI": 61}
                                        });
                                        if (0 !== t.code) {
                                            const e = new Hf(qf.UNEXPECTED_RESPONSE, "cross channel ap error, code" + t.code, {retry: !0});
                                            throw em.error(e.toString()), e
                                        }
                                        const n = JSON.parse(t.json_body);
                                        if (200 !== n.code) {
                                            const e = new Hf(qf.UNEXPECTED_RESPONSE, "cross channel app center error, code: ".concat(n.code, ", reason: ").concat(n.reason));
                                            throw em.error(e.toString()), e
                                        }
                                        if (!n.servers || 0 === n.servers.length) {
                                            const e = new Hf(qf.UNEXPECTED_RESPONSE, "cross channel app center empty server");
                                            throw em.error(e.toString()), e
                                        }
                                        return {
                                            vid: n.vid,
                                            workerToken: n.workerToken,
                                            addressList: (fm("CHANNEL_MEDIA_RELAY_SERVERS") || n.servers).map(e => "wss://".concat(e.address.replace(/\./g, "-"), ".").concat(fm("WORKER_DOMAIN"), ":").concat(e.wss))
                                        }
                                    }, void 0, e => !!(e.code !== qf.OPERATION_ABORTED && e.code !== qf.UNEXPECTED_RESPONSE || e.data && e.data.retry), n)
                                })(n, e, t, r));
                                try {
                                    const t = await $S(n);
                                    return n.forEach(e => e.cancel()), t
                                } catch (e) {
                                    throw e[0]
                                }
                            }(this.joinInfo, this.cancelToken.token, this.httpRetryConfig);
                            this.workerToken = e.workerToken, await this.signal.connect(e.addressList), this.emit("event", Rv.NETWORK_CONNECTED), this.signal.on("status", this.onStatus), this.signal.on("reconnecting", this.onReconnect)
                        }

                        async sendStartRelayMessage(e) {
                            const t = this.genMessage(Tv.StopPacketTransfer);
                            await this.signal.request(t), await this.signal.waitStatus("Normal Quit"), em.debug("[".concat(this.clientId, "] startChannelMediaRelay: StopPacketTransfer success"));
                            const r = this.genMessage(Tv.SetSdkProfile, e);
                            await this.signal.request(r), em.debug("[".concat(this.clientId, "] startChannelMediaRelay: SetSdkProfile success"));
                            const n = this.genMessage(Tv.SetSourceChannel, e);
                            await this.signal.request(n), await this.signal.waitStatus("SetSourceChannelStatus"), this.emit("event", Rv.PACKET_JOINED_SRC_CHANNEL), em.debug("[".concat(this.clientId, "] startChannelMediaRelay: SetSourceChannel success"));
                            const i = this.genMessage(Tv.SetSourceUserId, e);
                            await this.signal.request(i), em.debug("[".concat(this.clientId, "] startChannelMediaRelay: SetSourceUserId success"));
                            const o = this.genMessage(Tv.SetDestChannel, e);
                            await this.signal.request(o), await this.signal.waitStatus("SetDestChannelStatus"), this.emit("event", Rv.PACKET_JOINED_DEST_CHANNEL), em.debug("[".concat(this.clientId, "] startChannelMediaRelay: SetDestChannel success"));
                            const s = this.genMessage(Tv.StartPacketTransfer, e);
                            await this.signal.request(s), this.emit("event", Rv.PACKET_SENT_TO_DEST_CHANNEL), this.state = Iv.RELAY_STATE_RUNNING, em.debug("[".concat(this.clientId, "] startChannelMediaRelay: StartPacketTransfer success"))
                        }

                        async sendUpdateMessage(e) {
                            const t = this.genMessage(Tv.UpdateDestChannel, e);
                            await this.signal.request(t), this.emit("event", Rv.PACKET_UPDATE_DEST_CHANNEL), em.debug("[".concat(this.clientId, "] sendUpdateMessage: UpdateDestChannel success"))
                        }

                        async sendStopRelayMessage() {
                            const e = this.genMessage(Tv.StopPacketTransfer);
                            await this.signal.request(e), em.debug("[".concat(this.clientId, "] sendStopRelayMessage: StopPacketTransfer success"))
                        }

                        genMessage(e, t) {
                            const r = [], n = [], i = [];
                            this.requestId += 1;
                            const o = {
                                appId: this.joinInfo.appId,
                                cname: this.joinInfo.cname,
                                uid: this.joinInfo.uid.toString(),
                                sdkVersion: rm,
                                sid: this.sid,
                                ts: Date.now(),
                                requestId: this.requestId,
                                seq: this.requestId,
                                allocate: !0,
                                clientRequest: {}
                            };
                            "4.16.0" === o.sdkVersion && (o.sdkVersion = "0.0.1");
                            let s = null, a = null;
                            switch (e) {
                                case Tv.SetSdkProfile:
                                    return o.clientRequest = {command: "SetSdkProfile", type: "multi_channel"}, o;
                                case Tv.SetSourceChannel:
                                    if (!(a = t && t.getSrcChannelMediaInfo())) throw new Hf(qf.UNEXPECTED_ERROR, "can not find source config");
                                    return o.clientRequest = {
                                        command: "SetSourceChannel",
                                        uid: "0",
                                        channelName: a.channelName,
                                        token: a.token || this.joinInfo.appId
                                    }, o;
                                case Tv.SetSourceUserId:
                                    if (!(a = t && t.getSrcChannelMediaInfo())) throw new Hf(qf.UNEXPECTED_ERROR, "can not find source config");
                                    return o.clientRequest = {command: "SetSourceUserId", uid: a.uid + ""}, o;
                                case Tv.SetDestChannel:
                                    if (!(s = t && t.getDestChannelMediaInfo())) throw new Hf(qf.UNEXPECTED_ERROR, "can not find dest config");
                                    return s.forEach(e => {
                                        r.push(e.channelName), n.push(e.uid + ""), i.push(e.token || this.joinInfo.appId)
                                    }), o.clientRequest = {
                                        command: "SetDestChannel",
                                        channelName: r,
                                        uid: n,
                                        token: i
                                    }, o;
                                case Tv.StartPacketTransfer:
                                    return o.clientRequest = {command: "StartPacketTransfer"}, o;
                                case Tv.Reconnect:
                                    return o.clientRequest = {command: "Reconnect"}, o;
                                case Tv.StopPacketTransfer:
                                    return o.clientRequest = {command: "StopPacketTransfer"}, o;
                                case Tv.UpdateDestChannel:
                                    if (!(s = t && t.getDestChannelMediaInfo())) throw new Hf(qf.UNEXPECTED_ERROR, "can not find dest config");
                                    return s.forEach(e => {
                                        r.push(e.channelName), n.push(e.uid + ""), i.push(e.token || this.joinInfo.appId)
                                    }), o.clientRequest = {
                                        command: "UpdateDestChannel",
                                        channelName: r,
                                        uid: n,
                                        token: i
                                    }, o
                            }
                            return o
                        }
                    }(this._joinInfo, this._clientId, this._config.websocketRetryConfig || Kf, this._config.httpRetryConfig || Kf), this._channelMediaRelayClient.on("state", e => {
                        e === Iv.RELAY_STATE_FAILURE && this._channelMediaRelayClient && this._channelMediaRelayClient.dispose(), this.emit(z_.CHANNEL_MEDIA_RELAY_STATE, e)
                    }), this._channelMediaRelayClient.on("event", e => {
                        this.emit(z_.CHANNEL_MEDIA_RELAY_EVENT, e)
                    })), this._channelMediaRelayClient) : new Hf(qf.INVALID_OPERATION, "can not create channel media relay client, please join channel first").throw()
                }

                _handleGatewayEvents() {
                    this._gateway.on(Av.DISCONNECT_P2P, async () => {
                        await this._p2pChannel.disconnectForReconnect()
                    }), this._gateway.on(Av.CONNECTION_STATE_CHANGE, (e, t, r) => {
                        var n;
                        if (r === K_.FALLBACK) return;
                        const i = () => {
                            this.emit(z_.CONNECTION_STATE_CHANGE, e, t, r)
                        };
                        if (WE.reportApiInvoke(this._sessionId || (null === (n = this._gateway.joinInfo) || void 0 === n ? void 0 : n.sid) || null, {
                            name: M_.CONNECTION_STATE_CHANGE,
                            options: [e, t, r],
                            tag: U_.TRACER
                        }).onSuccess(JSON.stringify({
                            cur: e,
                            prev: t,
                            reason: r
                        })), em.info("[".concat(this._clientId, "] connection state change: ").concat(t, " -> ").concat(e)), "DISCONNECTED" === e) return this._reset(), void i();
                        if ("RECONNECTING" === e) this._users.forEach(e => {
                            e._trust_in_room_ = !1, e._trust_audio_enabled_state_ = !1, e._trust_video_enabled_state_ = !1, e._trust_audio_mute_state_ = !1, e._trust_video_mute_state_ = !1, e._trust_audio_stream_added_state_ = !1, e._trust_video_stream_added_state_ = !1, e._audioSSRC = void 0, e._videoSSRC = void 0, e._videoOrtc = void 0, e._audioOrtc = void 0, e._cname = void 0, e._rtxSsrcId = void 0
                        }), this._userOfflineTimeout && window.clearTimeout(this._userOfflineTimeout), this._streamRemovedTimeout && window.clearTimeout(this._streamRemovedTimeout), this._userOfflineTimeout = void 0, this._streamRemovedTimeout = void 0; else if ("CONNECTED" === e) {
                            var o;
                            this._streamFallbackTypeCacheMap.forEach((e, t) => {
                                this._gateway.setStreamFallbackOption(t, e).catch(e => {
                                    em.warning("[".concat(this._clientId, "] auto set stream fallback option failed"), e)
                                })
                            }), this._remoteStreamTypeCacheMap.forEach((e, t) => {
                                this._gateway.setRemoteVideoStreamType(t, e).catch(e => {
                                    em.warning("[".concat(this._clientId, "] auto set remote stream type failed"), e)
                                })
                            }), void 0 !== this._remoteDefaultVideoStreamType && void 0 === (null === (o = this._joinInfo) || void 0 === o ? void 0 : o.defaultVideoStream) && this.setRemoteDefaultVideoStreamType(this._remoteDefaultVideoStreamType).then(() => {
                                em.debug("[".concat(this._clientId, "] setRemoteDefaultVideoStreamType after gateway connected"))
                            }).catch(e => {
                                em.error("[".concat(this._clientId, "] setRemoteDefaultVideoStreamType after gateway failed, ").concat(e))
                            }), this._p2pChannel.republish(), this._userOfflineTimeout = window.setTimeout(() => {
                                "CONNECTED" === this.connectionState && (this._userOfflineTimeout = void 0, this._users.filter(e => !e._trust_in_room_).forEach(e => {
                                    em.debug("[".concat(this._clientId, "] user offline timeout, emit user offline ").concat(e.uid)), this._handleUserOffline({uid: e.uid})
                                }))
                            }, 3e3), this._streamRemovedTimeout = window.setTimeout(() => {
                                "CONNECTED" === this.connectionState && (this._streamRemovedTimeout = void 0, this._users.forEach(e => {
                                    e._trust_audio_mute_state_ || (em.debug("[".concat(this._clientId, "] auto dispatch audio unmute event ").concat(e.uid)), this._handleMuteStream(e.uid, "audio", !1)), e._trust_video_mute_state_ || (em.debug("[".concat(this._clientId, "] auto dispatch video unmute event ").concat(e.uid)), this._handleMuteStream(e.uid, "video", !1)), e._trust_audio_enabled_state_ || (em.debug("[".concat(this._clientId, "] auto dispatch enable local audio ").concat(e.uid)), this._handleSetStreamLocalEnable("audio", e.uid, !0)), e._trust_video_enabled_state_ || (em.debug("[".concat(this._clientId, "] auto dispatch enable local video ").concat(e.uid)), this._handleSetStreamLocalEnable("video", e.uid, !0)), e._trust_video_stream_added_state_ || (em.debug("[".concat(this._clientId, "] auto dispatch reset video stream added ").concat(e.uid)), this._handleResetAddStream(e, "video")), e._trust_audio_stream_added_state_ || (em.debug("[".concat(this._clientId, "] auto dispatch reset audio stream added ").concat(e.uid)), this._handleResetAddStream(e, "audio")), e._video_added_ || e._audio_added_ || (em.debug("[".concat(this._clientId, "] auto dispatch stream remove ").concat(e.uid)), this._handleRemoveStream({
                                        uid: e.uid,
                                        uint_id: e._uintid
                                    }))
                                }))
                            }, 1e3)
                        }
                        i()
                    }), this._gateway.on(Av.REQUEST_NEW_GATEWAY_LIST, (e, t) => {
                        if (!this._joinInfo) return t(new Hf(qf.UNEXPECTED_ERROR, "can not recover, no join info"));
                        Gw(this._joinInfo, this._axiosCancelSource.token, this._config.httpRetryConfig || Kf, this.store).then(t => {
                            this._joinInfo && (this._joinInfo.apResponse = t.gatewayInfo.res, this._joinInfo.gatewayAddrs = t.gatewayInfo.gatewayAddrs, this._joinInfo.uni_lbs_ip = t.gatewayInfo.uni_lbs_ip), e(t.gatewayInfo.gatewayAddrs.map(e => {
                                if (this._joinInfo && this._joinInfo.proxyServer) {
                                    const t = e.address.split(":");
                                    return "wss://".concat(this._joinInfo.proxyServer, "/ws/?h=").concat(t[0], "&p=").concat(t[1])
                                }
                                return "wss://".concat(e.address)
                            }))
                        }).catch(t)
                    }), this._gateway.on(Av.NETWORK_QUALITY, e => {
                        "normal" === this._networkQualitySensitivity && this.emit(z_.NETWORK_QUALITY, e)
                    }), this._gateway.on(Av.STREAM_TYPE_CHANGE, (e, t) => {
                        this.emit(z_.STREAM_TYPE_CHANGED, e, t), WE.reportApiInvoke(this._sessionId, {
                            name: M_.STREAM_TYPE_CHANGE,
                            options: [e, t],
                            tag: U_.TRACER
                        }).onSuccess(JSON.stringify({uid: e, streamType: t}))
                    }), this._gateway.on(Av.IS_P2P_DISCONNECTED, e => {
                        this._p2pChannel.isP2PDisconnected() ? e(!0) : this._p2pChannel.hasLocalMedia() || this._p2pChannel.hasRemoteMedia() ? e(!1) : e(!0)
                    }), this._gateway.on(Av.NEED_RENEW_SESSION, () => {
                        this._startSession()
                    }), this._gateway.on(Av.REQUEST_P2P_CONNECTION_PARAMS, async (e, t, r) => {
                        try {
                            t(await this._p2pChannel.startP2PConnection(e))
                        } catch (e) {
                            r(e)
                        }
                    }), this._gateway.on(Av.JOIN_RESPONSE, (e, t) => {
                        const {
                            dtlsParameters: r,
                            iceParameters: n,
                            candidates: i,
                            rtpCapabilities: o,
                            setup: s,
                            cname: a
                        } = xN(e.ortc, t);
                        this._p2pChannel.connect(n, r, i, o, s, a)
                    }), this._gateway.on(Av.REQUEST_DC_CONNECTION_PARAMS, e => {
                        e(this._p2pChannel.getEstablishParams())
                    }), this._gateway.on(Av.RESET_CONNECTION_EVENTS, () => {
                        this._handleGatewaySignalEvents()
                    }), this._gateway.on(Av.DATACHANNEL_FAILBACK, () => {
                        this._joinGateway()
                    }), this._gateway.on(Av.DATACHANNEL_PRECONNECT, async (e, t, r, n) => {
                        var i, o, s, a, c, u;
                        await this._p2pChannel.startP2PConnection({turnServer: null === (i = this._joinInfo) || void 0 === i ? void 0 : i.turnServer}, !0);
                        const d = function (e, t) {
                            let r;
                            return t && t.ip && "number" == typeof t.port ? (r = [{
                                foundation: "udpcandidate",
                                componentId: "1",
                                transport: "udp",
                                priority: "2103266323",
                                connectionAddress: t.ip,
                                port: t.port.toString(),
                                type: "host",
                                extension: {}
                            }], em.debug("Using remote candidate from AP ".concat(t.ip, ":").concat(t.port)), t.ip6 && (r.push({
                                foundation: "udpcandidate",
                                componentId: "1",
                                transport: "udp",
                                priority: "2103266323",
                                connectionAddress: t.ip6,
                                port: t.port.toString(),
                                type: "host",
                                extension: {}
                            }), em.debug("Using IPV6 remote candidate from AP ".concat(t.ip6, ":").concat(t.port)))) : r = [{
                                foundation: "udpcandidate",
                                componentId: "1",
                                transport: "udp",
                                priority: "2103266323",
                                connectionAddress: e.ip,
                                port: e.port.toString(),
                                type: "host",
                                extension: {}
                            }], r
                        }(e, t);
                        return this._p2pChannel.preConnect({
                            iceUfrag: "".concat(null === (o = this._joinInfo) || void 0 === o ? void 0 : o.apResponse.cid, "_").concat(null === (s = this._joinInfo) || void 0 === s ? void 0 : s.apResponse.cert),
                            icePwd: "".concat(null === (a = this._joinInfo) || void 0 === a ? void 0 : a.apResponse.cid, "_").concat(null === (c = this._joinInfo) || void 0 === c ? void 0 : c.apResponse.cert)
                        }, {
                            fingerprints: [{
                                hashFunction: "sha-256",
                                fingerprint: null !== (u = fm("FINGERPRINT")) && void 0 !== u ? u : e.fingerprint
                            }]
                        }, d, {
                            send: {audioCodecs: [], videoCodecs: [], audioExtensions: [], videoExtensions: []},
                            recv: {audioCodecs: [], videoCodecs: [], audioExtensions: [], videoExtensions: []}
                        }, "active", "o/i14u9pJrxRKAsu").then(r).catch(n)
                    })
                }

                _handleGatewaySignalEvents() {
                    this._gateway.signal.on(Z_.ON_USER_ONLINE, this._handleUserOnline), this._gateway.signal.on(Z_.ON_USER_OFFLINE, this._handleUserOffline), this._gateway.signal.on(Z_.ON_ADD_AUDIO_STREAM, e => this._handleAddAudioOrVideoStream("audio", e.uid, e.ssrcId, e.cname, e.uint_id, e.ortc)), this._gateway.signal.on(Z_.ON_ADD_VIDEO_STREAM, e => this._handleAddAudioOrVideoStream("video", e.uid, e.ssrcId, e.cname, e.uint_id, e.ortc, e.rtxSsrcId)), this._gateway.signal.on(Z_.ON_REMOVE_STREAM, this._handleRemoveStream), this._gateway.signal.on(Z_.ON_P2P_LOST, this._handleP2PLost), this._gateway.signal.on(Z_.MUTE_AUDIO, e => this._handleMuteStream(e.uid, "audio", !0)), this._gateway.signal.on(Z_.UNMUTE_AUDIO, e => this._handleMuteStream(e.uid, "audio", !1)), this._gateway.signal.on(Z_.MUTE_VIDEO, e => this._handleMuteStream(e.uid, "video", !0)), this._gateway.signal.on(Z_.UNMUTE_VIDEO, e => this._handleMuteStream(e.uid, "video", !1)), this._gateway.signal.on(Z_.RECEIVE_METADATA, e => {
                        const t = ub(e.metadata);
                        this.emit(z_.RECEIVE_METADATA, e.uid, t)
                    }), this._gateway.signal.on(Z_.ON_DATA_STREAM, e => {
                        e.seq && delete e.seq, e.payload = ub(e.payload), this.emit(z_.STREAM_MESSAGE, e.uid, e.payload), this.onStreamMessage && this.onStreamMessage(e)
                    }), this._gateway.signal.on(Z_.ON_CRYPT_ERROR, () => {
                        cb(() => {
                            em.warning("[".concat(this._clientId, "] on crypt error")), this.emit(z_.CRYPT_ERROR)
                        }, this._sessionId)
                    }), this._gateway.signal.on(Z_.ON_TOKEN_PRIVILEGE_WILL_EXPIRE, this._handleTokenWillExpire), this._gateway.signal.on(Z_.ON_TOKEN_PRIVILEGE_DID_EXPIRE, () => {
                        em.warning("[".concat(this._clientId, "] received message onTokenPrivilegeDidExpire, please get new token and join again")), this._gateway.leave(!0), this.emit(z_.ON_TOKEN_PRIVILEGE_DID_EXPIRE), this._reset()
                    }), this._gateway.signal.on(Z_.ON_STREAM_FALLBACK_UPDATE, e => {
                        em.debug("[".concat(this._clientId, "] stream fallback peerId: ").concat(e.stream_id, ", attr: ").concat(e.stream_type)), this.emit(z_.STREAM_FALLBACK, e.stream_id, 1 === e.stream_type ? "fallback" : "recover")
                    }), this._gateway.signal.on(Z_.ON_PUBLISH_STREAM, e => {
                        this.uid === this._uid && (this._p2pChannel.reportPublishEvent(!0, null, void 0, !1, JSON.stringify({proxy: e.proxy})), em.info("[".concat(this._clientId, "] on publish stream, ").concat(JSON.stringify(e))))
                    }), this._gateway.signal.on(Z_.ENABLE_LOCAL_VIDEO, e => {
                        this._handleSetStreamLocalEnable("video", e.uid, !0)
                    }), this._gateway.signal.on(Z_.DISABLE_LOCAL_VIDEO, e => {
                        this._handleSetStreamLocalEnable("video", e.uid, !1)
                    }), this._gateway.signal.on(X_.REQUEST_TIMEOUT, (e, t) => {
                        if (this._joinInfo) switch (e) {
                            case Q_.PUBLISH: {
                                if (!t) return;
                                const e = (t = t).ortc;
                                if (e) {
                                    var r, n, i, o;
                                    const s = e.some(e => {
                                        let {stream_type: t} = e;
                                        return t === Cv.Audio
                                    }), a = e.some(e => {
                                        let {stream_type: t} = e;
                                        return t !== Cv.Audio
                                    }), c = e.some(e => {
                                        let {stream_type: t} = e;
                                        return t === Cv.Screen || t === Cv.ScreenLow
                                    });
                                    "offer" === t.state && WE.publish(this._joinInfo.sid, {
                                        eventElapse: NS.measureFromPublishStart(this.store.clientId, this.store.pubId),
                                        succ: !1,
                                        ec: qf.TIMEOUT,
                                        audio: s,
                                        video: a,
                                        p2pid: t.p2p_id,
                                        publishRequestid: this.store.pubId,
                                        screenshare: c,
                                        audioName: s ? null === (r = e.find(e => {
                                            let {stream_type: t} = e;
                                            return t === Cv.Audio
                                        })) || void 0 === r || null === (n = r.ssrcs[0]) || void 0 === n ? void 0 : n.ssrcId.toString() : void 0,
                                        videoName: a ? null === (i = e.find(e => {
                                            let {stream_type: t} = e;
                                            return t !== Cv.Audio
                                        })) || void 0 === i || null === (o = i.ssrcs[0]) || void 0 === o ? void 0 : o.ssrcId.toString() : void 0
                                    })
                                }
                                break
                            }
                            case Q_.SUBSCRIBE:
                                (t = t) && WE.subscribe(this._joinInfo.sid, {
                                    succ: !1,
                                    ec: qf.TIMEOUT,
                                    audio: t.stream_type === qv.AUDIO,
                                    video: t.stream_type === qv.VIDEO,
                                    peerid: t.stream_id,
                                    subscribeRequestid: t.ssrcId,
                                    p2pid: this.store.p2pId,
                                    eventElapse: NS.measureFromSubscribeStart(this.store.clientId, t.ssrcId)
                                })
                        }
                    }), this._gateway.signal.on(Z_.ON_P2P_OK, e => {
                        this.uid, this._uid
                    }), this._gateway.signal.on(Z_.ON_PUBLISHED_USER_LIST, e => {
                        if (null == e || !e.users) return;
                        const t = [], r = [];
                        for (const n of e.users) {
                            let e = this._users.find(e => e.uid === n.stream_id);
                            e ? e._trust_in_room_ = !0 : (e = new gA(n.stream_id, n.stream_id), this._users.push(e), 0 === this.getListeners(z_.PUBLISHED_USER_LIST).length && (em.debug("[".concat(this._clientId, "] user online"), n.stream_id), this.emit(z_.USER_JOINED, e)));
                            const i = Ov.Audio & n.stream_type, o = (Ov.Video | Ov.LwoVideo) & n.stream_type,
                                s = i && e.hasAudio, a = o && e.hasVideo;
                            o && (e._trust_video_stream_added_state_ = !0, e._video_added_ = !0, e._videoSSRC = n.video_ssrc), i && (e._trust_audio_stream_added_state_ = !0, e._audio_added_ = !0, e._audioSSRC = n.audio_ssrc), i && !s && 0 === this.getListeners(z_.PUBLISHED_USER_LIST).length && (em.info("[".concat(this._clientId, "] remote user ").concat(e.uid, " published audio")), this.emit(z_.USER_PUBLISHED, e, "audio")), o && !a && 0 === this.getListeners(z_.PUBLISHED_USER_LIST).length && (em.info("[".concat(this._clientId, "] remote user ").concat(e.uid, " published video")), this.emit(z_.USER_PUBLISHED, e, "video")), (i && !s || o && !a) && t.push(e), o && this._p2pChannel.hasPendingRemoteMedia(e, "video") && r.push({
                                user: e,
                                mediaType: "video"
                            }), i && this._p2pChannel.hasPendingRemoteMedia(e, "audio") && r.push({
                                user: e,
                                mediaType: "audio"
                            })
                        }
                        r.length > 0 && (em.debug("[".concat(this._clientId, "] RE massSubscribe after reconnect ").concat(r.map(e => "user: ".concat(e.user.uid, ", mediaType: ").concat(e.mediaType)).join("; "), " ")), this.massSubscribe(r).catch(e => {
                            em.error("[".concat(this._clientId, "] mass resubscribe error"), e.toString())
                        })), this.getListeners(z_.PUBLISHED_USER_LIST).length > 0 ? (em.info("[".concat(this._clientId, "] client emit user-list event, users: ").concat(t.map(e => e.uid).join(", "))), this.emit(z_.PUBLISHED_USER_LIST, t)) : em.info("[".concat(this._clientId, "] client not emit user-list event case there is no user-list listener, users: ").concat(t.map(e => e.uid).join(", ")))
                    })
                }

                _handleP2PChannelEvents() {
                    this._p2pChannel.on(zv.RequestMuteLocal, async (e, t, r) => {
                        if (this._joinInfo) try {
                            await this._gateway.muteLocal(e, this._joinInfo.stringUid || this._joinInfo.uid), t()
                        } catch (e) {
                            e.code === qf.DISCONNECT_P2P ? t() : r(e)
                        } else t()
                    }), this._p2pChannel.on(zv.RequestUnmuteLocal, async (e, t, r) => {
                        if (this._joinInfo) try {
                            await this._gateway.unmuteLocal(e, this._joinInfo.stringUid || this._joinInfo.uid), t()
                        } catch (e) {
                            e.code === qf.DISCONNECT_P2P ? t() : r(e)
                        } else t()
                    }), this._p2pChannel.on(zv.RequestRePublish, (e, t, r) => {
                        this.publish(e, !1).then(t).catch(r)
                    }), this._p2pChannel.on(zv.RequestReSubscribe, async (e, t, r) => {
                        try {
                            for (const {
                                user: t,
                                kind: r
                            } of e) r === qv.VIDEO ? await this.subscribe(t, "video") : await this.subscribe(t, "audio");
                            t()
                        } catch (e) {
                            r(e)
                        }
                    }), this._p2pChannel.on(zv.RequestUploadStats, (e, t) => {
                        this._gateway.uploadStats(e, t)
                    }), this._p2pChannel.on(zv.MediaReconnectStart, e => {
                        this.emit(z_.MEDIA_RECONNECT_START, e)
                    }), this._p2pChannel.on(zv.MediaReconnectEnd, e => {
                        this.emit(z_.MEDIA_RECONNECT_END, e)
                    }), this._p2pChannel.on(zv.NeedSignalRTT, e => {
                        e(this._gateway.getSignalRTT())
                    }), this._p2pChannel.on(zv.RequestRestartICE, async () => {
                        const e = await this._p2pChannel.restartICE(), t = await e.next();
                        if (t.done) return;
                        const r = t.value;
                        let n;
                        try {
                            n = await this._gateway.restartICE({iceParameters: r})
                        } catch (t) {
                            return void e.throw(t)
                        }
                        const {iceParameters: i} = function (e) {
                            const t = e.iceParameters;
                            return {iceParameters: {iceUfrag: t.iceUfrag, icePwd: t.icePwd}}
                        }(n);
                        await e.next({remoteIceParameters: i})
                    }), this._p2pChannel.on(zv.RequestReconnect, async () => {
                        this._gateway.reconnect()
                    }), this._p2pChannel.on(zv.RequestReconnectPC, async () => {
                        var e;
                        const {
                            iceParameters: t,
                            dtlsParameters: r,
                            rtpCapabilities: n
                        } = await this._p2pChannel.startP2PConnection({turnServer: null === (e = this._joinInfo) || void 0 === e ? void 0 : e.turnServer}), {
                            gatewayEstablishParams: i,
                            gatewayAddress: o
                        } = await this._gateway.reconnectPC({
                            iceParameters: t,
                            dtlsParameters: r,
                            rtpCapabilities: n
                        }), {
                            dtlsParameters: s,
                            iceParameters: a,
                            candidates: c,
                            rtpCapabilities: u,
                            setup: d,
                            cname: l
                        } = xN(i, o);
                        await this._p2pChannel.connect(a, s, c, u, d, l), await this._p2pChannel.republish(), await this._p2pChannel.reSubscribe()
                    }), this._p2pChannel.on(zv.RequestUnpublishForReconnectPC, async (e, t, r) => {
                        this._joinInfo && void 0 !== this._uid ? (await this._gateway.unpublish(e, this._uid), t()) : r()
                    }), this._p2pChannel.on(zv.P2PLost, () => {
                        this.emit(z_.P2P_LOST, this.store.uid)
                    }), this._p2pChannel.on(zv.UpdateVideoEncoder, e => {
                        e._encoderConfig && this._gateway.setVideoProfile(e._encoderConfig)
                    }), this._p2pChannel.on(zv.ConnectionTypeChange, e => {
                        this.emit(z_.IS_USING_CLOUD_PROXY, e)
                    }), this._p2pChannel.on(zv.RequestLowStreamParameter, e => {
                        e(this._lowStreamParameter || {width: 160, height: 120, framerate: 15, bitrate: 50})
                    }), this._p2pChannel.on(zv.QueryClientConnectionState, e => {
                        e(this.connectionState)
                    })
                }

                getKeyMetrics() {
                    return this.store.keyMetrics
                }

                async enableContentInspect(e) {
                    if ("CONNECTED" !== this.connectionState || !this._joinInfo) throw new Hf(qf.INVALID_OPERATION, "[".concat(this._clientId, "] Client did not join channel"));
                    if (this._inspect) throw new Hf(qf.INVALID_OPERATION, "[".concat(this._clientId, "] Inspect content service already in connecting/connected state"));
                    if (!e) throw new Hf(qf.INVALID_PARAMS, "[".concat(this._clientId, "] inspectConfig is necessary"));
                    if (!e.inspectType || !Array.isArray(e.inspectType)) throw new Hf(qf.INVALID_PARAMS, "[".concat(this._clientId, "] inspectConfig.inspectType is necessary and is an instance of Array."));
                    {
                        const t = [...new Set(e.inspectType)];
                        t.forEach(e => {
                            if (!["supervise", "moderation"].includes(e)) throw new Hf(qf.INVALID_PARAMS, "[".concat(this._clientId, "] ").concat(e, " is not a valid inspect type."))
                        }), e.inspectType = t
                    }
                    if (e && e.extraInfo && e.extraInfo.length > 1024) throw new Hf(qf.INVALID_PARAMS, "[".concat(this._clientId, "] inspectConfig.extraInfo length cannot exceed 1024 bytes"));
                    try {
                        const t = new ZD(e);
                        this._inspect = t, this.handleVideoInspectEvents(this._inspect), await t.init({
                            appId: this._joinInfo.appId,
                            areaCode: "",
                            cname: this._joinInfo.cname,
                            sid: this._joinInfo.sid,
                            token: this._joinInfo.token,
                            uid: this._joinInfo.uid,
                            cid: this._joinInfo.cid,
                            vid: this._joinInfo.vid ? Number(this._joinInfo.vid) : 0
                        }, Kf)
                    } catch (e) {
                        throw Array.isArray(e) ? e[0] : e
                    }
                }

                async disableContentInspect() {
                    if (!this._inspect) throw new Hf(qf.INVALID_OPERATION, "[".concat(this._clientId, "] inspectVideoContent not started"));
                    try {
                        this._inspect.close(), this._inspect = void 0
                    } catch (e) {
                        throw Array.isArray(e) ? e[0] : e
                    }
                }

                handleVideoInspectEvents(e) {
                    e.on(eg.CONNECTION_STATE_CHANGE, (t, r) => {
                        switch (this.emit(z_.CONTENT_INSPECT_CONNECTION_STATE_CHANGE, t, r), r) {
                            case $v.CONNECTED:
                                if ("CONNECTED" !== this.connectionState) return void this.emit(z_.CONTENT_INSPECT_ERROR, new Hf(qf.OPERATION_ABORTED, "Content inspect was cancelled because it left the channel"));
                                e.inspectImage()
                        }
                    }), e.on(eg.INSPECT_RESULT, (e, t) => {
                        var r;
                        if ((null == t ? void 0 : t.code) === qf.INVALID_OPERATION && "DISCONNECTED" === this.connectionState) return em.debug("Stop inspect content because that has left channel"), null == this || null === (r = this._inspect) || void 0 === r || r.close(), void (this._inspect = void 0);
                        this.emit(z_.CONTENT_INSPECT_RESULT, e, t)
                    }), e.on(eg.CLIENT_LOCAL_VIDEO_TRACK, e => {
                        e(this.localTracks.filter(e => "video" === e.trackMediaType)[0])
                    })
                }

                getJoinChannelServiceRecords() {
                    return em.debug("getJoinChannelServiceRecords"), this.store.joinChannelServiceRecords
                }

                async setPublishAudioFilterEnabled(e) {
                    __(e, "enabled"), pm("ENABLE_PUBLISH_AUDIO_FILTER", e), this._joinInfo && await this._gateway.setPublishAudioFilterEnabled(e)
                }

                _handleResetAddStream(e, t) {
                    switch (t) {
                        case"audio":
                            e._audio_added_ = !1, e._trust_audio_stream_added_state_ = !0;
                            break;
                        case"video":
                            e._video_added_ = !1, e._trust_video_stream_added_state_ = !0
                    }
                }
            }).prototype, "leave", [ek], Object.getOwnPropertyDescriptor(jk.prototype, "leave"), jk.prototype), vE(jk.prototype, "publish", [tk], Object.getOwnPropertyDescriptor(jk.prototype, "publish"), jk.prototype), vE(jk.prototype, "unpublish", [rk], Object.getOwnPropertyDescriptor(jk.prototype, "unpublish"), jk.prototype), vE(jk.prototype, "subscribe", [nk], Object.getOwnPropertyDescriptor(jk.prototype, "subscribe"), jk.prototype), vE(jk.prototype, "massSubscribe", [ik], Object.getOwnPropertyDescriptor(jk.prototype, "massSubscribe"), jk.prototype), vE(jk.prototype, "unsubscribe", [ok], Object.getOwnPropertyDescriptor(jk.prototype, "unsubscribe"), jk.prototype), vE(jk.prototype, "massUnsubscribe", [sk], Object.getOwnPropertyDescriptor(jk.prototype, "massUnsubscribe"), jk.prototype), vE(jk.prototype, "setLowStreamParameter", [ak], Object.getOwnPropertyDescriptor(jk.prototype, "setLowStreamParameter"), jk.prototype), vE(jk.prototype, "enableDualStream", [ck], Object.getOwnPropertyDescriptor(jk.prototype, "enableDualStream"), jk.prototype), vE(jk.prototype, "disableDualStream", [uk], Object.getOwnPropertyDescriptor(jk.prototype, "disableDualStream"), jk.prototype), vE(jk.prototype, "setClientRole", [dk], Object.getOwnPropertyDescriptor(jk.prototype, "setClientRole"), jk.prototype), vE(jk.prototype, "setProxyServer", [lk], Object.getOwnPropertyDescriptor(jk.prototype, "setProxyServer"), jk.prototype), vE(jk.prototype, "setTurnServer", [hk], Object.getOwnPropertyDescriptor(jk.prototype, "setTurnServer"), jk.prototype), vE(jk.prototype, "setLicense", [pk], Object.getOwnPropertyDescriptor(jk.prototype, "setLicense"), jk.prototype), vE(jk.prototype, "startProxyServer", [fk], Object.getOwnPropertyDescriptor(jk.prototype, "startProxyServer"), jk.prototype), vE(jk.prototype, "stopProxyServer", [mk], Object.getOwnPropertyDescriptor(jk.prototype, "stopProxyServer"), jk.prototype), vE(jk.prototype, "setLocalAccessPointsV2", [_k], Object.getOwnPropertyDescriptor(jk.prototype, "setLocalAccessPointsV2"), jk.prototype), vE(jk.prototype, "setLocalAccessPoints", [vk], Object.getOwnPropertyDescriptor(jk.prototype, "setLocalAccessPoints"), jk.prototype), vE(jk.prototype, "setRemoteDefaultVideoStreamType", [gk], Object.getOwnPropertyDescriptor(jk.prototype, "setRemoteDefaultVideoStreamType"), jk.prototype), vE(jk.prototype, "setRemoteVideoStreamType", [Ek], Object.getOwnPropertyDescriptor(jk.prototype, "setRemoteVideoStreamType"), jk.prototype), vE(jk.prototype, "setStreamFallbackOption", [yk], Object.getOwnPropertyDescriptor(jk.prototype, "setStreamFallbackOption"), jk.prototype), vE(jk.prototype, "setEncryptionConfig", [Sk], Object.getOwnPropertyDescriptor(jk.prototype, "setEncryptionConfig"), jk.prototype), vE(jk.prototype, "renewToken", [bk], Object.getOwnPropertyDescriptor(jk.prototype, "renewToken"), jk.prototype), vE(jk.prototype, "enableAudioVolumeIndicator", [Tk], Object.getOwnPropertyDescriptor(jk.prototype, "enableAudioVolumeIndicator"), jk.prototype), vE(jk.prototype, "startLiveStreaming", [Rk], Object.getOwnPropertyDescriptor(jk.prototype, "startLiveStreaming"), jk.prototype), vE(jk.prototype, "setLiveTranscoding", [Ik], Object.getOwnPropertyDescriptor(jk.prototype, "setLiveTranscoding"), jk.prototype), vE(jk.prototype, "stopLiveStreaming", [wk], Object.getOwnPropertyDescriptor(jk.prototype, "stopLiveStreaming"), jk.prototype), vE(jk.prototype, "addInjectStreamUrl", [Ck], Object.getOwnPropertyDescriptor(jk.prototype, "addInjectStreamUrl"), jk.prototype), vE(jk.prototype, "removeInjectStreamUrl", [Ak], Object.getOwnPropertyDescriptor(jk.prototype, "removeInjectStreamUrl"), jk.prototype), vE(jk.prototype, "startChannelMediaRelay", [Ok], Object.getOwnPropertyDescriptor(jk.prototype, "startChannelMediaRelay"), jk.prototype), vE(jk.prototype, "updateChannelMediaRelay", [Nk], Object.getOwnPropertyDescriptor(jk.prototype, "updateChannelMediaRelay"), jk.prototype), vE(jk.prototype, "stopChannelMediaRelay", [Pk], Object.getOwnPropertyDescriptor(jk.prototype, "stopChannelMediaRelay"), jk.prototype), vE(jk.prototype, "sendCustomReportMessage", [Dk], Object.getOwnPropertyDescriptor(jk.prototype, "sendCustomReportMessage"), jk.prototype), vE(jk.prototype, "pickSVCLayer", [kk], Object.getOwnPropertyDescriptor(jk.prototype, "pickSVCLayer"), jk.prototype), vE(jk.prototype, "enableContentInspect", [Lk], Object.getOwnPropertyDescriptor(jk.prototype, "enableContentInspect"), jk.prototype), vE(jk.prototype, "disableContentInspect", [xk], Object.getOwnPropertyDescriptor(jk.prototype, "disableContentInspect"), jk.prototype), vE(jk.prototype, "getJoinChannelServiceRecords", [Mk], Object.getOwnPropertyDescriptor(jk.prototype, "getJoinChannelServiceRecords"), jk.prototype), vE(jk.prototype, "setPublishAudioFilterEnabled", [Uk], Object.getOwnPropertyDescriptor(jk.prototype, "setPublishAudioFilterEnabled"), jk.prototype), jk);
            const Wk = new Map;

            function Gk(e, t) {
                var r = Object.keys(e);
                if (Object.getOwnPropertySymbols) {
                    var n = Object.getOwnPropertySymbols(e);
                    t && (n = n.filter(function (t) {
                        return Object.getOwnPropertyDescriptor(e, t).enumerable
                    })), r.push.apply(r, n)
                }
                return r
            }

            function qk(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var r = null != arguments[t] ? arguments[t] : {};
                    t % 2 ? Gk(Object(r), !0).forEach(function (t) {
                        Kh(e, t, r[t])
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : Gk(Object(r)).forEach(function (t) {
                        Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t))
                    })
                }
                return e
            }

            function Hk(e, t, r, n) {
                r.optimizationMode && (n && n.width && n.height ? (r.encoderConfig = qk(qk({}, n), {}, {
                    bitrateMin: n.bitrateMin,
                    bitrateMax: n.bitrateMax
                }), "motion" !== r.optimizationMode && "detail" !== r.optimizationMode || (t.contentHint = r.optimizationMode, t.contentHint === r.optimizationMode ? em.debug("[".concat(e, "] set content hint to"), r.optimizationMode) : em.debug("[".concat(e, "] set content hint failed")))) : em.warning("[".concat(e, "] can not apply optimization mode bitrate config, no encoderConfig")))
            }

            const Kk = Sh().name;

            class zk {
                constructor(e, t) {
                    Kh(this, "id", 0), Kh(this, "element", void 0), Kh(this, "peerPair", void 0), Kh(this, "context", void 0), Kh(this, "audioPlayerElement", void 0), Kh(this, "audioTrack", void 0), zk.count += 1, this.id = zk.count, this.element = e, this.context = t
                }

                initPeers() {
                    this.peerPair = [new RTCPeerConnection, new RTCPeerConnection], this.peerPair[1].ontrack = (e => {
                        const t = document.createElement("audio");
                        t.srcObject = new MediaStream([e.track]), t.play(), this.audioPlayerElement = t
                    })
                }

                async switchSdp() {
                    if (!this.peerPair) return;
                    const e = async (e, t) => {
                        const r = "offer" === t ? await e.createOffer() : await e.createAnswer();
                        return await e.setLocalDescription(r), "complete" === e.iceGatheringState ? e.localDescription : new sl(t => {
                            e.onicegatheringstatechange = (() => {
                                "complete" === e.iceGatheringState && t(e.localDescription)
                            })
                        })
                    }, t = async (e, t) => await e.setRemoteDescription(t);
                    try {
                        const r = await e(this.peerPair[0], "offer");
                        await t(this.peerPair[1], r);
                        const n = await e(this.peerPair[1], "answer");
                        await t(this.peerPair[0], n)
                    } catch (e) {
                        throw new Hf(qf.LOCAL_AEC_ERROR, e.toString()).print()
                    }
                }

                async getTracksFromMediaElement(e) {
                    if (this.audioTrack) return this.audioTrack;
                    let t;
                    try {
                        e instanceof HTMLVideoElement && (e.captureStream ? e.captureStream() : e.mozCaptureStream()), t = this.context.createMediaStreamDestination(), this.context.createMediaElementSource(e).connect(t)
                    } catch (e) {
                        throw new Hf(qf.LOCAL_AEC_ERROR, e.toString()).print()
                    }
                    if (!t) throw new Hf(qf.LOCAL_AEC_ERROR, "no dest node when local aec").print();
                    const r = t.stream.getAudioTracks()[0];
                    return this.audioTrack = r, r
                }

                getElement() {
                    return this.element
                }

                async startEchoCancellation() {
                    this.context.resume(), this.peerPair && this.close(), this.initPeers();
                    const e = this.element, t = await this.getTracksFromMediaElement(e);
                    this.peerPair && this.peerPair[0].addTrack(t), await this.switchSdp()
                }

                close() {
                    em.debug("close echo cancellation unit, id is", this.id), this.audioPlayerElement && this.audioPlayerElement.pause(), this.peerPair && this.peerPair.forEach(e => {
                        e.close()
                    }), this.peerPair = void 0, this.audioPlayerElement = void 0
                }
            }

            var Yk, Jk;
            Kh(zk, "count", 0);
            const Xk = window.AudioContext || window.webkitAudioContext,
                Qk = new (Yk = BE({report: WE}), vE((Jk = class {
                    constructor() {
                        Kh(this, "units", []), Kh(this, "context", void 0)
                    }

                    processExternalMediaAEC(e) {
                        if (!this._doesEnvironmentNeedAEC()) return em.debug("the system does not need to process local aec"), -1;
                        this.context || (this.context = new Xk);
                        let t = this.units.find(t => t && t.getElement() === e);
                        return t || (t = new zk(e, this.context), this.units.push(t)), t.startEchoCancellation(), em.debug("start processing local audio echo cancellation, id is", t.id), t.id
                    }

                    _doesEnvironmentNeedAEC() {
                        return Sh().name !== vh.SAFARI
                    }
                }).prototype, "processExternalMediaAEC", [Yk], Object.getOwnPropertyDescriptor(Jk.prototype, "processExternalMediaAEC"), Jk.prototype), Jk);
            pm("PROCESS_ID", "process-".concat(YS(8, ""), "-").concat(YS(4, ""), "-").concat(YS(4, ""), "-").concat(YS(4, ""), "-").concat(YS(12, ""))), function () {
                const e = Sh();
                ig.getDisplayMedia = !(!navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia), ig.getStreamFromExtension = e.name === vh.CHROME && Number(e.version) > 34, ig.supportUnifiedPlan = function () {
                    if (!window.RTCRtpTransceiver) return !1;
                    if (!("currentDirection" in RTCRtpTransceiver.prototype)) return !1;
                    const e = new RTCPeerConnection;
                    let t = !1;
                    try {
                        e.addTransceiver("audio"), t = !0
                    } catch (e) {
                    }
                    return e.close(), t
                }(), ig.supportMinBitrate = e.name === vh.CHROME || e.name === vh.EDGE, ig.supportSetRtpSenderParameters = function () {
                    const e = Sh();
                    return !!(window.RTCRtpSender && window.RTCRtpSender.prototype.setParameters && window.RTCRtpSender.prototype.getParameters) && (!!Mh() || !(!Ih() && !Th()) || e.name === vh.FIREFOX && Number(e.version) >= 64)
                }(), e.name === vh.SAFARI && (Number(e.version) >= 14 ? ig.supportDualStream = !0 : ig.supportDualStream = !1), ig.webAudioMediaStreamDest = function () {
                    const e = Sh();
                    return !(e.name === vh.SAFARI && Number(e.version) < 12)
                }(), ig.supportReplaceTrack = !!window.RTCRtpSender && "function" == typeof RTCRtpSender.prototype.replaceTrack, ig.supportWebGL = "undefined" != typeof WebGLRenderingContext, ig.supportRequestFrame = !!window.CanvasCaptureMediaStreamTrack, Mh() || (ig.webAudioWithAEC = !0), ig.supportShareAudio = function () {
                    const e = Sh();
                    return (e.os === _h.WIN_10 || e.os === _h.WIN_81 || e.os === _h.WIN_7 || e.os === _h.LINUX || e.os === _h.MAC_OS) && e.name === vh.CHROME && Number(e.version) >= 74
                }(), ig.supportDualStreamEncoding = function () {
                    const e = Sh();
                    return !!fm("DISABLE_WEBAUDIO") || "Safari" === e.name && Number(e.version) >= 14 || !!("Chrome" === e.name && /Windows/i.test(e.os || "") && Number(e.version) >= 100 && fm("CHROME_DUAL_STREAM_USE_ENCODING"))
                }(), ig.supportDataChannel = !!(function (e) {
                    const t = Sh();
                    return !(t.name !== vh.CHROME || !t.osVersion) && Number(t.version) >= 76
                }() || function (e) {
                    const t = Sh();
                    return !(t.name !== vh.FIREFOX || !t.osVersion) && Number(t.version) >= 68
                }() || function (e) {
                    const t = Sh();
                    return !(t.name !== vh.SAFARI || !t.osVersion) && Number(t.version) >= 14
                }()), em.info("browser compatibility", JSON.stringify(ig), JSON.stringify(e))
            }(), function () {
                let e;
                try {
                    e = window.localStorage.getItem("websdk_ng_global_parameter")
                } catch (e) {
                    return void em.error("Error loading sdk config", e.message)
                }
                if (e) try {
                    const t = JSON.parse(window.atob(e)), r = Date.now();
                    em.debug("Loading global parameters from cache", t), Object.keys(t).forEach(e => {
                        if (Object.prototype.hasOwnProperty.call(mm, e)) {
                            const {value: n, expires: i} = t[e];
                            if (i && i <= r) return;
                            _m[e] = n, mm[e] = n
                        }
                    })
                } catch (t) {
                    em.error("Error loading mutableParamsCache: ".concat(e), t.message)
                }
            }();
            const $k = {
                __CLIENT_LIST__: bm,
                __TRACK_LIST__: Tm,
                VERSION: rm,
                BUILD: tm,
                setParameter: (e, t, r) => {
                    em.debug("setParameter key:".concat(e, ", value:").concat(JSON.stringify(t))), pm(e, t, r)
                },
                getParameter: fm,
                getSupportedCodec: async function () {
                    let e = {audio: [], video: []};
                    try {
                        let t = new RTCPeerConnection;
                        t.addTransceiver("video", {direction: "recvonly"}), t.addTransceiver("audio", {direction: "recvonly"});
                        const r = (await t.createOffer()).sdp;
                        if (!r) return e;
                        t.close(), t = null, e = function (e) {
                            const t = {video: [], audio: []};
                            return e.match(/ VP8/i) && t.video.push("VP8"), e.match(/ VP9/i) && t.video.push("VP9"), e.match(/ AV1/i) && t.video.push("AV1"), e.match(/ H264/i) && t.video.push("H264"), e.match(/ opus/i) && t.audio.push("OPUS"), e.match(/ PCMU/i) && t.audio.push("PCMU"), e.match(/ PCMA/i) && t.audio.push("PCMA"), e.match(/ G722/i) && t.audio.push("G722"), t
                        }(r)
                    } catch (e) {
                        throw new Hf(qf.CREATE_OFFER_FAILED, e.toString && e.toString()).print()
                    }
                    return e
                },
                checkSystemRequirements: function () {
                    const e = WE.reportApiInvoke(null, {
                        name: M_.CHECK_SYSTEM_REQUIREMENTS,
                        options: [],
                        tag: U_.TRACER
                    });
                    let t = !1;
                    try {
                        const r = window.RTCPeerConnection,
                            n = navigator.mediaDevices && navigator.mediaDevices.getUserMedia, i = window.WebSocket;
                        t = !!(r && n && i)
                    } catch (e) {
                        return em.error("check system requirement failed: ", e), !1
                    }
                    let r = !1;
                    const n = Sh();
                    n.name === vh.CHROME && Number(n.version) >= 58 && (!("WebKit" === yh.engine.name) || function () {
                        const e = Sh();
                        if (Th()) {
                            if (e.os === _h.MAC_OS) return !0;
                            if (e.os === _h.IOS) {
                                const e = yh.os.version && yh.os.version.split(".");
                                if (e && 14 === Number(e[0]) && e[1] && Number(e[1]) >= 3) return !0;
                                if (e && Number(e[0]) > 14) return !0
                            }
                        }
                        return !1
                    }()) && (r = !0), n.name === vh.FIREFOX && Number(n.version) >= 56 && (r = !0), n.name === vh.OPERA && Number(n.version) >= 45 && (r = !0), n.name === vh.SAFARI && Number(n.version) >= 11 && (r = !0), (Lh() || Sh().name === vh.QQ) && (r = !0), em.debug("checkSystemRequirements, api:", t, "browser", r);
                    const i = t && r;
                    return e.onSuccess(i), i
                },
                getDevices: function (e) {
                    return Ey.enumerateDevices(!0, !0, e)
                },
                getMicrophones: function (e) {
                    return Ey.getRecordingDevices(e)
                },
                getCameras: function (e) {
                    return Ey.getCamerasDevices(e)
                },
                getElectronScreenSources: uy,
                getPlaybackDevices: function (e) {
                    return Ey.getSpeakers(e)
                },
                createClient: function () {
                    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {
                        codec: "vp8",
                        audioCodec: "opus",
                        mode: "rtc"
                    };
                    const t = WE.reportApiInvoke(null, {name: M_.CREATE_CLIENT, options: [e], tag: U_.TRACER});
                    try {
                        !function (e) {
                            v_(e.codec, "config.codec", ["vp8", "vp9", "av1", "h264"]), v_(e.mode, "config.mode", ["rtc", "live"]), void 0 !== e.audioCodec && v_(e.audioCodec, "config.audioCodec", ["opus", "pcmu", "pcma", "g722"]), void 0 !== e.proxyServer && y_(e.proxyServer, "config.proxyServer", 1, 1e4), void 0 !== e.turnServer && iv(e.turnServer), void 0 !== e.httpRetryConfig && rv(e.httpRetryConfig), void 0 !== e.websocketRetryConfig && rv(e.websocketRetryConfig)
                        }(e)
                    } catch (e) {
                        throw t.onError(e), e
                    }
                    return void 0 === e.audioCodec && (e.audioCodec = "opus"), t.onSuccess(), new Bk(Fk(Fk({forceWaitGatewayResponse: !0}, e), {}, {role: "rtc" === e.mode ? "host" : e.role}))
                },
                createCameraVideoTrack: async function () {
                    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {encoderConfig: "480p_1"};
                    const t = WE.reportApiInvoke(null, {
                        tag: U_.TRACER,
                        name: M_.CREATE_CAM_VIDEO_TRACK,
                        options: [qk({}, e)]
                    }), r = DC(e), n = YS(8, "track-cam-");
                    let i = null;
                    em.info("start create camera video track with config", JSON.stringify(e), "trackId", n);
                    try {
                        i = (await my({video: r}, n)).getVideoTracks()[0] || null
                    } catch (e) {
                        throw t.onError(e), e
                    }
                    if (!i) {
                        const e = new Hf(qf.UNEXPECTED_ERROR, "can not find track in media stream");
                        return t.onError(e), e.throw()
                    }
                    e.optimizationMode && Hk(n, i, e, e.encoderConfig && cm(e.encoderConfig));
                    const o = new vA(i, e, r, e.scalabiltyMode ? dm(e.scalabiltyMode) : {
                        numSpatialLayers: 1,
                        numTemporalLayers: 1
                    }, e.optimizationMode, n);
                    return t.onSuccess(o.getTrackId()), em.info("create camera video success, trackId:", n), o
                },
                createCustomVideoTrack: function (e) {
                    const t = WE.reportApiInvoke(null, {
                        tag: U_.TRACER,
                        name: M_.CREATE_CUSTOM_VIDEO_TRACK,
                        options: [e]
                    }), r = new _A(e.mediaStreamTrack, {
                        bitrateMax: e.bitrateMax,
                        bitrateMin: e.bitrateMin
                    }, e.scalabiltyMode ? dm(e.scalabiltyMode) : {
                        numSpatialLayers: 1,
                        numTemporalLayers: 1
                    }, e.optimizationMode);
                    return t.onSuccess(r.getTrackId()), em.info("create custom video track success with config", e, "trackId", r.getTrackId()), r
                },
                createScreenVideoTrack: async function () {
                    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                        t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "disable";
                    const r = WE.reportApiInvoke(null, {
                        tag: U_.TRACER,
                        name: M_.CREATE_SCREEN_VIDEO_TRACK,
                        options: [qk({}, e), t]
                    });
                    e.encoderConfig ? "string" == typeof e.encoderConfig || e.encoderConfig.width && e.encoderConfig.height || (e.encoderConfig.width = {max: 1920}, e.encoderConfig.height = {max: 1080}) : e.encoderConfig = "1080p_2";
                    const n = function (e) {
                        const t = {};
                        e.screenSourceType && (t.mediaSource = e.screenSourceType), e.extensionId && Rh() && (t.extensionId = e.extensionId), e.electronScreenSourceId && (t.sourceId = e.electronScreenSourceId);
                        const r = e.encoderConfig ? um(e.encoderConfig) : null;
                        return t.mandatory = {
                            chromeMediaSource: "desktop",
                            maxWidth: r ? r.width : void 0,
                            maxHeight: r ? r.height : void 0
                        }, r && r.frameRate && ("number" == typeof r.frameRate ? (t.mandatory.maxFrameRate = r.frameRate, t.mandatory.minFrameRate = r.frameRate) : (t.mandatory.maxFrameRate = r.frameRate.max || r.frameRate.ideal || r.frameRate.exact || void 0, t.mandatory.minFrameRate = r.frameRate.min || r.frameRate.ideal || r.frameRate.exact || void 0), t.frameRate = r.frameRate), r && r.width && (t.width = r.width), r && r.height && (t.height = r.height), t
                    }(e), i = YS(8, "track-scr");
                    let o = null, s = null;
                    const a = og();
                    if (!a.supportShareAudio && "enable" === t) {
                        const e = new Hf(qf.NOT_SUPPORTED, "your browser or platform is not support share-screen with audio");
                        return r.onError(e), e.throw()
                    }
                    em.info("start create screen video track with config", e, "withAudio", t, "trackId", i);
                    try {
                        const c = await my({
                            screen: n,
                            screenAudio: "auto" === t ? a.supportShareAudio : "enable" === t
                        }, i);
                        o = c.getVideoTracks()[0] || null, s = c.getAudioTracks()[0] || null
                    } catch (e) {
                        throw r.onError(e), e
                    }
                    if (!o) {
                        const e = new Hf(qf.UNEXPECTED_ERROR, "can not find track in media stream");
                        return r.onError(e), e.throw()
                    }
                    if (!s && "enable" === t) {
                        o && o.stop();
                        const e = new Hf(qf.SHARE_AUDIO_NOT_ALLOWED);
                        return r.onError(e), e.throw()
                    }
                    e.optimizationMode || (e.optimizationMode = "detail"), e.optimizationMode && (Hk(i, o, e, e.encoderConfig && um(e.encoderConfig)), e.encoderConfig && "string" != typeof e.encoderConfig && (e.encoderConfig.bitrateMin = e.encoderConfig.bitrateMax));
                    const c = new _A(o, e.encoderConfig ? um(e.encoderConfig) : {}, e.scalabiltyMode ? dm(e.scalabiltyMode) : {
                        numSpatialLayers: 1,
                        numTemporalLayers: 1
                    }, e.optimizationMode, i, [Pv.SCREEN_TRACK]);
                    if (!s) return r.onSuccess(c.getTrackId()), em.info("create screen video track success", "video:", c.getTrackId()), c;
                    const u = new RS(s);
                    return r.onSuccess([c.getTrackId(), u.getTrackId()]), em.info("create screen video track success", "video:", c.getTrackId(), "audio:", u.getTrackId()), [c, u]
                },
                createMicrophoneAndCameraTracks: async function () {
                    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                        t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {encoderConfig: "480p_1"};
                    const r = WE.reportApiInvoke(null, {
                        tag: U_.TRACER,
                        name: M_.CREATE_MIC_AND_CAM_TRACKS,
                        options: [e, t]
                    }), n = DC(t), i = kC(e), o = YS(8, "track-mic-"), s = YS(8, "track-cam-");
                    let a = null, c = null;
                    em.info("start create camera video track(".concat(s, ") and microphone audio track(").concat(o, ") with config, audio: ").concat(JSON.stringify(e), ", video: ").concat(JSON.stringify(t)));
                    try {
                        const t = await my({audio: i, video: n}, "".concat(o, "-").concat(s));
                        a = t.getAudioTracks()[0], c = t.getVideoTracks()[0]
                    } catch (e) {
                        throw r.onError(e), e
                    }
                    if (!a || !c) {
                        const e = new Hf(qf.UNEXPECTED_ERROR, "can not find tracks in media stream");
                        return r.onError(e), e.throw()
                    }
                    t.optimizationMode && Hk(s, c, t, t.encoderConfig && cm(t.encoderConfig));
                    const u = new IS(a, e, i, o), d = new vA(c, t, n, t.scalabiltyMode ? dm(t.scalabiltyMode) : {
                        numSpatialLayers: 1,
                        numTemporalLayers: 1
                    }, t.optimizationMode, s);
                    return r.onSuccess([u.getTrackId(), d.getTrackId()]), em.info("create camera video track(".concat(s, ") and microphone audio track(").concat(o, ") success")), [u, d]
                },
                createMicrophoneAudioTrack: async function () {
                    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    const t = WE.reportApiInvoke(null, {tag: U_.TRACER, name: M_.CREATE_MIC_AUDIO_TRACK, options: [e]}),
                        r = kC(e), n = YS(8, "track-mic-");
                    let i = null;
                    em.info("start create microphone audio track with config", JSON.stringify(e), "trackId", n);
                    try {
                        i = (await my({audio: r}, n)).getAudioTracks()[0] || null
                    } catch (e) {
                        throw t.onError(e), e
                    }
                    if (!i) {
                        const e = new Hf(qf.UNEXPECTED_ERROR, "can not find track in media stream");
                        return t.onError(e), e.throw()
                    }
                    const o = new IS(i, e, r, n);
                    return t.onSuccess(o.getTrackId()), em.info("create microphone audio track success, trackId:", n), o
                },
                createCustomAudioTrack: function (e) {
                    const t = WE.reportApiInvoke(null, {
                        tag: U_.TRACER,
                        name: M_.CREATE_CUSTOM_AUDIO_TRACK,
                        options: [e]
                    }), r = new RS(e.mediaStreamTrack, e.encoderConfig ? hm(e.encoderConfig) : {});
                    return em.info("create custom audio track success with config", e, "trackId", r.getTrackId()), t.onSuccess(r.getTrackId()), r
                },
                createBufferSourceAudioTrack: async function (e) {
                    const t = WE.reportApiInvoke(null, {
                        tag: U_.TRACER,
                        name: M_.CREATE_BUFFER_AUDIO_TRACK,
                        options: [e]
                    });
                    if (fm("DISABLE_WEBAUDIO")) throw new Hf(qf.NOT_SUPPORTED, "can not create BufferSourceAudioTrack when WebAudio disabled");
                    const r = YS(8, "track-buf-");
                    em.info("start create buffer source audio track with config", JSON.stringify(e), "trackId", r);
                    const n = e.source;
                    if (!(e.source instanceof AudioBuffer)) try {
                        e.source = await async function (e, t) {
                            let r = null;
                            if ("string" == typeof e) {
                                const t = Wk.get(e);
                                if (t) return em.debug("use cached audio resource: ", e), t;
                                try {
                                    r = (await Yf(() => Bf.get(e, {responseType: "arraybuffer"}), void 0, void 0, {maxRetryCount: 3})).data
                                } catch (e) {
                                    throw new Hf(qf.FETCH_AUDIO_FILE_FAILED, e.toString())
                                }
                            } else {
                                const t = new sl((t, r) => {
                                    const n = new FileReader;
                                    n.onload = (e => {
                                        e.target ? t(e.target.result) : r(new Hf(qf.READ_LOCAL_AUDIO_FILE_ERROR))
                                    }), n.onerror = (() => {
                                        r(new Hf(qf.READ_LOCAL_AUDIO_FILE_ERROR))
                                    }), n.readAsArrayBuffer(e)
                                });
                                r = await t
                            }
                            const n = await function (e) {
                                const t = ZE();
                                return new sl((r, n) => {
                                    t.decodeAudioData(e, e => {
                                        r(e)
                                    }, e => {
                                        n(new Hf(qf.DECODE_AUDIO_FILE_FAILED, e.toString()))
                                    })
                                })
                            }(r);
                            return "string" == typeof e && t && Wk.set(e, n), n
                        }(e.source, e.cacheOnlineFile)
                    } catch (e) {
                        return t.onError(e), e.throw()
                    }
                    const i = new class extends sy {
                        set currentState(e) {
                            e !== this._currentState && (this._currentState = e, this.emit(tv.AUDIO_SOURCE_STATE_CHANGE, this._currentState))
                        }

                        get currentState() {
                            return this._currentState
                        }

                        constructor(e) {
                            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                            super(), Kh(this, "audioBuffer", void 0), Kh(this, "sourceNode", void 0), Kh(this, "startPlayTime", 0), Kh(this, "startPlayOffset", 0), Kh(this, "pausePlayTime", 0), Kh(this, "options", void 0), Kh(this, "currentLoopCount", 0), Kh(this, "_currentState", "stopped"), this.audioBuffer = e, this.options = t, this.startPlayOffset = this.options.startPlayTime || 0
                        }

                        createWebAudioDiagram() {
                            return this.context.createGain()
                        }

                        get duration() {
                            return this.audioBuffer.duration
                        }

                        get currentTime() {
                            return "stopped" === this.currentState ? 0 : "paused" === this.currentState ? this.pausePlayTime : (this.context.currentTime - this.startPlayTime + this.startPlayOffset) % this.audioBuffer.duration
                        }

                        updateOptions(e) {
                            "stopped" === this.currentState ? (this.options = e, this.startPlayOffset = this.options.startPlayTime || 0) : em.warning("can not set audio source options")
                        }

                        startProcessAudioBuffer() {
                            this.sourceNode && this.stopProcessAudioBuffer(), this.sourceNode = this.createSourceNode(), this.startSourceNode(), this.currentState = "playing"
                        }

                        pauseProcessAudioBuffer() {
                            this.sourceNode && "playing" === this.currentState && (this.pausePlayTime = this.currentTime, this.sourceNode.onended = null, this.sourceNode.stop(), this.sourceNode.buffer = null, this.sourceNode = this.createSourceNode(), this.currentState = "paused")
                        }

                        seekAudioBuffer(e) {
                            this.sourceNode && (this.sourceNode.onended = null, "playing" === this.currentState && this.sourceNode.stop(), this.sourceNode = this.createSourceNode(), "playing" === this.currentState ? (this.startPlayOffset = e, this.startSourceNode()) : "paused" === this.currentState && (this.pausePlayTime = e))
                        }

                        resumeProcessAudioBuffer() {
                            "paused" === this.currentState && this.sourceNode && (this.startPlayOffset = this.pausePlayTime, this.pausePlayTime = 0, this.startSourceNode(), this.currentState = "playing")
                        }

                        stopProcessAudioBuffer() {
                            if (this.sourceNode) {
                                this.sourceNode.onended = null;
                                try {
                                    this.sourceNode.stop()
                                } catch (e) {
                                }
                                this.reset()
                            }
                        }

                        startSourceNode() {
                            this.sourceNode && this.sourceNode.buffer && (this.sourceNode.start(0, this.startPlayOffset), this.startPlayTime = this.context.currentTime, this.sourceNode.onended = this.handleSourceNodeEnded.bind(this))
                        }

                        createSourceNode() {
                            const e = this.context.createBufferSource();
                            return e.buffer = this.audioBuffer, e.loop = !!this.options.loop, e.connect(this.outputNode), e
                        }

                        handleSourceNodeEnded() {
                            if (this.currentLoopCount += 1, this.options.cycle && this.options.cycle > this.currentLoopCount) return this.startPlayOffset = 0, this.sourceNode = void 0, void this.startProcessAudioBuffer();
                            this.reset()
                        }

                        reset() {
                            this.startPlayOffset = this.options.startPlayTime || 0, this.currentState = "stopped", this.sourceNode && (this.sourceNode.disconnect(), this.sourceNode = void 0), this.currentLoopCount = 0
                        }
                    }(e.source), o = new wS(n, i, e.encoderConfig ? hm(e.encoderConfig) : {}, r);
                    return em.info("create buffer source audio track success, trackId:", r), t.onSuccess(o.getTrackId()), o
                },
                setAppType: function (e) {
                    if (em.debug("setAppType: ".concat(e)), !(Number.isInteger(e) && e >= 0)) throw em.debug("Invalid appType"), new Hf(qf.INVALID_PARAMS, "invalid app type", e);
                    pm("APP_TYPE", Math.floor(e))
                },
                setLogLevel: function (e) {
                    em.setLogLevel(e)
                },
                enableLogUpload: function () {
                    fm("USE_NEW_LOG") ? pm("UPLOAD_LOG", !0) : em.enableLogUpload()
                },
                disableLogUpload: function () {
                    fm("USE_NEW_LOG") ? pm("UPLOAD_LOG", !1) : em.disableLogUpload()
                },
                createChannelMediaRelayConfiguration: function () {
                    return new tC
                },
                checkAudioTrackIsActive: async function (e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5e3;
                    const r = WE.reportApiInvoke(null, {
                        tag: U_.TRACER,
                        name: M_.CHECK_AUDIO_TRACK_IS_ACTIVE,
                        options: [t]
                    });
                    if (!(e instanceof RS || e instanceof WP)) {
                        const e = new Hf(qf.INVALID_TRACK, "the parameter is not a audio track");
                        return r.onError(e), e.throw()
                    }
                    t && t < 1e3 && (t = 1e3);
                    const n = e instanceof RS ? e.getTrackLabel() : "remote_track", i = e.getVolumeLevel();
                    let o = i, s = i;
                    const a = Date.now();
                    return new sl(i => {
                        const c = setInterval(() => {
                            const u = e.getVolumeLevel(), d = (o = u > o ? u : o) - (s = u < s ? u : s) > 1e-4,
                                l = Date.now() - a;
                            if (d || l > t) {
                                clearInterval(c);
                                const t = d, s = {duration: l, deviceLabel: n, maxVolumeLevel: o, result: t};
                                em.info("[track-".concat(e.getTrackId(), "] check audio track active completed. ").concat(JSON.stringify(s))), r.onSuccess(s), i(t)
                            }
                        }, 200)
                    })
                },
                checkVideoTrackIsActive: async function (e) {
                    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 5e3;
                    const r = WE.reportApiInvoke(null, {
                        tag: U_.TRACER,
                        name: M_.CHECK_VIDEO_TRACK_IS_ACTIVE,
                        options: [t]
                    });
                    if (!(e instanceof _A || e instanceof BP)) {
                        const e = new Hf(qf.INVALID_TRACK, "the parameter is not a video track");
                        return r.onError(e), e.throw()
                    }
                    t && t < 1e3 && (t = 1e3);
                    const n = e instanceof _A ? e.getTrackLabel() : "remote_track", i = e.getMediaStreamTrack(!0),
                        o = document.createElement("video");
                    o.style.width = "1px", o.style.height = "1px", o.setAttribute("muted", ""), o.muted = !0, o.setAttribute("playsinline", ""), o.controls = !1, (Ih() || Th()) && (o.style.opacity = "0.01", o.style.position = "fixed", o.style.left = "0", o.style.top = "0", document.body.appendChild(o)), o.srcObject = new MediaStream([i]), o.play();
                    const s = document.createElement("canvas");
                    s.width = 160, s.height = 120;
                    let a = 0, c = 0;
                    try {
                        const n = Date.now();
                        a = await function (e, t, r, n) {
                            let i, o = 0, s = null;
                            return new sl((a, c) => {
                                setTimeout(() => {
                                    i && (i(), a(o))
                                }, t), i = ry(() => {
                                    !function () {
                                        o > n && i && (i(), a(o));
                                        const t = r.getContext("2d");
                                        if (!t) {
                                            const e = new Hf(qf.UNEXPECTED_ERROR, "can not get canvas 2d context.");
                                            return em.error(e.toString()), void c(e)
                                        }
                                        t.drawImage(e, 0, 0, 160, 120);
                                        const u = t.getImageData(0, 0, r.width, r.height),
                                            d = Math.floor(u.data.length / 3);
                                        if (s) {
                                            for (let e = 0; e < d; e += 3) if (u.data[e] !== s[e]) return o += 1, void (s = u.data);
                                            s = u.data
                                        } else s = u.data
                                    }()
                                }, 30)
                            })
                        }(o, t, s, 4), c = Date.now() - n
                    } catch (e) {
                        throw r.onError(e), e
                    }
                    Kk === vh.SAFARI && (o.pause(), o.remove()), o.srcObject = null;
                    const u = a > 4, d = {duration: c, changedPicNum: a, deviceLabel: n, result: u};
                    return em.info("[track-".concat(e.getTrackId(), "] check video track active completed. ").concat(JSON.stringify(d))), r.onSuccess(d), u
                },
                setArea: function (e) {
                    const t = WE.reportApiInvoke(null, {name: M_.SET_AREA, options: e, tag: U_.TRACER});
                    try {
                        let t = [];
                        if ("string" == typeof e && (t = [e]), Array.isArray(e) && (e.forEach(e => {
                            if (!Vv.includes(e)) throw new Hf(qf.INVALID_PARAMS, "invalid area code")
                        }), t = e), "[object Object]" === Object.prototype.toString.call(e)) {
                            const {areaCode: r, excludedArea: n} = e;
                            if (!r) throw new Hf(qf.INVALID_PARAMS, "area code is needed");
                            let i = r;
                            "string" == typeof r && (i = [r]), t = n ? function (e, t) {
                                let r = [];
                                if (e.includes(Mv.GLOBAL)) {
                                    const o = [Mv.GLOBAL, Mv.OVERSEA], s = Object.keys(Bv);
                                    if (t === Mv.GLOBAL) throw new Hf(qf.INVALID_PARAMS, "GLOBAL is an invalid excludedArea value");
                                    if (t === Mv.CHINA) r = [Mv.OVERSEA]; else if (i = t, Bw.includes(i)) {
                                        const e = (n = t, Fw[Mv.GLOBAL][n] || []), i = [...o, t, ...e];
                                        r = s.filter(e => !i.includes(e))
                                    } else if (function (e) {
                                        let t = !1;
                                        return Bw.forEach(r => {
                                            Fw[Mv.GLOBAL][r].includes(e) && (t = !0)
                                        }), t
                                    }(t)) {
                                        const e = function (e) {
                                            let t;
                                            return Bw.forEach(r => {
                                                Fw[Mv.GLOBAL][r].includes(e) && (t = r)
                                            }), t
                                        }(t), n = [...o, e, t];
                                        r = s.filter(e => !n.includes(e))
                                    } else r = e;
                                    r = function (e) {
                                        const t = [];
                                        return Ww.forEach(r => {
                                            e.includes(r) && t.push(r)
                                        }), t.concat(e.filter(e => !Ww.includes(e)))
                                    }(r)
                                } else r = e;
                                var n, i;
                                return r
                            }(i, n) : i
                        }
                        pm("AREAS", t);
                        const r = (e => {
                            const t = {
                                CODE: "",
                                WEBCS_DOMAIN: [],
                                WEBCS_DOMAIN_BACKUP_LIST: [],
                                PROXY_CS: [],
                                CDS_AP: [],
                                ACCOUNT_REGISTER: [],
                                UAP_AP: [],
                                EVENT_REPORT_DOMAIN: [],
                                EVENT_REPORT_BACKUP_DOMAIN: [],
                                LOG_UPLOAD_SERVER: [],
                                PROXY_SERVER_TYPE3: []
                            };
                            return e.map(e => {
                                const r = Bv[e], n = Object.keys(r);
                                n && n.map(e => {
                                    "CODE" !== e && (t[e] = t[e].concat(r[e]))
                                })
                            }), t
                        })(t);
                        Object.keys(r).map(e => {
                            pm(e, "LOG_UPLOAD_SERVER" === e || "EVENT_REPORT_DOMAIN" === e || "EVENT_REPORT_BACKUP_DOMAIN" === e || "PROXY_SERVER_TYPE3" === e ? r[e][0] : r[e])
                        }), em.debug("set area success:", t.join(","))
                    } catch (e) {
                        throw t.onError(e), e
                    }
                    t.onSuccess()
                },
                audioElementPlayCenter: Sy,
                processExternalMediaAEC: function (e) {
                    Qk.processExternalMediaAEC(e)
                },
                registerExtensions: function (e) {
                    e.forEach(e => {
                        const t = e;
                        t.__registered__ = !0, t.logger.hookLog = em.extLog, t.reporter.hookApiInvoke = WE.extApiInvoke, t.parameters && Object.keys(t.parameters).forEach(e => {
                            t.parameters[e] = fm(e)
                        })
                    })
                },
                ChannelMediaRelayError: wv,
                ChannelMediaRelayEvent: Rv,
                ChannelMediaRelayState: Iv,
                RemoteStreamFallbackType: kv,
                RemoteStreamType: Dv,
                ConnectionDisconnectedReason: K_,
                AudienceLatencyLevelType: H_,
                AREAS: Mv
            }, Zk = window || document;
            return Object.defineProperties($k, {
                onAudioAutoplayFailed: {
                    get: () => LE.onAudioAutoplayFailed, set: e => {
                        LE.onAudioAutoplayFailed = e
                    }
                },
                onAutoplayFailed: {
                    get: () => LE.onAutoplayFailed, set: e => {
                        LE.onAutoplayFailed = e
                    }
                },
                _onSecurityPolicyViolation: {value: void 0, writable: !0},
                _cspEventHandlerPointer: {value: void 0, writable: !0},
                onSecurityPolicyViolation: {
                    get: () => $k._onSecurityPolicyViolation, set(e) {
                        if ($k._onSecurityPolicyViolation = e, !Zk) return;
                        const t = e => {
                            if (!(e && e.blockedURI && $k.onSecurityPolicyViolation)) return;
                            const t = e.blockedURI;
                            fm("CSP_DETECTED_HOSTNAME_LIST").some(e => t.includes(e)) && $k.onSecurityPolicyViolation && "function" == typeof $k.onSecurityPolicyViolation && $k.onSecurityPolicyViolation(e)
                        }, r = $k._cspEventHandlerPointer;
                        r && Zk.removeEventListener("securitypolicyviolation", r), e && "function" == typeof e && Zk.addEventListener("securitypolicyviolation", t), $k._cspEventHandlerPointer = t
                    }
                }
            }), Ey.on(V_.CAMERA_DEVICE_CHANGED, e => {
                em.info("camera device changed", JSON.stringify(e)), $k.onCameraChanged && $k.onCameraChanged(e)
            }), Ey.on(V_.RECORDING_DEVICE_CHANGED, e => {
                em.info("microphone device changed", JSON.stringify(e)), $k.onMicrophoneChanged && $k.onMicrophoneChanged(e)
            }), Ey.on(V_.PLAYOUT_DEVICE_CHANGED, e => {
                em.debug("playout device changed", JSON.stringify(e)), $k.onPlaybackDeviceChanged && $k.onPlaybackDeviceChanged(e)
            }), Sy.onAutoplayFailed = (() => {
                em.info("detect audio element autoplay failed"), LE.onAudioAutoplayFailed && LE.onAudioAutoplayFailed()
            }), $E.on("autoplay-failed", () => {
                em.info("detect webaudio autoplay failed"), LE.onAudioAutoplayFailed && LE.onAudioAutoplayFailed()
            }), window && (window.__ARTC__ = $k), $k
        }()
    }).call(this, r(25), r(22).Buffer, r(14))
}, function (e, t, r) {
    "use strict";

    function n(e, t, r, n) {
        var i = n ? " !== " : " === ", o = n ? " || " : " && ", s = n ? "!" : "", a = n ? "" : "!";
        switch (e) {
            case"null":
                return t + i + "null";
            case"array":
                return s + "Array.isArray(" + t + ")";
            case"object":
                return "(" + s + t + o + "typeof " + t + i + '"object"' + o + a + "Array.isArray(" + t + "))";
            case"integer":
                return "(typeof " + t + i + '"number"' + o + a + "(" + t + " % 1)" + o + t + i + t + (r ? o + s + "isFinite(" + t + ")" : "") + ")";
            case"number":
                return "(typeof " + t + i + '"' + e + '"' + (r ? o + s + "isFinite(" + t + ")" : "") + ")";
            default:
                return "typeof " + t + i + '"' + e + '"'
        }
    }

    e.exports = {
        copy: function (e, t) {
            for (var r in t = t || {}, e) t[r] = e[r];
            return t
        },
        checkDataType: n,
        checkDataTypes: function (e, t, r) {
            switch (e.length) {
                case 1:
                    return n(e[0], t, r, !0);
                default:
                    var i = "", s = o(e);
                    for (var a in s.array && s.object && (i = s.null ? "(" : "(!" + t + " || ", i += "typeof " + t + ' !== "object")', delete s.null, delete s.array, delete s.object), s.number && delete s.integer, s) i += (i ? " && " : "") + n(a, t, r, !0);
                    return i
            }
        },
        coerceToTypes: function (e, t) {
            if (Array.isArray(t)) {
                for (var r = [], n = 0; n < t.length; n++) {
                    var o = t[n];
                    i[o] ? r[r.length] = o : "array" === e && "array" === o && (r[r.length] = o)
                }
                if (r.length) return r
            } else {
                if (i[t]) return [t];
                if ("array" === e && "array" === t) return ["array"]
            }
        },
        toHash: o,
        getProperty: c,
        escapeQuotes: u,
        equal: r(78),
        ucs2length: r(183),
        varOccurences: function (e, t) {
            t += "[^0-9]";
            var r = e.match(new RegExp(t, "g"));
            return r ? r.length : 0
        },
        varReplace: function (e, t, r) {
            return t += "([^0-9])", r = r.replace(/\$/g, "$$$$"), e.replace(new RegExp(t, "g"), r + "$1")
        },
        schemaHasRules: function (e, t) {
            if ("boolean" == typeof e) return !e;
            for (var r in e) if (t[r]) return !0
        },
        schemaHasRulesExcept: function (e, t, r) {
            if ("boolean" == typeof e) return !e && "not" != r;
            for (var n in e) if (n != r && t[n]) return !0
        },
        schemaUnknownRules: function (e, t) {
            if ("boolean" == typeof e) return;
            for (var r in e) if (!t[r]) return r
        },
        toQuotedString: d,
        getPathExpr: function (e, t, r, n) {
            return p(e, r ? "'/' + " + t + (n ? "" : ".replace(/~/g, '~0').replace(/\\//g, '~1')") : n ? "'[' + " + t + " + ']'" : "'[\\'' + " + t + " + '\\']'")
        },
        getPath: function (e, t, r) {
            var n = d(r ? "/" + f(t) : c(t));
            return p(e, n)
        },
        getData: function (e, t, r) {
            var n, i, o, s;
            if ("" === e) return "rootData";
            if ("/" == e[0]) {
                if (!l.test(e)) throw new Error("Invalid JSON-pointer: " + e);
                i = e, o = "rootData"
            } else {
                if (!(s = e.match(h))) throw new Error("Invalid JSON-pointer: " + e);
                if (n = +s[1], "#" == (i = s[2])) {
                    if (n >= t) throw new Error("Cannot access property/index " + n + " levels up, current level is " + t);
                    return r[t - n]
                }
                if (n > t) throw new Error("Cannot access data " + n + " levels up, current level is " + t);
                if (o = "data" + (t - n || ""), !i) return o
            }
            for (var a = o, u = i.split("/"), d = 0; d < u.length; d++) {
                var p = u[d];
                p && (o += c(m(p)), a += " && " + o)
            }
            return a
        },
        unescapeFragment: function (e) {
            return m(decodeURIComponent(e))
        },
        unescapeJsonPointer: m,
        escapeFragment: function (e) {
            return encodeURIComponent(f(e))
        },
        escapeJsonPointer: f
    };
    var i = o(["string", "number", "integer", "boolean", "null"]);

    function o(e) {
        for (var t = {}, r = 0; r < e.length; r++) t[e[r]] = !0;
        return t
    }

    var s = /^[a-z$_][a-z$_0-9]*$/i, a = /'|\\/g;

    function c(e) {
        return "number" == typeof e ? "[" + e + "]" : s.test(e) ? "." + e : "['" + u(e) + "']"
    }

    function u(e) {
        return e.replace(a, "\\$&").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\f/g, "\\f").replace(/\t/g, "\\t")
    }

    function d(e) {
        return "'" + u(e) + "'"
    }

    var l = /^\/(?:[^~]|~0|~1)*$/, h = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;

    function p(e, t) {
        return '""' == e ? t : (e + " + " + t).replace(/([^\\])' \+ '/g, "$1")
    }

    function f(e) {
        return e.replace(/~/g, "~0").replace(/\//g, "~1")
    }

    function m(e) {
        return e.replace(/~1/g, "/").replace(/~0/g, "~")
    }
}, function (e, t, r) {
    "use strict";
    var n = r(291)();
    e.exports = function (e) {
        return e !== n && null !== e
    }
}, function (e, t, r) {
    "use strict";
    e.exports = function (e) {
        return void 0 !== e && null !== e
    }
}, function (e, t, r) {
    "use strict";
    r.d(t, "a", function () {
        return I
    });
    var n = r(6), i = r.n(n), o = r(8), s = r.n(o), a = r(10), c = r.n(a), u = r(11), d = r.n(u), l = r(7), h = r.n(l),
        p = r(3), f = r.n(p), m = r(16), _ = r(17), v = r(2), g = r(0), E = r(64), y = r(4), S = r(1);

    function b(e) {
        var t = function () {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function () {
                })), !0
            } catch (e) {
                return !1
            }
        }();
        return function () {
            var r, n = h()(e);
            if (t) {
                var i = h()(this).constructor;
                r = Reflect.construct(n, arguments, i)
            } else r = n.apply(this, arguments);
            return d()(this, r)
        }
    }

    var T = v.a.LOG_LEVELS, R = (T.INFO, T.WARN, T.ERROR), I = function (e) {
        c()(r, e);
        var t = b(r);

        function r() {
            return i()(this, r), t.apply(this, arguments)
        }

        return s()(r, null, [{
            key: "createUser", value: function (e, t) {
                return Object(y.a)(t, function (t) {
                    if (!r.Client || !r.Client.getInstance()) return t(g.errors.NOT_INITIALIZED);
                    var n = r.Client.getInstance();
                    if ("string" != typeof e.displayName) return S.a.log(R, g.errors.INVALID_USER_NAME, {}), t(g.errors.INVALID_USER_NAME);
                    n.request(r.basePath, {method: "post", data: e}).then(function (e) {
                        return t(null, new _.a(n, e.data))
                    }).catch(function (e) {
                        return t(n.error(e))
                    })
                })
            }
        }, {
            key: "createGuest", value: function (e, t) {
                if (!r.Client || !r.Client.getInstance()) return t("You have not initialized channelize client yet.");
                var n = r.Client.getInstance();
                return Object(y.a)(t, function (t) {
                    if ("string" != typeof e.displayName) return S.a.log(R, g.errors.INVALID_USER_NAME, {}), t(g.errors.INVALID_USER_NAME);
                    n.request("".concat(r.basePath, "/create_guest"), {method: "post", data: e}).then(function (e) {
                        var r = new _.a(n, e.data);
                        return t(null, r)
                    }).catch(function (e) {
                        return S.a.log(R, g.errors.API_ERROR, {err: n.error(e)}), t(n.error(e))
                    })
                })
            }
        }, {
            key: "get", value: function (e, t) {
                return Object(y.a)(t, function (t) {
                    if (!r.Client || !r.Client.getInstance()) return t(g.errors.NOT_INITIALIZED);
                    var n = r.Client.getInstance();
                    if ("string" != typeof e) return S.a.log(R, g.errors.INVALID_ID, {}), t(g.errors.INVALID_ID);
                    n.request("".concat(r.basePath, "/").concat(e), {method: "get"}).then(function (e) {
                        return t(null, new _.a(n, e.data))
                    }).catch(function (e) {
                        return S.a.log(R, g.errors.API_ERROR, {err: n.error(e)}), t(n.error(e))
                    })
                })
            }
        }, {
            key: "createUserListQuery", value: function () {
                if (!r.Client || !r.Client.getInstance()) throw new Error(g.errors.NOT_INITIALIZED);
                var e = r.Client.getInstance();
                return new E.a(e)
            }
        }]), r
    }(m.a);
    f()(I, "basePath", v.a.BASEPATH_USERS)
}, function (e, t, r) {
    "use strict";
    r.d(t, "a", function () {
        return C
    });
    var n = r(6), i = r.n(n), o = r(8), s = r.n(o), a = r(10), c = r.n(a), u = r(11), d = r.n(u), l = r(7), h = r.n(l),
        p = r(3), f = r.n(p), m = r(16), _ = r(66), v = r(38), g = r(2), E = r(13), y = r(0), S = r(39), b = r(4),
        T = r(1);

    function R(e) {
        var t = function () {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function () {
                })), !0
            } catch (e) {
                return !1
            }
        }();
        return function () {
            var r, n = h()(e);
            if (t) {
                var i = h()(this).constructor;
                r = Reflect.construct(n, arguments, i)
            } else r = n.apply(this, arguments);
            return d()(this, r)
        }
    }

    var I = g.a.LOG_LEVELS, w = (I.INFO, I.WARN, I.ERROR), C = function (e) {
        c()(r, e);
        var t = R(r);

        function r() {
            return i()(this, r), t.apply(this, arguments)
        }

        return s()(r, null, [{
            key: "getLiveBroadcast", value: function (e, t) {
                return Object(b.a)(t, function (t) {
                    if (!r.Client || !r.Client.getInstance()) return t(y.errors.NOT_INITIALIZED);
                    if ("string" != typeof e) return T.a.log(w, y.errors.INVALID_ID, {}), t(y.errors.INVALID_ID);
                    var n = r.Client.getInstance();
                    n.request("".concat(r.basePath, "/").concat(e), {method: "get", absolute: !0}).then(function (e) {
                        // ailoo hack
                        n.request("/Shopify/LiveBroadcast.rails?id=" + e.data.id, {method: "get", absolute: !0}).then(function (e2) {
                            e.data.products = e2.data.products;
                            var r = e.data ? n.liveBroadcastModel(e.data) : null;
                            return t(null, r)

                        });
                    }).catch(function (e) {
                        return T.a.log(w, y.errors.API_ERROR, {err: n.error(e)}), t(n.error(e))
                    })
                })
            }
        }, {
            key: "getLivebroadcastGlobalSettings", value: function (e) {
                var t = this;
                return Object(b.a)(e, function (e) {
                    r.Client.getInstance().request("".concat(E.a.LIVE_BROADCAST_BASE_URL).concat(r.livebroadcastGlobalSettingsPath), {
                        method: "get",
                        absolute: !0
                    }).then(function (t) {
                        return e(null, t.data)
                    }).catch(function (r) {
                        return T.a.log(w, y.errors.API_ERROR, {err: t._client.error(r)}), e(t._client.error(r))
                    })
                })
            }
        }, {
            key: "createLiveBroadcast", value: function (e, t) {
                return Object(b.a)(t, function (t) {
                    if (!r.Client || !r.Client.getInstance()) return t(y.errors.NOT_INITIALIZED);
                    var n = v.a.validate(e, Object(S.createSchema)());
                    if (n) return T.a.log(w, n, {}), t(n);
                    var i = r.Client.getInstance();
                    i.request(r.basePath, {method: "post", data: e, absolute: !0}).then(function (e) {
                        var r = i.liveBroadcastModel(e.data);
                        return t(null, r)
                    }).catch(function (e) {
                        return T.a.log(w, y.errors.API_ERROR, {err: i.error(e)}), t(i.error(e))
                    })
                })
            }
        }, {
            key: "createLiveBroadcastListQuery", value: function () {
                if (!r.Client || !r.Client.getInstance()) throw new Error(y.errors.NOT_INITIALIZED);
                var e = r.Client.getInstance();
                return new _.a(e)
            }
        }]), r
    }(m.a);
    f()(C, "basePath", "".concat(E.a.LIVE_BROADCAST_BASE_URL).concat(g.a.BASEPATH_LIVE_BROADCASTS)), f()(C, "livebroadcastGlobalSettingsPath", "".concat(g.a.BASEPATH_LIVEBROADCAST_GLOBAL_SETTINGS))
}, function (e, t, r) {
    "use strict";
    r.d(t, "a", function () {
        return q
    });
    var n = r(18), i = r.n(n), o = r(155), s = r.n(o), a = r(12), c = r.n(a), u = r(6), d = r.n(u), l = r(8),
        h = r.n(l), p = r(19), f = r.n(p), m = r(10), _ = r.n(m), v = r(11), g = r.n(v), E = r(7), y = r.n(E), S = r(3),
        b = r.n(S), T = r(5), R = r.n(T), I = r(97), w = r(34), C = r(38), A = r(2), O = r(0), N = r(13), P = r(4),
        D = r(39), k = r(67), L = r(68), x = r(69), M = r(70), U = r(1), j = r(24);

    function V(e, t) {
        var r = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
            var n = Object.getOwnPropertySymbols(e);
            t && (n = n.filter(function (t) {
                return Object.getOwnPropertyDescriptor(e, t).enumerable
            })), r.push.apply(r, n)
        }
        return r
    }

    function F(e) {
        for (var t = 1; t < arguments.length; t++) {
            var r = null != arguments[t] ? arguments[t] : {};
            t % 2 ? V(Object(r), !0).forEach(function (t) {
                b()(e, t, r[t])
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : V(Object(r)).forEach(function (t) {
                Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t))
            })
        }
        return e
    }

    function B(e) {
        var t = function () {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function () {
                })), !0
            } catch (e) {
                return !1
            }
        }();
        return function () {
            var r, n = y()(e);
            if (t) {
                var i = y()(this).constructor;
                r = Reflect.construct(n, arguments, i)
            } else r = n.apply(this, arguments);
            return g()(this, r)
        }
    }

    var W = A.a.LOG_LEVELS, G = (W.INFO, W.WARN, W.ERROR), q = function (e) {
        _()(r, e);
        var t = B(r);

        function r(e, n) {
            var i;
            return d()(this, r), i = t.call(this, e, n), b()(f()(i), "__isConversationEvent", function (e) {
                return r.__conversationEvents.includes(e)
            }), i.reactionsPlaybackData = [], i.chatPlaybackData = [], i.products && i.products.length && (i.products = i.products.filter(function (e) {
                return e.show
            })), e.websocketConnected || e.options.disableWebSocket || !e.connectToWebsocket ? i.__subscribeStatusEvents() : e.connectToWebsocket().then(function () {
                i.__subscribeStatusEvents()
            }), i
        }

        return h()(r, [{
            key: "refresh", value: function (e) {
                var t = this;
                return Object(P.a)(e, function (e) {
                    // ailoo hack
                    t._client.request("".concat(r.basePath, "/").concat(t.id), {
//                    t._client.request("".concat("/Shopify/LiveBroadcast.rails", "?id=").concat(t.id), {
                        method: "get",
                        absolute: !0
                    }).then(function (r) {

                        t._client.request("".concat("/Shopify/LiveBroadcast.rails", "?id=").concat(t.id), {
                            method: "get",
                            absolute: !0
                        }).then(function (r2) {
                            var n;
                            r.data.products = r2.data.products;

                            return r.data.products = null === r || void 0 === r ? void 0 : null === (n = r.data) || void 0 === n ? void 0 : n.products.filter(function (e) {
                                return e.show
                            }), t.updateData(r.data), e(null);

                        });

                    }).catch(function (r) {
                        return U.a.log(G, O.errors.API_ERROR, {err: t._client.error(r)}), e(t._client.error(r))
                    })
                })
            }
        }, {
            key: "fetchProductsSpotlightPlaybackData", value: function (e) {
                var t = this;
                return Object(P.a)(e, function (e) {
                    t._client.request("".concat(r.basePath, "/").concat(t.id).concat(r.spotlightPlaybackPath), {
                        method: "get",
                        absolute: !0
                    }).then(function (r) {
                        return t.productSpotlightPlaybackData = r.data, e(null, {success: !0})
                    }).catch(function (r) {
                        return U.a.log(G, O.errors.API_ERROR, {err: t._client.error(r)}), e(t._client.error(r))
                    })
                })
            }
        }, {
            key: "getSpotlightProductsByTime", value: function (e) {
                if (!this.productSpotlightPlaybackData) throw new Error("please fetch products spotlight data first");
                var t = this.productSpotlightPlaybackData.find(function (t) {
                    return e >= t.start && e <= t.end
                });
                return t ? t.productIds : []
            }
        }, {
            key: "getProductSpotlightTimeline", value: function () {
                var e;
                if (!this.productSpotlightPlaybackData) throw new Error("please fetch products spotlight data first");
                if (null === this || void 0 === this || null === (e = this.settings) || void 0 === e || !e.productSpotlightTimeline) throw new Error("please enable product timeline first.");
                return this.productSpotlightPlaybackData.reduce(function (e, t) {
                    for (var r = 0; r < (null === t || void 0 === t ? void 0 : null === (n = t.productIds) || void 0 === n ? void 0 : n.length); r += 1) {
                        var n, i, o = t.productIds[r];
                        if (null !== (i = e) && void 0 !== i && i[o] || (e = F(F({}, e), {}, b()({}, o, []))), e[o].length) {
                            var s = e[o].length - 1;
                            t.start === e[o][s].end ? e[o][s] = F(F({}, e[o][s]), {}, {end: t.end}) : e[o].push({
                                start: t.start,
                                end: t.end
                            })
                        } else e[o].push({start: t.start, end: t.end})
                    }
                    return e
                }, {})
            }
        }, {
            key: "fetchReactionsPlaybackData", value: function (e, t) {
                var r = this, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1e3,
                    i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0,
                    o = arguments.length > 4 && void 0 !== arguments[4] && arguments[4],
                    s = arguments.length > 5 ? arguments[5] : void 0;
                return Object(P.a)(s, function (s) {
                    var a = r.createReactionsPlaybackQuery();
                    if (a.startTime = e, a.endTime = t, a.limit = n, a.skip = i, -1 === r.reactionsPlaybackData.findIndex(function (r) {
                        return r.startTime === e && r.endTime === t
                    })) r.reactionsPlaybackData.push({
                        count: 0,
                        startTime: e,
                        endTime: t,
                        reactions: [],
                        fullyLoaded: !1
                    }); else if (!o) return s(null, {success: !0});
                    a.list(function (o, a) {
                        if (o) return s(o);
                        var c = r.reactionsPlaybackData.findIndex(function (r) {
                            return r.startTime === e && r.endTime === t
                        });
                        if (-1 !== c) {
                            var u = r.reactionsPlaybackData[c];
                            if (u.count = a.count, u.reactions = u.reactions.concat(a.reactions), u.count > u.reactions.length) return r.fetchReactionsPlaybackData(e, t, n, n + i, !0, s);
                            u.fullyLoaded = !0
                        }
                        return s(null, {success: !0})
                    })
                })
            }
        }, {
            key: "getReactionsByTime", value: function (e) {
                var t = this.reactionsPlaybackData.find(function (t) {
                    return t.startTime <= e && e <= t.endTime
                });
                if (!t) throw new Error("REACTIONS_NOT_FETCHED");
                var r = t.reactions.filter(function (t) {
                    return t.timeInSec === e
                });
                return r.length ? r : []
            }
        }, {
            key: "fetchMessagesPlaybackData", value: function (e, t) {
                var r = this, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 500,
                    i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0,
                    o = arguments.length > 4 && void 0 !== arguments[4] && arguments[4],
                    s = arguments.length > 5 ? arguments[5] : void 0;
                return Object(P.a)(s, function (s) {
                    t = t || (new Date).toISOString(), e = j.a.setMilliSeconds(e, "000"), t = j.a.setMilliSeconds(t, "999");
                    var a = r.createMessageListQuery();
                    if (a.startTime = e, a.endTime = t, a.limit = n, a.skip = i, a.sort = "createdAt ASC", a.includeDeleted = !1, -1 === r.chatPlaybackData.findIndex(function (r) {
                        return r.startTime === e && r.endTime === t
                    })) r.chatPlaybackData.push({
                        count: 0,
                        startTime: e,
                        endTime: t,
                        messages: [],
                        fullyLoaded: !1
                    }); else if (!o) return s(null, {success: !0});
                    a.list(function () {
                        var u = c()(R.a.mark(function c(u, d) {
                            var l, h;
                            return R.a.wrap(function (c) {
                                for (; ;) switch (c.prev = c.next) {
                                    case 0:
                                        if (!u) {
                                            c.next = 2;
                                            break
                                        }
                                        return c.abrupt("return", s(u));
                                    case 2:
                                        if (-1 === (l = r.chatPlaybackData.findIndex(function (r) {
                                            return r.startTime === e && r.endTime === t
                                        }))) {
                                            c.next = 12;
                                            break
                                        }
                                        if (h = r.chatPlaybackData[l], o) {
                                            c.next = 8;
                                            break
                                        }
                                        return c.next = 8, a.count().then(function (e) {
                                            h.count = e.count
                                        }).catch(function (e) {
                                            return s(e)
                                        });
                                    case 8:
                                        if (h.messages = h.messages.concat(d), !(h.count > h.messages.length)) {
                                            c.next = 11;
                                            break
                                        }
                                        return c.abrupt("return", r.fetchMessagesPlaybackData(e, t, n, n + i, !0, s));
                                    case 11:
                                        h.fullyLoaded = !0;
                                    case 12:
                                        return c.abrupt("return", s(null, {success: !0}));
                                    case 13:
                                    case"end":
                                        return c.stop()
                                }
                            }, c)
                        }));
                        return function (e, t) {
                            return u.apply(this, arguments)
                        }
                    }())
                })
            }
        }, {
            key: "getMessagesByTime", value: function (e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                if (e = j.a.setMilliSeconds(e, "000"), t) {
                    var r = [];
                    if (this.chatPlaybackData[this.chatPlaybackData.length - 1].endTime < e) throw new Error("MESSAGES_NOT_FETCHED");
                    return this.chatPlaybackData.forEach(function (t) {
                        if (!t.fullyLoaded) throw new Error("MESSAGES_NOT_FETCHED");
                        if (t.startTime <= e && j.a.setMilliSeconds(t.endTime, "000") <= e) r = r.concat(t.messages); else if (t.startTime <= e && t.endTime > e) {
                            var n = t.messages.filter(function (t) {
                                return j.a.setMilliSeconds(t.createdAt, "000") <= e
                            });
                            r = r.concat(n)
                        }
                    }), r
                }
                var n = this.chatPlaybackData.find(function (t) {
                    return t.startTime <= e && e <= t.endTime
                });
                if (!n) throw new Error("MESSAGES_NOT_FETCHED");
                return n.messages.filter(function (t) {
                    return j.a.setMilliSeconds(t.createdAt, "000") === e
                })
            }
        }, {
            key: "update", value: function (e, t) {
                var n = this;
                return Object(P.a)(t, function (t) {
                    var i = C.a.validate(e, Object(D.updateSchema)());
                    if (i) return U.a.log(G, i, {}), t(i);
                    n._client.request("".concat(r.basePath, "/").concat(n.id), {
                        method: "put",
                        data: e,
                        absolute: !0
                    }).then(function (r) {
                        return n.updateData(e), t(null)
                    }).catch(function (e) {
                        return U.a.log(G, O.errors.API_ERROR, {err: n._client.error(e)}), t(n._client.error(e))
                    })
                })
            }
        }, {
            key: "delete", value: function (e) {
                var t = this;
                return Object(P.a)(e, function (e) {
                    t._client.request("".concat(r.basePath, "/").concat(t.id), {
                        method: "delete",
                        absolute: !0
                    }).then(function (t) {
                        return e(null, t.data)
                    }).catch(function (r) {
                        return U.a.log(G, O.errors.API_ERROR, {err: t._client.error(r)}), e(t._client.error(r))
                    })
                })
            }
        }, {
            key: "subscribe", value: function () {
                var e = this, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                    n = arguments.length > 1 ? arguments[1] : void 0;
                return Object(P.a)(n, function (n) {
                    e._client.request("".concat(r.basePath, "/").concat(e.id, "/subscribe"), {
                        method: "post",
                        data: t,
                        absolute: !0
                    }).then(function (e) {
                        return n(null, e.data)
                    }).catch(function (t) {
                        return U.a.log(G, O.errors.API_ERROR, {err: e._client.error(t)}), n(e._client.error(t))
                    })
                })
            }
        }, {
            key: "getSubscribers", value: function (e) {
                var t = this;
                return Object(P.a)(e, function (e) {
                    t._client.request("".concat(r.basePath, "/").concat(t.id, "/subscribers"), {
                        method: "get",
                        absolute: !0
                    }).then(function (t) {
                        return e(null, t.data)
                    }).catch(function (r) {
                        return U.a.log(G, O.errors.API_ERROR, {err: t._client.error(r)}), e(t._client.error(r))
                    })
                })
            }
        }, {
            key: "addHosts", value: function (e, t) {
                var n = this;
                return Object(P.a)(t, function (t) {
                    if (!Array.isArray(e)) return U.a.log(G, O.errors.INVALID_USER_IDS, {}), t(O.errors.INVALID_USER_IDS);
                    n._client.request("".concat(r.basePath, "/").concat(n.id, "/add_hosts"), {
                        method: "post",
                        data: {userIds: e},
                        absolute: !0
                    }).then(function (e) {
                        return t(null, e.data)
                    }).catch(function (e) {
                        return U.a.log(G, O.errors.API_ERROR, {err: n._client.error(e)}), t(n._client.error(e))
                    })
                })
            }
        }, {
            key: "removeHosts", value: function (e, t) {
                var n = this;
                return Object(P.a)(t, function (t) {
                    if (!Array.isArray(e)) return U.a.log(G, O.errors.INVALID_USER_IDS, {}), t(O.errors.INVALID_USER_IDS);
                    n._client.request("".concat(r.basePath, "/").concat(n.id, "/remove_hosts"), {
                        method: "post",
                        data: {userIds: e},
                        absolute: !0
                    }).then(function (e) {
                        return t(null, e.data)
                    }).catch(function (e) {
                        return U.a.log(G, O.errors.API_ERROR, {err: n._client.error(e)}), t(n._client.error(e))
                    })
                })
            }
        }, {
            key: "reconnectRtmp", value: function (e) {
                var t = this;
                return Object(P.a)(e, function () {
                    var e = c()(R.a.mark(function e(n) {
                        return R.a.wrap(function (e) {
                            for (; ;) switch (e.prev = e.next) {
                                case 0:
                                    if (!t._client.options.disableWebSocket) {
                                        e.next = 2;
                                        break
                                    }
                                    return e.abrupt("return", n(O.errors.WEBSOCKET_NOT_ENABLED));
                                case 2:
                                    if (t._client.websocketConnected || !t._client.connectToWebsocket) {
                                        e.next = 5;
                                        break
                                    }
                                    return e.next = 5, t._client.connectToWebsocket();
                                case 5:
                                    if (t.isHost()) {
                                        e.next = 7;
                                        break
                                    }
                                    return e.abrupt("return", n(O.errors.USER_IS_NOT_HOST));
                                case 7:
                                    if ("live" === t.status) {
                                        e.next = 9;
                                        break
                                    }
                                    return e.abrupt("return", n(O.errors.EVENT_NOT_LIVE));
                                case 9:
                                    t.getRtmpConfig(function () {
                                        var e = c()(R.a.mark(function e(i, o) {
                                            var s, a, c, u, d, l;
                                            return R.a.wrap(function (e) {
                                                for (; ;) switch (e.prev = e.next) {
                                                    case 0:
                                                        if (!i) {
                                                            e.next = 2;
                                                            break
                                                        }
                                                        return e.abrupt("return", n(i));
                                                    case 2:
                                                        if (o.enable && o.rtmpServerUrl && o.streamKey) {
                                                            e.next = 4;
                                                            break
                                                        }
                                                        return e.abrupt("return", n(new Error(O.errors.RTMP_NOT_CONFIGURED)));
                                                    case 4:
                                                        if ("live" === o.status && o.streamConfig) {
                                                            e.next = 6;
                                                            break
                                                        }
                                                        return e.abrupt("return", n(new Error(O.errors.RTMP_NOT_STARTED)));
                                                    case 6:
                                                        if (!((o.streamConfig.height < o.streamConfig.width ? o.streamConfig.height : o.streamConfig.width) > 720)) {
                                                            e.next = 14;
                                                            break
                                                        }
                                                        return (s = new Error(O.errors.UNSUPPORTED_RESOLUTION)).status = 400, s.statusCode = 400, s.code = "UNSUPPORTED_RESOLUTION", U.a.log(G, s, {}), e.abrupt("return", n(s));
                                                    case 14:
                                                        if (a = t.getVideoProfile(o.streamConfig), !t.recordingParams) {
                                                            e.next = 18;
                                                            break
                                                        }
                                                        if (t.checkOrientationIsSameOrNot(a, t.recordingParams)) {
                                                            e.next = 18;
                                                            break
                                                        }
                                                        return e.abrupt("return", n(O.errors.ORIENTATION_CHANGE_NOT_ALLOWED));
                                                    case 18:
                                                        if ((c = t._client.getCurrentUser()) && c.id) {
                                                            e.next = 21;
                                                            break
                                                        }
                                                        return e.abrupt("return", n(O.errors.NO_LOGGED_IN_USER));
                                                    case 21:
                                                        return u = t.getRTCUserId(c.id) ? t.getRTCUserId(c.id) : t.createRtcUserId(), e.next = 24, t.generateToken(u, "host");
                                                    case 24:
                                                        d = e.sent, l = {
                                                            rtcUserId: u,
                                                            recordingParams: a,
                                                            broadcastPlatform: "rtmp",
                                                            rtmpUrl: "".concat(o.rtmpServerUrl).concat(o.streamKey),
                                                            appId: t._client.options.appId,
                                                            token: d
                                                        }, t._client.request("".concat(r.basePath, "/").concat(t.id, "/start"), {
                                                            method: "post",
                                                            data: l,
                                                            absolute: !0
                                                        }).then(function (e) {
                                                            t.refresh().then(function () {
                                                                n(null, e.data)
                                                            })
                                                        }).catch(function (e) {
                                                            return console.log("error", e), t._client.webrtc.leave(t.id, {}, function () {
                                                            }), U.a.log(G, O.errors.API_ERROR, {err: t._client.error(e)}), n(t._client.error(e))
                                                        });
                                                    case 27:
                                                    case"end":
                                                        return e.stop()
                                                }
                                            }, e)
                                        }));
                                        return function (t, r) {
                                            return e.apply(this, arguments)
                                        }
                                    }());
                                case 10:
                                case"end":
                                    return e.stop()
                            }
                        }, e)
                    }));
                    return function (t) {
                        return e.apply(this, arguments)
                    }
                }())
            }
        }, {
            key: "createRtcUserId", value: function () {
                return parseInt(1e4 + 2147473640 * Math.random(), 10)
            }
        }, {
            key: "joinAsHost", value: function () {
                var e = c()(R.a.mark(function e(t, n, i, o, s, a) {
                    var c, u, d, l, h, p, f, m, _ = this;
                    return R.a.wrap(function (e) {
                        for (; ;) switch (e.prev = e.next) {
                            case 0:
                                if (e.prev = 0, u = this.getVideoProfile(n), "live" !== this.status || !this.recordingParams) {
                                    e.next = 5;
                                    break
                                }
                                if (this.checkOrientationIsSameOrNot(u, this.recordingParams)) {
                                    e.next = 5;
                                    break
                                }
                                return e.abrupt("return", a(O.errors.ORIENTATION_CHANGE_NOT_ALLOWED));
                            case 5:
                                if ((d = this._client.getCurrentUser()) && d.id) {
                                    e.next = 8;
                                    break
                                }
                                return e.abrupt("return", a(O.errors.NO_LOGGED_IN_USER));
                            case 8:
                                return l = this.getRTCUserId(d.id) ? this.getRTCUserId(d.id) : this.createRtcUserId(), e.next = 11, this.generateToken(l, "host");
                            case 11:
                                if (h = e.sent, !i) {
                                    e.next = 21;
                                    break
                                }
                                return p = this.createRtcUserId(), e.next = 16, this.generateToken(p, "audience");
                            case 16:
                                return f = e.sent, e.next = 19, new Promise(function (e, r) {
                                    _._client.webrtc.joinAsAudience(_.id, p, f, {}, function (n, i) {
                                        if (n) return r(n);
                                        e(t)
                                    })
                                });
                            case 19:
                                e.next = 23;
                                break;
                            case 21:
                                return e.next = 23, new Promise(function (e, t) {
                                    _._client.webrtc.joinAsHost(_.id, i, u, l, h, {}, function (r, n) {
                                        if (r) return t(r);
                                        e(n)
                                    })
                                });
                            case 23:
                                if (this.__subscribeWatchEvents(), this.hosts.find(function (e) {
                                    return e.user.id === d.id
                                }).rtcUserId = l, t = F(F({}, t), {}, {
                                    rtcUserId: l,
                                    token: h,
                                    recordingParams: u,
                                    broadcastPlatform: i ? "rtmp" : "app",
                                    rtmpUrl: o,
                                    appId: this._client.options.appId
                                }), m = null, "upcoming" !== this.status && !i) {
                                    e.next = 34;
                                    break
                                }
                                return e.next = 31, this._client.request("".concat(r.basePath, "/").concat(this.id, "/start"), {
                                    method: "post",
                                    data: t,
                                    absolute: !0
                                });
                            case 31:
                                return m = e.sent, e.next = 34, this.refresh();
                            case 34:
                                a(null, null === (c = m) || void 0 === c ? void 0 : c.data), e.next = 42;
                                break;
                            case 37:
                                return e.prev = 37, e.t0 = e.catch(0), this._client.webrtc.leave(this.id, {}, function () {
                                }), U.a.log(G, O.errors.API_ERROR, {err: this._client.error(e.t0)}), e.abrupt("return", a(this._client.error(e.t0)));
                            case 42:
                            case"end":
                                return e.stop()
                        }
                    }, e, this, [[0, 37]])
                }));
                return function (t, r, n, i, o, s) {
                    return e.apply(this, arguments)
                }
            }()
        }, {
            key: "joinAsCoHost", value: function () {
                var e = c()(R.a.mark(function e(t, n, i, o) {
                    var s, a = this;
                    return R.a.wrap(function (e) {
                        for (; ;) switch (e.prev = e.next) {
                            case 0:
                                s = this.getVideoProfile(n), this._client.webrtc.joinAsHost(this.id, !1, s, t.rtcUserId, t.token, i, function (e, n) {
                                    if (e) return o(e);
                                    a.__subscribeWatchEvents(), a._client.request("".concat(r.basePath, "/").concat(a.id).concat(r.joinPath), {
                                        method: "post",
                                        absolute: !0,
                                        data: t
                                    }).then(function (e) {
                                        o(null, t.rtcUserId)
                                    }).catch(function (e) {
                                        return U.a.log(G, O.errors.API_ERROR, {err: a._client.error(e)}), o(a._client.error(e))
                                    })
                                });
                            case 2:
                            case"end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function (t, r, n, i) {
                    return e.apply(this, arguments)
                }
            }()
        }, {
            key: "getVideoProfile", value: function (e) {
                if (!e || 0 === Object.keys(e).length || e && (0 === e.width || 0 === e.height)) return {
                    width: A.a.DEFAULT_VIDEO_PROFILE[0][0],
                    height: A.a.DEFAULT_VIDEO_PROFILE[0][1],
                    fps: A.a.DEFAULT_VIDEO_PROFILE[0][2],
                    bitrate: A.a.DEFAULT_VIDEO_PROFILE[0][3],
                    name: A.a.DEFAULT_VIDEO_PROFILE[0][4]
                };
                var t, r = e.width, n = e.height, i = r > n ? "landscape" : "portrait", o = r < n ? r : n,
                    a = r > n ? r : n;
                t = o >= 720 ? 720 : o < 720 && o >= 480 ? 480 : 360;
                var c = A.a.VIDEO_PROFILES.filter(function (e) {
                    var r = s()(e, 4), n = (r[0], r[1]);
                    r[2], r[3];
                    return n === t
                }), u = c.reduce(function (e, t, r, n) {
                    return r && Math.abs(n[e][0] - a) < Math.abs(t[0] - a) ? e : r
                }, -1);
                return {
                    width: "landscape" === i ? c[u][0] : c[u][1],
                    height: "landscape" === i ? c[u][1] : c[u][0],
                    fps: c[u][2],
                    bitrate: c[u][3],
                    name: c[u][4]
                }
            }
        }, {
            key: "checkOrientationIsSameOrNot", value: function (e, t) {
                return e.width > e.height && t.width > t.height || e.width < e.height && t.width < t.height
            }
        }, {
            key: "start", value: function (e, t, r, n) {
                var i = this;
                return Object(P.a)(n, function () {
                    var n = c()(R.a.mark(function n(o) {
                        var s, a, c;
                        return R.a.wrap(function (n) {
                            for (; ;) switch (n.prev = n.next) {
                                case 0:
                                    if (!i._client.options.disableWebSocket) {
                                        n.next = 2;
                                        break
                                    }
                                    return n.abrupt("return", o(O.errors.WEBSOCKET_NOT_ENABLED));
                                case 2:
                                    if (i._client.websocketConnected || !i._client.connectToWebsocket) {
                                        n.next = 5;
                                        break
                                    }
                                    return n.next = 5, i._client.connectToWebsocket();
                                case 5:
                                    if (i.isHost()) {
                                        n.next = 7;
                                        break
                                    }
                                    return n.abrupt("return", o(O.errors.USER_IS_NOT_HOST));
                                case 7:
                                    if (s = {}, "completed" !== i.status) {
                                        n.next = 10;
                                        break
                                    }
                                    return n.abrupt("return", o(new Error(O.errors.BROADCAST_COMPLETED)));
                                case 10:
                                    if (a = t ? "rtmp" : "app", !i.broadcastPlatform || i.broadcastPlatform === a) {
                                        n.next = 13;
                                        break
                                    }
                                    return n.abrupt("return", o(new Error(O.errors.BROADCAST_PLATFORM_CHANGE_NOT_ALLOWED)));
                                case 13:
                                    if (!e || !Object.keys(e).length) {
                                        n.next = 18;
                                        break
                                    }
                                    if (!(c = C.a.validate(e, Object(D.streamConfigSchema)()))) {
                                        n.next = 18;
                                        break
                                    }
                                    return U.a.log(G, c, {}), n.abrupt("return", o(c));
                                case 18:
                                    if (t) {
                                        n.next = 21;
                                        break
                                    }
                                    return i.joinAsHost(s, e, t, void 0, r, o), n.abrupt("return");
                                case 21:
                                    i.getRtmpConfig(function (e, n) {
                                        if (e) return o(e);
                                        if (!n.enable || !n.rtmpServerUrl || !n.streamKey) return o(new Error(O.errors.RTMP_NOT_CONFIGURED));
                                        if ("live" !== n.status || !n.streamConfig) return o(new Error(O.errors.RTMP_NOT_STARTED));
                                        if ((n.streamConfig.height < n.streamConfig.width ? n.streamConfig.height : n.streamConfig.width) > 720) {
                                            var a = new Error(O.errors.UNSUPPORTED_RESOLUTION);
                                            return a.status = 400, a.statusCode = 400, a.code = "UNSUPPORTED_RESOLUTION", U.a.log(G, a, {}), o(a)
                                        }
                                        return i.joinAsHost(s, n.streamConfig, t, "".concat(n.rtmpServerUrl).concat(n.streamKey), r, o)
                                    });
                                case 22:
                                case"end":
                                    return n.stop()
                            }
                        }, n)
                    }));
                    return function (e) {
                        return n.apply(this, arguments)
                    }
                }())
            }
        }, {
            key: "getRtmpConfig", value: function (e) {
                var t = this;
                return Object(P.a)(e, function (e) {
                    t._client.request("".concat(N.a.LIVE_BROADCAST_BASE_URL).concat(r.rtmpConfigBasePath), {
                        method: "get",
                        absolute: !0
                    }).then(function (t) {
                        return t && t.data && Array.isArray(t.data) && 0 !== t.data.length ? e(null, t.data[0]) : e(new Error(O.errors.RTMP_NOT_CONFIGURED))
                    }).catch(function (t) {
                        e(new Error(t))
                    })
                })
            }
        }, {
            key: "updateVideoLayout", value: function (e) {
                var t = this;
                return Object(P.a)(e, function (e) {
                    t._client.request("".concat(r.basePath, "/").concat(t.id, "/update_video_layout"), {
                        method: "put",
                        absolute: !0,
                        data: {appId: t._client.options.appId}
                    }).then(function (t) {
                        return e(null, null)
                    }).catch(function (t) {
                        console.log("error", t), e(new Error(t))
                    })
                })
            }
        }, {
            key: "generateToken", value: function (e, t, n) {
                var i = this;
                return Object(P.a)(n, function (n) {
                    i._client.request("".concat(N.a.LIVE_BROADCAST_BASE_URL).concat(r.webrtcBasePath, "/generate_token"), {
                        method: "post",
                        absolute: !0,
                        data: {uid: e, role: t, channel: i.id, appId: i._client.options.appId}
                    }).then(function (e) {
                        return n(null, e.data.token)
                    }).catch(function (e) {
                        console.log("error", e), n(new Error(e))
                    })
                })
            }
        }, {
            key: "getOrientation", value: function (e) {
                var t = this;
                return Object(P.a)(e, function (e) {
                    if ("upcoming" === t.status) return e(null, null);
                    if (t.recordingParams) {
                        var r = t.recordingParams, n = r.width, i = r.height;
                        return e(null, n > i ? "landscape" : "portrait")
                    }
                    t.refresh(function (r) {
                        if (r) return e(r);
                        if (!t.recordingParams) return e(null, null);
                        var n = t.recordingParams, i = n.width, o = n.height;
                        return e(null, i > o ? "landscape" : "portrait")
                    })
                })
            }
        }, {
            key: "end", value: function (e) {
                var t = this;
                return Object(P.a)(e, function () {
                    var e = c()(R.a.mark(function e(n) {
                        return R.a.wrap(function (e) {
                            for (; ;) switch (e.prev = e.next) {
                                case 0:
                                    if (!t._client.options.disableWebSocket) {
                                        e.next = 2;
                                        break
                                    }
                                    return e.abrupt("return", n(O.errors.WEBSOCKET_NOT_ENABLED));
                                case 2:
                                    if (t._client.websocketConnected || !t._client.connectToWebsocket) {
                                        e.next = 5;
                                        break
                                    }
                                    return e.next = 5, t._client.connectToWebsocket();
                                case 5:
                                    t._client.webrtc.leave(t.id, {}, function (e, i) {
                                        if (e) return n(e);
                                        t._client.request("".concat(r.basePath, "/").concat(t.id, "/end"), {
                                            method: "post",
                                            absolute: !0,
                                            data: {appId: t._client.options.appId}
                                        }).then(function (e) {
                                            return t.__unsubscribeWatchEvents(), n(null, e.data)
                                        }).catch(function (e) {
                                            return U.a.log(G, O.errors.API_ERROR, {err: t._client.error(e)}), n(t._client.error(e))
                                        })
                                    });
                                case 6:
                                case"end":
                                    return e.stop()
                            }
                        }, e)
                    }));
                    return function (t) {
                        return e.apply(this, arguments)
                    }
                }())
            }
        }, {
            key: "cancel", value: function (e) {
                var t = this;
                return Object(P.a)(e, function (e) {
                    t._client.request("".concat(r.basePath, "/").concat(t.id, "/cancel"), {
                        method: "post",
                        absolute: !0
                    }).then(function (t) {
                        return e(null, t.data)
                    }).catch(function (r) {
                        return U.a.log(G, O.errors.API_ERROR, {err: t._client.error(r)}), e(t._client.error(r))
                    })
                })
            }
        }, {
            key: "startWatching", value: function (e) {
                var t = this;
                return Object(P.a)(e, function () {
                    var e = c()(R.a.mark(function e(r) {
                        var n, i, o;
                        return R.a.wrap(function (e) {
                            for (; ;) switch (e.prev = e.next) {
                                case 0:
                                    if (!t._client.options.disableWebSocket) {
                                        e.next = 2;
                                        break
                                    }
                                    return e.abrupt("return", r(O.errors.WEBSOCKET_NOT_ENABLED));
                                case 2:
                                    if (t._client.websocketConnected || !t._client.connectToWebsocket) {
                                        e.next = 5;
                                        break
                                    }
                                    return e.next = 5, t._client.connectToWebsocket();
                                case 5:
                                    if ("live" === t.status) {
                                        e.next = 8;
                                        break
                                    }
                                    return n = [t.startWatchingLiveBroadcast(), t.startWatchingConversation(), t.refresh()], e.abrupt("return", Promise.all(n).then(function (e) {
                                        t._client.updateActivityTrackingCookies && t._client.updateActivityTrackingCookies(t), r(null)
                                    }).catch(function (e) {
                                        return U.a.log(G, O.errors.API_ERROR, {err: t._client.error(e)}), r(t._client.error(e))
                                    }));
                                case 8:
                                    return i = t.createRtcUserId(), e.next = 11, t.generateToken(i, "audience");
                                case 11:
                                    o = e.sent, t._client.webrtc.joinAsAudience(t.id, i, o, {}, function (e, n) {
                                        if (e) return r(e);
                                        var i = [t.startWatchingLiveBroadcast(), t.startWatchingConversation(), t.refresh()];
                                        Promise.all(i).then(function (e) {
                                            t.__subscribeWatchEvents(), t._client.updateActivityTrackingCookies(t), r(null)
                                        }).catch(function (e) {
                                            return t._client.webrtc.leave(t.id, {}, function () {
                                            }), U.a.log(G, O.errors.API_ERROR, {err: t._client.error(e)}), r(t._client.error(e))
                                        })
                                    });
                                case 13:
                                case"end":
                                    return e.stop()
                            }
                        }, e)
                    }));
                    return function (t) {
                        return e.apply(this, arguments)
                    }
                }())
            }
        }, {
            key: "resumeWatchingLiveBroadcast", value: function (e) {
                var t = this;
                return Object(P.a)(e, function () {
                    var e = c()(R.a.mark(function e(r) {
                        var n;
                        return R.a.wrap(function (e) {
                            for (; ;) switch (e.prev = e.next) {
                                case 0:
                                    if (!t._client.options.disableWebSocket) {
                                        e.next = 2;
                                        break
                                    }
                                    return e.abrupt("return", r(O.errors.WEBSOCKET_NOT_ENABLED));
                                case 2:
                                    if (t._client.websocketConnected || !t._client.connectToWebsocket) {
                                        e.next = 5;
                                        break
                                    }
                                    return e.next = 5, t._client.connectToWebsocket();
                                case 5:
                                    n = [t.startWatchingLiveBroadcast(), t.refresh()], Promise.all(n).then(function (e) {
                                        r(null)
                                    }).catch(function (e) {
                                        return U.a.log(G, O.errors.API_ERROR, {err: "Error on resumeWatchingLiveBroadcast"}), r(new Error("Error on resumeWatchingLiveBroadcast"))
                                    });
                                case 7:
                                case"end":
                                    return e.stop()
                            }
                        }, e)
                    }));
                    return function (t) {
                        return e.apply(this, arguments)
                    }
                }())
            }
        }, {
            key: "stopWatching", value: function (e) {
                var t = this;
                return Object(P.a)(e, function () {
                    var e = c()(R.a.mark(function e(r) {
                        return R.a.wrap(function (e) {
                            for (; ;) switch (e.prev = e.next) {
                                case 0:
                                    if (!t._client.options.disableWebSocket) {
                                        e.next = 2;
                                        break
                                    }
                                    return e.abrupt("return", r(O.errors.WEBSOCKET_NOT_ENABLED));
                                case 2:
                                    if (t._client.websocketConnected || !t._client.connectToWebsocket) {
                                        e.next = 5;
                                        break
                                    }
                                    return e.next = 5, t._client.connectToWebsocket();
                                case 5:
                                    if ("live" === t.status) {
                                        e.next = 7;
                                        break
                                    }
                                    return e.abrupt("return", t.stopWatchingConversation(r));
                                case 7:
                                    t._client.webrtc.leave(t.id, {}, function (e, n) {
                                        if (e) return r(e);
                                        var i = [t.stopWatchingLiveBroadcast(), t.stopWatchingConversation()];
                                        Promise.all(i).then(function (e) {
                                            t.__unsubscribeWatchEvents(), r(null)
                                        }).catch(function (e) {
                                            return U.a.log(G, O.errors.API_ERROR, {err: t._client.error(e)}), r(t._client.error(e))
                                        })
                                    });
                                case 8:
                                case"end":
                                    return e.stop()
                            }
                        }, e)
                    }));
                    return function (t) {
                        return e.apply(this, arguments)
                    }
                }())
            }
        }, {
            key: "startWatchingLiveBroadcast", value: function (e) {
                var t = this;
                return Object(P.a)(e, function (e) {
                    t._client.request("".concat(r.basePath, "/").concat(t.id, "/start_watching"), {
                        method: "post",
                        absolute: !0
                    }).then(function (t) {
                        return e(null, t.data)
                    }).catch(function (r) {
                        return U.a.log(G, O.errors.API_ERROR, {err: t._client.error(r)}), e(t._client.error(r))
                    })
                })
            }
        }, {
            key: "stopWatchingLiveBroadcast", value: function (e) {
                var t = this;
                return Object(P.a)(e, function (e) {
                    t._client.request("".concat(r.basePath, "/").concat(t.id, "/stop_watching"), {
                        method: "post",
                        absolute: !0
                    }).then(function (t) {
                        return e(null, t.data)
                    }).catch(function (r) {
                        return U.a.log(G, O.errors.API_ERROR, {err: t._client.error(r)}), e(t._client.error(r))
                    })
                })
            }
        }, {
            key: "makeProductsFeatured", value: function (e, t) {
                var n = this;
                return Object(P.a)(t, function (t) {
                    if (!Array.isArray(e)) return U.a.log(G, O.errors.INVALID_PRODUCT_IDS, {}), t(O.errors.INVALID_PRODUCT_IDS);
                    var i = {productIds: e};
                    n._client.request("".concat(r.basePath, "/").concat(n.id, "/products/make_featured"), {
                        method: "post",
                        data: i,
                        absolute: !0
                    }).then(function (e) {
                        return t(null, e.data)
                    }).catch(function (e) {
                        return U.a.log(G, O.errors.API_ERROR, {err: n._client.error(e)}), t(n._client.error(e))
                    })
                })
            }
        }, {
            key: "makeProductsUnfeatured", value: function (e, t) {
                var n = this;
                return Object(P.a)(t, function (t) {
                    if (!Array.isArray(e)) return U.a.log(G, O.errors.INVALID_PRODUCT_IDS, {}), t(O.errors.INVALID_PRODUCT_IDS);
                    var i = {productIds: e};
                    n._client.request("".concat(r.basePath, "/").concat(n.id, "/products/make_unfeatured"), {
                        method: "post",
                        data: i,
                        absolute: !0
                    }).then(function (e) {
                        return t(null, e.data)
                    }).catch(function (e) {
                        return U.a.log(G, O.errors.API_ERROR, {err: n._client.error(e)}), t(n._client.error(e))
                    })
                })
            }
        }, {
            key: "addReaction", value: function (e, t) {
                var n = this;
                return Object(P.a)(t, function (t) {
                    if ("string" != typeof e) return U.a.log(G, O.errors.INVALID_REACTION_TYPE, {}), t(O.errors.INVALID_REACTION_TYPE);
                    n._client.request("".concat(r.basePath, "/").concat(n.id, "/add_reaction"), {
                        method: "post",
                        data: {type: e},
                        absolute: !0
                    }).then(function (e) {
                        return t(null, e.data)
                    }).catch(function (e) {
                        return U.a.log(G, O.errors.API_ERROR, {err: n._client.error(e)}), t(n._client.error(e))
                    })
                })
            }
        }, {
            key: "banUsers", value: function (e) {
                var t = this, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
                    i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "",
                    o = arguments.length > 3 ? arguments[3] : void 0;
                return Object(P.a)(o, function (o) {
                    var s = {userIds: e};
                    n && (s.expires = n), i && (s.reason = i);
                    var a = C.a.validate(s, Object(D.banUsersSchema)());
                    if (a) return U.a.log(G, a, {}), o(a);
                    t._client.request("".concat(r.conversationBasePath, "/").concat(t.conversationId, "/ban"), {
                        method: "post",
                        data: s
                    }).then(function (e) {
                        return o(null, e.data)
                    }).catch(function (e) {
                        return U.a.log(G, O.errors.API_ERROR, {err: t._client.error(e)}), o(t._client.error(e))
                    })
                })
            }
        }, {
            key: "unbanUsers", value: function (e, t) {
                var n = this;
                return Object(P.a)(t, function (t) {
                    if (!Array.isArray(e)) return U.a.log(G, O.errors.INVALID_USER_IDS, {}), t(O.errors.INVALID_USER_IDS);
                    var i = {userIds: e};
                    n._client.request("".concat(r.conversationBasePath, "/").concat(n.conversationId, "/ban"), {
                        method: "delete",
                        data: i
                    }).then(function (e) {
                        return t(null, e.data)
                    }).catch(function (e) {
                        return U.a.log(G, O.errors.API_ERROR, {err: n._client.error(e)}), t(n._client.error(e))
                    })
                })
            }
        }, {
            key: "startWatchingConversation", value: function (e) {
                var t = this;
                return Object(P.a)(e, function (e) {
                    t._client.request("".concat(r.conversationBasePath, "/").concat(t.conversationId, "/start_watching"), {method: "post"}).then(function (t) {
                        return e(null, t.data)
                    }).catch(function (r) {
                        return U.a.log(G, O.errors.API_ERROR, {err: t._client.error(r)}), e(t._client.error(r))
                    })
                })
            }
        }, {
            key: "stopWatchingConversation", value: function (e) {
                var t = this;
                return Object(P.a)(e, function (e) {
                    t._client.request("".concat(r.conversationBasePath, "/").concat(t.conversationId, "/stop_watching"), {method: "post"}).then(function (t) {
                        return e(null, t.data)
                    }).catch(function (r) {
                        return U.a.log(G, O.errors.API_ERROR, {err: t._client.error(r)}), e(t._client.error(r))
                    })
                })
            }
        }, {
            key: "sendMessage", value: function (e, t) {
                var n = this;
                return Object(P.a)(t, function (t) {
                    var i = C.a.validate(e, Object(D.sendMessageSchema)());
                    if (i) return U.a.log(G, i, {}), t(i);
                    if (!e.id) {
                        var o = Object(I.a)();
                        e.id = o
                    }
                    e.conversationId = n.conversationId, n._client.request("".concat(r.messageBasePath, "/send"), {
                        method: "post",
                        data: e
                    }).then(function (r) {
                        n.trackActivity({
                            name: "LIVE_MESSAGE",
                            data: {messageId: e.id}
                        }), t(null, n._client.messageModel(r.data))
                    }).catch(function (e) {
                        return U.a.log(G, O.errors.API_ERROR, {err: n._client.error(e)}), t(n._client.error(e))
                    })
                })
            }
        }, {
            key: "getBan", value: function (e) {
                var t = this;
                return Object(P.a)(e, function (e) {
                    t.getConversation(function (t, r) {
                        if (t) return e(t);
                        e(null, r.ban)
                    })
                })
            }
        }, {
            key: "getConversation", value: function (e) {
                var t = this;
                return Object(P.a)(e, function (e) {
                    t._client.request("".concat(r.conversationBasePath, "/").concat(t.conversationId), {method: "get"}).then(function (r) {
                        var n = t._client.conversationModel(r.data);
                        return e(null, n)
                    }).catch(function (r) {
                        return U.a.log(G, O.errors.API_ERROR, {err: t._client.error(r)}), e(t._client.error(r))
                    })
                })
            }
        }, {
            key: "askToJoin", value: function (e) {
                var t = this;
                return Object(P.a)(e, function (e) {
                    t._client.request("".concat(r.basePath, "/").concat(t.id).concat(r.askToJoinPath), {
                        method: "post",
                        absolute: !0,
                        data: {}
                    }).then(function (t) {
                        return e(null, {success: !0})
                    }).catch(function (r) {
                        return U.a.log(G, O.errors.API_ERROR, {err: t._client.error(r)}), e(t._client.error(r))
                    })
                })
            }
        }, {
            key: "askToJoinAction", value: function (e, t, n) {
                var i = this;
                return Object(P.a)(n, function (n) {
                    var o = {hostId: e, action: t};
                    i._client.request("".concat(r.basePath, "/").concat(i.id).concat(r.askToJoinActionPath), {
                        method: "post",
                        absolute: !0,
                        data: o
                    }).then(function (e) {
                        return n(null, {success: !0})
                    }).catch(function (e) {
                        return U.a.log(G, O.errors.API_ERROR, {err: i._client.error(e)}), n(i._client.error(e))
                    })
                })
            }
        }, {
            key: "join", value: function () {
                var e = c()(R.a.mark(function e(t, r, n) {
                    var i = this;
                    return R.a.wrap(function (e) {
                        for (; ;) switch (e.prev = e.next) {
                            case 0:
                                return e.abrupt("return", Object(P.a)(n, function () {
                                    var e = c()(R.a.mark(function e(n) {
                                        var o, s, a;
                                        return R.a.wrap(function (e) {
                                            for (; ;) switch (e.prev = e.next) {
                                                case 0:
                                                    if (!i._client.options.disableWebSocket) {
                                                        e.next = 2;
                                                        break
                                                    }
                                                    return e.abrupt("return", n(O.errors.WEBSOCKET_NOT_ENABLED));
                                                case 2:
                                                    if (i._client.websocketConnected || !i._client.connectToWebsocket) {
                                                        e.next = 5;
                                                        break
                                                    }
                                                    return e.next = 5, i._client.connectToWebsocket();
                                                case 5:
                                                    if ((o = i._client.getCurrentUser()) && o.id) {
                                                        e.next = 8;
                                                        break
                                                    }
                                                    return e.abrupt("return", n(O.errors.NO_LOGGED_IN_USER));
                                                case 8:
                                                    if (!!i.hosts.filter(function (e) {
                                                        return e.userId === o.id
                                                    }).length) {
                                                        e.next = 11;
                                                        break
                                                    }
                                                    return e.abrupt("return", n(O.errors.USER_IS_NOT_HOST));
                                                case 11:
                                                    return s = i.getRTCUserId(o.id) ? i.getRTCUserId(o.id) : i.createRtcUserId(), e.next = 14, i.generateToken(s, "host");
                                                case 14:
                                                    return a = e.sent, e.abrupt("return", i.joinAsCoHost({
                                                        hostId: t,
                                                        rtcUserId: s,
                                                        token: a
                                                    }, {}, r, n));
                                                case 16:
                                                case"end":
                                                    return e.stop()
                                            }
                                        }, e)
                                    }));
                                    return function (t) {
                                        return e.apply(this, arguments)
                                    }
                                }()));
                            case 1:
                            case"end":
                                return e.stop()
                        }
                    }, e)
                }));
                return function (t, r, n) {
                    return e.apply(this, arguments)
                }
            }()
        }, {
            key: "createViewersListQuery", value: function () {
                return new k.a(this._client, this.id)
            }
        }, {
            key: "createMessageListQuery", value: function () {
                return new x.a(this._client, this.conversationId)
            }
        }, {
            key: "createReactionsPlaybackQuery", value: function () {
                return new M.a(this._client, this.id)
            }
        }, {
            key: "createBanListQuery", value: function () {
                return new L.a(this._client, this.conversationId)
            }
        }, {
            key: "playLocalStream", value: function (e, t, r) {
                var n = this;
                return Object(P.a)(r, function () {
                    var r = c()(R.a.mark(function r(i) {
                        return R.a.wrap(function (r) {
                            for (; ;) switch (r.prev = r.next) {
                                case 0:
                                    if (!n._client.options.disableWebSocket) {
                                        r.next = 2;
                                        break
                                    }
                                    return r.abrupt("return", i(O.errors.WEBSOCKET_NOT_ENABLED));
                                case 2:
                                    if (n._client.websocketConnected || !n._client.connectToWebsocket) {
                                        r.next = 5;
                                        break
                                    }
                                    return r.next = 5, n._client.connectToWebsocket();
                                case 5:
                                    n.__validateMediaViewParams({
                                        view: e,
                                        options: t
                                    }, i), n._client.webrtc.playLocalStream(e, t, i);
                                case 7:
                                case"end":
                                    return r.stop()
                            }
                        }, r)
                    }));
                    return function (e) {
                        return r.apply(this, arguments)
                    }
                }())
            }
        }, {
            key: "playRemoteStream", value: function (e, t, r, n) {
                var i = this;
                return Object(P.a)(n, function () {
                    var n = c()(R.a.mark(function n(o) {
                        var s;
                        return R.a.wrap(function (n) {
                            for (; ;) switch (n.prev = n.next) {
                                case 0:
                                    if (!i._client.options.disableWebSocket) {
                                        n.next = 2;
                                        break
                                    }
                                    return n.abrupt("return", o(O.errors.WEBSOCKET_NOT_ENABLED));
                                case 2:
                                    if (i._client.websocketConnected || !i._client.connectToWebsocket) {
                                        n.next = 5;
                                        break
                                    }
                                    return n.next = 5, i._client.connectToWebsocket();
                                case 5:
                                    if (i.__validateMediaViewParams({
                                        userId: e,
                                        view: t,
                                        options: r
                                    }, o), s = i.getRTCUserId(e)) {
                                        n.next = 11;
                                        break
                                    }
                                    return n.next = 10, i.refresh();
                                case 10:
                                    s = i.getRTCUserId(e);
                                case 11:
                                    if (s) {
                                        n.next = 14;
                                        break
                                    }
                                    return o(new Error("UNIDENTIFIED_STREAM")), n.abrupt("return");
                                case 14:
                                    i.broadcastPlatform || (i.broadcastPlatform = "app"), i._client.webrtc.playRemoteStream(s, i.broadcastPlatform, t, r, o);
                                case 16:
                                case"end":
                                    return n.stop()
                            }
                        }, n)
                    }));
                    return function (e) {
                        return n.apply(this, arguments)
                    }
                }())
            }
        }, {
            key: "resumeRemoteStream", value: function (e, t) {
                if (this._client.options.disableWebSocket) return t(O.errors.WEBSOCKET_NOT_ENABLED);
                this._client.webrtc.resumeRemoteStream(this.getRTCUserId(e), t)
            }
        }, {
            key: "stopLocalStream", value: function () {
                if (this._client.options.disableWebSocket) throw O.errors.WEBSOCKET_NOT_ENABLED;
                this._client.webrtc.stopLocalStream()
            }
        }, {
            key: "stopRemoteStream", value: function (e) {
                if (this._client.options.disableWebSocket) throw O.errors.WEBSOCKET_NOT_ENABLED;
                this._client.webrtc.stopRemoteStream(this.getRTCUserId(e))
            }
        }, {
            key: "on", value: function () {
                var e = c()(R.a.mark(function e(t, r) {
                    var n;
                    return R.a.wrap(function (e) {
                        for (; ;) switch (e.prev = e.next) {
                            case 0:
                                if (!this._client.options.disableWebSocket) {
                                    e.next = 2;
                                    break
                                }
                                return e.abrupt("return");
                            case 2:
                                if (this._client.websocketConnected || !this._client.connectToWebsocket) {
                                    e.next = 5;
                                    break
                                }
                                return e.next = 5, this._client.connectToWebsocket();
                            case 5:
                                n = this.__isConversationEvent(t) ? this.conversationId : this.id, this._client.chsocket.on(t, n, r);
                            case 7:
                            case"end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function (t, r) {
                    return e.apply(this, arguments)
                }
            }()
        }, {
            key: "publish", value: function () {
                var e = c()(R.a.mark(function e(t) {
                    var r, n, i, o;
                    return R.a.wrap(function (e) {
                        for (; ;) switch (e.prev = e.next) {
                            case 0:
                                if (!this._client.options.disableWebSocket) {
                                    e.next = 2;
                                    break
                                }
                                return e.abrupt("return");
                            case 2:
                                if (this._client.websocketConnected || !this._client.connectToWebsocket) {
                                    e.next = 5;
                                    break
                                }
                                return e.next = 5, this._client.connectToWebsocket();
                            case 5:
                                r = this._client.getCurrentUser(), n = this.id, i = {
                                    liveBroadcastId: n,
                                    user: r
                                }, o = "live_broadcasts/".concat(this.id, "/").concat(t), this._client.chsocket.__publishSocket(o, i);
                            case 10:
                            case"end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function (t) {
                    return e.apply(this, arguments)
                }
            }()
        }, {
            key: "trackActivity", value: function (e, t) {
                var n = this;
                try {
                    return Object(P.a)(t, function (t) {
                        (e = F(F({}, e), {}, {
                            resourceId: n.id,
                            createdAt: new Date
                        })).timeInSec || (e.timeInSec = "live" === n.status ? Math.floor((new Date - new Date(n.actualStartTime)) / 1e3) : 0), n._client.request("".concat(N.a.LIVE_BROADCAST_BASE_URL).concat(r.activityBasePath), {
                            method: "post",
                            data: e,
                            absolute: !0
                        }).then(function (r) {
                            n.__dispatchActivityTrackingEvent(e), t(null, r)
                        }).catch(function (e) {
                            return U.a.log(G, O.errors.API_ERROR, {err: n._client.error(e)}), t(n._client.error(e))
                        })
                    })
                } catch (e) {
                    return U.a.log(G, O.errors.API_ERROR, {err: this._client.error(e)}), t(this._client.error(e))
                }
            }
        }, {
            key: "off", value: function () {
                var e = c()(R.a.mark(function e(t) {
                    var r, n = this;
                    return R.a.wrap(function (e) {
                        for (; ;) switch (e.prev = e.next) {
                            case 0:
                                if (!this._client.options.disableWebSocket) {
                                    e.next = 2;
                                    break
                                }
                                return e.abrupt("return");
                            case 2:
                                if (this._client.websocketConnected || !this._client.connectToWebsocket) {
                                    e.next = 5;
                                    break
                                }
                                return e.next = 5, this._client.connectToWebsocket();
                            case 5:
                                if (!t) {
                                    e.next = 8;
                                    break
                                }
                                return r = this.__isConversationEvent(t) ? this.conversationId : this.id, e.abrupt("return", this._client.chsocket.off(t, r));
                            case 8:
                                this._client.chsocket.getDependencyEvents("live_broadcast_id").forEach(function (e) {
                                    n._client.chsocket.off(e, n.id)
                                }), this._client.chsocket.getDependencyEvents("conversation_id").forEach(function (e) {
                                    n._client.chsocket.off(e, n.conversationId)
                                });
                            case 10:
                            case"end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function (t) {
                    return e.apply(this, arguments)
                }
            }()
        }, {
            key: "getRTCStream", value: function (e) {
                if (this._client.options.disableWebSocket) throw O.errors.WEBSOCKET_NOT_ENABLED;
                return this._client.webrtc.getStream(this.getRTCUserId(e))
            }
        }, {
            key: "isAudioOn", value: function (e) {
                if (this._client.options.disableWebSocket) throw O.errors.WEBSOCKET_NOT_ENABLED;
                return this._client.webrtc.isAudioOn(this.getRTCUserId(e))
            }
        }, {
            key: "isVideoOn", value: function (e) {
                if (this._client.options.disableWebSocket) throw O.errors.WEBSOCKET_NOT_ENABLED;
                return this._client.webrtc.isVideoOn(this.getRTCUserId(e))
            }
        }, {
            key: "muteAudio", value: function (e) {
                if (this._client.options.disableWebSocket) throw O.errors.WEBSOCKET_NOT_ENABLED;
                return this._client.webrtc.muteAudio(this.getRTCUserId(e))
            }
        }, {
            key: "muteVideo", value: function (e) {
                if (this._client.options.disableWebSocket) throw O.errors.WEBSOCKET_NOT_ENABLED;
                return this._client.webrtc.muteVideo(this.getRTCUserId(e))
            }
        }, {
            key: "unmuteAudio", value: function (e) {
                if (this._client.options.disableWebSocket) throw O.errors.WEBSOCKET_NOT_ENABLED;
                return this._client.webrtc.unmuteAudio(this.getRTCUserId(e))
            }
        }, {
            key: "unmuteVideo", value: function (e) {
                if (this._client.options.disableWebSocket) throw O.errors.WEBSOCKET_NOT_ENABLED;
                return this._client.webrtc.unmuteVideo(this.getRTCUserId(e))
            }
        }, {
            key: "__dispatchActivityTrackingEvent", value: function (e) {
                var t, r;
                e = F(F({}, e), {}, {userId: null === (t = this._client.getCurrentUser()) || void 0 === t ? void 0 : t.id}), window.CustomEvent ? r = new CustomEvent(A.a.ACTIVITY_TRACKING_EVENT_NAME, {detail: e}) : (r = document.createEvent("CustomEvent")).initCustomEvent(A.a.ACTIVITY_TRACKING_EVENT_NAME, !0, !0, {detail: e}), window.dispatchEvent(r)
            }
        }, {
            key: "__subscribeStatusEvents", value: function () {
                var e = c()(R.a.mark(function e() {
                    var t = this;
                    return R.a.wrap(function (e) {
                        for (; ;) switch (e.prev = e.next) {
                            case 0:
                                if (this.id && ["upcoming", "live"].includes(this.status) && !this._client.options.disableWebSocket) {
                                    e.next = 2;
                                    break
                                }
                                return e.abrupt("return");
                            case 2:
                                if (this._client.websocketConnected || !this._client.connectToWebsocket) {
                                    e.next = 5;
                                    break
                                }
                                return e.next = 5, this._client.connectToWebsocket();
                            case 5:
                                this.on("status_updated", function (e) {
                                    (t.updateData(e.liveBroadcast), Object.prototype.hasOwnProperty.call(e, "rtcUserId")) && (t.hosts.find(function (t) {
                                        return t.user.id === e.user.id
                                    }).rtcUserId = e.rtcUserId);
                                    ["completed", "cancelled"].includes(t.status) && t.__unsubscribeWatchEvents()
                                });
                            case 6:
                            case"end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function () {
                    return e.apply(this, arguments)
                }
            }()
        }, {
            key: "__subscribeWatchEvents", value: function () {
                var e = c()(R.a.mark(function e() {
                    var t = this;
                    return R.a.wrap(function (e) {
                        for (; ;) switch (e.prev = e.next) {
                            case 0:
                                if (this.id && !this._client.options.disableWebSocket) {
                                    e.next = 2;
                                    break
                                }
                                return e.abrupt("return");
                            case 2:
                                if (this._client.websocketConnected || !this._client.connectToWebsocket) {
                                    e.next = 5;
                                    break
                                }
                                return e.next = 5, this._client.connectToWebsocket();
                            case 5:
                                this.on("start_watching", function (e) {
                                    var r = e.liveBroadcast.watchersCount;
                                    t.updateData({watchersCount: r})
                                }), this.on("stop_watching", function (e) {
                                    var r = e.liveBroadcast.watchersCount;
                                    t.updateData({watchersCount: r})
                                }), this.on("reaction.added", function (e) {
                                    var r = e.liveBroadcast.reactionsCount;
                                    t.updateData({reactionsCount: r})
                                }), this.on("products_featured", function (e) {
                                    var r = e.products.map(function (e) {
                                        return e.id
                                    }), n = t.products.map(function (e) {
                                        return r.includes(e.id) && (e.featured = !0), e
                                    });
                                    t.updateData({products: n})
                                }), this.on("products_unfeatured", function (e) {
                                    var r = e.products.map(function (e) {
                                        return e.id
                                    }), n = t.products.map(function (e) {
                                        return r.includes(e.id) && (e.featured = !1), e
                                    });
                                    t.updateData({products: n})
                                }), this.on("products_updated", function (e) {
                                    var r = e.products.filter(function (e) {
                                        return e.show
                                    });
                                    t.updateData({products: r}), t._client.updateActivityTrackingCookies && t._client.updateActivityTrackingCookies(t)
                                });
                            case 11:
                            case"end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function () {
                    return e.apply(this, arguments)
                }
            }()
        }, {
            key: "__unsubscribeWatchEvents", value: function () {
                var e = c()(R.a.mark(function e() {
                    return R.a.wrap(function (e) {
                        for (; ;) switch (e.prev = e.next) {
                            case 0:
                                if (!this._client.options.disableWebSocket) {
                                    e.next = 2;
                                    break
                                }
                                return e.abrupt("return");
                            case 2:
                                if (this._client.websocketConnected || !this._client.connectToWebsocket) {
                                    e.next = 5;
                                    break
                                }
                                return e.next = 5, this._client.connectToWebsocket();
                            case 5:
                                this.off("start_watching"), this.off("stop_watching"), this.off("reaction.added"), this.off("products_featured"), this.off("products_unfeatured"), this.off("products_updated");
                            case 11:
                            case"end":
                                return e.stop()
                        }
                    }, e, this)
                }));
                return function () {
                    return e.apply(this, arguments)
                }
            }()
        }, {
            key: "__validateMediaViewParams", value: function (e, t) {
                if (Object.prototype.hasOwnProperty.call(e, "userId")) {
                    if ("string" != typeof e.userId) return U.a.log(G, O.errors.INVALID_USER_ID, {}), t(O.errors.INVALID_USER_ID);
                    if (!this.getHost(e.userId)) return U.a.log(G, O.errors.INVALID_REMOTE_MEDIA_USER, {}), t(O.errors.INVALID_REMOTE_MEDIA_USER)
                }
                return "string" != typeof e.view ? (U.a.log(G, O.errors.INVALID_MEDIA_VIEW, {}), t(O.errors.INVALID_MEDIA_VIEW)) : e.options && "object" !== i()(e.options) ? (U.a.log(G, O.errors.INVALID_OPTIONS, {}), t(O.errors.INVALID_OPTIONS)) : void 0
            }
        }, {
            key: "updateData", value: function (e) {
                var t = this, n = r.__properties;
                Object.keys(e).forEach(function (r) {
                    Object.prototype.hasOwnProperty.call(n, r) && (t[r] = e[r])
                })
            }
        }, {
            key: "getHost", value: function (e) {
                return this.hosts.find(function (t) {
                    return t.userId === e
                })
            }
        }, {
            key: "isHost", value: function () {
                var e = this._client.getCurrentUser();
                if (!e || !e.id) throw O.errors.NO_LOGGED_IN_USER;
                return Boolean(this.getHost(e.id))
            }
        }, {
            key: "getRTCUserId", value: function (e) {
                if (!e) return null;
                var t = this.getHost(e);
                return t ? t.rtcUserId : null
            }
        }, {
            key: "canWatch", value: function () {
                var e = this._client.getCurrentUser(), t = this.config.allow_watch, r = e.role;
                return Object.prototype.hasOwnProperty.call(A.a.ROLE_PRECEDENCE, r) && Object.prototype.hasOwnProperty.call(A.a.ROLE_PRECEDENCE, t) && A.a.ROLE_PRECEDENCE[r] >= A.a.ROLE_PRECEDENCE[t]
            }
        }, {
            key: "canChat", value: function () {
                var e = this._client.getCurrentUser(), t = this.config.allow_chat, r = e.role;
                return Object.prototype.hasOwnProperty.call(A.a.ROLE_PRECEDENCE, r) && Object.prototype.hasOwnProperty.call(A.a.ROLE_PRECEDENCE, t) && A.a.ROLE_PRECEDENCE[r] >= A.a.ROLE_PRECEDENCE[t]
            }
        }]), r
    }(w.a);
    b()(q, "__properties", {
        id: null,
        title: null,
        description: null,
        createdAt: null,
        updatedAt: null,
        conversationId: null,
        ownerId: null,
        startTime: null,
        endTime: null,
        actualStartTime: null,
        actualEndTime: null,
        bannerImageUrl: null,
        bannerVideoUrl: null,
        status: null,
        duration: null,
        published: null,
        hosts: [],
        products: [],
        metaData: {},
        recording: null,
        recordingUrl: null,
        recordingParams: null,
        watchersCount: null,
        maxWatchersCount: null,
        viewersCount: null,
        reactionsCount: {},
        owner: {},
        config: {},
        broadcastPlatform: null,
        productSpotlightPlaybackData: null,
        reactionsPlaybackData: null,
        chatPlaybackData: null,
        settings: {},
        recordingViewersCount: null,
        uniqueRecordingViewersCount: null,
        integrations: []
    }), b()(q, "__conversationEvents", ["watcher.message.created", "watcher.message.deleted_for_everyone", "message.pinned", "message.unpinned"]), b()(q, "basePath", "".concat(N.a.LIVE_BROADCAST_BASE_URL).concat(A.a.BASEPATH_LIVE_BROADCASTS)), b()(q, "conversationBasePath", "".concat(A.a.BASEPATH_CONVERSATIONS)), b()(q, "messageBasePath", "".concat(A.a.BASEPATH_MESSAGES)), b()(q, "activityBasePath", "".concat(A.a.BASEPATH_ACTIVITY)), b()(q, "rtmpConfigBasePath", "".concat(A.a.BASEPATH_RTMP_CONFIG)), b()(q, "spotlightPlaybackPath", "".concat(A.a.BASEPATH_SPOTLIGHT_PLAYBACK)), b()(q, "webrtcBasePath", "".concat(A.a.BASEPATH_WEBRTC)), b()(q, "askToJoinPath", "".concat(A.a.BASEPATH_ASK_TO_JOIN)), b()(q, "askToJoinActionPath", "".concat(A.a.BASEPATH_ASK_TO_JOIN_ACTION)), b()(q, "joinPath", "".concat(A.a.BASEPATH_JOIN))
}, function (e, t, r) {
    "use strict";
    r.d(t, "a", function () {
        return _
    });
    var n = r(6), i = r.n(n), o = r(10), s = r.n(o), a = r(11), c = r.n(a), u = r(7), d = r.n(u), l = r(3), h = r.n(l),
        p = r(34), f = r(2);

    function m(e) {
        var t = function () {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function () {
                })), !0
            } catch (e) {
                return !1
            }
        }();
        return function () {
            var r, n = d()(e);
            if (t) {
                var i = d()(this).constructor;
                r = Reflect.construct(n, arguments, i)
            } else r = n.apply(this, arguments);
            return c()(this, r)
        }
    }

    var _ = function (e) {
        s()(r, e);
        var t = m(r);

        function r() {
            return i()(this, r), t.apply(this, arguments)
        }

        return r
    }(p.a);
    h()(_, "__properties", {
        id: null,
        type: null,
        config: {},
        customType: null,
        metaData: {},
        lastMessage: {},
        lastReadAt: {},
        title: null,
        isGroup: null,
        createdAt: null,
        memberCount: 0,
        ownerId: null,
        members: [],
        profileImageUrl: null,
        isActive: null,
        isAdmin: null,
        isDeleted: null,
        mute: null,
        unreadMessageCount: null,
        updatedAt: null,
        user: {},
        watchersCount: 0,
        ban: {}
    }), h()(_, "basePath", f.a.BASEPATH_CONVERSATIONS)
}, function (e, t, r) {
    "use strict";
    r.d(t, "a", function () {
        return _
    });
    var n = r(6), i = r.n(n), o = r(8), s = r.n(o), a = r(3), c = r.n(a), u = r(4), d = r(1), l = r(2),
        h = r(370).Agora, p = r(0).errors, f = l.a.LOG_LEVELS, m = (f.INFO, f.WARN, f.ERROR), _ = function () {
            function e(t) {
                i()(this, e), c()(this, "__service", void 0), this.__service = new e.__services[t]
            }

            return s()(e, [{
                key: "getService", value: function () {
                    return this.__service
                }
            }, {
                key: "getClient", value: function () {
                    return this.getService().getClient()
                }
            }, {
                key: "setVideoResolution", value: function () {
                    return this.getService().setVideoResolution()
                }
            }, {
                key: "init", value: function (e, t, r) {
                    var n = this;
                    return Object(u.a)(r, function (r) {
                        n.getService().init(e, t, r)
                    })
                }
            }, {
                key: "updateCurrentUser", value: function (e) {
                    this.getService().updateCurrentUser(e)
                }
            }, {
                key: "close", value: function (e, t) {
                    var r = this;
                    return Object(u.a)(t, function (t) {
                        r.getService().close(e, t)
                    })
                }
            }, {
                key: "checkSystemRequirements", value: function () {
                    return this.getService().checkSystemRequirements()
                }
            }, {
                key: "getDevices", value: function (e, t) {
                    this.getService().getDevices(e, t)
                }
            }, {
                key: "on", value: function () {
                    var e;
                    (e = this.getService()).on.apply(e, arguments)
                }
            }, {
                key: "off", value: function () {
                    var e;
                    (e = this.getService()).off.apply(e, arguments)
                }
            }, {
                key: "joinAsAudience", value: function (e, t, r, n, i) {
                    var o = this;
                    return Object(u.a)(i, function (i) {
                        o.getService().joinAsAudience(e, t, r, n, i)
                    })
                }
            }, {
                key: "joinAsHost", value: function (e, t, r, n, i, o, s) {
                    var a = this;
                    return Object(u.a)(s, function (s) {
                        if (!a.checkSystemRequirements()) return d.a.log(m, p.BROWSER_NOT_COMPATIBLE, {}), s(p.BROWSER_NOT_COMPATIBLE);
                        a.getService().joinAsHost(e, t, r, n, i, o, s)
                    })
                }
            }, {
                key: "leave", value: function (e, t, r) {
                    var n = this;
                    return Object(u.a)(r, function (r) {
                        n.getService().leave(e, t, r)
                    })
                }
            }, {
                key: "playLocalStream", value: function (e, t, r) {
                    this.getService().playLocalStream(e, t, r)
                }
            }, {
                key: "playRemoteStream", value: function (e, t, r, n, i) {
                    this.getService().playRemoteStream(e, t, r, n, i)
                }
            }, {
                key: "resumeRemoteStream", value: function (e, t) {
                    var r = this;
                    return Object(u.a)(t, function (t) {
                        r.getService().resumeRemoteStream(e, t)
                    })
                }
            }, {
                key: "stopLocalStream", value: function () {
                    this.getService().stopLocalStream()
                }
            }, {
                key: "stopRemoteStream", value: function (e) {
                    this.getService().stopRemoteStream(e)
                }
            }, {
                key: "getStream", value: function (e) {
                    return this.getService().getStream(e)
                }
            }, {
                key: "isAudioOn", value: function (e) {
                    return this.getService().isAudioOn(e)
                }
            }, {
                key: "isVideoOn", value: function (e) {
                    return this.getService().isVideoOn(e)
                }
            }, {
                key: "muteAudio", value: function (e) {
                    return this.getService().muteAudio(e)
                }
            }, {
                key: "muteVideo", value: function (e) {
                    return this.getService().muteVideo(e)
                }
            }, {
                key: "unmuteAudio", value: function (e) {
                    return this.getService().unmuteAudio(e)
                }
            }, {
                key: "unmuteVideo", value: function (e) {
                    return this.getService().unmuteVideo(e)
                }
            }], [{
                key: "hasService", value: function (t) {
                    return Object.prototype.hasOwnProperty.call(e.__services, t)
                }
            }]), e
        }();
    c()(_, "__services", {agora: h})
}, function (e, t, r) {
    var n = r(115), i = r(15);

    function o(e, t, r) {
        null !== r && void 0 !== r && i.property.apply(this, arguments)
    }

    function s(e, t) {
        e.constructor.prototype[t] || i.memoizedProperty.apply(this, arguments)
    }

    function a(e, t, r) {
        t = t || {}, o(this, "shape", e.shape), o(this, "api", t.api, !1), o(this, "type", e.type), o(this, "enum", e.enum), o(this, "min", e.min), o(this, "max", e.max), o(this, "pattern", e.pattern), o(this, "location", e.location || this.location || "body"), o(this, "name", this.name || e.xmlName || e.queryName || e.locationName || r), o(this, "isStreaming", e.streaming || this.isStreaming || !1), o(this, "requiresLength", e.requiresLength, !1), o(this, "isComposite", e.isComposite || !1), o(this, "isShape", !0, !1), o(this, "isQueryName", Boolean(e.queryName), !1), o(this, "isLocationName", Boolean(e.locationName), !1), o(this, "isIdempotent", !0 === e.idempotencyToken), o(this, "isJsonValue", !0 === e.jsonvalue), o(this, "isSensitive", !0 === e.sensitive || e.prototype && !0 === e.prototype.sensitive), o(this, "isEventStream", Boolean(e.eventstream), !1), o(this, "isEvent", Boolean(e.event), !1), o(this, "isEventPayload", Boolean(e.eventpayload), !1), o(this, "isEventHeader", Boolean(e.eventheader), !1), o(this, "isTimestampFormatSet", Boolean(e.timestampFormat) || e.prototype && !0 === e.prototype.isTimestampFormatSet, !1), o(this, "endpointDiscoveryId", Boolean(e.endpointdiscoveryid), !1), o(this, "hostLabel", Boolean(e.hostLabel), !1), t.documentation && (o(this, "documentation", e.documentation), o(this, "documentationUrl", e.documentationUrl)), e.xmlAttribute && o(this, "isXmlAttribute", e.xmlAttribute || !1), o(this, "defaultValue", null), this.toWireFormat = function (e) {
            return null === e || void 0 === e ? "" : e
        }, this.toType = function (e) {
            return e
        }
    }

    function c(e) {
        a.apply(this, arguments), o(this, "isComposite", !0), e.flattened && o(this, "flattened", e.flattened || !1)
    }

    function u(e, t) {
        var r = this, i = null, u = !this.isShape;
        c.apply(this, arguments), u && (o(this, "defaultValue", function () {
            return {}
        }), o(this, "members", {}), o(this, "memberNames", []), o(this, "required", []), o(this, "isRequired", function () {
            return !1
        })), e.members && (o(this, "members", new n(e.members, t, function (e, r) {
            return a.create(r, t, e)
        })), s(this, "memberNames", function () {
            return e.xmlOrder || Object.keys(e.members)
        }), e.event && (s(this, "eventPayloadMemberName", function () {
            for (var e = r.members, t = r.memberNames, n = 0, i = t.length; n < i; n++) if (e[t[n]].isEventPayload) return t[n]
        }), s(this, "eventHeaderMemberNames", function () {
            for (var e = r.members, t = r.memberNames, n = [], i = 0, o = t.length; i < o; i++) e[t[i]].isEventHeader && n.push(t[i]);
            return n
        }))), e.required && (o(this, "required", e.required), o(this, "isRequired", function (t) {
            if (!i) {
                i = {};
                for (var r = 0; r < e.required.length; r++) i[e.required[r]] = !0
            }
            return i[t]
        }, !1, !0)), o(this, "resultWrapper", e.resultWrapper || null), e.payload && o(this, "payload", e.payload), "string" == typeof e.xmlNamespace ? o(this, "xmlNamespaceUri", e.xmlNamespace) : "object" == typeof e.xmlNamespace && (o(this, "xmlNamespacePrefix", e.xmlNamespace.prefix), o(this, "xmlNamespaceUri", e.xmlNamespace.uri))
    }

    function d(e, t) {
        var r = this, n = !this.isShape;
        if (c.apply(this, arguments), n && o(this, "defaultValue", function () {
            return []
        }), e.member && s(this, "member", function () {
            return a.create(e.member, t)
        }), this.flattened) {
            var i = this.name;
            s(this, "name", function () {
                return r.member.name || i
            })
        }
    }

    function l(e, t) {
        var r = !this.isShape;
        c.apply(this, arguments), r && (o(this, "defaultValue", function () {
            return {}
        }), o(this, "key", a.create({type: "string"}, t)), o(this, "value", a.create({type: "string"}, t))), e.key && s(this, "key", function () {
            return a.create(e.key, t)
        }), e.value && s(this, "value", function () {
            return a.create(e.value, t)
        })
    }

    function h() {
        a.apply(this, arguments);
        var e = ["rest-xml", "query", "ec2"];
        this.toType = function (t) {
            return t = this.api && e.indexOf(this.api.protocol) > -1 ? t || "" : t, this.isJsonValue ? JSON.parse(t) : t && "function" == typeof t.toString ? t.toString() : t
        }, this.toWireFormat = function (e) {
            return this.isJsonValue ? JSON.stringify(e) : e
        }
    }

    function p() {
        a.apply(this, arguments), this.toType = function (e) {
            var t = i.base64.decode(e);
            if (this.isSensitive && i.isNode() && "function" == typeof i.Buffer.alloc) {
                var r = i.Buffer.alloc(t.length, t);
                t.fill(0), t = r
            }
            return t
        }, this.toWireFormat = i.base64.encode
    }

    function f() {
        p.apply(this, arguments)
    }

    function m() {
        a.apply(this, arguments), this.toType = function (e) {
            return "boolean" == typeof e ? e : null === e || void 0 === e ? null : "true" === e
        }
    }

    a.normalizedTypes = {
        character: "string",
        double: "float",
        long: "integer",
        short: "integer",
        biginteger: "integer",
        bigdecimal: "float",
        blob: "binary"
    }, a.types = {
        structure: u, list: d, map: l, boolean: m, timestamp: function (e) {
            var t = this;
            if (a.apply(this, arguments), e.timestampFormat) o(this, "timestampFormat", e.timestampFormat); else if (t.isTimestampFormatSet && this.timestampFormat) o(this, "timestampFormat", this.timestampFormat); else if ("header" === this.location) o(this, "timestampFormat", "rfc822"); else if ("querystring" === this.location) o(this, "timestampFormat", "iso8601"); else if (this.api) switch (this.api.protocol) {
                case"json":
                case"rest-json":
                    o(this, "timestampFormat", "unixTimestamp");
                    break;
                case"rest-xml":
                case"query":
                case"ec2":
                    o(this, "timestampFormat", "iso8601")
            }
            this.toType = function (e) {
                return null === e || void 0 === e ? null : "function" == typeof e.toUTCString ? e : "string" == typeof e || "number" == typeof e ? i.date.parseTimestamp(e) : null
            }, this.toWireFormat = function (e) {
                return i.date.format(e, t.timestampFormat)
            }
        }, float: function () {
            a.apply(this, arguments), this.toType = function (e) {
                return null === e || void 0 === e ? null : parseFloat(e)
            }, this.toWireFormat = this.toType
        }, integer: function () {
            a.apply(this, arguments), this.toType = function (e) {
                return null === e || void 0 === e ? null : parseInt(e, 10)
            }, this.toWireFormat = this.toType
        }, string: h, base64: f, binary: p
    }, a.resolve = function (e, t) {
        if (e.shape) {
            var r = t.api.shapes[e.shape];
            if (!r) throw new Error("Cannot find shape reference: " + e.shape);
            return r
        }
        return null
    }, a.create = function (e, t, r) {
        if (e.isShape) return e;
        var n = a.resolve(e, t);
        if (n) {
            var i = Object.keys(e);
            t.documentation || (i = i.filter(function (e) {
                return !e.match(/documentation/)
            }));
            var o = function () {
                n.constructor.call(this, e, t, r)
            };
            return o.prototype = n, new o
        }
        e.type || (e.members ? e.type = "structure" : e.member ? e.type = "list" : e.key ? e.type = "map" : e.type = "string");
        var s = e.type;
        if (a.normalizedTypes[e.type] && (e.type = a.normalizedTypes[e.type]), a.types[e.type]) return new a.types[e.type](e, t, r);
        throw new Error("Unrecognized shape type: " + s)
    }, a.shapes = {
        StructureShape: u,
        ListShape: d,
        MapShape: l,
        StringShape: h,
        BooleanShape: m,
        Base64Shape: f
    }, e.exports = a
}, function (e, t, r) {
    (function (e) {
        var n = Object.getOwnPropertyDescriptors || function (e) {
            for (var t = Object.keys(e), r = {}, n = 0; n < t.length; n++) r[t[n]] = Object.getOwnPropertyDescriptor(e, t[n]);
            return r
        }, i = /%[sdj%]/g;
        t.format = function (e) {
            if (!v(e)) {
                for (var t = [], r = 0; r < arguments.length; r++) t.push(a(arguments[r]));
                return t.join(" ")
            }
            r = 1;
            for (var n = arguments, o = n.length, s = String(e).replace(i, function (e) {
                if ("%%" === e) return "%";
                if (r >= o) return e;
                switch (e) {
                    case"%s":
                        return String(n[r++]);
                    case"%d":
                        return Number(n[r++]);
                    case"%j":
                        try {
                            return JSON.stringify(n[r++])
                        } catch (e) {
                            return "[Circular]"
                        }
                    default:
                        return e
                }
            }), c = n[r]; r < o; c = n[++r]) m(c) || !y(c) ? s += " " + c : s += " " + a(c);
            return s
        }, t.deprecate = function (r, n) {
            if (void 0 !== e && !0 === e.noDeprecation) return r;
            if (void 0 === e) return function () {
                return t.deprecate(r, n).apply(this, arguments)
            };
            var i = !1;
            return function () {
                if (!i) {
                    if (e.throwDeprecation) throw new Error(n);
                    e.traceDeprecation ? console.trace(n) : console.error(n), i = !0
                }
                return r.apply(this, arguments)
            }
        };
        var o, s = {};

        function a(e, r) {
            var n = {seen: [], stylize: u};
            return arguments.length >= 3 && (n.depth = arguments[2]), arguments.length >= 4 && (n.colors = arguments[3]), f(r) ? n.showHidden = r : r && t._extend(n, r), g(n.showHidden) && (n.showHidden = !1), g(n.depth) && (n.depth = 2), g(n.colors) && (n.colors = !1), g(n.customInspect) && (n.customInspect = !0), n.colors && (n.stylize = c), d(n, e, n.depth)
        }

        function c(e, t) {
            var r = a.styles[t];
            return r ? "[" + a.colors[r][0] + "m" + e + "[" + a.colors[r][1] + "m" : e
        }

        function u(e, t) {
            return e
        }

        function d(e, r, n) {
            if (e.customInspect && r && T(r.inspect) && r.inspect !== t.inspect && (!r.constructor || r.constructor.prototype !== r)) {
                var i = r.inspect(n, e);
                return v(i) || (i = d(e, i, n)), i
            }
            var o = function (e, t) {
                if (g(t)) return e.stylize("undefined", "undefined");
                if (v(t)) {
                    var r = "'" + JSON.stringify(t).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
                    return e.stylize(r, "string")
                }
                if (_(t)) return e.stylize("" + t, "number");
                if (f(t)) return e.stylize("" + t, "boolean");
                if (m(t)) return e.stylize("null", "null")
            }(e, r);
            if (o) return o;
            var s = Object.keys(r), a = function (e) {
                var t = {};
                return e.forEach(function (e, r) {
                    t[e] = !0
                }), t
            }(s);
            if (e.showHidden && (s = Object.getOwnPropertyNames(r)), b(r) && (s.indexOf("message") >= 0 || s.indexOf("description") >= 0)) return l(r);
            if (0 === s.length) {
                if (T(r)) {
                    var c = r.name ? ": " + r.name : "";
                    return e.stylize("[Function" + c + "]", "special")
                }
                if (E(r)) return e.stylize(RegExp.prototype.toString.call(r), "regexp");
                if (S(r)) return e.stylize(Date.prototype.toString.call(r), "date");
                if (b(r)) return l(r)
            }
            var u, y = "", R = !1, I = ["{", "}"];
            (p(r) && (R = !0, I = ["[", "]"]), T(r)) && (y = " [Function" + (r.name ? ": " + r.name : "") + "]");
            return E(r) && (y = " " + RegExp.prototype.toString.call(r)), S(r) && (y = " " + Date.prototype.toUTCString.call(r)), b(r) && (y = " " + l(r)), 0 !== s.length || R && 0 != r.length ? n < 0 ? E(r) ? e.stylize(RegExp.prototype.toString.call(r), "regexp") : e.stylize("[Object]", "special") : (e.seen.push(r), u = R ? function (e, t, r, n, i) {
                for (var o = [], s = 0, a = t.length; s < a; ++s) C(t, String(s)) ? o.push(h(e, t, r, n, String(s), !0)) : o.push("");
                return i.forEach(function (i) {
                    i.match(/^\d+$/) || o.push(h(e, t, r, n, i, !0))
                }), o
            }(e, r, n, a, s) : s.map(function (t) {
                return h(e, r, n, a, t, R)
            }), e.seen.pop(), function (e, t, r) {
                if (e.reduce(function (e, t) {
                    return 0, t.indexOf("\n") >= 0 && 0, e + t.replace(/\u001b\[\d\d?m/g, "").length + 1
                }, 0) > 60) return r[0] + ("" === t ? "" : t + "\n ") + " " + e.join(",\n  ") + " " + r[1];
                return r[0] + t + " " + e.join(", ") + " " + r[1]
            }(u, y, I)) : I[0] + y + I[1]
        }

        function l(e) {
            return "[" + Error.prototype.toString.call(e) + "]"
        }

        function h(e, t, r, n, i, o) {
            var s, a, c;
            if ((c = Object.getOwnPropertyDescriptor(t, i) || {value: t[i]}).get ? a = c.set ? e.stylize("[Getter/Setter]", "special") : e.stylize("[Getter]", "special") : c.set && (a = e.stylize("[Setter]", "special")), C(n, i) || (s = "[" + i + "]"), a || (e.seen.indexOf(c.value) < 0 ? (a = m(r) ? d(e, c.value, null) : d(e, c.value, r - 1)).indexOf("\n") > -1 && (a = o ? a.split("\n").map(function (e) {
                return "  " + e
            }).join("\n").substr(2) : "\n" + a.split("\n").map(function (e) {
                return "   " + e
            }).join("\n")) : a = e.stylize("[Circular]", "special")), g(s)) {
                if (o && i.match(/^\d+$/)) return a;
                (s = JSON.stringify("" + i)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (s = s.substr(1, s.length - 2), s = e.stylize(s, "name")) : (s = s.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), s = e.stylize(s, "string"))
            }
            return s + ": " + a
        }

        function p(e) {
            return Array.isArray(e)
        }

        function f(e) {
            return "boolean" == typeof e
        }

        function m(e) {
            return null === e
        }

        function _(e) {
            return "number" == typeof e
        }

        function v(e) {
            return "string" == typeof e
        }

        function g(e) {
            return void 0 === e
        }

        function E(e) {
            return y(e) && "[object RegExp]" === R(e)
        }

        function y(e) {
            return "object" == typeof e && null !== e
        }

        function S(e) {
            return y(e) && "[object Date]" === R(e)
        }

        function b(e) {
            return y(e) && ("[object Error]" === R(e) || e instanceof Error)
        }

        function T(e) {
            return "function" == typeof e
        }

        function R(e) {
            return Object.prototype.toString.call(e)
        }

        function I(e) {
            return e < 10 ? "0" + e.toString(10) : e.toString(10)
        }

        t.debuglog = function (r) {
            if (g(o) && (o = e.env.NODE_DEBUG || ""), r = r.toUpperCase(), !s[r]) if (new RegExp("\\b" + r + "\\b", "i").test(o)) {
                var n = e.pid;
                s[r] = function () {
                    var e = t.format.apply(t, arguments);
                    console.error("%s %d: %s", r, n, e)
                }
            } else s[r] = function () {
            };
            return s[r]
        }, t.inspect = a, a.colors = {
            bold: [1, 22],
            italic: [3, 23],
            underline: [4, 24],
            inverse: [7, 27],
            white: [37, 39],
            grey: [90, 39],
            black: [30, 39],
            blue: [34, 39],
            cyan: [36, 39],
            green: [32, 39],
            magenta: [35, 39],
            red: [31, 39],
            yellow: [33, 39]
        }, a.styles = {
            special: "cyan",
            number: "yellow",
            boolean: "yellow",
            undefined: "grey",
            null: "bold",
            string: "green",
            date: "magenta",
            regexp: "red"
        }, t.isArray = p, t.isBoolean = f, t.isNull = m, t.isNullOrUndefined = function (e) {
            return null == e
        }, t.isNumber = _, t.isString = v, t.isSymbol = function (e) {
            return "symbol" == typeof e
        }, t.isUndefined = g, t.isRegExp = E, t.isObject = y, t.isDate = S, t.isError = b, t.isFunction = T, t.isPrimitive = function (e) {
            return null === e || "boolean" == typeof e || "number" == typeof e || "string" == typeof e || "symbol" == typeof e || void 0 === e
        }, t.isBuffer = r(233);
        var w = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];

        function C(e, t) {
            return Object.prototype.hasOwnProperty.call(e, t)
        }

        t.log = function () {
            console.log("%s - %s", function () {
                var e = new Date, t = [I(e.getHours()), I(e.getMinutes()), I(e.getSeconds())].join(":");
                return [e.getDate(), w[e.getMonth()], t].join(" ")
            }(), t.format.apply(t, arguments))
        }, t.inherits = r(26), t._extend = function (e, t) {
            if (!t || !y(t)) return e;
            for (var r = Object.keys(t), n = r.length; n--;) e[r[n]] = t[r[n]];
            return e
        };
        var A = "undefined" != typeof Symbol ? Symbol("util.promisify.custom") : void 0;

        function O(e, t) {
            if (!e) {
                var r = new Error("Promise was rejected with a falsy value");
                r.reason = e, e = r
            }
            return t(e)
        }

        t.promisify = function (e) {
            if ("function" != typeof e) throw new TypeError('The "original" argument must be of type Function');
            if (A && e[A]) {
                var t;
                if ("function" != typeof (t = e[A])) throw new TypeError('The "util.promisify.custom" argument must be of type Function');
                return Object.defineProperty(t, A, {value: t, enumerable: !1, writable: !1, configurable: !0}), t
            }

            function t() {
                for (var t, r, n = new Promise(function (e, n) {
                    t = e, r = n
                }), i = [], o = 0; o < arguments.length; o++) i.push(arguments[o]);
                i.push(function (e, n) {
                    e ? r(e) : t(n)
                });
                try {
                    e.apply(this, i)
                } catch (e) {
                    r(e)
                }
                return n
            }

            return Object.setPrototypeOf(t, Object.getPrototypeOf(e)), A && Object.defineProperty(t, A, {
                value: t,
                enumerable: !1,
                writable: !1,
                configurable: !0
            }), Object.defineProperties(t, n(e))
        }, t.promisify.custom = A, t.callbackify = function (t) {
            if ("function" != typeof t) throw new TypeError('The "original" argument must be of type Function');

            function r() {
                for (var r = [], n = 0; n < arguments.length; n++) r.push(arguments[n]);
                var i = r.pop();
                if ("function" != typeof i) throw new TypeError("The last argument must be of type Function");
                var o = this, s = function () {
                    return i.apply(o, arguments)
                };
                t.apply(this, r).then(function (t) {
                    e.nextTick(s, null, t)
                }, function (t) {
                    e.nextTick(O, t, s)
                })
            }

            return Object.setPrototypeOf(r, Object.getPrototypeOf(t)), Object.defineProperties(r, n(t)), r
        }
    }).call(this, r(14))
}, function (e, t, r) {
    r(80);
    var n = r(9), i = n.Service, o = n.apiLoader;
    o.services.sts = {}, n.STS = i.defineService("sts", ["2011-06-15"]), r(266), Object.defineProperty(o.services.sts, "2011-06-15", {
        get: function () {
            var e = r(268);
            return e.paginators = r(269).pagination, e
        }, enumerable: !0, configurable: !0
    }), e.exports = n.STS
}, function (e, t, r) {
    "use strict";
    (function (t) {
        void 0 === t || !t.version || 0 === t.version.indexOf("v0.") || 0 === t.version.indexOf("v1.") && 0 !== t.version.indexOf("v1.8.") ? e.exports = {
            nextTick: function (e, r, n, i) {
                if ("function" != typeof e) throw new TypeError('"callback" argument must be a function');
                var o, s, a = arguments.length;
                switch (a) {
                    case 0:
                    case 1:
                        return t.nextTick(e);
                    case 2:
                        return t.nextTick(function () {
                            e.call(null, r)
                        });
                    case 3:
                        return t.nextTick(function () {
                            e.call(null, r, n)
                        });
                    case 4:
                        return t.nextTick(function () {
                            e.call(null, r, n, i)
                        });
                    default:
                        for (o = new Array(a - 1), s = 0; s < o.length;) o[s++] = arguments[s];
                        return t.nextTick(function () {
                            e.apply(null, o)
                        })
                }
            }
        } : e.exports = t
    }).call(this, r(14))
}, function (e, t, r) {
    (function (e) {
        function r(e) {
            return Object.prototype.toString.call(e)
        }

        t.isArray = function (e) {
            return Array.isArray ? Array.isArray(e) : "[object Array]" === r(e)
        }, t.isBoolean = function (e) {
            return "boolean" == typeof e
        }, t.isNull = function (e) {
            return null === e
        }, t.isNullOrUndefined = function (e) {
            return null == e
        }, t.isNumber = function (e) {
            return "number" == typeof e
        }, t.isString = function (e) {
            return "string" == typeof e
        }, t.isSymbol = function (e) {
            return "symbol" == typeof e
        }, t.isUndefined = function (e) {
            return void 0 === e
        }, t.isRegExp = function (e) {
            return "[object RegExp]" === r(e)
        }, t.isObject = function (e) {
            return "object" == typeof e && null !== e
        }, t.isDate = function (e) {
            return "[object Date]" === r(e)
        }, t.isError = function (e) {
            return "[object Error]" === r(e) || e instanceof Error
        }, t.isFunction = function (e) {
            return "function" == typeof e
        }, t.isPrimitive = function (e) {
            return null === e || "boolean" == typeof e || "number" == typeof e || "string" == typeof e || "symbol" == typeof e || void 0 === e
        }, t.isBuffer = e.isBuffer
    }).call(this, r(22).Buffer)
}, function (e, t, r) {
    var n = r(15), i = r(84).populateHostPrefix;

    function o(e, t, r, i) {
        var o = [e, t].join("/");
        o = o.replace(/\/+/g, "/");
        var s = {}, a = !1;
        if (n.each(r.members, function (e, t) {
            var r = i[e];
            if (null !== r && void 0 !== r) if ("uri" === t.location) {
                var c = new RegExp("\\{" + t.name + "(\\+)?\\}");
                o = o.replace(c, function (e, t) {
                    return (t ? n.uriEscapePath : n.uriEscape)(String(r))
                })
            } else "querystring" === t.location && (a = !0, "list" === t.type ? s[t.name] = r.map(function (e) {
                return n.uriEscape(t.member.toWireFormat(e).toString())
            }) : "map" === t.type ? n.each(r, function (e, t) {
                Array.isArray(t) ? s[e] = t.map(function (e) {
                    return n.uriEscape(String(e))
                }) : s[e] = n.uriEscape(String(t))
            }) : s[t.name] = n.uriEscape(t.toWireFormat(r).toString()))
        }), a) {
            o += o.indexOf("?") >= 0 ? "&" : "?";
            var c = [];
            n.arrayEach(Object.keys(s).sort(), function (e) {
                Array.isArray(s[e]) || (s[e] = [s[e]]);
                for (var t = 0; t < s[e].length; t++) c.push(n.uriEscape(String(e)) + "=" + s[e][t])
            }), o += c.join("&")
        }
        return o
    }

    e.exports = {
        buildRequest: function (e) {
            !function (e) {
                e.httpRequest.method = e.service.api.operations[e.operation].httpMethod
            }(e), function (e) {
                var t = e.service.api.operations[e.operation], r = t.input,
                    n = o(e.httpRequest.endpoint.path, t.httpPath, r, e.params);
                e.httpRequest.path = n
            }(e), function (e) {
                var t = e.service.api.operations[e.operation];
                n.each(t.input.members, function (t, r) {
                    var i = e.params[t];
                    null !== i && void 0 !== i && ("headers" === r.location && "map" === r.type ? n.each(i, function (t, n) {
                        e.httpRequest.headers[r.name + t] = n
                    }) : "header" === r.location && (i = r.toWireFormat(i).toString(), r.isJsonValue && (i = n.base64.encode(i)), e.httpRequest.headers[r.name] = i))
                })
            }(e), i(e)
        }, extractError: function () {
        }, extractData: function (e) {
            var t = e.request, r = {}, i = e.httpResponse, o = t.service.api.operations[t.operation].output, s = {};
            n.each(i.headers, function (e, t) {
                s[e.toLowerCase()] = t
            }), n.each(o.members, function (e, t) {
                var o = (t.name || e).toLowerCase();
                if ("headers" === t.location && "map" === t.type) {
                    r[e] = {};
                    var a = t.isLocationName ? t.name : "", c = new RegExp("^" + a + "(.+)", "i");
                    n.each(i.headers, function (t, n) {
                        var i = t.match(c);
                        null !== i && (r[e][i[1]] = n)
                    })
                } else if ("header" === t.location) {
                    if (void 0 !== s[o]) {
                        var u = t.isJsonValue ? n.base64.decode(s[o]) : s[o];
                        r[e] = t.toType(u)
                    }
                } else "statusCode" === t.location && (r[e] = parseInt(i.statusCode, 10))
            }), e.data = r
        }, generateURI: o
    }
}, function (e, t, r) {
    var n = r(22).Buffer;
    "undefined" != typeof ArrayBuffer && void 0 === ArrayBuffer.isView && (ArrayBuffer.isView = function (e) {
        return i.indexOf(Object.prototype.toString.call(e)) > -1
    });
    var i = ["[object Int8Array]", "[object Uint8Array]", "[object Uint8ClampedArray]", "[object Int16Array]", "[object Uint16Array]", "[object Int32Array]", "[object Uint32Array]", "[object Float32Array]", "[object Float64Array]", "[object DataView]"];
    e.exports = {
        isEmptyData: function (e) {
            return "string" == typeof e ? 0 === e.length : 0 === e.byteLength
        }, convertToBuffer: function (e) {
            return "string" == typeof e && (e = new n(e, "utf8")), ArrayBuffer.isView(e) ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength / Uint8Array.BYTES_PER_ELEMENT) : new Uint8Array(e)
        }
    }
}, function (e, t, r) {
    (t = e.exports = r(131)).Stream = t, t.Readable = t, t.Writable = r(134), t.Duplex = r(36), t.Transform = r(136), t.PassThrough = r(287)
}, function (e, t, r) {
    "use strict";
    e.exports = r(139)() ? Object.setPrototypeOf : r(140)
}, function (e, t, r) {
    "use strict";
    e.exports = r(313)() ? globalThis : r(314)
}, function (e, t, r) {
    "use strict";
    var n = Object.prototype.toString, i = n.call(function () {
        return arguments
    }());
    e.exports = function (e) {
        return n.call(e) === i
    }
}, function (e, t, r) {
    "use strict";
    var n = Object.prototype.toString, i = n.call("");
    e.exports = function (e) {
        return "string" == typeof e || e && "object" == typeof e && (e instanceof String || n.call(e) === i) || !1
    }
}, function (e, t) {
    e.exports = function (e) {
        return void 0 === e || null === e
    }
}, function (e, t, r) {
    var n = r(158), i = r(159), o = r(99), s = r(160);
    e.exports = function (e) {
        return n(e) || i(e) || o(e) || s()
    }
}, function (e, t, r) {
    e.exports = r(162)
}, function (e, t, r) {
    "use strict";
    r.d(t, "a", function () {
        return T
    });
    var n = r(6), i = r.n(n), o = r(8), s = r.n(o), a = r(10), c = r.n(a), u = r(11), d = r.n(u), l = r(7), h = r.n(l),
        p = r(3), f = r.n(p), m = r(23), _ = r(2), v = r(4), g = r(0), E = r(1);

    function y(e) {
        var t = function () {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function () {
                })), !0
            } catch (e) {
                return !1
            }
        }();
        return function () {
            var r, n = h()(e);
            if (t) {
                var i = h()(this).constructor;
                r = Reflect.construct(n, arguments, i)
            } else r = n.apply(this, arguments);
            return d()(this, r)
        }
    }

    var S = _.a.LOG_LEVELS, b = (S.INFO, S.WARN, S.ERROR), T = function (e) {
        c()(r, e);
        var t = y(r);

        function r(e) {
            var n;
            return i()(this, r), (n = t.call(this, e))._filter = {}, n
        }

        return s()(r, [{
            key: "usersList", value: function (e) {
                var t = this;
                return Object(v.a)(e, function (e) {
                    t._client.request("".concat(r.basePath, "/"), {
                        method: "get",
                        params: t._filter
                    }).then(function (r) {
                        var n = [];
                        return r.data.forEach(function (e) {
                            n.push(t._client.userModel(e))
                        }), e(null, n)
                    }).catch(function (r) {
                        return E.a.log(b, g.errors.API_ERROR, {err: t._client.error(r)}), e(t._client.error(r))
                    })
                })
            }
        }, {
            key: "online", get: function () {
                return this._filter.online
            }, set: function (e) {
                this._filter.online = e
            }
        }, {
            key: "search", get: function () {
                return this._filter.search
            }, set: function (e) {
                this._filter.search = e
            }
        }, {
            key: "sort", get: function () {
                return this._filter.sort
            }, set: function (e) {
                this._filter.sort = e
            }
        }, {
            key: "limit", get: function () {
                return this._filter.limit
            }, set: function (e) {
                this._filter.limit = e
            }
        }, {
            key: "skip", get: function () {
                return this._filter.skip
            }, set: function (e) {
                this._filter.skip = e
            }
        }, {
            key: "includeBlocked", get: function () {
                return this._filter.includeBlocked
            }, set: function (e) {
                this._filter.includeBlocked = e
            }
        }, {
            key: "skipUserIds", get: function () {
                return this._filter.skipUserIds
            }, set: function (e) {
                this._filter.skipUserIds = e
            }
        }, {
            key: "role", get: function () {
                return this._filter.role
            }, set: function (e) {
                this._filter.role = e
            }
        }, {
            key: "includeDeleted", get: function () {
                return this._filter.includeDeleted
            }, set: function (e) {
                this._filter.includeDeleted = e
            }
        }]), r
    }(m.a);
    f()(T, "basePath", _.a.BASEPATH_USERS)
}, function (e, t, r) {
    "use strict";
    r.d(t, "a", function () {
        return T
    });
    var n = r(6), i = r.n(n), o = r(8), s = r.n(o), a = r(10), c = r.n(a), u = r(11), d = r.n(u), l = r(7), h = r.n(l),
        p = r(3), f = r.n(p), m = r(34), _ = r(2), v = r(4), g = r(1), E = r(0);

    function y(e) {
        var t = function () {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function () {
                })), !0
            } catch (e) {
                return !1
            }
        }();
        return function () {
            var r, n = h()(e);
            if (t) {
                var i = h()(this).constructor;
                r = Reflect.construct(n, arguments, i)
            } else r = n.apply(this, arguments);
            return d()(this, r)
        }
    }

    var S = _.a.LOG_LEVELS, b = (S.INFO, S.WARN, S.ERROR), T = function (e) {
        c()(r, e);
        var t = y(r);

        function r() {
            return i()(this, r), t.apply(this, arguments)
        }

        return s()(r, [{
            key: "deleteForEveryone", value: function (e) {
                var t = this;
                return Object(v.a)(e, function (e) {
                    t._client.request("".concat(r.basePath, "/delete_for_everyone"), {
                        method: "post",
                        data: {messageIds: [t.id]}
                    }).then(function (t) {
                        return e(null, t.data)
                    }).catch(function (r) {
                        return g.a.log(b, E.errors.API_ERROR, {err: t._client.error(r)}), e(t._client.error(r))
                    })
                })
            }
        }, {
            key: "pin", value: function (e) {
                var t = this;
                return Object(v.a)(e, function (e) {
                    t._client.request("".concat(r.basePath, "/").concat(t.id, "/pin"), {method: "post"}).then(function (t) {
                        return e(null, t.data)
                    }).catch(function (r) {
                        return g.a.log(b, E.errors.API_ERROR, {err: t._client.error(r)}), e(t._client.error(r))
                    })
                })
            }
        }, {
            key: "unpin", value: function (e) {
                var t = this;
                return Object(v.a)(e, function (e) {
                    t._client.request("".concat(r.basePath, "/").concat(t.id, "/unpin"), {method: "post"}).then(function (t) {
                        return e(null, t.data)
                    }).catch(function (r) {
                        return g.a.log(b, E.errors.API_ERROR, {err: t._client.error(r)}), e(t._client.error(r))
                    })
                })
            }
        }, {
            key: "addReaction", value: function (e, t) {
                var n = this;
                return Object(v.a)(t, function (t) {
                    if ("string" != typeof e) return g.a.log(b, E.errors.INVALID_REACTION_TYPE, {}), t(E.errors.INVALID_REACTION_TYPE);
                    n._client.request("".concat(r.basePath, "/").concat(n.id, "/add_reaction"), {
                        method: "post",
                        data: {type: e}
                    }).then(function (e) {
                        return t(null, e.data)
                    }).catch(function (e) {
                        return g.a.log(b, E.errors.API_ERROR, {err: n._client.error(e)}), t(n._client.error(e))
                    })
                })
            }
        }, {
            key: "removeReaction", value: function (e, t) {
                var n = this;
                return Object(v.a)(t, function (t) {
                    if ("string" != typeof e) return g.a.log(b, E.errors.INVALID_REACTION_TYPE, {}), t(E.errors.INVALID_REACTION_TYPE);
                    n._client.request("".concat(r.basePath, "/").concat(n.id, "/remove_reaction"), {
                        method: "post",
                        data: {type: e}
                    }).then(function (e) {
                        return t(null, e.data)
                    }).catch(function (e) {
                        return g.a.log(b, E.errors.API_ERROR, {err: n._client.error(e)}), t(n._client.error(e))
                    })
                })
            }
        }]), r
    }(m.a);
    f()(T, "__properties", {
        id: null,
        type: null,
        customType: null,
        attachments: [],
        body: null,
        conversationId: null,
        ownerId: null,
        owner: {},
        mentionedUsers: [],
        isDeleted: null,
        createdAt: null,
        updatedAt: null,
        metaData: null,
        parentId: null,
        parentMessage: {},
        originalMessageId: null,
        reactionsCount: {},
        reactions: {},
        replyCount: null,
        showInConversation: null,
        pinned: null
    }), f()(T, "basePath", _.a.BASEPATH_MESSAGES)
}, function (e, t, r) {
    "use strict";
    r.d(t, "a", function () {
        return R
    });
    var n = r(6), i = r.n(n), o = r(8), s = r.n(o), a = r(10), c = r.n(a), u = r(11), d = r.n(u), l = r(7), h = r.n(l),
        p = r(3), f = r.n(p), m = r(23), _ = r(2), v = r(13), g = r(4), E = r(0), y = r(1);

    function S(e) {
        var t = function () {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function () {
                })), !0
            } catch (e) {
                return !1
            }
        }();
        return function () {
            var r, n = h()(e);
            if (t) {
                var i = h()(this).constructor;
                r = Reflect.construct(n, arguments, i)
            } else r = n.apply(this, arguments);
            return d()(this, r)
        }
    }

    var b = _.a.LOG_LEVELS, T = (b.INFO, b.WARN, b.ERROR), R = function (e) {
        c()(r, e);
        var t = S(r);

        function r(e) {
            var n;
            return i()(this, r), (n = t.call(this, e))._filter = {}, n
        }

        return s()(r, [{
            key: "list", value: function (e) {
                var t = this;
                return Object(g.a)(e, function (e) {
                    t._client.request(r.basePath, {method: "get", params: t._filter, absolute: !0}).then(function (r) {
                        var n = r.data, i = !1 === Array.isArray(n), o = i ? {} : [];
                        return i ? Object.keys(n).forEach(function (e) {
                            o[e] = [], n[e].forEach(function (r) {
                                o[e].push(t._client.liveBroadcastModel(r))
                            })
                        }) : n.forEach(function (e) {
                            o.push(t._client.liveBroadcastModel(e))
                        }), e(null, o)
                    }).catch(function (r) {
                        return y.a.log(T, E.errors.API_ERROR, {err: t._client.error(r)}), e(t._client.error(r))
                    })
                })
            }
        }, {
            key: "count", value: function (e) {
                var t = this;
                return Object(g.a)(e, function (e) {
                    var n = t.__getCountFilter();
                    t._client.request("".concat(r.basePath, "/count"), {
                        method: "get",
                        params: n,
                        absolute: !0
                    }).then(function (t) {
                        return e(null, t.data)
                    }).catch(function (r) {
                        return y.a.log(T, E.errors.API_ERROR, {err: t._client.error(r)}), e(t._client.error(r))
                    })
                })
            }
        }, {
            key: "ids", get: function () {
                return this._filter.ids
            }, set: function (e) {
                this._filter.ids = e
            }
        }, {
            key: "ownerIds", get: function () {
                return this._filter.ownerIds
            }, set: function (e) {
                this._filter.ownerIds = e
            }
        }, {
            key: "search", get: function () {
                return this._filter.search
            }, set: function (e) {
                this._filter.search = e
            }
        }, {
            key: "status", get: function () {
                return this._filter.status
            }, set: function (e) {
                this._filter.status = e
            }
        }, {
            key: "includeUnpublished", get: function () {
                return this._filter.includeUnpublished
            }, set: function (e) {
                this._filter.includeUnpublished = e
            }
        }, {
            key: "recording", get: function () {
                return this._filter.recording
            }, set: function (e) {
                this._filter.recording = e
            }
        }, {
            key: "hosts", get: function () {
                return this._filter.hosts
            }, set: function (e) {
                this._filter.hosts = e
            }
        }, {
            key: "fromStartTime", get: function () {
                return this._filter.fromStartTime
            }, set: function (e) {
                this._filter.fromStartTime = e
            }
        }, {
            key: "toStartTime", get: function () {
                return this._filter.toStartTime
            }, set: function (e) {
                this._filter.toStartTime = e
            }
        }, {
            key: "groupBy", get: function () {
                return this._filter.groupBy
            }, set: function (e) {
                this._filter.groupBy = e
            }
        }, {
            key: "groupLimit", get: function () {
                return this._filter.groupLimit
            }, set: function (e) {
                this._filter.groupLimit = e
            }
        }, {
            key: "sort", get: function () {
                return this._filter.sort
            }, set: function (e) {
                this._filter.sort = e
            }
        }, {
            key: "limit", get: function () {
                return this._filter.limit
            }, set: function (e) {
                this._filter.limit = e
            }
        }, {
            key: "skip", get: function () {
                return this._filter.skip
            }, set: function (e) {
                this._filter.skip = e
            }
        }]), r
    }(m.a);
    f()(R, "basePath", "".concat(v.a.LIVE_BROADCAST_BASE_URL).concat(_.a.BASEPATH_LIVE_BROADCASTS))
}, function (e, t, r) {
    "use strict";
    r.d(t, "a", function () {
        return T
    });
    var n = r(6), i = r.n(n), o = r(8), s = r.n(o), a = r(10), c = r.n(a), u = r(11), d = r.n(u), l = r(7), h = r.n(l),
        p = r(3), f = r.n(p), m = r(23), _ = r(2), v = r(4), g = r(0), E = r(1);

    function y(e) {
        var t = function () {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function () {
                })), !0
            } catch (e) {
                return !1
            }
        }();
        return function () {
            var r, n = h()(e);
            if (t) {
                var i = h()(this).constructor;
                r = Reflect.construct(n, arguments, i)
            } else r = n.apply(this, arguments);
            return d()(this, r)
        }
    }

    var S = _.a.LOG_LEVELS, b = (S.INFO, S.WARN, S.ERROR), T = function (e) {
        c()(r, e);
        var t = y(r);

        function r(e, n) {
            var o;
            return i()(this, r), (o = t.call(this, e))._filter = {}, o.liveBroadcastId = n, o
        }

        return s()(r, [{
            key: "list", value: function (e) {
                var t = this;
                return Object(v.a)(e, function (e) {
                    t._client.request("".concat(r.basePath, "/").concat(t.liveBroadcastId, "/viewers"), {
                        method: "get",
                        params: t._filter
                    }).then(function (r) {
                        var n = [];
                        return r.data.forEach(function (e) {
                            n.push(t._client.userModel(e))
                        }), e(null, n)
                    }).catch(function (r) {
                        return E.a.log(b, g.errors.API_ERROR, {err: t._client.error(r)}), e(t._client.error(r))
                    })
                })
            }
        }, {
            key: "limit", get: function () {
                return this._filter.limit
            }, set: function (e) {
                this._filter.limit = e
            }
        }, {
            key: "skip", get: function () {
                return this._filter.skip
            }, set: function (e) {
                this._filter.skip = e
            }
        }]), r
    }(m.a);
    f()(T, "basePath", _.a.BASEPATH_LIVE_BROADCASTS)
}, function (e, t, r) {
    "use strict";
    r.d(t, "a", function () {
        return T
    });
    var n = r(6), i = r.n(n), o = r(8), s = r.n(o), a = r(10), c = r.n(a), u = r(11), d = r.n(u), l = r(7), h = r.n(l),
        p = r(3), f = r.n(p), m = r(23), _ = r(2), v = r(4), g = r(0), E = r(1);

    function y(e) {
        var t = function () {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function () {
                })), !0
            } catch (e) {
                return !1
            }
        }();
        return function () {
            var r, n = h()(e);
            if (t) {
                var i = h()(this).constructor;
                r = Reflect.construct(n, arguments, i)
            } else r = n.apply(this, arguments);
            return d()(this, r)
        }
    }

    var S = _.a.LOG_LEVELS, b = (S.INFO, S.WARN, S.ERROR), T = function (e) {
        c()(r, e);
        var t = y(r);

        function r(e, n) {
            var o;
            return i()(this, r), (o = t.call(this, e))._filter = {}, o.conversationId = n, o
        }

        return s()(r, [{
            key: "list", value: function (e) {
                var t = this;
                return Object(v.a)(e, function (e) {
                    t._client.request("".concat(r.basePath, "/").concat(t.conversationId, "/ban"), {
                        method: "get",
                        params: t._filter
                    }).then(function (t) {
                        return e(null, t.data)
                    }).catch(function (r) {
                        return E.a.log(b, g.errors.API_ERROR, {err: t._client.error(r)}), e(t._client.error(r))
                    })
                })
            }
        }, {
            key: "limit", get: function () {
                return this._filter.limit
            }, set: function (e) {
                this._filter.limit = e
            }
        }, {
            key: "skip", get: function () {
                return this._filter.skip
            }, set: function (e) {
                this._filter.skip = e
            }
        }]), r
    }(m.a);
    f()(T, "basePath", _.a.BASEPATH_CONVERSATIONS)
}, function (e, t, r) {
    "use strict";
    r.d(t, "a", function () {
        return T
    });
    var n = r(6), i = r.n(n), o = r(8), s = r.n(o), a = r(10), c = r.n(a), u = r(11), d = r.n(u), l = r(7), h = r.n(l),
        p = r(3), f = r.n(p), m = r(23), _ = r(2), v = r(4), g = r(0), E = r(1);

    function y(e) {
        var t = function () {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function () {
                })), !0
            } catch (e) {
                return !1
            }
        }();
        return function () {
            var r, n = h()(e);
            if (t) {
                var i = h()(this).constructor;
                r = Reflect.construct(n, arguments, i)
            } else r = n.apply(this, arguments);
            return d()(this, r)
        }
    }

    var S = _.a.LOG_LEVELS, b = (S.INFO, S.WARN, S.ERROR), T = function (e) {
        c()(r, e);
        var t = y(r);

        function r(e, n) {
            var o;
            return i()(this, r), (o = t.call(this, e))._filter = {}, o.conversationId = n, o
        }

        return s()(r, [{
            key: "list", value: function (e) {
                var t = this;
                return Object(v.a)(e, function (e) {
                    t._client.request("".concat(r.basePath, "/").concat(t.conversationId, "/messages"), {
                        method: "get",
                        params: t._filter
                    }).then(function (r) {
                        var n = [];
                        return r.data.forEach(function (e) {
                            n.push(t._client.messageModel(e))
                        }), e(null, n)
                    }).catch(function (r) {
                        return E.a.log(b, g.errors.API_ERROR, {err: t._client.error(r)}), e(t._client.error(r))
                    })
                })
            }
        }, {
            key: "count", value: function (e) {
                var t = this;
                return Object(v.a)(e, function (e) {
                    var n = t.__getCountFilter();
                    t._client.request("".concat(r.basePath, "/").concat(t.conversationId, "/messages/count"), {
                        method: "get",
                        params: n
                    }).then(function (t) {
                        return e(null, t.data)
                    }).catch(function (r) {
                        return E.a.log(b, g.errors.API_ERROR, {err: t._client.error(r)}), e(t._client.error(r))
                    })
                })
            }
        }, {
            key: "startTime", get: function () {
                return this._filter["createdAt[start]"]
            }, set: function (e) {
                this._filter["createdAt[start]"] = e
            }
        }, {
            key: "endTime", get: function () {
                return this._filter["createdAt[end]"]
            }, set: function (e) {
                this._filter["createdAt[end]"] = e
            }
        }, {
            key: "createdAt", get: function () {
                return this._filter.createdAt
            }, set: function (e) {
                this._filter.createdAt = e
            }
        }, {
            key: "ids", get: function () {
                return this._filter.ids
            }, set: function (e) {
                this._filter.ids = e
            }
        }, {
            key: "types", get: function () {
                return this._filter.types
            }, set: function (e) {
                this._filter.types = e
            }
        }, {
            key: "customTypes", get: function () {
                return this._filter.customTypes
            }, set: function (e) {
                this._filter.customTypes = e
            }
        }, {
            key: "attachmentTypes", get: function () {
                return this._filter.attachmentTypes
            }, set: function (e) {
                this._filter.attachmentTypes = e
            }
        }, {
            key: "includeDeleted", get: function () {
                return this._filter.includeDeleted
            }, set: function (e) {
                this._filter.includeDeleted = e
            }
        }, {
            key: "ownerIds", get: function () {
                return this._filter.ownerIds
            }, set: function (e) {
                this._filter.ownerIds = e
            }
        }, {
            key: "parentId", get: function () {
                return this._filter.parentId
            }, set: function (e) {
                this._filter.parentId = e
            }
        }, {
            key: "showInConversation", get: function () {
                return this._filter.showInConversation
            }, set: function (e) {
                this._filter.showInConversation = e
            }
        }, {
            key: "pinned", get: function () {
                return this._filter.pinned
            }, set: function (e) {
                this._filter.pinned = e
            }
        }, {
            key: "sort", get: function () {
                return this._filter.sort
            }, set: function (e) {
                this._filter.sort = e
            }
        }, {
            key: "limit", get: function () {
                return this._filter.limit
            }, set: function (e) {
                this._filter.limit = e
            }
        }, {
            key: "skip", get: function () {
                return this._filter.skip
            }, set: function (e) {
                this._filter.skip = e
            }
        }]), r
    }(m.a);
    f()(T, "basePath", _.a.BASEPATH_CONVERSATIONS)
}, function (e, t, r) {
    "use strict";
    r.d(t, "a", function () {
        return T
    });
    var n = r(6), i = r.n(n), o = r(8), s = r.n(o), a = r(10), c = r.n(a), u = r(11), d = r.n(u), l = r(7), h = r.n(l),
        p = r(3), f = r.n(p), m = r(23), _ = r(2), v = r(4), g = r(0), E = r(1);

    function y(e) {
        var t = function () {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function () {
                })), !0
            } catch (e) {
                return !1
            }
        }();
        return function () {
            var r, n = h()(e);
            if (t) {
                var i = h()(this).constructor;
                r = Reflect.construct(n, arguments, i)
            } else r = n.apply(this, arguments);
            return d()(this, r)
        }
    }

    var S = _.a.LOG_LEVELS, b = (S.INFO, S.WARN, S.ERROR), T = function (e) {
        c()(r, e);
        var t = y(r);

        function r(e, n) {
            var o;
            return i()(this, r), (o = t.call(this, e))._filter = {}, o.liveBroadcastId = n, o
        }

        return s()(r, [{
            key: "list", value: function (e) {
                var t = this;
                return Object(v.a)(e, function (e) {
                    t._client.request("".concat(r.basePath, "/").concat(t.liveBroadcastId, "/playback/reactions"), {
                        method: "get",
                        params: t._filter
                    }).then(function (t) {
                        return e(null, t.data)
                    }).catch(function (r) {
                        return E.a.log(b, g.errors.API_ERROR, {err: t._client.error(r)}), e(t._client.error(r))
                    })
                })
            }
        }, {
            key: "startTime", get: function () {
                return this._filter.startTime
            }, set: function (e) {
                this._filter.startTime = e
            }
        }, {
            key: "endTime", get: function () {
                return this._filter.endTime
            }, set: function (e) {
                this._filter.endTime = e
            }
        }, {
            key: "limit", get: function () {
                return this._filter.limit
            }, set: function (e) {
                this._filter.limit = e
            }
        }, {
            key: "skip", get: function () {
                return this._filter.skip
            }, set: function (e) {
                this._filter.skip = e
            }
        }]), r
    }(m.a);
    f()(T, "basePath", _.a.BASEPATH_LIVE_BROADCASTS)
}, function (e, t, r) {
    "use strict";
    r.d(t, "a", function () {
        return o
    });
    var n = "undefined" != typeof crypto && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || "undefined" != typeof msCrypto && "function" == typeof msCrypto.getRandomValues && msCrypto.getRandomValues.bind(msCrypto),
        i = new Uint8Array(16);

    function o() {
        if (!n) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
        return n(i)
    }
}, function (e, t, r) {
    "use strict";
    r.d(t, "a", function () {
        return T
    });
    var n = r(6), i = r.n(n), o = r(8), s = r.n(o), a = r(10), c = r.n(a), u = r(11), d = r.n(u), l = r(7), h = r.n(l),
        p = r(3), f = r.n(p), m = r(16), _ = r(2), v = r(0), g = r(4), E = r(1);

    function y(e) {
        var t = function () {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function () {
                })), !0
            } catch (e) {
                return !1
            }
        }();
        return function () {
            var r, n = h()(e);
            if (t) {
                var i = h()(this).constructor;
                r = Reflect.construct(n, arguments, i)
            } else r = n.apply(this, arguments);
            return d()(this, r)
        }
    }

    var S = _.a.LOG_LEVELS, b = (S.INFO, S.WARN, S.ERROR), T = function (e) {
        c()(r, e);
        var t = y(r);

        function r() {
            return i()(this, r), t.apply(this, arguments)
        }

        return s()(r, null, [{
            key: "upload", value: function (e, t, n, i) {
                return Object(g.a)(i, function (i) {
                    if (!r.Client || !r.Client.getInstance()) return i(v.errors.NOT_INITIALIZED);
                    var o = r.Client.getInstance();
                    if (!(e instanceof File)) return E.a.log(b, v.errors.INVALID_FILE_OBJECT, {}), i(v.errors.INVALID_FILE_OBJECT);
                    var s = e.type.split("/").shift();
                    if (!["image", "video", "audio"].includes(s)) return E.a.log(b, v.errors.INVALID_FILE_TYPE, {}), i(v.errors.INVALID_FILE_TYPE);
                    r.__getMetaData(e, t, n, function (t, n) {
                        if (t) return i(t);
                        var s = r.__getRequestUploadUrlData(n);
                        r.__requestUploadUrl(s, function (t, r) {
                            if (t) return i(t);
                            var s = [];
                            if (s.push(o.request(r.uploadUrl, {
                                method: "put",
                                data: e,
                                absolute: !0,
                                noAuth: !0,
                                headers: {"Content-Type": e.type}
                            })), r.uploadThumbnailUrl) {
                                var a = n.thumbnailFile;
                                s.push(o.request(r.uploadThumbnailUrl, {
                                    method: "put",
                                    data: a,
                                    absolute: !0,
                                    noAuth: !0,
                                    headers: {"Content-Type": a.type}
                                }))
                            }
                            Promise.all(s).then(function (e) {
                                return n.fileUrl = r.fileUrl, n.thumbnailUrl = r.thumbnailUrl, n.type = n.attachmentType, i(null, n)
                            }).catch(function (e) {
                                return E.a.log(b, v.errors.API_ERROR, {err: e}), i(e, null)
                            })
                        })
                    })
                })
            }
        }, {
            key: "__dataURLtoBlob", value: function (e) {
                for (var t = e.split(","), r = t[0].match(/:(.*?);/)[1], n = atob(t[1]), i = n.length, o = new Uint8Array(i); i -= 1;) o[i] = n.charCodeAt(i);
                return new Blob([o], {type: r})
            }
        }, {
            key: "__getMetaData", value: function (e, t, n, i) {
                return Object(g.a)(i, function (i) {
                    if (!r.Client || !r.Client.getInstance()) return i(v.errors.NOT_INITIALIZED);
                    var o = r.Client.getInstance(),
                        s = {name: e.name, mimeType: e.type, extension: e.name.split(".").pop(), attachmentType: t};
                    if (!n || !o.browser) return i(null, s);
                    var a = document.body;
                    if ("audio" === t || "video" === t) {
                        var c = URL.createObjectURL(e), u = document.createElement("video");
                        u.setAttribute("style", "visibility: hidden; display: none; position: absolute;"), u.autoplay = !0, u.controls = !0;
                        var d, l, h = document.createElement("source");
                        h.setAttribute("src", c), u.appendChild(h), a.appendChild(u), "video" === t && (d = document.createElement("canvas"), l = d.getContext("2d")), u.addEventListener("play", function () {
                            if ("undefined" == typeof window || null == window || null == window.setTimeout) return i(null, s);
                            window.setTimeout(function () {
                                var e = 1e3 * u.duration;
                                return s.duration = e, "video" === t && (d.width = 180, d.height = 180, l.drawImage(u, 0, 0, 180, 180), s.thumbnailFile = r.__dataURLtoBlob(d.toDataURL())), u.parentNode.removeChild(u), i(null, s)
                            }, 2e3)
                        })
                    } else {
                        var p = URL.createObjectURL(e), f = document.createElement("img");
                        f.setAttribute("src", p), f.setAttribute("style", "visibility: hidden; display: none; position: absolute;"), a.appendChild(f), f.onload = function () {
                            var e = document.createElement("canvas"), t = e.getContext("2d");
                            return e.width = 180, e.height = 180, t.drawImage(f, 0, 0, 180, 180), s.thumbnailFile = r.__dataURLtoBlob(e.toDataURL()), a.removeChild(f), i(null, s)
                        }
                    }
                })
            }
        }, {
            key: "__getRequestUploadUrlData", value: function (e) {
                if (!r.Client || !r.Client.getInstance()) throw new Error(v.errors.NOT_INITIALIZED);
                r.Client.getInstance();
                var t = e.name, n = {name: t};
                if (e.thumbnailFile) {
                    var i = t.substring(0, t.lastIndexOf("."));
                    n.thumbnail = {name: "".concat(i, "-thumbnail.png")}
                }
                return n
            }
        }, {
            key: "__requestUploadUrl", value: function (e, t) {
                return Object(g.a)(t, function (t) {
                    if (!r.Client || !r.Client.getInstance()) return t(v.errors.NOT_INITIALIZED);
                    var n = r.Client.getInstance();
                    e = JSON.stringify(e), n.request(r.basePath, {
                        method: "post",
                        data: e,
                        headers: {"Content-Type": "application/json"}
                    }).then(function (e) {
                        return t(null, e.data)
                    }).catch(function (e) {
                        return E.a.log(b, v.errors.API_ERROR, {err: n.error(e)}), t(n.error(e))
                    })
                })
            }
        }]), r
    }(m.a);
    f()(T, "basePath", _.a.BASEPATH_FILES)
}, function (e, t, r) {
    "use strict";
    r.d(t, "a", function () {
        return x
    });
    var n = r(18), i = r.n(n), o = r(6), s = r.n(o), a = r(8), c = r.n(a), u = r(3), d = r.n(u), l = r(63), h = r.n(l),
        p = r(16), f = r(44), m = r(17), _ = r(65), v = r(45), g = r(46), E = r(47), y = r(35), S = r(72), b = r(74),
        T = r(48), R = r(0), I = r(2), w = r(4), C = r(13), A = r(1);

    function O(e, t) {
        var r = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
            var n = Object.getOwnPropertySymbols(e);
            t && (n = n.filter(function (t) {
                return Object.getOwnPropertyDescriptor(e, t).enumerable
            })), r.push.apply(r, n)
        }
        return r
    }

    function N(e) {
        for (var t = 1; t < arguments.length; t++) {
            var r = null != arguments[t] ? arguments[t] : {};
            t % 2 ? O(Object(r), !0).forEach(function (t) {
                d()(e, t, r[t])
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : O(Object(r)).forEach(function (t) {
                Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t))
            })
        }
        return e
    }

    var P = r(22).Buffer, D = I.a.LOG_LEVELS, k = D.INFO, L = (D.WARN, D.ERROR), x = function () {
        function e() {
            var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            if (s()(this, e), d()(this, "setLogLevel", function (e) {
                if (!Object.values(I.a.LOG_LEVELS).includes(e)) throw new Error(R.errors.INVALID_LOG_LEVEL);
                A.a.setLogLevel(e)
            }), d()(this, "setLogger", function (e) {
                if (!e || "function" != typeof e || 3 !== e.length) throw new Error(R.errors.INVALID_LOGGER);
                A.a.setLogger(e)
            }), d()(this, "isServerConnection", function () {
                return !0
            }), d()(this, "__btoa", function (e) {
                return P.from(e).toString("base64")
            }), d()(this, "userModel", function (t) {
                if ("object" !== i()(t)) throw new Error(R.errors.INVALID_DATA);
                return new m.a(e.getInstance(), t)
            }), d()(this, "liveBroadcastModel", function (t) {
                if ("object" !== i()(t)) throw new Error(R.errors.INVALID_DATA);
                return new g.a(e.getInstance(), t)
            }), d()(this, "conversationModel", function (t) {
                if ("object" !== i()(t)) throw new Error(R.errors.INVALID_DATA);
                return new E.a(e.getInstance(), t)
            }), d()(this, "messageModel", function (t) {
                if ("object" !== i()(t)) throw new Error(R.errors.INVALID_DATA);
                return new _.a(e.getInstance(), t)
            }), d()(this, "error", function (e) {
                return e.response ? e.response.data.error || e.response.data : e
            }), t = N(N({}, I.a.DEFAULT_SERVER_OPTIONS), t), e.instance) return e.instance;
            if (!t.publicKey) throw new Error(R.errors.REQUIRED_PUBLIC_KEY);
            if (!t.privateKey) throw new Error(R.errors.REQUIRED_PRIVATE_KEY);
            if (t.webrtc = t.webrtc || "agora", !T.a.hasService(t.webrtc)) throw new Error(R.errors.INVALID_WEBRTC_SERVICE);
            this.browser = void 0 !== t.browser ? t.browser : "undefined" != typeof window, this.node = !this.browser, e.instance = this, this.connected = !1, this.publicKey = t.publicKey, this.privateKey = t.privateKey, this.options = t, p.a.Client = e, this.User = f.a, this.LiveBroadcast = v.a, this.File = S.a, this.chsocket = new b.a(N(N({}, t), {}, {client: this})), this.webrtc = new T.a(t.webrtc)
        }

        return c()(e, [{
            key: "connect", value: function (e) {
                var t = this, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                    n = arguments.length > 2 ? arguments[2] : void 0;
                return Object(w.a)(n, function (n) {
                    return t.connected ? (A.a.log(L, R.errors.ALREADY_CONNECTED, {}), n(R.errors.ALREADY_CONNECTED)) : e ? void t.User.get(e, function (e, i) {
                        return e ? n(e) : t.__connect(i, r, n)
                    }) : t.__connect({}, r, n)
                })
            }
        }, {
            key: "setCurrentUser", value: function (e, t) {
                var r = this;
                return Object(w.a)(t, function (t) {
                    if (!e) return r.__setCurrentUser({}, t);
                    r.User.get(e, function (e, n) {
                        return e ? t(e) : r.__setCurrentUser(n, t)
                    })
                })
            }
        }, {
            key: "disconnect", value: function (e) {
                var t = this;
                return Object(w.a)(e, function (e) {
                    if (!t.connected) return A.a.log(L, R.errors.ALREADY_DISCONNECTED, {}), e(R.errors.ALREADY_DISCONNECTED);
                    t.__disconnect(e)
                })
            }
        }, {
            key: "createAccessToken", value: function (t, r) {
                var n = this;
                return Object(w.a)(r, function (r) {
                    if (!t || "string" != typeof t) return A.a.log(L, R.errors.INVALID_USER_ID, {}), r(R.errors.INVALID_USER_ID);
                    n.request("".concat(e.basePath, "/create_access_token"), {
                        method: "post",
                        data: {userId: t}
                    }).then(function (e) {
                        return e.data.user = new m.a(n, e.data.user), r(null, e.data)
                    }).catch(function (e) {
                        return A.a.log(L, R.errors.API_ERROR, {err: n.error(e)}), r(n.error(e))
                    })
                })
            }
        }, {
            key: "getCurrentUser", value: function () {
                return this.currentUser
            }
        }, {
            key: "isGuestUser", value: function () {
                return this.currentUser && this.currentUser.role === I.a.ROLES.GUEST
            }
        }, {
            key: "__connect", value: function (e, t, r) {
                var n = this;
                return Object(w.a)(r, function (r) {
                    var i = {userName: e.id, password: ""};
                    n.chsocket.connect(e, i, function (i, o) {
                        if (i) return A.a.log(L, R.errors.WEBSOCKET_CONNECTION_ERROR, {err: i}), r(i);
                        n.currentUser = e, y.a.get("live-broadcast", function (i, o) {
                            if (i) return r(i);
                            t.appId = o.settings.appId, n.options = N(N({}, n.options), t), n.webrtc.init(e, t, function (e, t) {
                                return e ? r(e) : (n.connected = !0, A.a.log(k, "Connected to SDK as a user", {user: n.currentUser}), r(null, n.currentUser))
                            })
                        })
                    })
                })
            }
        }, {
            key: "__setCurrentUser", value: function (e, t) {
                this.currentUser = e, this.chsocket.updateCurrentUser(this.currentUser), A.a.log(k, "Current User changed in SDK", {user: this.currentUser}), t(null, this.currentUser)
            }
        }, {
            key: "__disconnect", value: function (e) {
                var t = this;
                return Object(w.a)(e, function (e) {
                    t.chsocket.__disconnect(), t.webrtc.close(), t.currentUser = null, t.connected = !1, A.a.log(k, "Disconnected with SDK", {}), e()
                })
            }
        }, {
            key: "request", value: function (e, t) {
                t || (t = {});
                var r = e;
                t.absolute || (r = C.a.BASE_URL + e), t.headers = t.headers || {}, t.headers["Public-Key"] = this.publicKey, !t.noAuth && this.privateKey && (t.headers.Authorization = "Basic ".concat(this.__btoa(this.privateKey)));
                var n = this.getCurrentUser();
                return n && n.id && (t.headers["User-Id"] = n.id), h()(r, t)
            }
        }], [{
            key: "getInstance", value: function () {
                return e.instance
            }
        }]), e
    }();
    d()(x, "basePath", I.a.BASEPATH_USERS)
}, function (e, t, r) {
    "use strict";
    r.d(t, "a", function () {
        return M
    });
    var n = r(62), i = r.n(n), o = r(6), s = r.n(o), a = r(8), c = r.n(a), u = r(19), d = r.n(u), l = r(10), h = r.n(l),
        p = r(11), f = r.n(p), m = r(7), _ = r.n(m), v = r(3), g = r.n(v), E = r(20), y = r(13), S = r(1), b = r(2),
        T = r(4), R = r(280), I = b.a.LOG_LEVELS, w = (I.INFO, I.WARN, I.ERROR), C = function () {
            function e(t, r) {
                s()(this, e), g()(this, "__generateClientId", function (e) {
                    return "client-".concat(e, "-").concat(Math.random().toString(36).substr(2, 19))
                }), this.chsocket = t, this.options = r, this.__reconnected = !1, this.refreshTokenTime = 55, this.refreshTimer = null
            }

            return c()(e, [{
                key: "connect", value: function (e, t, r) {
                    var n = this;
                    return Object(T.a)(r, function (r) {
                        return E.config.region = y.a.AWS_REGION, E.config.credentials = new E.CognitoIdentityCredentials({IdentityPoolId: y.a.AWS_COGNITO_IDENTITY_POOL_ID}), E.config.credentials.get(function (i, o) {
                            if (!i) return n.refresh(e, r), n._connectToAWSIOT(e, E.config.credentials, t, r);
                            S.a.log(w, "error retrieving identity", {err: i}), r(i)
                        })
                    })
                }
            }, {
                key: "refresh", value: function (e, t) {
                    var r = this;
                    this.refreshTimer = setInterval(function () {
                        return E.config.region = y.a.AWS_REGION, E.config.credentials = new E.CognitoIdentityCredentials({IdentityPoolId: y.a.AWS_COGNITO_IDENTITY_POOL_ID}), E.config.credentials.get(function (e, n) {
                            e ? (S.a.log(w, "error retrieving identity", {err: e}), t(e)) : r.__client && r.__client.updateWebSocketCredentials(E.config.credentials.accessKeyId, E.config.credentials.secretAccessKey, E.config.credentials.sessionToken)
                        })
                    }, 60 * this.refreshTokenTime * 1e3)
                }
            }, {
                key: "_connectToAWSIOT", value: function (e, t, r, n) {
                    var i = this;
                    return Object(T.a)(n, function (n) {
                        var o = {
                            clientId: i.__generateClientId(e),
                            protocol: "wss",
                            host: y.a.AWS_IOT_HOST,
                            accessKeyId: t.accessKeyId,
                            secretKey: t.secretAccessKey,
                            sessionToken: t.sessionToken,
                            region: y.a.AWS_REGION,
                            will: null,
                            keepalive: 300
                        };
                        o = Object.assign(o, r), i.__client = R.device(o), i.__client.on("connect", function (e) {
                            i.chsocket.__onConnected(i.__reconnected), i.__reconnected || n(null, !0)
                        }), i.__client.on("offline", function (e) {
                        }), i.__client.on("close", function (e) {
                            i.chsocket.__connected && i.chsocket.__onConnectionLost(e)
                        }), i.__client.on("reconnect", function () {
                            i.__reconnected = !0
                        }), i.__client.on("error", function (e) {
                            i.__reconnected || n(e)
                        }), i.__client.on("message", function (e, t, r) {
                            var n = JSON.parse(t);
                            i.chsocket.__trigger(e, n)
                        })
                    })
                }
            }, {
                key: "__disconnect", value: function () {
                    this.__client.end(), clearInterval(this.refreshTimer)
                }
            }, {
                key: "__subscribe", value: function (e) {
                    this.__client.subscribe(e)
                }
            }, {
                key: "__unsubscribe", value: function (e) {
                    this.__client.unsubscribe(e)
                }
            }, {
                key: "__publish", value: function (e, t) {
                    this.__client.publish(e, t)
                }
            }]), e
        }(), A = r(0), O = r(24), N = {}, P = r(16);

    function D(e) {
        var t = function () {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function () {
                })), !0
            } catch (e) {
                return !1
            }
        }();
        return function () {
            var r, n = _()(e);
            if (t) {
                var i = _()(this).constructor;
                r = Reflect.construct(n, arguments, i)
            } else r = n.apply(this, arguments);
            return f()(this, r)
        }
    }

    var k = b.a.LOG_LEVELS, L = k.INFO, x = k.WARN, M = (k.ERROR, function (e) {
        h()(r, e);
        var t = D(r);

        function r() {
            var e, n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            return s()(this, r), e = t.call(this), g()(d()(e), "__socketClass", C), g()(d()(e), "__socket", void 0), g()(d()(e), "__events", {
                connected: {topic: "connected", allowedRole: b.a.ROLES.ANONYMOUS},
                disconnected: {topic: "disconnected", allowedRole: b.a.ROLES.ANONYMOUS},
                reconnected: {topic: "reconnected", allowedRole: b.a.ROLES.ANONYMOUS},
                status_updated: {
                    topic: "live_broadcasts/[live_broadcast_id]/status_updated",
                    vars: ["live_broadcast_id"],
                    allowedRole: b.a.ROLES.ANONYMOUS
                },
                start_watching: {
                    topic: "live_broadcasts/[live_broadcast_id]/start_watching",
                    vars: ["live_broadcast_id"],
                    allowedRole: b.a.ROLES.ANONYMOUS
                },
                stop_watching: {
                    topic: "live_broadcasts/[live_broadcast_id]/stop_watching",
                    vars: ["live_broadcast_id"],
                    allowedRole: b.a.ROLES.ANONYMOUS
                },
                "reaction.added": {
                    topic: "live_broadcasts/[live_broadcast_id]/reaction_added",
                    vars: ["live_broadcast_id"],
                    allowedRole: b.a.ROLES.ANONYMOUS
                },
                products_featured: {
                    topic: "live_broadcasts/[live_broadcast_id]/products/featured",
                    vars: ["live_broadcast_id"],
                    allowedRole: b.a.ROLES.ANONYMOUS
                },
                products_unfeatured: {
                    topic: "live_broadcasts/[live_broadcast_id]/products/unfeatured",
                    vars: ["live_broadcast_id"],
                    allowedRole: b.a.ROLES.ANONYMOUS
                },
                products_updated: {
                    topic: "live_broadcasts/[live_broadcast_id]/products_updated",
                    vars: ["live_broadcast_id"],
                    allowedRole: b.a.ROLES.ANONYMOUS
                },
                "user.conversation_ban_updated": {
                    topic: "users/[login_user]/conversation/ban_updated",
                    allowedRole: b.a.ROLES.GUEST
                },
                "watcher.message.created": {
                    vars: ["conversation_id"],
                    topic: "conversations/[conversation_id]/message_created",
                    allowedRole: b.a.ROLES.ANONYMOUS
                },
                "watcher.message.deleted_for_everyone": {
                    vars: ["conversation_id"],
                    topic: "conversations/[conversation_id]/messages/deleted_for_everyone",
                    allowedRole: b.a.ROLES.ANONYMOUS
                },
                "message.pinned": {
                    vars: ["conversation_id"],
                    topic: "conversations/[conversation_id]/message/pinned",
                    allowedRole: b.a.ROLES.ANONYMOUS
                },
                "message.unpinned": {
                    vars: ["conversation_id"],
                    topic: "conversations/[conversation_id]/message/unpinned",
                    allowedRole: b.a.ROLES.ANONYMOUS
                },
                ask_to_join: {topic: "users/[login_user]/live_broadcast/ask_to_join", allowedRole: b.a.ROLES.HOST},
                ask_to_join_action: {
                    topic: "users/[login_user]/live_broadcast/ask_to_join_action",
                    allowedRole: b.a.ROLES.HOST
                }
            }), g()(d()(e), "allowForceResubscribe", !1), g()(d()(e), "__baseEvents", ["connected", "disconnected", "reconnected"]), g()(d()(e), "__subscribedTopics", {}), g()(d()(e), "__preConnectEvents", []), g()(d()(e), "__addDefaultProperties", function (e) {
                return Object.assign(e, {version: y.a.VERSION})
            }), g()(d()(e), "__capitalize", function (e) {
                return e.charAt(0).toUpperCase() + e.slice(1)
            }), e.__socket = new e.__socketClass(d()(e), n), e.__client = n.client, e.__connected = !1, e.__publicKey = n.publicKey, e.options = n, e
        }

        return c()(r, [{
            key: "connect", value: function (e, t, r) {
                var n = this;
                return Object(T.a)(r, function (r) {
                    n.__user = e, n.__userId = e.id, n.__socket.connect(e.id, t, r)
                })
            }
        }, {
            key: "__onConnected", value: function (e) {
                this.__connected = !0, e ? (this.__trigger("reconnected", null), S.a.log(L, "Websocket client reconnected", {})) : (this.__trigger("connected", null), S.a.log(L, "Websocket client connected", {})), this.allowForceResubscribe && e && this.__autoSubscribed ? this.__resubscribe() : !this.__autoSubscribed && this.options.autoSubscribeSocketEvents && this.__subscribeAll(), this.__preConnectSubscribe()
            }
        }, {
            key: "__onConnectionLost", value: function (e) {
                this.__connected = !1, this.__trigger("disconnected", e), S.a.log(L, "Websocket client disconnected", {})
            }
        }, {
            key: "__disconnect", value: function () {
                this.__socket.__disconnect(), this.__resetProperties()
            }
        }, {
            key: "updateCurrentUser", value: function (e) {
                var t = this, r = [];
                Object.keys(this.__subscribedTopics).forEach(function (e) {
                    var n = t.__subscribedTopics[e], i = n.event, o = n.cb;
                    t.__isUserBasedEvent(i) && (t.__unsubscribe(i), r.push({event: i, callbacks: o}))
                }), this.__user = e, this.__userId = e.id, r.forEach(function (e) {
                    e.callbacks.forEach(function (r) {
                        t.__subscribe(e.event, {}, r)
                    })
                })
            }
        }, {
            key: "__validate", value: function (e, t, r) {
                if (!this.__isSupported(e)) throw new Error(O.a.sprintf(A.errors.INVALID_EVENT, e));
                if (!this.__hasDependencyVars(e)) return !0;
                this.__events[e].vars.forEach(function (r) {
                    if (!t[r]) throw new Error(O.a.sprintf(A.errors.REQUIRED_SOCKET_EVENT_PARAM, r, e))
                });
                var n = "__validate".concat(this.__capitalize(e));
                if ("function" == typeof this[n]) {
                    var i = this[n](e, t);
                    if (i.error) throw new Error(i.message)
                }
            }
        }, {
            key: "on", value: function () {
                var e = Array.prototype.slice.call(arguments, 0, arguments.length), t = e.shift(), r = e.pop(), n = {};
                e.length && this.__hasDependencyVars(t) && this.__events[t].vars.forEach(function (t) {
                    n[t] = e.shift()
                }), this.__validate(t, n, r), this.__isConnected() || this.__isBaseEvent(t) ? this.__subscribe(t, n, r) : this.__preConnectAdd(t, n, r)
            }
        }, {
            key: "off", value: function () {
                var e = Array.prototype.slice.call(arguments, 0, arguments.length), t = e.shift(), r = {};
                e.length && this.__hasDependencyVars(t) && this.__events[t].vars.forEach(function (t) {
                    r[t] = e.shift()
                }), this.__validate(t, r), !this.__isConnected() && this.__isBaseEvent(t) || this.__unsubscribe(t, r)
            }
        }, {
            key: "addEvent", value: function (e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                if (e && this.__isSupported(e)) throw new Error(A.errors.EVENT_ALREADY_ADDED);
                if (!e || "string" != typeof e) throw new Error(A.errors.INVALID_EVENT_NAME);
                var r = t.topic, n = t.vars, i = t.allowedRole;
                if (!r || "string" != typeof r) throw new Error(A.errors.INVALID_EVENT_TOPIC);
                if (!Array.isArray(n)) throw new Error(A.errors.INVALID_EVENT_VARS);
                if (!i || "string" != typeof i) throw new Error(A.errors.INVALID_EVENT_ROLE);
                this.__events[e] = {topic: r, vars: n, allowedRole: i}
            }
        }, {
            key: "__resetProperties", value: function () {
                this.__autoSubscribed = !1, this.__subscribedTopics = {}, this.__preConnectEvents = []
            }
        }, {
            key: "__preConnectAdd", value: function (e, t, r) {
                this.__preConnectEvents.push({event: e, params: t, cb: r})
            }
        }, {
            key: "__isBaseEvent", value: function (e) {
                return this.__baseEvents.includes(e)
            }
        }, {
            key: "__isUserBasedEvent", value: function (e) {
                return this.__events[e].topic.includes("[login_user]")
            }
        }, {
            key: "__isConnected", value: function () {
                return this.__connected
            }
        }, {
            key: "__preConnectSubscribe", value: function () {
                for (var e; e = this.__preConnectEvents.shift();) this.__subscribe(e.event, e.params, e.cb)
            }
        }, {
            key: "__getEventTopic", value: function (e) {
                var t = this, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                    n = this.__events[e].topic, i = this.__events[e].vars;
                return Array.isArray(n) ? n.map(function (e) {
                    return t.__replaceTopicVar(e, i, r)
                }) : this.__replaceTopicVar(n, i, r)
            }
        }, {
            key: "__isSubscribed", value: function (e) {
                return Object.prototype.hasOwnProperty.call(this.__subscribedTopics, e)
            }
        }, {
            key: "__isSupported", value: function (e) {
                return Object.prototype.hasOwnProperty.call(this.__events, e)
            }
        }, {
            key: "__hasDependencyVars", value: function (e) {
                return this.__events[e] && Object.prototype.hasOwnProperty.call(this.__events[e], "vars") && this.__events[e].vars.length
            }
        }, {
            key: "__subscribe", value: function (e, t, r) {
                var n = this, i = this.__getRole();
                if (!i || this.isAllowed(e)) {
                    var o = this.__getEventTopic(e, t);
                    (Array.isArray(o) ? o : [o]).forEach(function (t) {
                        n.__isSubscribed(t) || (n.__isBaseEvent(e) || n.__subscribeSocket(t), n.__subscribedTopics[t] = {
                            event: e,
                            cb: []
                        }), r && "function" == typeof r && n.__subscribedTopics[t].cb.push(r)
                    })
                } else S.a.log(x, O.a.sprintf(A.errors.EVENT_NOT_ALLOWED, e, i), {})
            }
        }, {
            key: "__unsubscribe", value: function (e, t) {
                var r = this, n = this.__getRole();
                if (!n || this.isAllowed(e)) {
                    var i = this.__getEventTopic(e, t);
                    (Array.isArray(i) ? i : [i]).forEach(function (t) {
                        r.__isSubscribed(t) && (r.__isBaseEvent(e) || r.__unsubscribeSocket(t), delete r.__subscribedTopics[t])
                    })
                } else S.a.log(x, O.a.sprintf(A.errors.EVENT_NOT_ALLOWED, e, n), {})
            }
        }, {
            key: "__subscribeSocket", value: function (e) {
                this.__socket.__subscribe("".concat(this.__publicKey, "/").concat(e))
            }
        }, {
            key: "__unsubscribeSocket", value: function (e) {
                this.__socket.__unsubscribe("".concat(this.__publicKey, "/").concat(e))
            }
        }, {
            key: "__publishSocket", value: function (e, t) {
                t = this.__addDefaultProperties(t), this.__userId && this.__hasUserRole() && e.includes("[login_user]") && (e = e.replace("[login_user]", this.__userId)), t.publicKey = this.__publicKey, this.__socket.__publish("".concat(this.__publicKey, "/").concat(e), JSON.stringify(t))
            }
        }, {
            key: "__subscribeAll", value: function () {
                var e = this, t = this.__getRole();
                Object.keys(this.__events).forEach(function (r) {
                    !e.__hasDependencyVars(r) && t && e.isAllowed(r) && e.__subscribe(r, null)
                }), this.__autoSubscribed = !0
            }
        }, {
            key: "__resubscribe", value: function () {
                var e = this;
                Object.keys(this.__subscribedTopics).forEach(function (t) {
                    var r = e.__subscribedTopics[t].event;
                    e.__isBaseEvent(r) || e.__subscribeSocket(t)
                })
            }
        }, {
            key: "__trigger", value: function (e, t) {
                if (e = e.replace("".concat(this.__publicKey, "/"), ""), this.__isSubscribed(e)) {
                    var r = this.__processPayload(e, t), n = this.__subscribedTopics[e].event;
                    S.a.log(L, "WebSocket event triggered - ".concat(n), {payload: t}), this.__subscribedTopics[e].cb.forEach(function (e) {
                        e.apply(void 0, i()(r))
                    })
                }
            }
        }, {
            key: "__processPayload", value: function (e, t) {
                var r = this.__subscribedTopics[e].event;
                return "function" == typeof N[r] ? N[r](this.__client, e, t) : [t]
            }
        }, {
            key: "__replaceTopicVar", value: function (e, t, r) {
                return this.__userId && (e = e.replace("[login_user]", this.__userId)), t && t.length ? (t.forEach(function (t) {
                    e = e.replace("[".concat(t, "]"), r[t])
                }), e) : e
            }
        }, {
            key: "getDependencyEvents", value: function (e) {
                var t = this, r = [];
                return Object.keys(this.__events).forEach(function (n) {
                    var i = t.__events[n].vars;
                    i && i.includes(e) && r.push(n)
                }), r
            }
        }, {
            key: "__hasUserRole", value: function () {
                return this.__user && this.__user.role === b.a.ROLES.USER
            }
        }, {
            key: "__getRole", value: function () {
                return this.__user && this.__user.role
            }
        }, {
            key: "isAllowed", value: function (e) {
                var t = this.__events[e].allowedRole, r = this.__getRole();
                return Object.prototype.hasOwnProperty.call(b.a.ROLE_PRECEDENCE, r) && Object.prototype.hasOwnProperty.call(b.a.ROLE_PRECEDENCE, t) && b.a.ROLE_PRECEDENCE[r] >= b.a.ROLE_PRECEDENCE[t]
            }
        }]), r
    }(P.a))
}, function (e, t, r) {
    "use strict";
    r.d(t, "a", function () {
        return H
    });
    var n = {};
    r.r(n), r.d(n, "getCookie", function () {
        return M
    }), r.d(n, "setCookie", function () {
        return U
    }), r.d(n, "deleteCookie", function () {
        return j
    });
    var i = r(12), o = r.n(i), s = r(62), a = r.n(s), c = r(18), u = r.n(c), d = r(6), l = r.n(d), h = r(8), p = r.n(h),
        f = r(3), m = r.n(f), _ = r(5), v = r.n(_), g = r(63), E = r.n(g), y = r(16), S = r(44), b = r(17), T = r(65),
        R = r(45), I = r(46), w = r(47), C = r(35), A = r(72), O = r(74), N = r(48), P = r(0), D = r(2), k = r(4),
        L = r(13), x = r(1), M = function (e) {
            var t, r = "".concat(e, "=");
            return decodeURIComponent(document.cookie).split("; ").forEach(function (e) {
                0 === e.indexOf(r) && (t = e.substring(r.length))
            }), t
        }, U = function (e, t) {
            var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 7, n = new Date;
            n.setTime(n.getTime() + 24 * r * 60 * 60 * 1e3);
            var i = "expires=".concat(n.toUTCString());
            document.cookie = "".concat(e, "=").concat(t, "; ").concat(i, "; path=/")
        }, j = function (e) {
            document.cookie = "".concat(e, "=;").concat("Thu, 01 Jan 1970 00:00:00 UTC", "; path=/")
        };

    function V(e, t) {
        var r = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
            var n = Object.getOwnPropertySymbols(e);
            t && (n = n.filter(function (t) {
                return Object.getOwnPropertyDescriptor(e, t).enumerable
            })), r.push.apply(r, n)
        }
        return r
    }

    function F(e) {
        for (var t = 1; t < arguments.length; t++) {
            var r = null != arguments[t] ? arguments[t] : {};
            t % 2 ? V(Object(r), !0).forEach(function (t) {
                m()(e, t, r[t])
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : V(Object(r)).forEach(function (t) {
                Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t))
            })
        }
        return e
    }

    var B = r(22).Buffer, W = D.a.LOG_LEVELS, G = W.INFO, q = (W.WARN, W.ERROR), H = function () {
        function e() {
            var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            if (l()(this, e), m()(this, "__btoa", function (e) {
                return B.from(e).toString("base64")
            }), m()(this, "__decodeBase64", function (e) {
                return B.from(e, "base64").toString()
            }), m()(this, "setLogLevel", function (e) {
                if (!Object.values(D.a.LOG_LEVELS).includes(e)) throw new Error(P.errors.INVALID_LOG_LEVEL);
                x.a.setLogLevel(e)
            }), m()(this, "setLogger", function (e) {
                if (!e || "function" != typeof e || 3 !== e.length) throw new Error(P.errors.INVALID_LOGGER);
                x.a.setLogger(e)
            }), m()(this, "isServerConnection", function () {
                return !1
            }), m()(this, "userModel", function (t) {
                if ("object" !== u()(t)) throw new Error(P.errors.INVALID_DATA);
                return new b.a(e.getInstance(), t)
            }), m()(this, "liveBroadcastModel", function (t) {
                if ("object" !== u()(t)) throw new Error(P.errors.INVALID_DATA);
                return new I.a(e.getInstance(), t)
            }), m()(this, "conversationModel", function (t) {
                if ("object" !== u()(t)) throw new Error(P.errors.INVALID_DATA);
                return new w.a(e.getInstance(), t)
            }), m()(this, "messageModel", function (t) {
                if ("object" !== u()(t)) throw new Error(P.errors.INVALID_DATA);
                return new T.a(e.getInstance(), t)
            }), m()(this, "error", function (e) {
                return e.response ? e.response.data.error || e.response.data : e
            }), m()(this, "__isValidEmail", function (e) {
                return /\S+@\S+\.\S+/.test(e)
            }), t = F(F({}, D.a.DEFAULT_CLIENT_OPTIONS), t), e.instance) return e.instance;
            if (!t.publicKey) throw new Error(P.errors.REQUIRED_PUBLIC_KEY);
            if (t.webrtc = t.webrtc || "agora", !N.a.hasService(t.webrtc)) throw new Error(P.errors.INVALID_WEBRTC_SERVICE);
            this.browser = void 0 !== t.browser ? t.browser : "undefined" != typeof window, this.node = !this.browser, e.instance = this, this.connected = !1, this.websocketConnected = !1, this.waitForWebsocketConnection = null, this.publicKey = t.publicKey, this.options = t;
            var r = n;
            this.options.cookieManager && (r = this.options.cookieManager), r.setCookie("channelize_livebroadcast_public_key", t.publicKey, 365), y.a.Client = e, this.User = S.a, this.LiveBroadcast = R.a, this.File = A.a, this.chsocket = new O.a(F(F({}, t), {}, {client: this})), this.webrtc = new N.a(t.webrtc)
        }

        return p()(e, [{
            key: "connectAsAnonymous", value: function () {
                var e = this, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                    r = arguments.length > 1 ? arguments[1] : void 0;
                return Object(k.a)(r, function (r) {
                    if (e.connected) return x.a.log(q, P.errors.ALREADY_CONNECTED, {}), r(P.errors.ALREADY_CONNECTED);
                    if (e.options = F(F({}, e.options), t), e.browser && "localStorage" in window) {
                        var n = e.__getLocalAnonymousUser();
                        if (n) return e.__connectAsAnonymous(n, t, r)
                    }
                    var i = Math.random().toString(10).substr(2, 10), o = {
                        id: "".concat(D.a.ANONYMOUS_ID_PREFIX, "-").concat(i),
                        displayName: D.a.ANONYMOUS_USER_DISPLAY_NAME,
                        role: D.a.ROLES.ANONYMOUS
                    };
                    e.browser && "localStorage" in window && e.__setLocalAnonymousUser(o), e.__connectAsAnonymous(o, t, r)
                })
            }
        }, {
            key: "connect", value: function (e, t) {
                var r = this, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
                    i = arguments.length > 3 ? arguments[3] : void 0;
                return Object(k.a)(i, function (i) {
                    if (r.connected) return x.a.log(q, P.errors.ALREADY_CONNECTED, {}), i(P.errors.ALREADY_CONNECTED);
                    if (!e || "string" != typeof e) return x.a.log(q, P.errors.INVALID_USER_ID, {}), i(P.errors.INVALID_USER_ID);
                    if (!t || "string" != typeof t) return x.a.log(q, P.errors.INVALID_ACCESS_TOKEN, {}), i(P.errors.INVALID_ACCESS_TOKEN);
                    if (r.options = F(F({}, r.options), n), r.browser && "localStorage" in window) {
                        var o = r.__getLocalUser(e, t);
                        if (o) return r.__connect(o, t, n, i)
                    }
                    r.__verifyAccessToken(e, t, function (e, o) {
                        if (e) return i(e);
                        o.user.accessToken = t, r.browser && "localStorage" in window && r.__setLocalUser(o.user, t), r.__connect(o.user, t, n, i)
                    })
                })
            }
        }, {
            key: "connectAsGuest", value: function (e) {
                var t = this, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                    n = arguments.length > 2 ? arguments[2] : void 0;
                return Object(k.a)(n, function (n) {
                    if (t.connected) return x.a.log(q, P.errors.ALREADY_CONNECTED, {}), n(P.errors.ALREADY_CONNECTED);
                    var i = {};
                    if ("string" == typeof e) i.displayName = e; else {
                        if ("object" !== u()(e)) return x.a.log(q, P.errors.INVALID_GUEST, {}), n(P.errors.INVALID_GUEST);
                        e.displayName && (i.displayName = e.displayName), e.profileImageUrl && (i.profileImageUrl = e.profileImageUrl)
                    }
                    if (t.options = F(F({}, t.options), r), t.browser && "localStorage" in window) {
                        var o = t.__getLocalGuestUser(i.displayName);
                        if (o) return t.__connect(o, o.accessToken, r, n)
                    }
                    t.User.createGuest(i, function (e, i) {
                        if (e) return n(e);
                        t.browser && "localStorage" in window && t.__setLocalGuestUser(i), t.__connect(i, i.accessToken, r, n)
                    })
                })
            }
        }, {
            key: "switchToGuest", value: function (e, t) {
                var r = this;
                return Object(k.a)(t, function (t) {
                    if (!r.connected) return x.a.log(q, P.errors.NOT_CONNECTED, {}), t(P.errors.NOT_CONNECTED);
                    if (!r.isAnonymousUser()) return x.a.log(q, P.errors.NOT_ANONYMOUS_USER, {}), t(P.errors.NOT_ANONYMOUS_USER);
                    var n = {anonymousUserId: r.getCurrentUser().id};
                    if ("string" == typeof e) n.displayName = e; else {
                        if ("object" !== u()(e)) return x.a.log(q, P.errors.INVALID_GUEST, {}), t(P.errors.INVALID_GUEST);
                        e.displayName && (n.displayName = e.displayName), e.profileImageUrl && (n.profileImageUrl = e.profileImageUrl)
                    }
                    if (r.browser && "localStorage" in window) {
                        var i = r.__getLocalGuestUser(n.displayName);
                        if (i) return r.__switchToGuest(i, t)
                    }
                    r.User.createGuest(n, function (e, n) {
                        if (e) return t(e);
                        r.browser && "localStorage" in window && r.__setLocalGuestUser(n), r.__switchToGuest(n, t)
                    })
                })
            }
        }, {
            key: "getModule", value: function (e, t) {
                return Object(k.a)(t, function (t) {
                    return C.a.get(e, t)
                })
            }
        }, {
            key: "__getLocalUser", value: function (e, t) {
                var r = D.a.LOCALSTORAGE_PREFIX + this.publicKey, n = window.localStorage;
                this.options.localStorage && (n = this.options.localStorage);
                var i = n.getItem(r);
                if (!i) return !1;
                try {
                    i = JSON.parse(i)
                } catch (e) {
                    return !1
                }
                return !(!i.user || !i.accessToken) && (this.__btoa(t) === i.accessToken && e === i.user.id && new b.a(this, i.user))
            }
        }, {
            key: "getCurrentUser", value: function () {
                return this.currentUser
            }
        }, {
            key: "updateActivityTrackingCookies", value: function (e) {
                var t = D.a.ACTIVITY_TRACKING_COOKIES_EXPIRY_IN_DAYS || 30, r = n;
                this.options.cookieManager && (r = this.options.cookieManager);
                var i = r.getCookie("channelize_livebroadcast_id");
                if (r.setCookie("channelize_livebroadcast_id", e.id, t), r.setCookie("channelize_livebroadcast_last_interaction_timestamp", Date.now(), t), "live" === e.status && i && i === e.id) {
                    var o = r.getCookie("channelize_livebroadcast_products"), s = new Set;
                    o && (s = new Set(this.__decodeBase64(o).split(","))), e.products.forEach(function (e) {
                        s.add(e.sku || e.id)
                    }), r.setCookie("channelize_livebroadcast_products", this.__btoa(a()(s).join(",")), t)
                } else {
                    var c = this.__btoa(e.products.map(function (e) {
                        return e.sku || e.id
                    }).join(","));
                    r.setCookie("channelize_livebroadcast_products", c, t)
                }
                if ("live" === e.status) {
                    var u = D.a.ACTIVITY_TRACKING_SHOW_IN_LIVE_COOKIE_EXPIRY_IN_HOURS;
                    r.setCookie("channelize_livebroadcast_is_show_live", !0, u / 24)
                } else i && i !== e.id && r.deleteCookie("channelize_livebroadcast_is_show_live")
            }
        }, {
            key: "__setLocalUser", value: function (e, t) {
                var r = D.a.LOCALSTORAGE_PREFIX + this.publicKey, n = {
                    user: e.toJSON(),
                    accessToken: this.__btoa(t),
                    expires: Date.now() + D.a.LOCALSTORAGE_EXPIRY_TIME
                }, i = window.localStorage;
                this.options.localStorage && (i = this.options.localStorage), i.setItem(r, JSON.stringify(n))
            }
        }, {
            key: "__removeLocalUser", value: function () {
                var e = D.a.LOCALSTORAGE_PREFIX + this.publicKey, t = window.localStorage;
                this.options.localStorage && (t = this.options.localStorage), t.removeItem(e)
            }
        }, {
            key: "__connect", value: function (e, t, r, n) {
                var i = this;
                return Object(k.a)(n, function (n) {
                    if (r.disableWebSocket) return i.accessToken = i.__btoa(t), i.currentUser = e, i.connected = !0, n(null, i.currentUser);
                    i.accessToken = i.__btoa(t), i.currentUser = e, C.a.get("live-broadcast", function () {
                        var e = o()(v.a.mark(function e(t, o) {
                            return v.a.wrap(function (e) {
                                for (; ;) switch (e.prev = e.next) {
                                    case 0:
                                        if (!t) {
                                            e.next = 2;
                                            break
                                        }
                                        return e.abrupt("return", n(t));
                                    case 2:
                                        if (r.appId = o.settings.appId, i.options = F(F({}, i.options), r), r.websocketConnectionType && "sync" !== r.websocketConnectionType) {
                                            e.next = 9;
                                            break
                                        }
                                        return e.next = 7, i.connectToWebsocket("user", r);
                                    case 7:
                                        e.next = 10;
                                        break;
                                    case 9:
                                        i.connectToWebsocket("user", r);
                                    case 10:
                                        return i.connected = !0, x.a.log(G, "Connected to SDK as a user", {user: i.currentUser}), e.abrupt("return", n(null, i.currentUser));
                                    case 13:
                                    case"end":
                                        return e.stop()
                                }
                            }, e)
                        }));
                        return function (t, r) {
                            return e.apply(this, arguments)
                        }
                    }())
                })
            }
        }, {
            key: "__connectAsAnonymous", value: function (e, t, r) {
                var n = this;
                return Object(k.a)(r, function (r) {
                    if (t.disableWebSocket) return n.currentUser = e, n.connected = !0, r(null, n.currentUser);
                    n.currentUser = e, C.a.get("live-broadcast", function () {
                        var e = o()(v.a.mark(function e(i, o) {
                            return v.a.wrap(function (e) {
                                for (; ;) switch (e.prev = e.next) {
                                    case 0:
                                        if (!i) {
                                            e.next = 2;
                                            break
                                        }
                                        return e.abrupt("return", r(i));
                                    case 2:
                                        if (t.appId = o.settings.appId, n.options = F(F({}, n.options), t), t.websocketConnectionType && "sync" !== t.websocketConnectionType) {
                                            e.next = 9;
                                            break
                                        }
                                        return e.next = 7, n.connectToWebsocket("anonymous", t);
                                    case 7:
                                        e.next = 10;
                                        break;
                                    case 9:
                                        n.connectToWebsocket("anonymous", t);
                                    case 10:
                                        return n.connected = !0, e.abrupt("return", r(null, n.currentUser));
                                    case 12:
                                    case"end":
                                        return e.stop()
                                }
                            }, e)
                        }));
                        return function (t, r) {
                            return e.apply(this, arguments)
                        }
                    }())
                })
            }
        }, {
            key: "__switchToGuest", value: function (e, t) {
                return this.accessToken = this.__btoa(e.accessToken), this.currentUser = e, this.chsocket.updateCurrentUser(this.currentUser), this.webrtc.updateCurrentUser(this.currentUser), x.a.log(G, "Switched from anonymous user to guest user", {user: this.currentUser}), t(null, this.currentUser)
            }
        }, {
            key: "connectToWebsocket", value: function () {
                var e = this, t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "user",
                    r = arguments.length > 1 ? arguments[1] : void 0;
                return this.websocketConnected ? Promise.resolve() : this.waitForWebsocketConnection ? this.waitForWebsocketConnection.then(function () {
                    return !0
                }) : (this.waitForWebsocketConnection = new Promise(function (n, i) {
                    var o = null;
                    "user" === t && (o = {
                        userName: e.currentUser.id,
                        password: ""
                    }), e.chsocket.connect(e.currentUser, o, function (o, s) {
                        if (e.waitForWebsocketConnection = !1, o) return x.a.log(q, P.errors.WEBSOCKET_CONNECTION_ERROR, {err: o}), i(o);
                        e.webrtc.init(null, r, function (r, o) {
                            return r ? (x.a.log(q, P.errors.WEBRTC_CONNECTION_ERROR, {err: r}), i(r)) : (e.websocketConnected = !0, x.a.log(G, "Connected to SDK as a ".concat(t), {user: e.currentUser}), n(null))
                        })
                    })
                }), this.waitForWebsocketConnection)
            }
        }, {
            key: "disconnect", value: function (e, t) {
                var r = this;
                return Object(k.a)(t, function (t) {
                    return r.connected ? e && "string" != typeof e ? (x.a.log(q, P.errors.INVALID_DEVICE_ID, {}), t(P.errors.INVALID_DEVICE_ID)) : r.isAnonymousUser() || r.isGuestUser() ? r.__disconnect(t) : void r.__logout(e, function (e, n) {
                        return e ? t(e) : r.__disconnect(t)
                    }) : (x.a.log(q, P.errors.ALREADY_DISCONNECTED, {}), t(P.errors.ALREADY_DISCONNECTED))
                })
            }
        }, {
            key: "__disconnect", value: function (e) {
                var t = this;
                return Object(k.a)(e, function (e) {
                    t.options.disableWebSocket || (t.chsocket.__disconnect(), t.webrtc.close()), t.currentUser = null, t.accessToken = null, t.connected = !1, t.browser && "localStorage" in window && t.__removeLocalUser(), x.a.log(G, "Disconnected with SDK", {}), e()
                })
            }
        }, {
            key: "loginWithEmailPassword", value: function (t, r, n) {
                var i = this;
                return Object(k.a)(n, function (n) {
                    return t && i.__isValidEmail(t) ? r && "string" == typeof r ? void i.request("".concat(e.basePath, "/login"), {
                        method: "post",
                        data: {authenticationType: 1, email: t, password: r}
                    }).then(function (e) {
                        return e.data.user = new b.a(i, e.data.user), n(null, e.data)
                    }).catch(function (e) {
                        return x.a.log(q, P.errors.API_ERROR, {err: i.error(e)}), n(i.error(e))
                    }) : n(P.errors.INVALID_PASSWORD) : n(P.errors.INVALID_EMAIL)
                })
            }
        }, {
            key: "loginWithUserId", value: function (t, r, n) {
                var i = this;
                return Object(k.a)(n, function (n) {
                    return t && "string" == typeof t ? r && "string" == typeof r ? void i.request("".concat(e.basePath, "/login"), {
                        method: "post",
                        data: {authenticationType: 0, userId: t, pmClientServerToken: r}
                    }).then(function (e) {
                        return e.data.user = new b.a(i, e.data.user), n(null, e.data)
                    }).catch(function (e) {
                        return x.a.log(q, P.errors.API_ERROR, {err: i.error(e)}), n(i.error(e))
                    }) : n(P.errors.INVALID_CLIENT_SERVER_TOKEN) : n(P.errors.INVALID_USER_ID)
                })
            }
        }, {
            key: "isAnonymousUser", value: function () {
                return this.currentUser && this.currentUser.role === D.a.ROLES.ANONYMOUS
            }
        }, {
            key: "isGuestUser", value: function () {
                return this.currentUser && this.currentUser.role === D.a.ROLES.GUEST
            }
        }, {
            key: "__getLocalAnonymousUser", value: function () {
                var e = D.a.LOCALSTORAGE_PREFIX + this.publicKey, t = window.localStorage;
                this.options.localStorage && (t = this.options.localStorage);
                var r = t.getItem(e);
                if (!r) return !1;
                try {
                    r = JSON.parse(r)
                } catch (e) {
                    return !1
                }
                return !(!r.user || r.user.role !== D.a.ROLES.ANONYMOUS) && r.user
            }
        }, {
            key: "__setLocalAnonymousUser", value: function (e) {
                var t = D.a.LOCALSTORAGE_PREFIX + this.publicKey,
                    r = {user: e, expires: Date.now() + D.a.LOCALSTORAGE_EXPIRY_TIME}, n = window.localStorage;
                this.options.localStorage && (n = this.options.localStorage), n.setItem(t, JSON.stringify(r))
            }
        }, {
            key: "__getLocalGuestUser", value: function (e) {
                var t = D.a.LOCALSTORAGE_PREFIX + this.publicKey, r = window.localStorage;
                this.options.localStorage && (r = this.options.localStorage);
                var n = r.getItem(t);
                if (!n) return !1;
                try {
                    n = JSON.parse(n)
                } catch (e) {
                    return !1
                }
                return !(!n.user || n.user.role !== D.a.ROLES.GUEST) && (!(!n.user.accessToken || e !== n.user.displayName) && new b.a(this, n.user))
            }
        }, {
            key: "__setLocalGuestUser", value: function (e) {
                var t = D.a.LOCALSTORAGE_PREFIX + this.publicKey, r = {
                    user: e,
                    accessToken: this.__btoa(e.accessToken),
                    expires: Date.now() + D.a.LOCALSTORAGE_EXPIRY_TIME
                }, n = window.localStorage;
                this.options.localStorage && (n = this.options.localStorage), n.setItem(t, JSON.stringify(r))
            }
        }, {
            key: "__verifyAccessToken", value: function (t, r, n) {
                var i = this;
                return Object(k.a)(n, function (t) {
                    i.request("".concat(e.basePath, "/verify_access_token"), {
                        method: "post",
                        data: {accessToken: r}
                    }).then(function (e) {
                        return e.data.user = new b.a(i, e.data.user), t(null, e.data)
                    }).catch(function (e) {
                        return x.a.log(q, P.errors.API_ERROR, {err: i.error(e)}), t(i.error(e))
                    })
                })
            }
        }, {
            key: "__logout", value: function (t, r) {
                var n = this;
                return Object(k.a)(r, function (r) {
                    n.request("".concat(e.basePath, "/logout"), {
                        method: "post",
                        data: {deviceId: t}
                    }).then(function (e) {
                        return r(null, e)
                    }).catch(function (e) {
                        return x.a.log(q, P.errors.API_ERROR, {err: n.error(e)}), r(n.error(e))
                    })
                })
            }
        }, {
            key: "request", value: function (e, t) {
                t || (t = {});
                var r = e;
                return t.absolute || (r = L.a.BASE_URL + e), t.headers = t.headers || {}, t.headers["Public-Key"] = this.publicKey, !t.noAuth && this.accessToken && (t.headers.Authorization = "Bearer ".concat(this.accessToken)), this.isAnonymousUser() && (t.headers["Anonymous-User-Id"] = this.currentUser.id), E()(r, t)
            }
        }], [{
            key: "getInstance", value: function () {
                return e.instance
            }
        }]), e
    }();
    m()(H, "basePath", D.a.BASEPATH_USERS)
}, function (e, t, r) {
    "use strict";
    (function (t) {
        var n = r(21), i = r(165), o = {"Content-Type": "application/x-www-form-urlencoded"};

        function s(e, t) {
            !n.isUndefined(e) && n.isUndefined(e["Content-Type"]) && (e["Content-Type"] = t)
        }

        var a = {
            adapter: function () {
                var e;
                return "undefined" != typeof XMLHttpRequest ? e = r(101) : void 0 !== t && (e = r(101)), e
            }(),
            transformRequest: [function (e, t) {
                return i(t, "Content-Type"), n.isFormData(e) || n.isArrayBuffer(e) || n.isBuffer(e) || n.isStream(e) || n.isFile(e) || n.isBlob(e) ? e : n.isArrayBufferView(e) ? e.buffer : n.isURLSearchParams(e) ? (s(t, "application/x-www-form-urlencoded;charset=utf-8"), e.toString()) : n.isObject(e) ? (s(t, "application/json;charset=utf-8"), JSON.stringify(e)) : e
            }],
            transformResponse: [function (e) {
                if ("string" == typeof e) try {
                    e = JSON.parse(e)
                } catch (e) {
                }
                return e
            }],
            timeout: 0,
            xsrfCookieName: "XSRF-TOKEN",
            xsrfHeaderName: "X-XSRF-TOKEN",
            maxContentLength: -1,
            validateStatus: function (e) {
                return e >= 200 && e < 300
            },
            headers: {common: {Accept: "application/json, text/plain, */*"}}
        };
        n.forEach(["delete", "get", "head"], function (e) {
            a.headers[e] = {}
        }), n.forEach(["post", "put", "patch"], function (e) {
            a.headers[e] = n.merge(o)
        }), e.exports = a
    }).call(this, r(14))
}, function (e, t, r) {
    "use strict";
    var n = r(182), i = r(78), o = r(41), s = r(105), a = r(184);

    function c(e, t, r) {
        var n = this._refs[r];
        if ("string" == typeof n) {
            if (!this._refs[n]) return c.call(this, e, t, n);
            n = this._refs[n]
        }
        if ((n = n || this._schemas[r]) instanceof s) return p(n.schema, this._opts.inlineRefs) ? n.schema : n.validate || this._compile(n);
        var i, o, a, d = u.call(this, t, r);
        return d && (i = d.schema, t = d.root, a = d.baseId), i instanceof s ? o = i.validate || e.call(this, i.schema, t, void 0, a) : void 0 !== i && (o = p(i, this._opts.inlineRefs) ? i : e.call(this, i, t, void 0, a)), o
    }

    function u(e, t) {
        var r = n.parse(t), i = m(r), o = f(this._getId(e.schema));
        if (0 === Object.keys(e.schema).length || i !== o) {
            var a = v(i), c = this._refs[a];
            if ("string" == typeof c) return function (e, t, r) {
                var n = u.call(this, e, t);
                if (n) {
                    var i = n.schema, o = n.baseId;
                    e = n.root;
                    var s = this._getId(i);
                    return s && (o = g(o, s)), l.call(this, r, o, i, e)
                }
            }.call(this, e, c, r);
            if (c instanceof s) c.validate || this._compile(c), e = c; else {
                if (!((c = this._schemas[a]) instanceof s)) return;
                if (c.validate || this._compile(c), a == v(t)) return {schema: c, root: e, baseId: o};
                e = c
            }
            if (!e.schema) return;
            o = f(this._getId(e.schema))
        }
        return l.call(this, r, o, e.schema, e)
    }

    e.exports = c, c.normalizeId = v, c.fullPath = f, c.url = g, c.ids = function (e) {
        var t = v(this._getId(e)), r = {"": t}, s = {"": f(t, !1)}, c = {}, u = this;
        return a(e, {allKeys: !0}, function (e, t, a, d, l, h, p) {
            if ("" !== t) {
                var f = u._getId(e), m = r[d], _ = s[d] + "/" + l;
                if (void 0 !== p && (_ += "/" + ("number" == typeof p ? p : o.escapeFragment(p))), "string" == typeof f) {
                    f = m = v(m ? n.resolve(m, f) : f);
                    var g = u._refs[f];
                    if ("string" == typeof g && (g = u._refs[g]), g && g.schema) {
                        if (!i(e, g.schema)) throw new Error('id "' + f + '" resolves to more than one schema')
                    } else if (f != v(_)) if ("#" == f[0]) {
                        if (c[f] && !i(e, c[f])) throw new Error('id "' + f + '" resolves to more than one schema');
                        c[f] = e
                    } else u._refs[f] = _
                }
                r[t] = m, s[t] = _
            }
        }), c
    }, c.inlineRef = p, c.schema = u;
    var d = o.toHash(["properties", "patternProperties", "enum", "dependencies", "definitions"]);

    function l(e, t, r, n) {
        if (e.fragment = e.fragment || "", "/" == e.fragment.slice(0, 1)) {
            for (var i = e.fragment.split("/"), s = 1; s < i.length; s++) {
                var a = i[s];
                if (a) {
                    if (void 0 === (r = r[a = o.unescapeFragment(a)])) break;
                    var c;
                    if (!d[a] && ((c = this._getId(r)) && (t = g(t, c)), r.$ref)) {
                        var l = g(t, r.$ref), h = u.call(this, n, l);
                        h && (r = h.schema, n = h.root, t = h.baseId)
                    }
                }
            }
            return void 0 !== r && r !== n.schema ? {schema: r, root: n, baseId: t} : void 0
        }
    }

    var h = o.toHash(["type", "format", "pattern", "maxLength", "minLength", "maxProperties", "minProperties", "maxItems", "minItems", "maximum", "minimum", "uniqueItems", "multipleOf", "required", "enum"]);

    function p(e, t) {
        return !1 !== t && (void 0 === t || !0 === t ? function e(t) {
            var r;
            if (Array.isArray(t)) {
                for (var n = 0; n < t.length; n++) if ("object" == typeof (r = t[n]) && !e(r)) return !1
            } else for (var i in t) {
                if ("$ref" == i) return !1;
                if ("object" == typeof (r = t[i]) && !e(r)) return !1
            }
            return !0
        }(e) : t ? function e(t) {
            var r, n = 0;
            if (Array.isArray(t)) {
                for (var i = 0; i < t.length; i++) if ("object" == typeof (r = t[i]) && (n += e(r)), n == 1 / 0) return 1 / 0
            } else for (var o in t) {
                if ("$ref" == o) return 1 / 0;
                if (h[o]) n++; else if ("object" == typeof (r = t[o]) && (n += e(r) + 1), n == 1 / 0) return 1 / 0
            }
            return n
        }(e) <= t : void 0)
    }

    function f(e, t) {
        return !1 !== t && (e = v(e)), m(n.parse(e))
    }

    function m(e) {
        return n.serialize(e).split("#")[0] + "#"
    }

    var _ = /#\/?$/;

    function v(e) {
        return e ? e.replace(_, "") : ""
    }

    function g(e, t) {
        return t = v(t), n.resolve(e, t)
    }
}, function (e, t, r) {
    "use strict";
    e.exports = function e(t, r) {
        if (t === r) return !0;
        if (t && r && "object" == typeof t && "object" == typeof r) {
            if (t.constructor !== r.constructor) return !1;
            var n, i, o;
            if (Array.isArray(t)) {
                if ((n = t.length) != r.length) return !1;
                for (i = n; 0 != i--;) if (!e(t[i], r[i])) return !1;
                return !0
            }
            if (t.constructor === RegExp) return t.source === r.source && t.flags === r.flags;
            if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === r.valueOf();
            if (t.toString !== Object.prototype.toString) return t.toString() === r.toString();
            if ((n = (o = Object.keys(t)).length) !== Object.keys(r).length) return !1;
            for (i = n; 0 != i--;) if (!Object.prototype.hasOwnProperty.call(r, o[i])) return !1;
            for (i = n; 0 != i--;) {
                var s = o[i];
                if (!e(t[s], r[s])) return !1
            }
            return !0
        }
        return t != t && r != r
    }
}, function (e, t, r) {
    "use strict";
    var n = r(77);

    function i(e, t, r) {
        this.message = r || i.message(e, t), this.missingRef = n.url(e, t), this.missingSchema = n.normalizeId(n.fullPath(this.missingRef))
    }

    function o(e) {
        return e.prototype = Object.create(Error.prototype), e.prototype.constructor = e, e
    }

    e.exports = {
        Validation: o(function (e) {
            this.message = "validation failed", this.errors = e, this.ajv = this.validation = !0
        }), MissingRef: o(i)
    }, i.message = function (e, t) {
        return "can't resolve reference " + t + " from id " + e
    }
}, function (e, t, r) {
    var n = r(15);
    n.crypto.lib = r(246), n.Buffer = r(22).Buffer, n.url = r(87), n.querystring = r(129), n.realClock = r(258), n.environment = "js", n.createEventStream = r(259).createEventStream, n.isBrowser = function () {
        return !0
    }, n.isNode = function () {
        return !1
    };
    var i = r(9);
    if (e.exports = i, r(124), r(125), r(265), r(270), r(271), r(272), r(277), i.XML.Parser = r(278), r(279), void 0 === o) var o = {browser: !0}
}, function (e, t, r) {
    var n = r(15), i = r(82), o = r(83), s = r(84).populateHostPrefix;
    e.exports = {
        buildRequest: function (e) {
            var t = e.httpRequest, r = e.service.api, n = r.targetPrefix + "." + r.operations[e.operation].name,
                o = r.jsonVersion || "1.0", a = r.operations[e.operation].input, c = new i;
            1 === o && (o = "1.0"), t.body = c.build(e.params || {}, a), t.headers["Content-Type"] = "application/x-amz-json-" + o, t.headers["X-Amz-Target"] = n, s(e)
        }, extractError: function (e) {
            var t = {}, r = e.httpResponse;
            if (t.code = r.headers["x-amzn-errortype"] || "UnknownError", "string" == typeof t.code && (t.code = t.code.split(":")[0]), r.body.length > 0) try {
                var i = JSON.parse(r.body.toString()), o = i.__type || i.code || i.Code;
                o && (t.code = o.split("#").pop()), "RequestEntityTooLarge" === t.code ? t.message = "Request body must be less than 1 MB" : t.message = i.message || i.Message || null
            } catch (i) {
                t.statusCode = r.statusCode, t.message = r.statusMessage
            } else t.statusCode = r.statusCode, t.message = r.statusCode.toString();
            e.error = n.error(new Error, t)
        }, extractData: function (e) {
            var t = e.httpResponse.body.toString() || "{}";
            if (!1 === e.request.service.config.convertResponseTypes) e.data = JSON.parse(t); else {
                var r = e.request.service.api.operations[e.request.operation].output || {}, n = new o;
                e.data = n.parse(t, r)
            }
        }
    }
}, function (e, t, r) {
    var n = r(15);

    function i() {
    }

    function o(e, t) {
        if (t && void 0 !== e && null !== e) switch (t.type) {
            case"structure":
                return function (e, t) {
                    var r = {};
                    return n.each(e, function (e, n) {
                        var i = t.members[e];
                        if (i) {
                            if ("body" !== i.location) return;
                            var s = i.isLocationName ? i.name : e, a = o(n, i);
                            void 0 !== a && (r[s] = a)
                        }
                    }), r
                }(e, t);
            case"map":
                return function (e, t) {
                    var r = {};
                    return n.each(e, function (e, n) {
                        var i = o(n, t.value);
                        void 0 !== i && (r[e] = i)
                    }), r
                }(e, t);
            case"list":
                return function (e, t) {
                    var r = [];
                    return n.arrayEach(e, function (e) {
                        var n = o(e, t.member);
                        void 0 !== n && r.push(n)
                    }), r
                }(e, t);
            default:
                return function (e, t) {
                    return t.toWireFormat(e)
                }(e, t)
        }
    }

    i.prototype.build = function (e, t) {
        return JSON.stringify(o(e, t))
    }, e.exports = i
}, function (e, t, r) {
    var n = r(15);

    function i() {
    }

    function o(e, t) {
        if (t && void 0 !== e) switch (t.type) {
            case"structure":
                return function (e, t) {
                    if (null == e) return;
                    var r = {}, i = t.members;
                    return n.each(i, function (t, n) {
                        var i = n.isLocationName ? n.name : t;
                        if (Object.prototype.hasOwnProperty.call(e, i)) {
                            var s = o(e[i], n);
                            void 0 !== s && (r[t] = s)
                        }
                    }), r
                }(e, t);
            case"map":
                return function (e, t) {
                    if (null == e) return;
                    var r = {};
                    return n.each(e, function (e, n) {
                        var i = o(n, t.value);
                        r[e] = void 0 === i ? null : i
                    }), r
                }(e, t);
            case"list":
                return function (e, t) {
                    if (null == e) return;
                    var r = [];
                    return n.arrayEach(e, function (e) {
                        var n = o(e, t.member);
                        void 0 === n ? r.push(null) : r.push(n)
                    }), r
                }(e, t);
            default:
                return function (e, t) {
                    return t.toType(e)
                }(e, t)
        }
    }

    i.prototype.parse = function (e, t) {
        return o(JSON.parse(e), t)
    }, e.exports = i
}, function (e, t, r) {
    var n = r(15), i = r(9);
    e.exports = {
        populateHostPrefix: function (e) {
            if (!e.service.config.hostPrefixEnabled) return e;
            var t = e.service.api.operations[e.operation];
            if (function (e) {
                var t = e.service.api, r = t.operations[e.operation],
                    i = t.endpointOperation && t.endpointOperation === n.string.lowerFirst(r.name);
                return "NULL" !== r.endpointDiscoveryRequired || !0 === i
            }(e)) return e;
            if (t.endpoint && t.endpoint.hostPrefix) {
                var r = function (e, t, r) {
                    return n.each(r.members, function (r, i) {
                        if (!0 === i.hostLabel) {
                            if ("string" != typeof t[r] || "" === t[r]) throw n.error(new Error, {
                                message: "Parameter " + r + " should be a non-empty string.",
                                code: "InvalidParameter"
                            });
                            var o = new RegExp("\\{" + r + "\\}", "g");
                            e = e.replace(o, t[r])
                        }
                    }), e
                }(t.endpoint.hostPrefix, e.params, t.input);
                !function (e, t) {
                    e.host && (e.host = t + e.host), e.hostname && (e.hostname = t + e.hostname)
                }(e.httpRequest.endpoint, r), function (e) {
                    var t = e.split("."), r = /^[a-zA-Z0-9]{1}$|^[a-zA-Z0-9][a-zA-Z0-9\-]*[a-zA-Z0-9]$/;
                    n.arrayEach(t, function (e) {
                        if (!e.length || e.length < 1 || e.length > 63) throw n.error(new Error, {
                            code: "ValidationError",
                            message: "Hostname label length should be between 1 to 63 characters, inclusive."
                        });
                        if (!r.test(e)) throw i.util.error(new Error, {
                            code: "ValidationError",
                            message: e + " is not hostname compatible."
                        })
                    })
                }(e.httpRequest.endpoint.hostname)
            }
            return e
        }
    }
}, function (e, t, r) {
    !function (e) {
        "use strict";

        function t(e) {
            return null !== e && "[object Array]" === Object.prototype.toString.call(e)
        }

        function r(e) {
            return null !== e && "[object Object]" === Object.prototype.toString.call(e)
        }

        function n(e, i) {
            if (e === i) return !0;
            if (Object.prototype.toString.call(e) !== Object.prototype.toString.call(i)) return !1;
            if (!0 === t(e)) {
                if (e.length !== i.length) return !1;
                for (var o = 0; o < e.length; o++) if (!1 === n(e[o], i[o])) return !1;
                return !0
            }
            if (!0 === r(e)) {
                var s = {};
                for (var a in e) if (hasOwnProperty.call(e, a)) {
                    if (!1 === n(e[a], i[a])) return !1;
                    s[a] = !0
                }
                for (var c in i) if (hasOwnProperty.call(i, c) && !0 !== s[c]) return !1;
                return !0
            }
            return !1
        }

        function i(e) {
            if ("" === e || !1 === e || null === e) return !0;
            if (t(e) && 0 === e.length) return !0;
            if (r(e)) {
                for (var n in e) if (e.hasOwnProperty(n)) return !1;
                return !0
            }
            return !1
        }

        var o;
        o = "function" == typeof String.prototype.trimLeft ? function (e) {
            return e.trimLeft()
        } : function (e) {
            return e.match(/^\s*(.*)/)[1]
        };
        var s = 0, a = 1, c = 2, u = 3, d = 4, l = 6, h = 8, p = 9, f = {
            ".": "Dot",
            "*": "Star",
            ",": "Comma",
            ":": "Colon",
            "{": "Lbrace",
            "}": "Rbrace",
            "]": "Rbracket",
            "(": "Lparen",
            ")": "Rparen",
            "@": "Current"
        }, m = {"<": !0, ">": !0, "=": !0, "!": !0}, _ = {" ": !0, "\t": !0, "\n": !0};

        function v(e) {
            return e >= "a" && e <= "z" || e >= "A" && e <= "Z" || "_" === e
        }

        function g(e) {
            return e >= "0" && e <= "9" || "-" === e
        }

        function E(e) {
            return e >= "a" && e <= "z" || e >= "A" && e <= "Z" || e >= "0" && e <= "9" || "_" === e
        }

        function y() {
        }

        y.prototype = {
            tokenize: function (e) {
                var t, r, n, i = [];
                for (this._current = 0; this._current < e.length;) if (v(e[this._current])) t = this._current, r = this._consumeUnquotedIdentifier(e), i.push({
                    type: "UnquotedIdentifier",
                    value: r,
                    start: t
                }); else if (void 0 !== f[e[this._current]]) i.push({
                    type: f[e[this._current]],
                    value: e[this._current],
                    start: this._current
                }), this._current++; else if (g(e[this._current])) n = this._consumeNumber(e), i.push(n); else if ("[" === e[this._current]) n = this._consumeLBracket(e), i.push(n); else if ('"' === e[this._current]) t = this._current, r = this._consumeQuotedIdentifier(e), i.push({
                    type: "QuotedIdentifier",
                    value: r,
                    start: t
                }); else if ("'" === e[this._current]) t = this._current, r = this._consumeRawStringLiteral(e), i.push({
                    type: "Literal",
                    value: r,
                    start: t
                }); else if ("`" === e[this._current]) {
                    t = this._current;
                    var o = this._consumeLiteral(e);
                    i.push({type: "Literal", value: o, start: t})
                } else if (void 0 !== m[e[this._current]]) i.push(this._consumeOperator(e)); else if (void 0 !== _[e[this._current]]) this._current++; else if ("&" === e[this._current]) t = this._current, this._current++, "&" === e[this._current] ? (this._current++, i.push({
                    type: "And",
                    value: "&&",
                    start: t
                })) : i.push({type: "Expref", value: "&", start: t}); else {
                    if ("|" !== e[this._current]) {
                        var s = new Error("Unknown character:" + e[this._current]);
                        throw s.name = "LexerError", s
                    }
                    t = this._current, this._current++, "|" === e[this._current] ? (this._current++, i.push({
                        type: "Or",
                        value: "||",
                        start: t
                    })) : i.push({type: "Pipe", value: "|", start: t})
                }
                return i
            }, _consumeUnquotedIdentifier: function (e) {
                var t = this._current;
                for (this._current++; this._current < e.length && E(e[this._current]);) this._current++;
                return e.slice(t, this._current)
            }, _consumeQuotedIdentifier: function (e) {
                var t = this._current;
                this._current++;
                for (var r = e.length; '"' !== e[this._current] && this._current < r;) {
                    var n = this._current;
                    "\\" !== e[n] || "\\" !== e[n + 1] && '"' !== e[n + 1] ? n++ : n += 2, this._current = n
                }
                return this._current++, JSON.parse(e.slice(t, this._current))
            }, _consumeRawStringLiteral: function (e) {
                var t = this._current;
                this._current++;
                for (var r = e.length; "'" !== e[this._current] && this._current < r;) {
                    var n = this._current;
                    "\\" !== e[n] || "\\" !== e[n + 1] && "'" !== e[n + 1] ? n++ : n += 2, this._current = n
                }
                return this._current++, e.slice(t + 1, this._current - 1).replace("\\'", "'")
            }, _consumeNumber: function (e) {
                var t = this._current;
                this._current++;
                for (var r = e.length; g(e[this._current]) && this._current < r;) this._current++;
                return {type: "Number", value: parseInt(e.slice(t, this._current)), start: t}
            }, _consumeLBracket: function (e) {
                var t = this._current;
                return this._current++, "?" === e[this._current] ? (this._current++, {
                    type: "Filter",
                    value: "[?",
                    start: t
                }) : "]" === e[this._current] ? (this._current++, {
                    type: "Flatten",
                    value: "[]",
                    start: t
                }) : {type: "Lbracket", value: "[", start: t}
            }, _consumeOperator: function (e) {
                var t = this._current, r = e[t];
                return this._current++, "!" === r ? "=" === e[this._current] ? (this._current++, {
                    type: "NE",
                    value: "!=",
                    start: t
                }) : {
                    type: "Not",
                    value: "!",
                    start: t
                } : "<" === r ? "=" === e[this._current] ? (this._current++, {
                    type: "LTE",
                    value: "<=",
                    start: t
                }) : {
                    type: "LT",
                    value: "<",
                    start: t
                } : ">" === r ? "=" === e[this._current] ? (this._current++, {
                    type: "GTE",
                    value: ">=",
                    start: t
                }) : {
                    type: "GT",
                    value: ">",
                    start: t
                } : "=" === r && "=" === e[this._current] ? (this._current++, {
                    type: "EQ",
                    value: "==",
                    start: t
                }) : void 0
            }, _consumeLiteral: function (e) {
                this._current++;
                for (var t, r = this._current, n = e.length; "`" !== e[this._current] && this._current < n;) {
                    var i = this._current;
                    "\\" !== e[i] || "\\" !== e[i + 1] && "`" !== e[i + 1] ? i++ : i += 2, this._current = i
                }
                var s = o(e.slice(r, this._current));
                return s = s.replace("\\`", "`"), t = this._looksLikeJSON(s) ? JSON.parse(s) : JSON.parse('"' + s + '"'), this._current++, t
            }, _looksLikeJSON: function (e) {
                if ("" === e) return !1;
                if ('[{"'.indexOf(e[0]) >= 0) return !0;
                if (["true", "false", "null"].indexOf(e) >= 0) return !0;
                if (!("-0123456789".indexOf(e[0]) >= 0)) return !1;
                try {
                    return JSON.parse(e), !0
                } catch (e) {
                    return !1
                }
            }
        };
        var S = {};

        function b() {
        }

        function T(e) {
            this.runtime = e
        }

        function R(e) {
            this._interpreter = e, this.functionTable = {
                abs: {_func: this._functionAbs, _signature: [{types: [s]}]},
                avg: {_func: this._functionAvg, _signature: [{types: [h]}]},
                ceil: {_func: this._functionCeil, _signature: [{types: [s]}]},
                contains: {_func: this._functionContains, _signature: [{types: [c, u]}, {types: [a]}]},
                ends_with: {_func: this._functionEndsWith, _signature: [{types: [c]}, {types: [c]}]},
                floor: {_func: this._functionFloor, _signature: [{types: [s]}]},
                length: {_func: this._functionLength, _signature: [{types: [c, u, d]}]},
                map: {_func: this._functionMap, _signature: [{types: [l]}, {types: [u]}]},
                max: {_func: this._functionMax, _signature: [{types: [h, p]}]},
                merge: {_func: this._functionMerge, _signature: [{types: [d], variadic: !0}]},
                max_by: {_func: this._functionMaxBy, _signature: [{types: [u]}, {types: [l]}]},
                sum: {_func: this._functionSum, _signature: [{types: [h]}]},
                starts_with: {_func: this._functionStartsWith, _signature: [{types: [c]}, {types: [c]}]},
                min: {_func: this._functionMin, _signature: [{types: [h, p]}]},
                min_by: {_func: this._functionMinBy, _signature: [{types: [u]}, {types: [l]}]},
                type: {_func: this._functionType, _signature: [{types: [a]}]},
                keys: {_func: this._functionKeys, _signature: [{types: [d]}]},
                values: {_func: this._functionValues, _signature: [{types: [d]}]},
                sort: {_func: this._functionSort, _signature: [{types: [p, h]}]},
                sort_by: {_func: this._functionSortBy, _signature: [{types: [u]}, {types: [l]}]},
                join: {_func: this._functionJoin, _signature: [{types: [c]}, {types: [p]}]},
                reverse: {_func: this._functionReverse, _signature: [{types: [c, u]}]},
                to_array: {_func: this._functionToArray, _signature: [{types: [a]}]},
                to_string: {_func: this._functionToString, _signature: [{types: [a]}]},
                to_number: {_func: this._functionToNumber, _signature: [{types: [a]}]},
                not_null: {_func: this._functionNotNull, _signature: [{types: [a], variadic: !0}]}
            }
        }

        S.EOF = 0, S.UnquotedIdentifier = 0, S.QuotedIdentifier = 0, S.Rbracket = 0, S.Rparen = 0, S.Comma = 0, S.Rbrace = 0, S.Number = 0, S.Current = 0, S.Expref = 0, S.Pipe = 1, S.Or = 2, S.And = 3, S.EQ = 5, S.GT = 5, S.LT = 5, S.GTE = 5, S.LTE = 5, S.NE = 5, S.Flatten = 9, S.Star = 20, S.Filter = 21, S.Dot = 40, S.Not = 45, S.Lbrace = 50, S.Lbracket = 55, S.Lparen = 60, b.prototype = {
            parse: function (e) {
                this._loadTokens(e), this.index = 0;
                var t = this.expression(0);
                if ("EOF" !== this._lookahead(0)) {
                    var r = this._lookaheadToken(0),
                        n = new Error("Unexpected token type: " + r.type + ", value: " + r.value);
                    throw n.name = "ParserError", n
                }
                return t
            }, _loadTokens: function (e) {
                var t = (new y).tokenize(e);
                t.push({type: "EOF", value: "", start: e.length}), this.tokens = t
            }, expression: function (e) {
                var t = this._lookaheadToken(0);
                this._advance();
                for (var r = this.nud(t), n = this._lookahead(0); e < S[n];) this._advance(), r = this.led(n, r), n = this._lookahead(0);
                return r
            }, _lookahead: function (e) {
                return this.tokens[this.index + e].type
            }, _lookaheadToken: function (e) {
                return this.tokens[this.index + e]
            }, _advance: function () {
                this.index++
            }, nud: function (e) {
                var t, r;
                switch (e.type) {
                    case"Literal":
                        return {type: "Literal", value: e.value};
                    case"UnquotedIdentifier":
                        return {type: "Field", name: e.value};
                    case"QuotedIdentifier":
                        var n = {type: "Field", name: e.value};
                        if ("Lparen" === this._lookahead(0)) throw new Error("Quoted identifier not allowed for function names.");
                        return n;
                    case"Not":
                        return {type: "NotExpression", children: [t = this.expression(S.Not)]};
                    case"Star":
                        return t = null, {
                            type: "ValueProjection",
                            children: [{type: "Identity"}, t = "Rbracket" === this._lookahead(0) ? {type: "Identity"} : this._parseProjectionRHS(S.Star)]
                        };
                    case"Filter":
                        return this.led(e.type, {type: "Identity"});
                    case"Lbrace":
                        return this._parseMultiselectHash();
                    case"Flatten":
                        return {
                            type: "Projection",
                            children: [{
                                type: "Flatten",
                                children: [{type: "Identity"}]
                            }, t = this._parseProjectionRHS(S.Flatten)]
                        };
                    case"Lbracket":
                        return "Number" === this._lookahead(0) || "Colon" === this._lookahead(0) ? (t = this._parseIndexExpression(), this._projectIfSlice({type: "Identity"}, t)) : "Star" === this._lookahead(0) && "Rbracket" === this._lookahead(1) ? (this._advance(), this._advance(), {
                            type: "Projection",
                            children: [{type: "Identity"}, t = this._parseProjectionRHS(S.Star)]
                        }) : this._parseMultiselectList();
                    case"Current":
                        return {type: "Current"};
                    case"Expref":
                        return {type: "ExpressionReference", children: [r = this.expression(S.Expref)]};
                    case"Lparen":
                        for (var i = []; "Rparen" !== this._lookahead(0);) "Current" === this._lookahead(0) ? (r = {type: "Current"}, this._advance()) : r = this.expression(0), i.push(r);
                        return this._match("Rparen"), i[0];
                    default:
                        this._errorToken(e)
                }
            }, led: function (e, t) {
                var r;
                switch (e) {
                    case"Dot":
                        var n = S.Dot;
                        return "Star" !== this._lookahead(0) ? {
                            type: "Subexpression",
                            children: [t, r = this._parseDotRHS(n)]
                        } : (this._advance(), {
                            type: "ValueProjection",
                            children: [t, r = this._parseProjectionRHS(n)]
                        });
                    case"Pipe":
                        return {type: "Pipe", children: [t, r = this.expression(S.Pipe)]};
                    case"Or":
                        return {type: "OrExpression", children: [t, r = this.expression(S.Or)]};
                    case"And":
                        return {type: "AndExpression", children: [t, r = this.expression(S.And)]};
                    case"Lparen":
                        for (var i, o = t.name, s = []; "Rparen" !== this._lookahead(0);) "Current" === this._lookahead(0) ? (i = {type: "Current"}, this._advance()) : i = this.expression(0), "Comma" === this._lookahead(0) && this._match("Comma"), s.push(i);
                        return this._match("Rparen"), {type: "Function", name: o, children: s};
                    case"Filter":
                        var a = this.expression(0);
                        return this._match("Rbracket"), {
                            type: "FilterProjection",
                            children: [t, r = "Flatten" === this._lookahead(0) ? {type: "Identity"} : this._parseProjectionRHS(S.Filter), a]
                        };
                    case"Flatten":
                        return {
                            type: "Projection",
                            children: [{type: "Flatten", children: [t]}, this._parseProjectionRHS(S.Flatten)]
                        };
                    case"EQ":
                    case"NE":
                    case"GT":
                    case"GTE":
                    case"LT":
                    case"LTE":
                        return this._parseComparator(t, e);
                    case"Lbracket":
                        var c = this._lookaheadToken(0);
                        return "Number" === c.type || "Colon" === c.type ? (r = this._parseIndexExpression(), this._projectIfSlice(t, r)) : (this._match("Star"), this._match("Rbracket"), {
                            type: "Projection",
                            children: [t, r = this._parseProjectionRHS(S.Star)]
                        });
                    default:
                        this._errorToken(this._lookaheadToken(0))
                }
            }, _match: function (e) {
                if (this._lookahead(0) !== e) {
                    var t = this._lookaheadToken(0), r = new Error("Expected " + e + ", got: " + t.type);
                    throw r.name = "ParserError", r
                }
                this._advance()
            }, _errorToken: function (e) {
                var t = new Error("Invalid token (" + e.type + '): "' + e.value + '"');
                throw t.name = "ParserError", t
            }, _parseIndexExpression: function () {
                if ("Colon" === this._lookahead(0) || "Colon" === this._lookahead(1)) return this._parseSliceExpression();
                var e = {type: "Index", value: this._lookaheadToken(0).value};
                return this._advance(), this._match("Rbracket"), e
            }, _projectIfSlice: function (e, t) {
                var r = {type: "IndexExpression", children: [e, t]};
                return "Slice" === t.type ? {type: "Projection", children: [r, this._parseProjectionRHS(S.Star)]} : r
            }, _parseSliceExpression: function () {
                for (var e = [null, null, null], t = 0, r = this._lookahead(0); "Rbracket" !== r && t < 3;) {
                    if ("Colon" === r) t++, this._advance(); else {
                        if ("Number" !== r) {
                            var n = this._lookahead(0),
                                i = new Error("Syntax error, unexpected token: " + n.value + "(" + n.type + ")");
                            throw i.name = "Parsererror", i
                        }
                        e[t] = this._lookaheadToken(0).value, this._advance()
                    }
                    r = this._lookahead(0)
                }
                return this._match("Rbracket"), {type: "Slice", children: e}
            }, _parseComparator: function (e, t) {
                return {type: "Comparator", name: t, children: [e, this.expression(S[t])]}
            }, _parseDotRHS: function (e) {
                var t = this._lookahead(0);
                return ["UnquotedIdentifier", "QuotedIdentifier", "Star"].indexOf(t) >= 0 ? this.expression(e) : "Lbracket" === t ? (this._match("Lbracket"), this._parseMultiselectList()) : "Lbrace" === t ? (this._match("Lbrace"), this._parseMultiselectHash()) : void 0
            }, _parseProjectionRHS: function (e) {
                var t;
                if (S[this._lookahead(0)] < 10) t = {type: "Identity"}; else if ("Lbracket" === this._lookahead(0)) t = this.expression(e); else if ("Filter" === this._lookahead(0)) t = this.expression(e); else {
                    if ("Dot" !== this._lookahead(0)) {
                        var r = this._lookaheadToken(0),
                            n = new Error("Sytanx error, unexpected token: " + r.value + "(" + r.type + ")");
                        throw n.name = "ParserError", n
                    }
                    this._match("Dot"), t = this._parseDotRHS(e)
                }
                return t
            }, _parseMultiselectList: function () {
                for (var e = []; "Rbracket" !== this._lookahead(0);) {
                    var t = this.expression(0);
                    if (e.push(t), "Comma" === this._lookahead(0) && (this._match("Comma"), "Rbracket" === this._lookahead(0))) throw new Error("Unexpected token Rbracket")
                }
                return this._match("Rbracket"), {type: "MultiSelectList", children: e}
            }, _parseMultiselectHash: function () {
                for (var e, t, r, n = [], i = ["UnquotedIdentifier", "QuotedIdentifier"]; ;) {
                    if (e = this._lookaheadToken(0), i.indexOf(e.type) < 0) throw new Error("Expecting an identifier token, got: " + e.type);
                    if (t = e.value, this._advance(), this._match("Colon"), r = {
                        type: "KeyValuePair",
                        name: t,
                        value: this.expression(0)
                    }, n.push(r), "Comma" === this._lookahead(0)) this._match("Comma"); else if ("Rbrace" === this._lookahead(0)) {
                        this._match("Rbrace");
                        break
                    }
                }
                return {type: "MultiSelectHash", children: n}
            }
        }, T.prototype = {
            search: function (e, t) {
                return this.visit(e, t)
            }, visit: function (e, o) {
                var s, a, c, u, d, l, h, p, f;
                switch (e.type) {
                    case"Field":
                        return null === o ? null : r(o) ? void 0 === (l = o[e.name]) ? null : l : null;
                    case"Subexpression":
                        for (c = this.visit(e.children[0], o), f = 1; f < e.children.length; f++) if (null === (c = this.visit(e.children[1], c))) return null;
                        return c;
                    case"IndexExpression":
                        return h = this.visit(e.children[0], o), this.visit(e.children[1], h);
                    case"Index":
                        if (!t(o)) return null;
                        var m = e.value;
                        return m < 0 && (m = o.length + m), void 0 === (c = o[m]) && (c = null), c;
                    case"Slice":
                        if (!t(o)) return null;
                        var _ = e.children.slice(0), v = this.computeSliceParams(o.length, _), g = v[0], E = v[1],
                            y = v[2];
                        if (c = [], y > 0) for (f = g; f < E; f += y) c.push(o[f]); else for (f = g; f > E; f += y) c.push(o[f]);
                        return c;
                    case"Projection":
                        var S = this.visit(e.children[0], o);
                        if (!t(S)) return null;
                        for (p = [], f = 0; f < S.length; f++) null !== (a = this.visit(e.children[1], S[f])) && p.push(a);
                        return p;
                    case"ValueProjection":
                        if (!r(S = this.visit(e.children[0], o))) return null;
                        p = [];
                        var b = function (e) {
                            for (var t = Object.keys(e), r = [], n = 0; n < t.length; n++) r.push(e[t[n]]);
                            return r
                        }(S);
                        for (f = 0; f < b.length; f++) null !== (a = this.visit(e.children[1], b[f])) && p.push(a);
                        return p;
                    case"FilterProjection":
                        if (!t(S = this.visit(e.children[0], o))) return null;
                        var T = [], R = [];
                        for (f = 0; f < S.length; f++) i(s = this.visit(e.children[2], S[f])) || T.push(S[f]);
                        for (var I = 0; I < T.length; I++) null !== (a = this.visit(e.children[1], T[I])) && R.push(a);
                        return R;
                    case"Comparator":
                        switch (u = this.visit(e.children[0], o), d = this.visit(e.children[1], o), e.name) {
                            case"EQ":
                                c = n(u, d);
                                break;
                            case"NE":
                                c = !n(u, d);
                                break;
                            case"GT":
                                c = u > d;
                                break;
                            case"GTE":
                                c = u >= d;
                                break;
                            case"LT":
                                c = u < d;
                                break;
                            case"LTE":
                                c = u <= d;
                                break;
                            default:
                                throw new Error("Unknown comparator: " + e.name)
                        }
                        return c;
                    case"Flatten":
                        var w = this.visit(e.children[0], o);
                        if (!t(w)) return null;
                        var C = [];
                        for (f = 0; f < w.length; f++) t(a = w[f]) ? C.push.apply(C, a) : C.push(a);
                        return C;
                    case"Identity":
                        return o;
                    case"MultiSelectList":
                        if (null === o) return null;
                        for (p = [], f = 0; f < e.children.length; f++) p.push(this.visit(e.children[f], o));
                        return p;
                    case"MultiSelectHash":
                        if (null === o) return null;
                        var A;
                        for (p = {}, f = 0; f < e.children.length; f++) p[(A = e.children[f]).name] = this.visit(A.value, o);
                        return p;
                    case"OrExpression":
                        return i(s = this.visit(e.children[0], o)) && (s = this.visit(e.children[1], o)), s;
                    case"AndExpression":
                        return !0 === i(u = this.visit(e.children[0], o)) ? u : this.visit(e.children[1], o);
                    case"NotExpression":
                        return i(u = this.visit(e.children[0], o));
                    case"Literal":
                        return e.value;
                    case"Pipe":
                        return h = this.visit(e.children[0], o), this.visit(e.children[1], h);
                    case"Current":
                        return o;
                    case"Function":
                        var O = [];
                        for (f = 0; f < e.children.length; f++) O.push(this.visit(e.children[f], o));
                        return this.runtime.callFunction(e.name, O);
                    case"ExpressionReference":
                        var N = e.children[0];
                        return N.jmespathType = "Expref", N;
                    default:
                        throw new Error("Unknown node type: " + e.type)
                }
            }, computeSliceParams: function (e, t) {
                var r = t[0], n = t[1], i = t[2], o = [null, null, null];
                if (null === i) i = 1; else if (0 === i) {
                    var s = new Error("Invalid slice, step cannot be 0");
                    throw s.name = "RuntimeError", s
                }
                var a = i < 0;
                return r = null === r ? a ? e - 1 : 0 : this.capSliceRange(e, r, i), n = null === n ? a ? -1 : e : this.capSliceRange(e, n, i), o[0] = r, o[1] = n, o[2] = i, o
            }, capSliceRange: function (e, t, r) {
                return t < 0 ? (t += e) < 0 && (t = r < 0 ? -1 : 0) : t >= e && (t = r < 0 ? e - 1 : e), t
            }
        }, R.prototype = {
            callFunction: function (e, t) {
                var r = this.functionTable[e];
                if (void 0 === r) throw new Error("Unknown function: " + e + "()");
                return this._validateArgs(e, t, r._signature), r._func.call(this, t)
            }, _validateArgs: function (e, t, r) {
                var n, i, o, s;
                if (r[r.length - 1].variadic) {
                    if (t.length < r.length) throw n = 1 === r.length ? " argument" : " arguments", new Error("ArgumentError: " + e + "() takes at least" + r.length + n + " but received " + t.length)
                } else if (t.length !== r.length) throw n = 1 === r.length ? " argument" : " arguments", new Error("ArgumentError: " + e + "() takes " + r.length + n + " but received " + t.length);
                for (var a = 0; a < r.length; a++) {
                    s = !1, i = r[a].types, o = this._getTypeName(t[a]);
                    for (var c = 0; c < i.length; c++) if (this._typeMatches(o, i[c], t[a])) {
                        s = !0;
                        break
                    }
                    if (!s) throw new Error("TypeError: " + e + "() expected argument " + (a + 1) + " to be type " + i + " but received type " + o + " instead.")
                }
            }, _typeMatches: function (e, t, r) {
                if (t === a) return !0;
                if (t !== p && t !== h && t !== u) return e === t;
                if (t === u) return e === u;
                if (e === u) {
                    var n;
                    t === h ? n = s : t === p && (n = c);
                    for (var i = 0; i < r.length; i++) if (!this._typeMatches(this._getTypeName(r[i]), n, r[i])) return !1;
                    return !0
                }
            }, _getTypeName: function (e) {
                switch (Object.prototype.toString.call(e)) {
                    case"[object String]":
                        return c;
                    case"[object Number]":
                        return s;
                    case"[object Array]":
                        return u;
                    case"[object Boolean]":
                        return 5;
                    case"[object Null]":
                        return 7;
                    case"[object Object]":
                        return "Expref" === e.jmespathType ? l : d
                }
            }, _functionStartsWith: function (e) {
                return 0 === e[0].lastIndexOf(e[1])
            }, _functionEndsWith: function (e) {
                var t = e[0], r = e[1];
                return -1 !== t.indexOf(r, t.length - r.length)
            }, _functionReverse: function (e) {
                if (this._getTypeName(e[0]) === c) {
                    for (var t = e[0], r = "", n = t.length - 1; n >= 0; n--) r += t[n];
                    return r
                }
                var i = e[0].slice(0);
                return i.reverse(), i
            }, _functionAbs: function (e) {
                return Math.abs(e[0])
            }, _functionCeil: function (e) {
                return Math.ceil(e[0])
            }, _functionAvg: function (e) {
                for (var t = 0, r = e[0], n = 0; n < r.length; n++) t += r[n];
                return t / r.length
            }, _functionContains: function (e) {
                return e[0].indexOf(e[1]) >= 0
            }, _functionFloor: function (e) {
                return Math.floor(e[0])
            }, _functionLength: function (e) {
                return r(e[0]) ? Object.keys(e[0]).length : e[0].length
            }, _functionMap: function (e) {
                for (var t = [], r = this._interpreter, n = e[0], i = e[1], o = 0; o < i.length; o++) t.push(r.visit(n, i[o]));
                return t
            }, _functionMerge: function (e) {
                for (var t = {}, r = 0; r < e.length; r++) {
                    var n = e[r];
                    for (var i in n) t[i] = n[i]
                }
                return t
            }, _functionMax: function (e) {
                if (e[0].length > 0) {
                    if (this._getTypeName(e[0][0]) === s) return Math.max.apply(Math, e[0]);
                    for (var t = e[0], r = t[0], n = 1; n < t.length; n++) r.localeCompare(t[n]) < 0 && (r = t[n]);
                    return r
                }
                return null
            }, _functionMin: function (e) {
                if (e[0].length > 0) {
                    if (this._getTypeName(e[0][0]) === s) return Math.min.apply(Math, e[0]);
                    for (var t = e[0], r = t[0], n = 1; n < t.length; n++) t[n].localeCompare(r) < 0 && (r = t[n]);
                    return r
                }
                return null
            }, _functionSum: function (e) {
                for (var t = 0, r = e[0], n = 0; n < r.length; n++) t += r[n];
                return t
            }, _functionType: function (e) {
                switch (this._getTypeName(e[0])) {
                    case s:
                        return "number";
                    case c:
                        return "string";
                    case u:
                        return "array";
                    case d:
                        return "object";
                    case 5:
                        return "boolean";
                    case l:
                        return "expref";
                    case 7:
                        return "null"
                }
            }, _functionKeys: function (e) {
                return Object.keys(e[0])
            }, _functionValues: function (e) {
                for (var t = e[0], r = Object.keys(t), n = [], i = 0; i < r.length; i++) n.push(t[r[i]]);
                return n
            }, _functionJoin: function (e) {
                var t = e[0];
                return e[1].join(t)
            }, _functionToArray: function (e) {
                return this._getTypeName(e[0]) === u ? e[0] : [e[0]]
            }, _functionToString: function (e) {
                return this._getTypeName(e[0]) === c ? e[0] : JSON.stringify(e[0])
            }, _functionToNumber: function (e) {
                var t, r = this._getTypeName(e[0]);
                return r === s ? e[0] : r !== c || (t = +e[0], isNaN(t)) ? null : t
            }, _functionNotNull: function (e) {
                for (var t = 0; t < e.length; t++) if (7 !== this._getTypeName(e[t])) return e[t];
                return null
            }, _functionSort: function (e) {
                var t = e[0].slice(0);
                return t.sort(), t
            }, _functionSortBy: function (e) {
                var t = e[0].slice(0);
                if (0 === t.length) return t;
                var r = this._interpreter, n = e[1], i = this._getTypeName(r.visit(n, t[0]));
                if ([s, c].indexOf(i) < 0) throw new Error("TypeError");
                for (var o = this, a = [], u = 0; u < t.length; u++) a.push([u, t[u]]);
                a.sort(function (e, t) {
                    var s = r.visit(n, e[1]), a = r.visit(n, t[1]);
                    if (o._getTypeName(s) !== i) throw new Error("TypeError: expected " + i + ", received " + o._getTypeName(s));
                    if (o._getTypeName(a) !== i) throw new Error("TypeError: expected " + i + ", received " + o._getTypeName(a));
                    return s > a ? 1 : s < a ? -1 : e[0] - t[0]
                });
                for (var d = 0; d < a.length; d++) t[d] = a[d][1];
                return t
            }, _functionMaxBy: function (e) {
                for (var t, r, n = e[1], i = e[0], o = this.createKeyFunction(n, [s, c]), a = -1 / 0, u = 0; u < i.length; u++) (r = o(i[u])) > a && (a = r, t = i[u]);
                return t
            }, _functionMinBy: function (e) {
                for (var t, r, n = e[1], i = e[0], o = this.createKeyFunction(n, [s, c]), a = 1 / 0, u = 0; u < i.length; u++) (r = o(i[u])) < a && (a = r, t = i[u]);
                return t
            }, createKeyFunction: function (e, t) {
                var r = this, n = this._interpreter;
                return function (i) {
                    var o = n.visit(e, i);
                    if (t.indexOf(r._getTypeName(o)) < 0) {
                        var s = "TypeError: expected one of " + t + ", received " + r._getTypeName(o);
                        throw new Error(s)
                    }
                    return o
                }
            }
        }, e.tokenize = function (e) {
            return (new y).tokenize(e)
        }, e.compile = function (e) {
            return (new b).parse(e)
        }, e.search = function (e, t) {
            var r = new b, n = new R, i = new T(n);
            n._interpreter = i;
            var o = r.parse(t);
            return i.search(o, e)
        }, e.strictDeepEqual = n
    }(t)
}, function (e, t) {
}, function (e, t, r) {
    "use strict";
    var n = r(253), i = r(255);

    function o() {
        this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null
    }

    t.parse = E, t.resolve = function (e, t) {
        return E(e, !1, !0).resolve(t)
    }, t.resolveObject = function (e, t) {
        return e ? E(e, !1, !0).resolveObject(t) : t
    }, t.format = function (e) {
        i.isString(e) && (e = E(e));
        return e instanceof o ? e.format() : o.prototype.format.call(e)
    }, t.Url = o;
    var s = /^([a-z0-9.+-]+:)/i, a = /:[0-9]*$/, c = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,
        u = ["{", "}", "|", "\\", "^", "`"].concat(["<", ">", '"', "`", " ", "\r", "\n", "\t"]), d = ["'"].concat(u),
        l = ["%", "/", "?", ";", "#"].concat(d), h = ["/", "?", "#"], p = /^[+a-z0-9A-Z_-]{0,63}$/,
        f = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, m = {javascript: !0, "javascript:": !0},
        _ = {javascript: !0, "javascript:": !0}, v = {
            http: !0,
            https: !0,
            ftp: !0,
            gopher: !0,
            file: !0,
            "http:": !0,
            "https:": !0,
            "ftp:": !0,
            "gopher:": !0,
            "file:": !0
        }, g = r(129);

    function E(e, t, r) {
        if (e && i.isObject(e) && e instanceof o) return e;
        var n = new o;
        return n.parse(e, t, r), n
    }

    o.prototype.parse = function (e, t, r) {
        if (!i.isString(e)) throw new TypeError("Parameter 'url' must be a string, not " + typeof e);
        var o = e.indexOf("?"), a = -1 !== o && o < e.indexOf("#") ? "?" : "#", u = e.split(a);
        u[0] = u[0].replace(/\\/g, "/");
        var E = e = u.join(a);
        if (E = E.trim(), !r && 1 === e.split("#").length) {
            var y = c.exec(E);
            if (y) return this.path = E, this.href = E, this.pathname = y[1], y[2] ? (this.search = y[2], this.query = t ? g.parse(this.search.substr(1)) : this.search.substr(1)) : t && (this.search = "", this.query = {}), this
        }
        var S = s.exec(E);
        if (S) {
            var b = (S = S[0]).toLowerCase();
            this.protocol = b, E = E.substr(S.length)
        }
        if (r || S || E.match(/^\/\/[^@\/]+@[^@\/]+/)) {
            var T = "//" === E.substr(0, 2);
            !T || S && _[S] || (E = E.substr(2), this.slashes = !0)
        }
        if (!_[S] && (T || S && !v[S])) {
            for (var R, I, w = -1, C = 0; C < h.length; C++) {
                -1 !== (A = E.indexOf(h[C])) && (-1 === w || A < w) && (w = A)
            }
            -1 !== (I = -1 === w ? E.lastIndexOf("@") : E.lastIndexOf("@", w)) && (R = E.slice(0, I), E = E.slice(I + 1), this.auth = decodeURIComponent(R)), w = -1;
            for (C = 0; C < l.length; C++) {
                var A;
                -1 !== (A = E.indexOf(l[C])) && (-1 === w || A < w) && (w = A)
            }
            -1 === w && (w = E.length), this.host = E.slice(0, w), E = E.slice(w), this.parseHost(), this.hostname = this.hostname || "";
            var O = "[" === this.hostname[0] && "]" === this.hostname[this.hostname.length - 1];
            if (!O) for (var N = this.hostname.split(/\./), P = (C = 0, N.length); C < P; C++) {
                var D = N[C];
                if (D && !D.match(p)) {
                    for (var k = "", L = 0, x = D.length; L < x; L++) D.charCodeAt(L) > 127 ? k += "x" : k += D[L];
                    if (!k.match(p)) {
                        var M = N.slice(0, C), U = N.slice(C + 1), j = D.match(f);
                        j && (M.push(j[1]), U.unshift(j[2])), U.length && (E = "/" + U.join(".") + E), this.hostname = M.join(".");
                        break
                    }
                }
            }
            this.hostname.length > 255 ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), O || (this.hostname = n.toASCII(this.hostname));
            var V = this.port ? ":" + this.port : "", F = this.hostname || "";
            this.host = F + V, this.href += this.host, O && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), "/" !== E[0] && (E = "/" + E))
        }
        if (!m[b]) for (C = 0, P = d.length; C < P; C++) {
            var B = d[C];
            if (-1 !== E.indexOf(B)) {
                var W = encodeURIComponent(B);
                W === B && (W = escape(B)), E = E.split(B).join(W)
            }
        }
        var G = E.indexOf("#");
        -1 !== G && (this.hash = E.substr(G), E = E.slice(0, G));
        var q = E.indexOf("?");
        if (-1 !== q ? (this.search = E.substr(q), this.query = E.substr(q + 1), t && (this.query = g.parse(this.query)), E = E.slice(0, q)) : t && (this.search = "", this.query = {}), E && (this.pathname = E), v[b] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
            V = this.pathname || "";
            var H = this.search || "";
            this.path = V + H
        }
        return this.href = this.format(), this
    }, o.prototype.format = function () {
        var e = this.auth || "";
        e && (e = (e = encodeURIComponent(e)).replace(/%3A/i, ":"), e += "@");
        var t = this.protocol || "", r = this.pathname || "", n = this.hash || "", o = !1, s = "";
        this.host ? o = e + this.host : this.hostname && (o = e + (-1 === this.hostname.indexOf(":") ? this.hostname : "[" + this.hostname + "]"), this.port && (o += ":" + this.port)), this.query && i.isObject(this.query) && Object.keys(this.query).length && (s = g.stringify(this.query));
        var a = this.search || s && "?" + s || "";
        return t && ":" !== t.substr(-1) && (t += ":"), this.slashes || (!t || v[t]) && !1 !== o ? (o = "//" + (o || ""), r && "/" !== r.charAt(0) && (r = "/" + r)) : o || (o = ""), n && "#" !== n.charAt(0) && (n = "#" + n), a && "?" !== a.charAt(0) && (a = "?" + a), t + o + (r = r.replace(/[?#]/g, function (e) {
            return encodeURIComponent(e)
        })) + (a = a.replace("#", "%23")) + n
    }, o.prototype.resolve = function (e) {
        return this.resolveObject(E(e, !1, !0)).format()
    }, o.prototype.resolveObject = function (e) {
        if (i.isString(e)) {
            var t = new o;
            t.parse(e, !1, !0), e = t
        }
        for (var r = new o, n = Object.keys(this), s = 0; s < n.length; s++) {
            var a = n[s];
            r[a] = this[a]
        }
        if (r.hash = e.hash, "" === e.href) return r.href = r.format(), r;
        if (e.slashes && !e.protocol) {
            for (var c = Object.keys(e), u = 0; u < c.length; u++) {
                var d = c[u];
                "protocol" !== d && (r[d] = e[d])
            }
            return v[r.protocol] && r.hostname && !r.pathname && (r.path = r.pathname = "/"), r.href = r.format(), r
        }
        if (e.protocol && e.protocol !== r.protocol) {
            if (!v[e.protocol]) {
                for (var l = Object.keys(e), h = 0; h < l.length; h++) {
                    var p = l[h];
                    r[p] = e[p]
                }
                return r.href = r.format(), r
            }
            if (r.protocol = e.protocol, e.host || _[e.protocol]) r.pathname = e.pathname; else {
                for (var f = (e.pathname || "").split("/"); f.length && !(e.host = f.shift());) ;
                e.host || (e.host = ""), e.hostname || (e.hostname = ""), "" !== f[0] && f.unshift(""), f.length < 2 && f.unshift(""), r.pathname = f.join("/")
            }
            if (r.search = e.search, r.query = e.query, r.host = e.host || "", r.auth = e.auth, r.hostname = e.hostname || e.host, r.port = e.port, r.pathname || r.search) {
                var m = r.pathname || "", g = r.search || "";
                r.path = m + g
            }
            return r.slashes = r.slashes || e.slashes, r.href = r.format(), r
        }
        var E = r.pathname && "/" === r.pathname.charAt(0), y = e.host || e.pathname && "/" === e.pathname.charAt(0),
            S = y || E || r.host && e.pathname, b = S, T = r.pathname && r.pathname.split("/") || [],
            R = (f = e.pathname && e.pathname.split("/") || [], r.protocol && !v[r.protocol]);
        if (R && (r.hostname = "", r.port = null, r.host && ("" === T[0] ? T[0] = r.host : T.unshift(r.host)), r.host = "", e.protocol && (e.hostname = null, e.port = null, e.host && ("" === f[0] ? f[0] = e.host : f.unshift(e.host)), e.host = null), S = S && ("" === f[0] || "" === T[0])), y) r.host = e.host || "" === e.host ? e.host : r.host, r.hostname = e.hostname || "" === e.hostname ? e.hostname : r.hostname, r.search = e.search, r.query = e.query, T = f; else if (f.length) T || (T = []), T.pop(), T = T.concat(f), r.search = e.search, r.query = e.query; else if (!i.isNullOrUndefined(e.search)) {
            if (R) r.hostname = r.host = T.shift(), (O = !!(r.host && r.host.indexOf("@") > 0) && r.host.split("@")) && (r.auth = O.shift(), r.host = r.hostname = O.shift());
            return r.search = e.search, r.query = e.query, i.isNull(r.pathname) && i.isNull(r.search) || (r.path = (r.pathname ? r.pathname : "") + (r.search ? r.search : "")), r.href = r.format(), r
        }
        if (!T.length) return r.pathname = null, r.search ? r.path = "/" + r.search : r.path = null, r.href = r.format(), r;
        for (var I = T.slice(-1)[0], w = (r.host || e.host || T.length > 1) && ("." === I || ".." === I) || "" === I, C = 0, A = T.length; A >= 0; A--) "." === (I = T[A]) ? T.splice(A, 1) : ".." === I ? (T.splice(A, 1), C++) : C && (T.splice(A, 1), C--);
        if (!S && !b) for (; C--; C) T.unshift("..");
        !S || "" === T[0] || T[0] && "/" === T[0].charAt(0) || T.unshift(""), w && "/" !== T.join("/").substr(-1) && T.push("");
        var O, N = "" === T[0] || T[0] && "/" === T[0].charAt(0);
        R && (r.hostname = r.host = N ? "" : T.length ? T.shift() : "", (O = !!(r.host && r.host.indexOf("@") > 0) && r.host.split("@")) && (r.auth = O.shift(), r.host = r.hostname = O.shift()));
        return (S = S || r.host && T.length) && !N && T.unshift(""), T.length ? r.pathname = T.join("/") : (r.pathname = null, r.path = null), i.isNull(r.pathname) && i.isNull(r.search) || (r.path = (r.pathname ? r.pathname : "") + (r.search ? r.search : "")), r.auth = e.auth || r.auth, r.slashes = r.slashes || e.slashes, r.href = r.format(), r
    }, o.prototype.parseHost = function () {
        var e = this.host, t = a.exec(e);
        t && (":" !== (t = t[0]) && (this.port = t.substr(1)), e = e.substr(0, e.length - t.length)), e && (this.hostname = e)
    }
}, function (e, t, r) {
    (function (t) {
        var n = r(29), i = r(50).inherits, o = r(281), s = r(359), a = r(153), c = r(361), u = r(61), d = r(362),
            l = r(364), h = r(96);

        function p(e) {
            return e > 9 ? e : "0" + e
        }

        function f(e, t, r, n, i, o, c, d, l, h, p, f, m, _) {
            var v = e + "\n" + n + "\n" + i + "\n" + ("host:" + r.toLowerCase() + "\n") + "\nhost\n" + a(h, {asBytes: !0});
            !0 === m && console.log("canonical request: " + v + "\n");
            var g = a(v, {asBytes: !0});
            !0 === m && console.log("hashed canonical request: " + g + "\n");
            var E = "AWS4-HMAC-SHA256\n" + f + "\n" + p + "/" + d + "/" + l + "/aws4_request\n" + g;
            !0 === m && console.log("string to sign: " + E + "\n");
            var y = function (e, t, r, n) {
                var i = s(t, "AWS4" + e, {asBytes: !0}), o = s(r, i, {asBytes: !0}), a = s(n, o, {asBytes: !0});
                return s("aws4_request", a, {asBytes: !0})
            }(c, p, d, l);
            !0 === m && console.log("signing key: " + y + "\n");
            var S = s(E, y, {asBytes: !0});
            !0 === m && console.log("signature: " + S + "\n");
            var b = i + "&X-Amz-Signature=" + S;
            u(_) || (b += "&X-Amz-Security-Token=" + encodeURIComponent(_));
            var T = t + r + n + "?" + b;
            return !0 === m && console.log("url: " + T + "\n"), T
        }

        function m(e, t, r, n) {
            var i = function () {
                    var e = new Date;
                    return e.getUTCFullYear() + "" + p(e.getUTCMonth() + 1) + p(e.getUTCDate()) + "T" + p(e.getUTCHours()) + p(e.getUTCMinutes()) + p(e.getUTCSeconds()) + "Z"
                }(), o = function (e) {
                    return e.substring(0, e.indexOf("T"))
                }(i),
                s = "X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=" + t + "%2F" + o + "%2F" + e.region + "%2Fiotdevicegateway%2Faws4_request&X-Amz-Date=" + i + "&X-Amz-SignedHeaders=host",
                a = e.host;
            return u(e.port) || 443 === e.port || (a = e.host + ":" + e.port), f("GET", "wss://", a, "/mqtt", s, 0, r, e.region, "iotdevicegateway", "", o, i, e.debug, n)
        }

        function _(e) {
            var t = e.host;
            return u(e.port) || 443 === e.port || (t = e.host + ":" + e.port), "wss://" + t + "/mqtt"
        }

        function v(e) {
            var t = {}, r = {};
            return function (e, t) {
                for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.call(this, e[r], parseInt(r, 10))
            }(e.split(/\r?\n/), function (e) {
                var n = (e = e.split(/(^|\s)[;#]/)[0]).match(/^\s*\[([^\[\]]+)\]\s*$/);
                if (n) r = n[1]; else if (r) {
                    var i = e.match(/^\s*(.+?)\s*=\s*(.+?)\s*$/);
                    i && (t[r] = t[r] || {}, t[r][i[1]] = i[2])
                }
            }), t
        }

        function g(e) {
            if (!(this instanceof g)) return new g(e);
            var n = this, i = [], s = !0, a = 0, p = "oldest";
            i.length = 0;
            var f = [];
            f.length = 0;
            var E = [], y = !0;
            E.length = 0;
            var S = [];
            S.length = 0;
            var b, T, R, I, w = "inactive", C = null, A = 250, O = 1e3, N = 2e4, P = 128e3, D = null,
                k = "?SDK=JavaScript&Version=" + r(365).version;
            if (u(e) || 0 === Object.keys(e).length) throw new Error(c.INVALID_CONNECT_OPTIONS);
            if (u(e.keepalive) && (e.keepalive = 300), (u(e.enableMetrics) || !0 === e.enableMetrics) && (u(e.username) ? e.username = k : e.username += k), u(e.baseReconnectTimeMs) || (O = e.baseReconnectTimeMs), u(e.minimumConnectionTimeMs) || (N = e.minimumConnectionTimeMs), u(e.maximumReconnectTimeMs) || (P = e.maximumReconnectTimeMs), u(e.drainTimeMs) || (A = e.drainTimeMs), u(e.autoResubscribe) || (y = e.autoResubscribe), u(e.offlineQueueing) || (s = e.offlineQueueing), u(e.offlineQueueMaxSize) || (a = e.offlineQueueMaxSize), u(e.offlineQueueDropBehavior) || (p = e.offlineQueueDropBehavior), b = O, e.reconnectPeriod = b, e.fastDisconnectDetection = !0, e.resubscribe = !1, e.baseReconnectTimeMs <= 0) throw new Error(c.INVALID_RECONNECT_TIMING);
            if (P < O) throw new Error(c.INVALID_RECONNECT_TIMING);
            if (N < O) throw new Error(c.INVALID_RECONNECT_TIMING);
            if ("newest" !== p && "oldest" !== p) throw new Error(c.INVALID_OFFLINE_QUEUEING_PARAMETERS);
            if (a < 0) throw new Error(c.INVALID_OFFLINE_QUEUEING_PARAMETERS);
            if (u(e.protocol) && (e.protocol = "mqtts"), u(e.host)) throw new Error(c.INVALID_CONNECT_OPTIONS);
            if ("mqtts" === e.protocol) u(e.port) && (e.port = 8883), d(e); else if ("wss" === e.protocol || "wss-custom-auth" === e.protocol) {
                if ("wss" === e.protocol) {
                    var L;
                    if (T = u(e.accessKeyId) ? t.env.AWS_ACCESS_KEY_ID : e.accessKeyId, R = u(e.secretKey) ? t.env.AWS_SECRET_ACCESS_KEY : e.secretKey, I = u(e.sessionToken) ? t.env.AWS_SESSION_TOKEN : e.sessionToken, u(T) || u(R)) try {
                        L = u(e.filename) ? function () {
                            var e = t.env.HOME || t.env.USERPROFILE || (t.env.HOMEPATH ? (t.env.HOMEDRIVE || "C:/") + t.env.HOMEPATH : null);
                            return l.join(e, ".aws", "credentials")
                        }() : e.filename;
                        var x = e.profile || t.env.AWS_PROFILE || "default", M = v(h.readFileSync(L, "utf-8"))[x];
                        T = M.aws_access_key_id, R = M.aws_secret_access_key, I = M.aws_session_token
                    } catch (e) {
                        console.log(e), console.log("Failed to read credentials from " + L)
                    }
                    if (u(T) || u(R)) throw console.log("To connect via WebSocket/SigV4, AWS Access Key ID and AWS Secret Key must be passed either in options or as environment variables; see README.md"), new Error(c.INVALID_CONNECT_OPTIONS)
                } else if (u(e.customAuthHeaders)) throw console.log("To authenticate with a custom authorizer, you must provide the required HTTP headers; see README.md"), new Error(c.INVALID_CONNECT_OPTIONS);
                if (!u(e.host) && u(e.region)) {
                    var U = /[a-zA-Z0-9]+\.iot\.([a-z]+-[a-z]+-[0-9]+)\.amazonaws\..+/.exec(e.host);
                    if (null === U) throw console.log("Host endpoint is not valid"), new Error(c.INVALID_CONNECT_OPTIONS);
                    e.region = U[1]
                }
                u(e.port) && (e.port = 443), u(e.websocketOptions) ? e.websocketOptions = {protocol: "mqttv3.1"} : e.websocketOptions.protocol = "mqttv3.1", "wss-custom-auth" === e.protocol && (e.websocketOptions.headers = e.customAuthHeaders)
            }
            u(e) || !0 !== e.debug || (console.log(e), console.log("attempting new mqtt connection..."));
            var j = {};

            function V(e, t) {
                0 === E.filter(function (t) {
                    return t.topic === e
                }).length && E.push({topic: e, options: t})
            }

            function F(e, t) {
                var r = E.filter(function (t) {
                    return t.topic !== e
                });
                E = r
            }

            function B(e, t, r) {
                var n = null;
                !1 !== y && ("subscribe" === e ? n = V : "unsubscribe" === e && (n = F), "[object Array]" === Object.prototype.toString.call(t) ? t.forEach(function (e, t, i) {
                    n(e, r)
                }) : n(t, r))
            }

            function W() {
                return "inactive" === w
            }

            j.mqtts = r(366), j.wss = r(367);
            var G = new o.MqttClient(function (t) {
                var r, n = e.protocol;
                return "wss" === n ? (r = "" === T || "" === R ? "wss://no-credentials-available" : m(e, T, R, I), !0 === e.debug && console.log("using websockets, will connect to '" + r + "'..."), e.url = r) : "wss-custom-auth" === n && (e.url = _(e), !0 === e.debug && console.log("using websockets custom auth, will connect to '" + e.url + "'..."), n = "wss"), j[n](t, e)
            }, e);

            function q() {
                b = O, G.options.reconnectPeriod = b, D = null, w = "stable"
            }

            function H() {
                var e = S.shift();
                if (u(e)) {
                    var t = f.shift();
                    if (u(t)) {
                        var r = i.shift();
                        u(r) || G.publish(r.topic, r.message, r.options, r.callback), 0 === i.length && (clearInterval(C), C = null)
                    } else B(t.type, t.topics, t.options), "subscribe" === t.type ? u(t.callback) ? G.subscribe(t.topics, t.options) : G.subscribe(t.topics, t.options, t.callback) : "unsubscribe" === t.type && G.unsubscribe(t.topics, t.callback)
                } else u(e.callback) ? G.subscribe(e.topic, e.options) : G.subscribe(e.topic, e.options, e.callback)
            }

            G.on("connect", function (e) {
                null === D && (D = setTimeout(q, N)), w = "established", null === C && (S = E.slice(0), C = setInterval(H, A)), n.emit("connect", e)
            }), G.on("close", function (t) {
                u(t) || n.emit("error", t), u(e) || !0 !== e.debug || console.log("connection lost - will attempt reconnection in " + G.options.reconnectPeriod / 1e3 + " seconds..."), clearTimeout(D), D = null, clearInterval(C), C = null, w = "inactive", n.emit("close")
            }), G.on("reconnect", function () {
                b *= 2, b = Math.min(P, b), G.options.reconnectPeriod = b, n.emit("reconnect")
            }), G.on("offline", function () {
                n.emit("offline")
            }), G.on("error", function (e) {
                n.emit("error", e)
            }), G.on("packetsend", function (e) {
                n.emit("packetsend", e)
            }), G.on("packetreceive", function (e) {
                n.emit("packetreceive", e)
            }), G.on("message", function (e, t, r) {
                n.emit("message", e, t, r)
            }), this.publish = function (e, t, r, n) {
                !0 !== s || !W() && null === C ? !0 !== s && W() || G.publish(e, t, r, n) : function () {
                    var e = !0;
                    return a > 0 && i.length >= a && ("oldest" === p ? i.shift() : e = !1), e
                }() && i.push({topic: e, message: t, options: r, callback: n})
            }, this.subscribe = function (e, t, r) {
                W() && !1 !== y ? f.length < 50 ? f.push({
                    type: "subscribe",
                    topics: e,
                    options: t,
                    callback: r
                }) : n.emit("error", new Error("Maximum queued offline subscription reached")) : (B("subscribe", e, t), u(r) ? G.subscribe(e, t) : G.subscribe(e, t, r))
            }, this.unsubscribe = function (t, r) {
                W() && !1 !== y ? f.length < 50 && f.push({
                    type: "unsubscribe",
                    topics: t,
                    options: e,
                    callback: r
                }) : (B("unsubscribe", t), G.unsubscribe(t, r))
            }, this.end = function (e, t) {
                G.end(e, t)
            }, this.handleMessage = G.handleMessage.bind(G), G.handleMessage = function (e, t) {
                n.handleMessage(e, t)
            }, this.updateWebSocketCredentials = function (e, t, r, n) {
                T = e, R = t, I = r
            }, this.getWebsocketHeaders = function () {
                return e.websocketOptions.headers
            }, this.updateCustomAuthHeaders = function (t) {
                e.websocketOptions.headers = t
            }, this.simulateNetworkFailure = function () {
                G.stream.emit("error", new Error("simulated connection error")), G.stream.end()
            }
        }

        i(g, n.EventEmitter), e.exports = g, e.exports.DeviceClient = g, e.exports.prepareWebSocketUrl = m, e.exports.prepareWebSocketCustomAuthUrl = _
    }).call(this, r(14))
}, function (e, t) {
    e.exports = function () {
        for (var e = {}, t = 0; t < arguments.length; t++) {
            var n = arguments[t];
            for (var i in n) r.call(n, i) && (e[i] = n[i])
        }
        return e
    };
    var r = Object.prototype.hasOwnProperty
}, function (e, t, r) {
    "use strict";
    var n = r(43), i = {object: !0, function: !0, undefined: !0};
    e.exports = function (e) {
        return !!n(e) && hasOwnProperty.call(i, typeof e)
    }
}, function (e, t, r) {
    "use strict";
    e.exports = r(304)() ? Object.assign : r(305)
}, function (e, t, r) {
    "use strict";
    var n, i = r(137), o = r(91), s = r(37), a = r(30), c = r(28), u = r(324), d = r(31), l = Object.defineProperty,
        h = Object.defineProperties;
    e.exports = n = function (e, t) {
        if (!(this instanceof n)) throw new TypeError("Constructor requires 'new'");
        h(this, {
            __list__: c("w", a(e)),
            __context__: c("w", t),
            __nextIndex__: c("w", 0)
        }), t && (s(t.on), t.on("_add", this._onAdd), t.on("_delete", this._onDelete), t.on("_clear", this._onClear))
    }, delete n.prototype.constructor, h(n.prototype, o({
        _next: c(function () {
            var e;
            if (this.__list__) return this.__redo__ && void 0 !== (e = this.__redo__.shift()) ? e : this.__nextIndex__ < this.__list__.length ? this.__nextIndex__++ : void this._unBind()
        }), next: c(function () {
            return this._createResult(this._next())
        }), _createResult: c(function (e) {
            return void 0 === e ? {done: !0, value: void 0} : {done: !1, value: this._resolve(e)}
        }), _resolve: c(function (e) {
            return this.__list__[e]
        }), _unBind: c(function () {
            this.__list__ = null, delete this.__redo__, this.__context__ && (this.__context__.off("_add", this._onAdd), this.__context__.off("_delete", this._onDelete), this.__context__.off("_clear", this._onClear), this.__context__ = null)
        }), toString: c(function () {
            return "[object " + (this[d.toStringTag] || "Object") + "]"
        })
    }, u({
        _onAdd: c(function (e) {
            e >= this.__nextIndex__ || (++this.__nextIndex__, this.__redo__ ? (this.__redo__.forEach(function (t, r) {
                t >= e && (this.__redo__[r] = ++t)
            }, this), this.__redo__.push(e)) : l(this, "__redo__", c("c", [e])))
        }), _onDelete: c(function (e) {
            var t;
            e >= this.__nextIndex__ || (--this.__nextIndex__, this.__redo__ && (-1 !== (t = this.__redo__.indexOf(e)) && this.__redo__.splice(t, 1), this.__redo__.forEach(function (t, r) {
                t > e && (this.__redo__[r] = --t)
            }, this)))
        }), _onClear: c(function () {
            this.__redo__ && i.call(this.__redo__), this.__nextIndex__ = 0
        })
    }))), l(n.prototype, d.iterator, c(function () {
        return this
    }))
}, function (e, t, r) {
    "use strict";
    var n = r(355);
    e.exports = function (e, t) {
        var r;

        function i(n) {
            t.rejectUnauthorized && e.emit("error", n), r.end()
        }

        return t.port = t.port || 8883, t.host = t.hostname || t.host || "localhost", t.rejectUnauthorized = !1 !== t.rejectUnauthorized, delete t.path, (r = n.connect(t)).on("secureConnect", function () {
            t.rejectUnauthorized && !r.authorized ? r.emit("error", new Error("TLS not authorized")) : r.removeListener("error", i)
        }), r.on("error", i), r
    }
}, function (e, t, r) {
    "use strict";
    (function (t, n) {
        var i = r(56).Transform, o = r(356), s = r(358), a = r(27).Buffer;
        e.exports = function (e, r, c) {
            var u, d, l = "browser" === t.title, h = !!n.WebSocket, p = l ? function e(t, r, n) {
                if (d.bufferedAmount > m) return void setTimeout(e, _, t, r, n);
                g && "string" == typeof t && (t = a.from(t, "utf8"));
                try {
                    d.send(t)
                } catch (e) {
                    return n(e)
                }
                n()
            } : function (e, t, r) {
                if (d.readyState !== d.OPEN) return void r();
                g && "string" == typeof e && (e = a.from(e, "utf8"));
                d.send(e, r)
            };
            r && !Array.isArray(r) && "object" == typeof r && (c = r, r = null, ("string" == typeof c.protocol || Array.isArray(c.protocol)) && (r = c.protocol));
            c || (c = {});
            void 0 === c.objectMode && (c.objectMode = !(!0 === c.binary || void 0 === c.binary));
            var f = function (e, t, r) {
                var n = new i({objectMode: e.objectMode});
                return n._write = t, n._flush = r, n
            }(c, p, function (e) {
                d.close(), e()
            });
            c.objectMode || (f._writev = T);
            var m = c.browserBufferSize || 524288, _ = c.browserBufferTimeout || 1e3;
            "object" == typeof e ? d = e : (d = h && l ? new s(e, r) : new s(e, r, c)).binaryType = "arraybuffer";
            var v = void 0 === d.addEventListener;
            d.readyState === d.OPEN ? u = f : (u = u = o(void 0, void 0, c), c.objectMode || (u._writev = T), v ? d.addEventListener("open", E) : d.onopen = E);
            u.socket = d, v ? (d.addEventListener("close", y), d.addEventListener("error", S), d.addEventListener("message", b)) : (d.onclose = y, d.onerror = S, d.onmessage = b);
            f.on("close", function () {
                d.close()
            });
            var g = !c.objectMode;

            function E() {
                u.setReadable(f), u.setWritable(f), u.emit("connect")
            }

            function y() {
                u.end(), u.destroy()
            }

            function S(e) {
                u.destroy(e)
            }

            function b(e) {
                var t = e.data;
                t = t instanceof ArrayBuffer ? a.from(t) : a.from(t, "utf8"), f.push(t)
            }

            function T(e, t) {
                for (var r = new Array(e.length), n = 0; n < e.length; n++) "string" == typeof e[n].chunk ? r[n] = a.from(e[n], "utf8") : r[n] = e[n].chunk;
                this._write(a.concat(r), "binary", t)
            }

            return u
        }
    }).call(this, r(14), r(25))
}, function (e, t, r) {
    e.exports = function () {
        var e = e || function (e, t) {
            var r = {}, n = r.lib = {}, i = n.Base = function () {
                function e() {
                }

                return {
                    extend: function (t) {
                        e.prototype = this;
                        var r = new e;
                        return t && r.mixIn(t), r.hasOwnProperty("init") || (r.init = function () {
                            r.$super.init.apply(this, arguments)
                        }), r.init.prototype = r, r.$super = this, r
                    }, create: function () {
                        var e = this.extend();
                        return e.init.apply(e, arguments), e
                    }, init: function () {
                    }, mixIn: function (e) {
                        for (var t in e) e.hasOwnProperty(t) && (this[t] = e[t]);
                        e.hasOwnProperty("toString") && (this.toString = e.toString)
                    }, clone: function () {
                        return this.init.prototype.extend(this)
                    }
                }
            }(), o = n.WordArray = i.extend({
                init: function (e, t) {
                    e = this.words = e || [], this.sigBytes = void 0 != t ? t : 4 * e.length
                }, toString: function (e) {
                    return (e || a).stringify(this)
                }, concat: function (e) {
                    var t = this.words, r = e.words, n = this.sigBytes, i = e.sigBytes;
                    if (this.clamp(), n % 4) for (var o = 0; o < i; o++) {
                        var s = r[o >>> 2] >>> 24 - o % 4 * 8 & 255;
                        t[n + o >>> 2] |= s << 24 - (n + o) % 4 * 8
                    } else for (var o = 0; o < i; o += 4) t[n + o >>> 2] = r[o >>> 2];
                    return this.sigBytes += i, this
                }, clamp: function () {
                    var t = this.words, r = this.sigBytes;
                    t[r >>> 2] &= 4294967295 << 32 - r % 4 * 8, t.length = e.ceil(r / 4)
                }, clone: function () {
                    var e = i.clone.call(this);
                    return e.words = this.words.slice(0), e
                }, random: function (t) {
                    for (var r, n = [], i = function (t) {
                        var t = t, r = 987654321, n = 4294967295;
                        return function () {
                            var i = ((r = 36969 * (65535 & r) + (r >> 16) & n) << 16) + (t = 18e3 * (65535 & t) + (t >> 16) & n) & n;
                            return i /= 4294967296, (i += .5) * (e.random() > .5 ? 1 : -1)
                        }
                    }, s = 0; s < t; s += 4) {
                        var a = i(4294967296 * (r || e.random()));
                        r = 987654071 * a(), n.push(4294967296 * a() | 0)
                    }
                    return new o.init(n, t)
                }
            }), s = r.enc = {}, a = s.Hex = {
                stringify: function (e) {
                    for (var t = e.words, r = e.sigBytes, n = [], i = 0; i < r; i++) {
                        var o = t[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                        n.push((o >>> 4).toString(16)), n.push((15 & o).toString(16))
                    }
                    return n.join("")
                }, parse: function (e) {
                    for (var t = e.length, r = [], n = 0; n < t; n += 2) r[n >>> 3] |= parseInt(e.substr(n, 2), 16) << 24 - n % 8 * 4;
                    return new o.init(r, t / 2)
                }
            }, c = s.Latin1 = {
                stringify: function (e) {
                    for (var t = e.words, r = e.sigBytes, n = [], i = 0; i < r; i++) {
                        var o = t[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                        n.push(String.fromCharCode(o))
                    }
                    return n.join("")
                }, parse: function (e) {
                    for (var t = e.length, r = [], n = 0; n < t; n++) r[n >>> 2] |= (255 & e.charCodeAt(n)) << 24 - n % 4 * 8;
                    return new o.init(r, t)
                }
            }, u = s.Utf8 = {
                stringify: function (e) {
                    try {
                        return decodeURIComponent(escape(c.stringify(e)))
                    } catch (e) {
                        throw new Error("Malformed UTF-8 data")
                    }
                }, parse: function (e) {
                    return c.parse(unescape(encodeURIComponent(e)))
                }
            }, d = n.BufferedBlockAlgorithm = i.extend({
                reset: function () {
                    this._data = new o.init, this._nDataBytes = 0
                }, _append: function (e) {
                    "string" == typeof e && (e = u.parse(e)), this._data.concat(e), this._nDataBytes += e.sigBytes
                }, _process: function (t) {
                    var r = this._data, n = r.words, i = r.sigBytes, s = this.blockSize, a = 4 * s, c = i / a,
                        u = (c = t ? e.ceil(c) : e.max((0 | c) - this._minBufferSize, 0)) * s, d = e.min(4 * u, i);
                    if (u) {
                        for (var l = 0; l < u; l += s) this._doProcessBlock(n, l);
                        var h = n.splice(0, u);
                        r.sigBytes -= d
                    }
                    return new o.init(h, d)
                }, clone: function () {
                    var e = i.clone.call(this);
                    return e._data = this._data.clone(), e
                }, _minBufferSize: 0
            }), l = (n.Hasher = d.extend({
                cfg: i.extend(), init: function (e) {
                    this.cfg = this.cfg.extend(e), this.reset()
                }, reset: function () {
                    d.reset.call(this), this._doReset()
                }, update: function (e) {
                    return this._append(e), this._process(), this
                }, finalize: function (e) {
                    e && this._append(e);
                    var t = this._doFinalize();
                    return t
                }, blockSize: 16, _createHelper: function (e) {
                    return function (t, r) {
                        return new e.init(r).finalize(t)
                    }
                }, _createHmacHelper: function (e) {
                    return function (t, r) {
                        return new l.HMAC.init(e, r).finalize(t)
                    }
                }
            }), r.algo = {});
            return r
        }(Math);
        return e
    }()
}, function (e, t) {
}, function (e, t, r) {
    "use strict";
    var n = r(71), i = r(32);
    t.a = function (e, t, r) {
        var o = (e = e || {}).random || (e.rng || n.a)();
        if (o[6] = 15 & o[6] | 64, o[8] = 63 & o[8] | 128, t) {
            r = r || 0;
            for (var s = 0; s < 16; ++s) t[r + s] = o[s];
            return t
        }
        return Object(i.a)(o)
    }
}, function (e, t) {
    e.exports = function (e, t) {
        (null == t || t > e.length) && (t = e.length);
        for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
        return n
    }
}, function (e, t, r) {
    var n = r(98);
    e.exports = function (e, t) {
        if (e) {
            if ("string" == typeof e) return n(e, t);
            var r = Object.prototype.toString.call(e).slice(8, -1);
            return "Object" === r && e.constructor && (r = e.constructor.name), "Map" === r || "Set" === r ? Array.from(e) : "Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? n(e, t) : void 0
        }
    }
}, function (e, t, r) {
    "use strict";
    e.exports = function (e, t) {
        return function () {
            for (var r = new Array(arguments.length), n = 0; n < r.length; n++) r[n] = arguments[n];
            return e.apply(t, r)
        }
    }
}, function (e, t, r) {
    "use strict";
    var n = r(21), i = r(166), o = r(168), s = r(169), a = r(170), c = r(102);
    e.exports = function (e) {
        return new Promise(function (t, u) {
            var d = e.data, l = e.headers;
            n.isFormData(d) && delete l["Content-Type"];
            var h = new XMLHttpRequest;
            if (e.auth) {
                var p = e.auth.username || "", f = e.auth.password || "";
                l.Authorization = "Basic " + btoa(p + ":" + f)
            }
            if (h.open(e.method.toUpperCase(), o(e.url, e.params, e.paramsSerializer), !0), h.timeout = e.timeout, h.onreadystatechange = function () {
                if (h && 4 === h.readyState && (0 !== h.status || h.responseURL && 0 === h.responseURL.indexOf("file:"))) {
                    var r = "getAllResponseHeaders" in h ? s(h.getAllResponseHeaders()) : null, n = {
                        data: e.responseType && "text" !== e.responseType ? h.response : h.responseText,
                        status: h.status,
                        statusText: h.statusText,
                        headers: r,
                        config: e,
                        request: h
                    };
                    i(t, u, n), h = null
                }
            }, h.onerror = function () {
                u(c("Network Error", e, null, h)), h = null
            }, h.ontimeout = function () {
                u(c("timeout of " + e.timeout + "ms exceeded", e, "ECONNABORTED", h)), h = null
            }, n.isStandardBrowserEnv()) {
                var m = r(171),
                    _ = (e.withCredentials || a(e.url)) && e.xsrfCookieName ? m.read(e.xsrfCookieName) : void 0;
                _ && (l[e.xsrfHeaderName] = _)
            }
            if ("setRequestHeader" in h && n.forEach(l, function (e, t) {
                void 0 === d && "content-type" === t.toLowerCase() ? delete l[t] : h.setRequestHeader(t, e)
            }), e.withCredentials && (h.withCredentials = !0), e.responseType) try {
                h.responseType = e.responseType
            } catch (t) {
                if ("json" !== e.responseType) throw t
            }
            "function" == typeof e.onDownloadProgress && h.addEventListener("progress", e.onDownloadProgress), "function" == typeof e.onUploadProgress && h.upload && h.upload.addEventListener("progress", e.onUploadProgress), e.cancelToken && e.cancelToken.promise.then(function (e) {
                h && (h.abort(), u(e), h = null)
            }), void 0 === d && (d = null), h.send(d)
        })
    }
}, function (e, t, r) {
    "use strict";
    var n = r(167);
    e.exports = function (e, t, r, i, o) {
        var s = new Error(e);
        return n(s, t, r, i, o)
    }
}, function (e, t, r) {
    "use strict";
    e.exports = function (e) {
        return !(!e || !e.__CANCEL__)
    }
}, function (e, t, r) {
    "use strict";

    function n(e) {
        this.message = e
    }

    n.prototype.toString = function () {
        return "Cancel" + (this.message ? ": " + this.message : "")
    }, n.prototype.__CANCEL__ = !0, e.exports = n
}, function (e, t, r) {
    "use strict";
    var n = r(41);
    e.exports = function (e) {
        n.copy(e, this)
    }
}, function (e, t, r) {
    "use strict";
    e.exports = function (e, t) {
        t || (t = {}), "function" == typeof t && (t = {cmp: t});
        var r = "boolean" == typeof t.cycles && t.cycles, n = t.cmp && function (e) {
            return function (t) {
                return function (r, n) {
                    var i = {key: r, value: t[r]}, o = {key: n, value: t[n]};
                    return e(i, o)
                }
            }
        }(t.cmp), i = [];
        return function e(t) {
            if (t && t.toJSON && "function" == typeof t.toJSON && (t = t.toJSON()), void 0 !== t) {
                if ("number" == typeof t) return isFinite(t) ? "" + t : "null";
                if ("object" != typeof t) return JSON.stringify(t);
                var o, s;
                if (Array.isArray(t)) {
                    for (s = "[", o = 0; o < t.length; o++) o && (s += ","), s += e(t[o]) || "null";
                    return s + "]"
                }
                if (null === t) return "null";
                if (-1 !== i.indexOf(t)) {
                    if (r) return JSON.stringify("__cycle__");
                    throw new TypeError("Converting circular structure to JSON")
                }
                var a = i.push(t) - 1, c = Object.keys(t).sort(n && n(t));
                for (s = "", o = 0; o < c.length; o++) {
                    var u = c[o], d = e(t[u]);
                    d && (s && (s += ","), s += JSON.stringify(u) + ":" + d)
                }
                return i.splice(a, 1), "{" + s + "}"
            }
        }(e)
    }
}, function (e, t, r) {
    "use strict";
    e.exports = function (e, t, r) {
        var n = "", i = !0 === e.schema.$async, o = e.util.schemaHasRulesExcept(e.schema, e.RULES.all, "$ref"),
            s = e.self._getId(e.schema);
        if (e.opts.strictKeywords) {
            var a = e.util.schemaUnknownRules(e.schema, e.RULES.keywords);
            if (a) {
                var c = "unknown keyword: " + a;
                if ("log" !== e.opts.strictKeywords) throw new Error(c);
                e.logger.warn(c)
            }
        }
        if (e.isTop && (n += " var validate = ", i && (e.async = !0, n += "async "), n += "function(data, dataPath, parentData, parentDataProperty, rootData) { 'use strict'; ", s && (e.opts.sourceCode || e.opts.processCode) && (n += " /*# sourceURL=" + s + " */ ")), "boolean" == typeof e.schema || !o && !e.schema.$ref) {
            var u = e.level, d = e.dataLevel, l = e.schema["false schema"],
                h = e.schemaPath + e.util.getProperty("false schema"), p = e.errSchemaPath + "/false schema",
                f = !e.opts.allErrors, m = "data" + (d || ""), _ = "valid" + u;
            if (!1 === e.schema) {
                e.isTop ? f = !0 : n += " var " + _ + " = false; ", ($ = $ || []).push(n), n = "", !1 !== e.createErrors ? (n += " { keyword: '" + (y || "false schema") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(p) + " , params: {} ", !1 !== e.opts.messages && (n += " , message: 'boolean schema is false' "), e.opts.verbose && (n += " , schema: false , parentSchema: validate.schema" + e.schemaPath + " , data: " + m + " "), n += " } ") : n += " {} ";
                var v = n;
                n = $.pop(), !e.compositeRule && f ? e.async ? n += " throw new ValidationError([" + v + "]); " : n += " validate.errors = [" + v + "]; return false; " : n += " var err = " + v + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "
            } else e.isTop ? n += i ? " return data; " : " validate.errors = null; return true; " : n += " var " + _ + " = true; ";
            return e.isTop && (n += " }; return validate; "), n
        }
        if (e.isTop) {
            var g = e.isTop;
            u = e.level = 0, d = e.dataLevel = 0, m = "data";
            if (e.rootId = e.resolve.fullPath(e.self._getId(e.root.schema)), e.baseId = e.baseId || e.rootId, delete e.isTop, e.dataPathArr = [""], void 0 !== e.schema.default && e.opts.useDefaults && e.opts.strictDefaults) {
                var E = "default is ignored in the schema root";
                if ("log" !== e.opts.strictDefaults) throw new Error(E);
                e.logger.warn(E)
            }
            n += " var vErrors = null; ", n += " var errors = 0;     ", n += " if (rootData === undefined) rootData = data; "
        } else {
            u = e.level, m = "data" + ((d = e.dataLevel) || "");
            if (s && (e.baseId = e.resolve.url(e.baseId, s)), i && !e.async) throw new Error("async schema in sync schema");
            n += " var errs_" + u + " = errors;"
        }
        _ = "valid" + u, f = !e.opts.allErrors;
        var y, S = "", b = "", T = e.schema.type, R = Array.isArray(T);
        if (T && e.opts.nullable && !0 === e.schema.nullable && (R ? -1 == T.indexOf("null") && (T = T.concat("null")) : "null" != T && (T = [T, "null"], R = !0)), R && 1 == T.length && (T = T[0], R = !1), e.schema.$ref && o) {
            if ("fail" == e.opts.extendRefs) throw new Error('$ref: validation keywords used in schema at path "' + e.errSchemaPath + '" (see option extendRefs)');
            !0 !== e.opts.extendRefs && (o = !1, e.logger.warn('$ref: keywords ignored in schema at path "' + e.errSchemaPath + '"'))
        }
        if (e.schema.$comment && e.opts.$comment && (n += " " + e.RULES.all.$comment.code(e, "$comment")), T) {
            if (e.opts.coerceTypes) var I = e.util.coerceToTypes(e.opts.coerceTypes, T);
            var w = e.RULES.types[T];
            if (I || R || !0 === w || w && !Z(w)) {
                h = e.schemaPath + ".type", p = e.errSchemaPath + "/type", h = e.schemaPath + ".type", p = e.errSchemaPath + "/type";
                var C = R ? "checkDataTypes" : "checkDataType";
                if (n += " if (" + e.util[C](T, m, e.opts.strictNumbers, !0) + ") { ", I) {
                    var A = "dataType" + u, O = "coerced" + u;
                    n += " var " + A + " = typeof " + m + "; var " + O + " = undefined; ", "array" == e.opts.coerceTypes && (n += " if (" + A + " == 'object' && Array.isArray(" + m + ") && " + m + ".length == 1) { " + m + " = " + m + "[0]; " + A + " = typeof " + m + "; if (" + e.util.checkDataType(e.schema.type, m, e.opts.strictNumbers) + ") " + O + " = " + m + "; } "), n += " if (" + O + " !== undefined) ; ";
                    var N = I;
                    if (N) for (var P, D = -1, k = N.length - 1; D < k;) "string" == (P = N[D += 1]) ? n += " else if (" + A + " == 'number' || " + A + " == 'boolean') " + O + " = '' + " + m + "; else if (" + m + " === null) " + O + " = ''; " : "number" == P || "integer" == P ? (n += " else if (" + A + " == 'boolean' || " + m + " === null || (" + A + " == 'string' && " + m + " && " + m + " == +" + m + " ", "integer" == P && (n += " && !(" + m + " % 1)"), n += ")) " + O + " = +" + m + "; ") : "boolean" == P ? n += " else if (" + m + " === 'false' || " + m + " === 0 || " + m + " === null) " + O + " = false; else if (" + m + " === 'true' || " + m + " === 1) " + O + " = true; " : "null" == P ? n += " else if (" + m + " === '' || " + m + " === 0 || " + m + " === false) " + O + " = null; " : "array" == e.opts.coerceTypes && "array" == P && (n += " else if (" + A + " == 'string' || " + A + " == 'number' || " + A + " == 'boolean' || " + m + " == null) " + O + " = [" + m + "]; ");
                    n += " else {   ", ($ = $ || []).push(n), n = "", !1 !== e.createErrors ? (n += " { keyword: '" + (y || "type") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(p) + " , params: { type: '", n += R ? "" + T.join(",") : "" + T, n += "' } ", !1 !== e.opts.messages && (n += " , message: 'should be ", n += R ? "" + T.join(",") : "" + T, n += "' "), e.opts.verbose && (n += " , schema: validate.schema" + h + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + m + " "), n += " } ") : n += " {} ";
                    v = n;
                    n = $.pop(), !e.compositeRule && f ? e.async ? n += " throw new ValidationError([" + v + "]); " : n += " validate.errors = [" + v + "]; return false; " : n += " var err = " + v + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", n += " } if (" + O + " !== undefined) {  ";
                    var L = d ? "data" + (d - 1 || "") : "parentData", x = d ? e.dataPathArr[d] : "parentDataProperty";
                    n += " " + m + " = " + O + "; ", d || (n += "if (" + L + " !== undefined)"), n += " " + L + "[" + x + "] = " + O + "; } "
                } else {
                    ($ = $ || []).push(n), n = "", !1 !== e.createErrors ? (n += " { keyword: '" + (y || "type") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(p) + " , params: { type: '", n += R ? "" + T.join(",") : "" + T, n += "' } ", !1 !== e.opts.messages && (n += " , message: 'should be ", n += R ? "" + T.join(",") : "" + T, n += "' "), e.opts.verbose && (n += " , schema: validate.schema" + h + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + m + " "), n += " } ") : n += " {} ";
                    v = n;
                    n = $.pop(), !e.compositeRule && f ? e.async ? n += " throw new ValidationError([" + v + "]); " : n += " validate.errors = [" + v + "]; return false; " : n += " var err = " + v + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "
                }
                n += " } "
            }
        }
        if (e.schema.$ref && !o) n += " " + e.RULES.all.$ref.code(e, "$ref") + " ", f && (n += " } if (errors === ", n += g ? "0" : "errs_" + u, n += ") { ", b += "}"); else {
            var M = e.RULES;
            if (M) for (var U = -1, j = M.length - 1; U < j;) if (Z(w = M[U += 1])) {
                if (w.type && (n += " if (" + e.util.checkDataType(w.type, m, e.opts.strictNumbers) + ") { "), e.opts.useDefaults) if ("object" == w.type && e.schema.properties) {
                    l = e.schema.properties;
                    var V = Object.keys(l);
                    if (V) for (var F, B = -1, W = V.length - 1; B < W;) {
                        if (void 0 !== (H = l[F = V[B += 1]]).default) {
                            var G = m + e.util.getProperty(F);
                            if (e.compositeRule) {
                                if (e.opts.strictDefaults) {
                                    E = "default is ignored for: " + G;
                                    if ("log" !== e.opts.strictDefaults) throw new Error(E);
                                    e.logger.warn(E)
                                }
                            } else n += " if (" + G + " === undefined ", "empty" == e.opts.useDefaults && (n += " || " + G + " === null || " + G + " === '' "), n += " ) " + G + " = ", "shared" == e.opts.useDefaults ? n += " " + e.useDefault(H.default) + " " : n += " " + JSON.stringify(H.default) + " ", n += "; "
                        }
                    }
                } else if ("array" == w.type && Array.isArray(e.schema.items)) {
                    var q = e.schema.items;
                    if (q) {
                        D = -1;
                        for (var H, K = q.length - 1; D < K;) if (void 0 !== (H = q[D += 1]).default) {
                            G = m + "[" + D + "]";
                            if (e.compositeRule) {
                                if (e.opts.strictDefaults) {
                                    E = "default is ignored for: " + G;
                                    if ("log" !== e.opts.strictDefaults) throw new Error(E);
                                    e.logger.warn(E)
                                }
                            } else n += " if (" + G + " === undefined ", "empty" == e.opts.useDefaults && (n += " || " + G + " === null || " + G + " === '' "), n += " ) " + G + " = ", "shared" == e.opts.useDefaults ? n += " " + e.useDefault(H.default) + " " : n += " " + JSON.stringify(H.default) + " ", n += "; "
                        }
                    }
                }
                var z = w.rules;
                if (z) for (var Y, J = -1, X = z.length - 1; J < X;) if (ee(Y = z[J += 1])) {
                    var Q = Y.code(e, Y.keyword, w.type);
                    Q && (n += " " + Q + " ", f && (S += "}"))
                }
                if (f && (n += " " + S + " ", S = ""), w.type && (n += " } ", T && T === w.type && !I)) {
                    n += " else { ";
                    var $;
                    h = e.schemaPath + ".type", p = e.errSchemaPath + "/type";
                    ($ = $ || []).push(n), n = "", !1 !== e.createErrors ? (n += " { keyword: '" + (y || "type") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(p) + " , params: { type: '", n += R ? "" + T.join(",") : "" + T, n += "' } ", !1 !== e.opts.messages && (n += " , message: 'should be ", n += R ? "" + T.join(",") : "" + T, n += "' "), e.opts.verbose && (n += " , schema: validate.schema" + h + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + m + " "), n += " } ") : n += " {} ";
                    v = n;
                    n = $.pop(), !e.compositeRule && f ? e.async ? n += " throw new ValidationError([" + v + "]); " : n += " validate.errors = [" + v + "]; return false; " : n += " var err = " + v + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", n += " } "
                }
                f && (n += " if (errors === ", n += g ? "0" : "errs_" + u, n += ") { ", b += "}")
            }
        }

        function Z(e) {
            for (var t = e.rules, r = 0; r < t.length; r++) if (ee(t[r])) return !0
        }

        function ee(t) {
            return void 0 !== e.schema[t.keyword] || t.implements && function (t) {
                for (var r = t.implements, n = 0; n < r.length; n++) if (void 0 !== e.schema[r[n]]) return !0
            }(t)
        }

        return f && (n += " " + b + " "), g ? (i ? (n += " if (errors === 0) return data;           ", n += " else throw new ValidationError(vErrors); ") : (n += " validate.errors = vErrors; ", n += " return errors === 0;       "), n += " }; return validate;") : n += " var " + _ + " = errors === errs_" + u + ";", n
    }
}, function (e, t, r) {
    "use strict";
    e.exports = function (e, t, r) {
        var n, i = " ", o = e.level, s = e.dataLevel, a = e.schema[t], c = e.schemaPath + e.util.getProperty(t),
            u = e.errSchemaPath + "/" + t, d = !e.opts.allErrors, l = "data" + (s || ""),
            h = e.opts.$data && a && a.$data;
        h ? (i += " var schema" + o + " = " + e.util.getData(a.$data, s, e.dataPathArr) + "; ", n = "schema" + o) : n = a;
        var p = "maximum" == t, f = p ? "exclusiveMaximum" : "exclusiveMinimum", m = e.schema[f],
            _ = e.opts.$data && m && m.$data, v = p ? "<" : ">", g = p ? ">" : "<", E = void 0;
        if (!h && "number" != typeof a && void 0 !== a) throw new Error(t + " must be number");
        if (!_ && void 0 !== m && "number" != typeof m && "boolean" != typeof m) throw new Error(f + " must be number or boolean");
        if (_) {
            var y = e.util.getData(m.$data, s, e.dataPathArr), S = "exclusive" + o, b = "exclType" + o,
                T = "exclIsNumber" + o, R = "' + " + (C = "op" + o) + " + '";
            i += " var schemaExcl" + o + " = " + y + "; ", i += " var " + S + "; var " + b + " = typeof " + (y = "schemaExcl" + o) + "; if (" + b + " != 'boolean' && " + b + " != 'undefined' && " + b + " != 'number') { ";
            var I;
            E = f;
            (I = I || []).push(i), i = "", !1 !== e.createErrors ? (i += " { keyword: '" + (E || "_exclusiveLimit") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: {} ", !1 !== e.opts.messages && (i += " , message: '" + f + " should be boolean' "), e.opts.verbose && (i += " , schema: validate.schema" + c + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + l + " "), i += " } ") : i += " {} ";
            var w = i;
            i = I.pop(), !e.compositeRule && d ? e.async ? i += " throw new ValidationError([" + w + "]); " : i += " validate.errors = [" + w + "]; return false; " : i += " var err = " + w + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", i += " } else if ( ", h && (i += " (" + n + " !== undefined && typeof " + n + " != 'number') || "), i += " " + b + " == 'number' ? ( (" + S + " = " + n + " === undefined || " + y + " " + v + "= " + n + ") ? " + l + " " + g + "= " + y + " : " + l + " " + g + " " + n + " ) : ( (" + S + " = " + y + " === true) ? " + l + " " + g + "= " + n + " : " + l + " " + g + " " + n + " ) || " + l + " !== " + l + ") { var op" + o + " = " + S + " ? '" + v + "' : '" + v + "='; ", void 0 === a && (E = f, u = e.errSchemaPath + "/" + f, n = y, h = _)
        } else {
            R = v;
            if ((T = "number" == typeof m) && h) {
                var C = "'" + R + "'";
                i += " if ( ", h && (i += " (" + n + " !== undefined && typeof " + n + " != 'number') || "), i += " ( " + n + " === undefined || " + m + " " + v + "= " + n + " ? " + l + " " + g + "= " + m + " : " + l + " " + g + " " + n + " ) || " + l + " !== " + l + ") { "
            } else {
                T && void 0 === a ? (S = !0, E = f, u = e.errSchemaPath + "/" + f, n = m, g += "=") : (T && (n = Math[p ? "min" : "max"](m, a)), m === (!T || n) ? (S = !0, E = f, u = e.errSchemaPath + "/" + f, g += "=") : (S = !1, R += "="));
                C = "'" + R + "'";
                i += " if ( ", h && (i += " (" + n + " !== undefined && typeof " + n + " != 'number') || "), i += " " + l + " " + g + " " + n + " || " + l + " !== " + l + ") { "
            }
        }
        E = E || t, (I = I || []).push(i), i = "", !1 !== e.createErrors ? (i += " { keyword: '" + (E || "_limit") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { comparison: " + C + ", limit: " + n + ", exclusive: " + S + " } ", !1 !== e.opts.messages && (i += " , message: 'should be " + R + " ", i += h ? "' + " + n : n + "'"), e.opts.verbose && (i += " , schema:  ", i += h ? "validate.schema" + c : "" + a, i += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + l + " "), i += " } ") : i += " {} ";
        w = i;
        return i = I.pop(), !e.compositeRule && d ? e.async ? i += " throw new ValidationError([" + w + "]); " : i += " validate.errors = [" + w + "]; return false; " : i += " var err = " + w + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", i += " } ", d && (i += " else { "), i
    }
}, function (e, t, r) {
    "use strict";
    e.exports = function (e, t, r) {
        var n, i = " ", o = e.level, s = e.dataLevel, a = e.schema[t], c = e.schemaPath + e.util.getProperty(t),
            u = e.errSchemaPath + "/" + t, d = !e.opts.allErrors, l = "data" + (s || ""),
            h = e.opts.$data && a && a.$data;
        if (h ? (i += " var schema" + o + " = " + e.util.getData(a.$data, s, e.dataPathArr) + "; ", n = "schema" + o) : n = a, !h && "number" != typeof a) throw new Error(t + " must be number");
        i += "if ( ", h && (i += " (" + n + " !== undefined && typeof " + n + " != 'number') || "), i += " " + l + ".length " + ("maxItems" == t ? ">" : "<") + " " + n + ") { ";
        var p = t, f = f || [];
        f.push(i), i = "", !1 !== e.createErrors ? (i += " { keyword: '" + (p || "_limitItems") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { limit: " + n + " } ", !1 !== e.opts.messages && (i += " , message: 'should NOT have ", i += "maxItems" == t ? "more" : "fewer", i += " than ", i += h ? "' + " + n + " + '" : "" + a, i += " items' "), e.opts.verbose && (i += " , schema:  ", i += h ? "validate.schema" + c : "" + a, i += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + l + " "), i += " } ") : i += " {} ";
        var m = i;
        return i = f.pop(), !e.compositeRule && d ? e.async ? i += " throw new ValidationError([" + m + "]); " : i += " validate.errors = [" + m + "]; return false; " : i += " var err = " + m + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", i += "} ", d && (i += " else { "), i
    }
}, function (e, t, r) {
    "use strict";
    e.exports = function (e, t, r) {
        var n, i = " ", o = e.level, s = e.dataLevel, a = e.schema[t], c = e.schemaPath + e.util.getProperty(t),
            u = e.errSchemaPath + "/" + t, d = !e.opts.allErrors, l = "data" + (s || ""),
            h = e.opts.$data && a && a.$data;
        if (h ? (i += " var schema" + o + " = " + e.util.getData(a.$data, s, e.dataPathArr) + "; ", n = "schema" + o) : n = a, !h && "number" != typeof a) throw new Error(t + " must be number");
        var p = "maxLength" == t ? ">" : "<";
        i += "if ( ", h && (i += " (" + n + " !== undefined && typeof " + n + " != 'number') || "), !1 === e.opts.unicode ? i += " " + l + ".length " : i += " ucs2length(" + l + ") ", i += " " + p + " " + n + ") { ";
        var f = t, m = m || [];
        m.push(i), i = "", !1 !== e.createErrors ? (i += " { keyword: '" + (f || "_limitLength") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { limit: " + n + " } ", !1 !== e.opts.messages && (i += " , message: 'should NOT be ", i += "maxLength" == t ? "longer" : "shorter", i += " than ", i += h ? "' + " + n + " + '" : "" + a, i += " characters' "), e.opts.verbose && (i += " , schema:  ", i += h ? "validate.schema" + c : "" + a, i += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + l + " "), i += " } ") : i += " {} ";
        var _ = i;
        return i = m.pop(), !e.compositeRule && d ? e.async ? i += " throw new ValidationError([" + _ + "]); " : i += " validate.errors = [" + _ + "]; return false; " : i += " var err = " + _ + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", i += "} ", d && (i += " else { "), i
    }
}, function (e, t, r) {
    "use strict";
    e.exports = function (e, t, r) {
        var n, i = " ", o = e.level, s = e.dataLevel, a = e.schema[t], c = e.schemaPath + e.util.getProperty(t),
            u = e.errSchemaPath + "/" + t, d = !e.opts.allErrors, l = "data" + (s || ""),
            h = e.opts.$data && a && a.$data;
        if (h ? (i += " var schema" + o + " = " + e.util.getData(a.$data, s, e.dataPathArr) + "; ", n = "schema" + o) : n = a, !h && "number" != typeof a) throw new Error(t + " must be number");
        i += "if ( ", h && (i += " (" + n + " !== undefined && typeof " + n + " != 'number') || "), i += " Object.keys(" + l + ").length " + ("maxProperties" == t ? ">" : "<") + " " + n + ") { ";
        var p = t, f = f || [];
        f.push(i), i = "", !1 !== e.createErrors ? (i += " { keyword: '" + (p || "_limitProperties") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { limit: " + n + " } ", !1 !== e.opts.messages && (i += " , message: 'should NOT have ", i += "maxProperties" == t ? "more" : "fewer", i += " than ", i += h ? "' + " + n + " + '" : "" + a, i += " properties' "), e.opts.verbose && (i += " , schema:  ", i += h ? "validate.schema" + c : "" + a, i += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + l + " "), i += " } ") : i += " {} ";
        var m = i;
        return i = f.pop(), !e.compositeRule && d ? e.async ? i += " throw new ValidationError([" + m + "]); " : i += " validate.errors = [" + m + "]; return false; " : i += " var err = " + m + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", i += "} ", d && (i += " else { "), i
    }
}, function (e) {
    e.exports = JSON.parse('{"$schema":"http://json-schema.org/draft-07/schema#","$id":"http://json-schema.org/draft-07/schema#","title":"Core schema meta-schema","definitions":{"schemaArray":{"type":"array","minItems":1,"items":{"$ref":"#"}},"nonNegativeInteger":{"type":"integer","minimum":0},"nonNegativeIntegerDefault0":{"allOf":[{"$ref":"#/definitions/nonNegativeInteger"},{"default":0}]},"simpleTypes":{"enum":["array","boolean","integer","null","number","object","string"]},"stringArray":{"type":"array","items":{"type":"string"},"uniqueItems":true,"default":[]}},"type":["object","boolean"],"properties":{"$id":{"type":"string","format":"uri-reference"},"$schema":{"type":"string","format":"uri"},"$ref":{"type":"string","format":"uri-reference"},"$comment":{"type":"string"},"title":{"type":"string"},"description":{"type":"string"},"default":true,"readOnly":{"type":"boolean","default":false},"examples":{"type":"array","items":true},"multipleOf":{"type":"number","exclusiveMinimum":0},"maximum":{"type":"number"},"exclusiveMaximum":{"type":"number"},"minimum":{"type":"number"},"exclusiveMinimum":{"type":"number"},"maxLength":{"$ref":"#/definitions/nonNegativeInteger"},"minLength":{"$ref":"#/definitions/nonNegativeIntegerDefault0"},"pattern":{"type":"string","format":"regex"},"additionalItems":{"$ref":"#"},"items":{"anyOf":[{"$ref":"#"},{"$ref":"#/definitions/schemaArray"}],"default":true},"maxItems":{"$ref":"#/definitions/nonNegativeInteger"},"minItems":{"$ref":"#/definitions/nonNegativeIntegerDefault0"},"uniqueItems":{"type":"boolean","default":false},"contains":{"$ref":"#"},"maxProperties":{"$ref":"#/definitions/nonNegativeInteger"},"minProperties":{"$ref":"#/definitions/nonNegativeIntegerDefault0"},"required":{"$ref":"#/definitions/stringArray"},"additionalProperties":{"$ref":"#"},"definitions":{"type":"object","additionalProperties":{"$ref":"#"},"default":{}},"properties":{"type":"object","additionalProperties":{"$ref":"#"},"default":{}},"patternProperties":{"type":"object","additionalProperties":{"$ref":"#"},"propertyNames":{"format":"regex"},"default":{}},"dependencies":{"type":"object","additionalProperties":{"anyOf":[{"$ref":"#"},{"$ref":"#/definitions/stringArray"}]}},"propertyNames":{"$ref":"#"},"const":true,"enum":{"type":"array","items":true,"minItems":1,"uniqueItems":true},"type":{"anyOf":[{"$ref":"#/definitions/simpleTypes"},{"type":"array","items":{"$ref":"#/definitions/simpleTypes"},"minItems":1,"uniqueItems":true}]},"format":{"type":"string"},"contentMediaType":{"type":"string"},"contentEncoding":{"type":"string"},"if":{"$ref":"#"},"then":{"$ref":"#"},"else":{"$ref":"#"},"allOf":{"$ref":"#/definitions/schemaArray"},"anyOf":{"$ref":"#/definitions/schemaArray"},"oneOf":{"$ref":"#/definitions/schemaArray"},"not":{"$ref":"#"}},"default":true}')
}, function (e, t, r) {
    (function (e) {
        var n = void 0 !== e && e || "undefined" != typeof self && self || window, i = Function.prototype.apply;

        function o(e, t) {
            this._id = e, this._clearFn = t
        }

        t.setTimeout = function () {
            return new o(i.call(setTimeout, n, arguments), clearTimeout)
        }, t.setInterval = function () {
            return new o(i.call(setInterval, n, arguments), clearInterval)
        }, t.clearTimeout = t.clearInterval = function (e) {
            e && e.close()
        }, o.prototype.unref = o.prototype.ref = function () {
        }, o.prototype.close = function () {
            this._clearFn.call(n, this._id)
        }, t.enroll = function (e, t) {
            clearTimeout(e._idleTimeoutId), e._idleTimeout = t
        }, t.unenroll = function (e) {
            clearTimeout(e._idleTimeoutId), e._idleTimeout = -1
        }, t._unrefActive = t.active = function (e) {
            clearTimeout(e._idleTimeoutId);
            var t = e._idleTimeout;
            t >= 0 && (e._idleTimeoutId = setTimeout(function () {
                e._onTimeout && e._onTimeout()
            }, t))
        }, r(217), t.setImmediate = "undefined" != typeof self && self.setImmediate || void 0 !== e && e.setImmediate || this && this.setImmediate, t.clearImmediate = "undefined" != typeof self && self.clearImmediate || void 0 !== e && e.clearImmediate || this && this.clearImmediate
    }).call(this, r(25))
}, function (e, t, r) {
    var n = r(9), i = r(15), o = r(218), s = r(49), a = r(84).populateHostPrefix;
    e.exports = {
        buildRequest: function (e) {
            var t = e.service.api.operations[e.operation], r = e.httpRequest;
            r.headers["Content-Type"] = "application/x-www-form-urlencoded; charset=utf-8", r.params = {
                Version: e.service.api.apiVersion,
                Action: t.name
            }, (new o).serialize(e.params, t.input, function (e, t) {
                r.params[e] = t
            }), r.body = i.queryParamsToString(r.params), a(e)
        }, extractError: function (e) {
            var t, r = e.httpResponse.body.toString();
            if (r.match("<UnknownOperationException")) t = {
                Code: "UnknownOperation",
                Message: "Unknown operation " + e.request.operation
            }; else try {
                t = (new n.XML.Parser).parse(r)
            } catch (r) {
                t = {Code: e.httpResponse.statusCode, Message: e.httpResponse.statusMessage}
            }
            t.requestId && !e.requestId && (e.requestId = t.requestId), t.Errors && (t = t.Errors), t.Error && (t = t.Error), t.Code ? e.error = i.error(new Error, {
                code: t.Code,
                message: t.Message
            }) : e.error = i.error(new Error, {code: e.httpResponse.statusCode, message: null})
        }, extractData: function (e) {
            var t = e.request, r = t.service.api.operations[t.operation].output || {}, o = r;
            if (o.resultWrapper) {
                var a = s.create({type: "structure"});
                a.members[o.resultWrapper] = r, a.memberNames = [o.resultWrapper], i.property(r, "name", r.resultWrapper), r = a
            }
            var c = new n.XML.Parser;
            if (r && r.members && !r.members._XAMZRequestId) {
                var u = s.create({type: "string"}, {api: {protocol: "query"}}, "requestId");
                r.members._XAMZRequestId = u
            }
            var d = c.parse(e.httpResponse.body.toString(), r);
            e.requestId = d._XAMZRequestId || d.requestId, d._XAMZRequestId && delete d._XAMZRequestId, o.resultWrapper && d[o.resultWrapper] && (i.update(d, d[o.resultWrapper]), delete d[o.resultWrapper]), e.data = d
        }
    }
}, function (e, t, r) {
    var n = r(15).memoizedProperty;

    function i(e, t, r, i) {
        n(this, i(e), function () {
            return r(e, t)
        })
    }

    e.exports = function (e, t, r, n, o) {
        for (var s in n = n || String, e) Object.prototype.hasOwnProperty.call(e, s) && (i.call(this, s, e[s], r, n), o && o(s, e[s]))
    }
}, function (e, t, r) {
    var n = r(15), i = r(54), o = r(81), s = r(82), a = r(83);

    function c(e, t) {
        e.service.api.operations[e.operation].input;
        if (!e.httpRequest.headers["Content-Type"]) {
            var r = t ? "binary/octet-stream" : "application/json";
            e.httpRequest.headers["Content-Type"] = r
        }
    }

    e.exports = {
        buildRequest: function (e) {
            i.buildRequest(e), ["HEAD", "DELETE"].indexOf(e.httpRequest.method) < 0 && function (e) {
                var t = new s, r = e.service.api.operations[e.operation].input;
                if (r.payload) {
                    var n, i = r.members[r.payload];
                    if (void 0 === (n = e.params[r.payload])) return;
                    "structure" === i.type ? (e.httpRequest.body = t.build(n, i), c(e)) : (e.httpRequest.body = n, ("binary" === i.type || i.isStreaming) && c(e, !0))
                } else {
                    var o = t.build(e.params, r);
                    "{}" === o && "GET" === e.httpRequest.method || (e.httpRequest.body = o), c(e)
                }
            }(e)
        }, extractError: function (e) {
            o.extractError(e)
        }, extractData: function (e) {
            i.extractData(e);
            var t = e.request, r = t.service.api.operations[t.operation],
                s = t.service.api.operations[t.operation].output || {};
            if (r.hasEventOutput, s.payload) {
                var c = s.members[s.payload], u = e.httpResponse.body;
                if (c.isEventStream) d = new a, e.data[payload] = n.createEventStream(2 === AWS.HttpClient.streamsApiVersion ? e.httpResponse.stream : u, d, c); else if ("structure" === c.type || "list" === c.type) {
                    var d = new a;
                    e.data[s.payload] = d.parse(u, c)
                } else "binary" === c.type || c.isStreaming ? e.data[s.payload] = u : e.data[s.payload] = c.toType(u)
            } else {
                var l = e.data;
                o.extractData(e), e.data = n.merge(l, e.data)
            }
        }
    }
}, function (e, t, r) {
    var n = r(9), i = r(15), o = r(54);
    e.exports = {
        buildRequest: function (e) {
            o.buildRequest(e), ["GET", "HEAD"].indexOf(e.httpRequest.method) < 0 && function (e) {
                var t = e.service.api.operations[e.operation].input, r = new n.XML.Builder, o = e.params, s = t.payload;
                if (s) {
                    var a = t.members[s];
                    if (void 0 === (o = o[s])) return;
                    if ("structure" === a.type) {
                        var c = a.name;
                        e.httpRequest.body = r.toXML(o, a, c, !0)
                    } else e.httpRequest.body = o
                } else e.httpRequest.body = r.toXML(o, t, t.name || t.shape || i.string.upperFirst(e.operation) + "Request")
            }(e)
        }, extractError: function (e) {
            var t;
            o.extractError(e);
            try {
                t = (new n.XML.Parser).parse(e.httpResponse.body.toString())
            } catch (r) {
                t = {Code: e.httpResponse.statusCode, Message: e.httpResponse.statusMessage}
            }
            t.Errors && (t = t.Errors), t.Error && (t = t.Error), t.Code ? e.error = i.error(new Error, {
                code: t.Code,
                message: t.Message
            }) : e.error = i.error(new Error, {code: e.httpResponse.statusCode, message: null})
        }, extractData: function (e) {
            var t;
            o.extractData(e);
            var r = e.request, s = e.httpResponse.body, a = r.service.api.operations[r.operation], c = a.output,
                u = (a.hasEventOutput, c.payload);
            if (u) {
                var d = c.members[u];
                d.isEventStream ? (t = new n.XML.Parser, e.data[u] = i.createEventStream(2 === n.HttpClient.streamsApiVersion ? e.httpResponse.stream : e.httpResponse.body, t, d)) : "structure" === d.type ? (t = new n.XML.Parser, e.data[u] = t.parse(s.toString(), d)) : "binary" === d.type || d.isStreaming ? e.data[u] = s : e.data[u] = d.toType(s)
            } else if (s.length > 0) {
                var l = (t = new n.XML.Parser).parse(s.toString(), c);
                i.update(e.data, l)
            }
        }
    }
}, function (e, t, r) {
    var n = r(115), i = r(119), o = r(49), s = r(120), a = r(121), c = r(122), u = r(15), d = u.property,
        l = u.memoizedProperty;
    e.exports = function (e, t) {
        var r = this;
        e = e || {}, (t = t || {}).api = this, e.metadata = e.metadata || {};
        var h = t.serviceIdentifier;
        delete t.serviceIdentifier, d(this, "isApi", !0, !1), d(this, "apiVersion", e.metadata.apiVersion), d(this, "endpointPrefix", e.metadata.endpointPrefix), d(this, "signingName", e.metadata.signingName), d(this, "globalEndpoint", e.metadata.globalEndpoint), d(this, "signatureVersion", e.metadata.signatureVersion), d(this, "jsonVersion", e.metadata.jsonVersion), d(this, "targetPrefix", e.metadata.targetPrefix), d(this, "protocol", e.metadata.protocol), d(this, "timestampFormat", e.metadata.timestampFormat), d(this, "xmlNamespaceUri", e.metadata.xmlNamespace), d(this, "abbreviation", e.metadata.serviceAbbreviation), d(this, "fullName", e.metadata.serviceFullName), d(this, "serviceId", e.metadata.serviceId), h && c[h] && d(this, "xmlNoDefaultLists", c[h].xmlNoDefaultLists, !1), l(this, "className", function () {
            var t = e.metadata.serviceAbbreviation || e.metadata.serviceFullName;
            return t ? ("ElasticLoadBalancing" === (t = t.replace(/^Amazon|AWS\s*|\(.*|\s+|\W+/g, "")) && (t = "ELB"), t) : null
        }), d(this, "operations", new n(e.operations, t, function (e, r) {
            return new i(e, r, t)
        }, u.string.lowerFirst, function (e, t) {
            !0 === t.endpointoperation && d(r, "endpointOperation", u.string.lowerFirst(e)), t.endpointdiscovery && !r.hasRequiredEndpointDiscovery && d(r, "hasRequiredEndpointDiscovery", !0 === t.endpointdiscovery.required)
        })), d(this, "shapes", new n(e.shapes, t, function (e, r) {
            return o.create(r, t)
        })), d(this, "paginators", new n(e.paginators, t, function (e, r) {
            return new s(e, r, t)
        })), d(this, "waiters", new n(e.waiters, t, function (e, r) {
            return new a(e, r, t)
        }, u.string.lowerFirst)), t.documentation && (d(this, "documentation", e.documentation), d(this, "documentationUrl", e.documentationUrl))
    }
}, function (e, t, r) {
    var n = r(49), i = r(15), o = i.property, s = i.memoizedProperty;
    e.exports = function (e, t, r) {
        var i = this;
        r = r || {}, o(this, "name", t.name || e), o(this, "api", r.api, !1), t.http = t.http || {}, o(this, "endpoint", t.endpoint), o(this, "httpMethod", t.http.method || "POST"), o(this, "httpPath", t.http.requestUri || "/"), o(this, "authtype", t.authtype || ""), o(this, "endpointDiscoveryRequired", t.endpointdiscovery ? t.endpointdiscovery.required ? "REQUIRED" : "OPTIONAL" : "NULL"), s(this, "input", function () {
            return t.input ? n.create(t.input, r) : new n.create({type: "structure"}, r)
        }), s(this, "output", function () {
            return t.output ? n.create(t.output, r) : new n.create({type: "structure"}, r)
        }), s(this, "errors", function () {
            var e = [];
            if (!t.errors) return null;
            for (var i = 0; i < t.errors.length; i++) e.push(n.create(t.errors[i], r));
            return e
        }), s(this, "paginator", function () {
            return r.api.paginators[e]
        }), r.documentation && (o(this, "documentation", t.documentation), o(this, "documentationUrl", t.documentationUrl)), s(this, "idempotentMembers", function () {
            var e = [], t = i.input, r = t.members;
            if (!t.members) return e;
            for (var n in r) r.hasOwnProperty(n) && !0 === r[n].isIdempotent && e.push(n);
            return e
        }), s(this, "hasEventOutput", function () {
            return function (e) {
                var t = e.members, r = e.payload;
                if (!e.members) return !1;
                if (r) {
                    var n = t[r];
                    return n.isEventStream
                }
                for (var i in t) if (!t.hasOwnProperty(i) && !0 === t[i].isEventStream) return !0;
                return !1
            }(i.output)
        })
    }
}, function (e, t, r) {
    var n = r(15).property;
    e.exports = function (e, t) {
        n(this, "inputToken", t.input_token), n(this, "limitKey", t.limit_key), n(this, "moreResults", t.more_results), n(this, "outputToken", t.output_token), n(this, "resultKey", t.result_key)
    }
}, function (e, t, r) {
    var n = r(15), i = n.property;
    e.exports = function (e, t, r) {
        r = r || {}, i(this, "name", e), i(this, "api", r.api, !1), t.operation && i(this, "operation", n.string.lowerFirst(t.operation));
        var o = this;
        ["type", "description", "delay", "maxAttempts", "acceptors"].forEach(function (e) {
            var r = t[e];
            r && i(o, e, r)
        })
    }
}, function (e) {
    e.exports = JSON.parse('{"acm":{"name":"ACM","cors":true},"apigateway":{"name":"APIGateway","cors":true},"applicationautoscaling":{"prefix":"application-autoscaling","name":"ApplicationAutoScaling","cors":true},"appstream":{"name":"AppStream"},"autoscaling":{"name":"AutoScaling","cors":true},"batch":{"name":"Batch"},"budgets":{"name":"Budgets"},"clouddirectory":{"name":"CloudDirectory","versions":["2016-05-10*"]},"cloudformation":{"name":"CloudFormation","cors":true},"cloudfront":{"name":"CloudFront","versions":["2013-05-12*","2013-11-11*","2014-05-31*","2014-10-21*","2014-11-06*","2015-04-17*","2015-07-27*","2015-09-17*","2016-01-13*","2016-01-28*","2016-08-01*","2016-08-20*","2016-09-07*","2016-09-29*","2016-11-25*","2017-03-25*","2017-10-30*","2018-06-18*","2018-11-05*","2019-03-26*"],"cors":true},"cloudhsm":{"name":"CloudHSM","cors":true},"cloudsearch":{"name":"CloudSearch"},"cloudsearchdomain":{"name":"CloudSearchDomain"},"cloudtrail":{"name":"CloudTrail","cors":true},"cloudwatch":{"prefix":"monitoring","name":"CloudWatch","cors":true},"cloudwatchevents":{"prefix":"events","name":"CloudWatchEvents","versions":["2014-02-03*"],"cors":true},"cloudwatchlogs":{"prefix":"logs","name":"CloudWatchLogs","cors":true},"codebuild":{"name":"CodeBuild","cors":true},"codecommit":{"name":"CodeCommit","cors":true},"codedeploy":{"name":"CodeDeploy","cors":true},"codepipeline":{"name":"CodePipeline","cors":true},"cognitoidentity":{"prefix":"cognito-identity","name":"CognitoIdentity","cors":true},"cognitoidentityserviceprovider":{"prefix":"cognito-idp","name":"CognitoIdentityServiceProvider","cors":true},"cognitosync":{"prefix":"cognito-sync","name":"CognitoSync","cors":true},"configservice":{"prefix":"config","name":"ConfigService","cors":true},"cur":{"name":"CUR","cors":true},"datapipeline":{"name":"DataPipeline"},"devicefarm":{"name":"DeviceFarm","cors":true},"directconnect":{"name":"DirectConnect","cors":true},"directoryservice":{"prefix":"ds","name":"DirectoryService"},"discovery":{"name":"Discovery"},"dms":{"name":"DMS"},"dynamodb":{"name":"DynamoDB","cors":true},"dynamodbstreams":{"prefix":"streams.dynamodb","name":"DynamoDBStreams","cors":true},"ec2":{"name":"EC2","versions":["2013-06-15*","2013-10-15*","2014-02-01*","2014-05-01*","2014-06-15*","2014-09-01*","2014-10-01*","2015-03-01*","2015-04-15*","2015-10-01*","2016-04-01*","2016-09-15*"],"cors":true},"ecr":{"name":"ECR","cors":true},"ecs":{"name":"ECS","cors":true},"efs":{"prefix":"elasticfilesystem","name":"EFS","cors":true},"elasticache":{"name":"ElastiCache","versions":["2012-11-15*","2014-03-24*","2014-07-15*","2014-09-30*"],"cors":true},"elasticbeanstalk":{"name":"ElasticBeanstalk","cors":true},"elb":{"prefix":"elasticloadbalancing","name":"ELB","cors":true},"elbv2":{"prefix":"elasticloadbalancingv2","name":"ELBv2","cors":true},"emr":{"prefix":"elasticmapreduce","name":"EMR","cors":true},"es":{"name":"ES"},"elastictranscoder":{"name":"ElasticTranscoder","cors":true},"firehose":{"name":"Firehose","cors":true},"gamelift":{"name":"GameLift","cors":true},"glacier":{"name":"Glacier"},"health":{"name":"Health"},"iam":{"name":"IAM","cors":true},"importexport":{"name":"ImportExport"},"inspector":{"name":"Inspector","versions":["2015-08-18*"],"cors":true},"iot":{"name":"Iot","cors":true},"iotdata":{"prefix":"iot-data","name":"IotData","cors":true},"kinesis":{"name":"Kinesis","cors":true},"kinesisanalytics":{"name":"KinesisAnalytics"},"kms":{"name":"KMS","cors":true},"lambda":{"name":"Lambda","cors":true},"lexruntime":{"prefix":"runtime.lex","name":"LexRuntime","cors":true},"lightsail":{"name":"Lightsail"},"machinelearning":{"name":"MachineLearning","cors":true},"marketplacecommerceanalytics":{"name":"MarketplaceCommerceAnalytics","cors":true},"marketplacemetering":{"prefix":"meteringmarketplace","name":"MarketplaceMetering"},"mturk":{"prefix":"mturk-requester","name":"MTurk","cors":true},"mobileanalytics":{"name":"MobileAnalytics","cors":true},"opsworks":{"name":"OpsWorks","cors":true},"opsworkscm":{"name":"OpsWorksCM"},"organizations":{"name":"Organizations"},"pinpoint":{"name":"Pinpoint"},"polly":{"name":"Polly","cors":true},"rds":{"name":"RDS","versions":["2014-09-01*"],"cors":true},"redshift":{"name":"Redshift","cors":true},"rekognition":{"name":"Rekognition","cors":true},"resourcegroupstaggingapi":{"name":"ResourceGroupsTaggingAPI"},"route53":{"name":"Route53","cors":true},"route53domains":{"name":"Route53Domains","cors":true},"s3":{"name":"S3","dualstackAvailable":true,"cors":true},"s3control":{"name":"S3Control","dualstackAvailable":true,"xmlNoDefaultLists":true},"servicecatalog":{"name":"ServiceCatalog","cors":true},"ses":{"prefix":"email","name":"SES","cors":true},"shield":{"name":"Shield"},"simpledb":{"prefix":"sdb","name":"SimpleDB"},"sms":{"name":"SMS"},"snowball":{"name":"Snowball"},"sns":{"name":"SNS","cors":true},"sqs":{"name":"SQS","cors":true},"ssm":{"name":"SSM","cors":true},"storagegateway":{"name":"StorageGateway","cors":true},"stepfunctions":{"prefix":"states","name":"StepFunctions"},"sts":{"name":"STS","cors":true},"support":{"name":"Support"},"swf":{"name":"SWF"},"xray":{"name":"XRay","cors":true},"waf":{"name":"WAF","cors":true},"wafregional":{"prefix":"waf-regional","name":"WAFRegional"},"workdocs":{"name":"WorkDocs","cors":true},"workspaces":{"name":"WorkSpaces"},"codestar":{"name":"CodeStar"},"lexmodelbuildingservice":{"prefix":"lex-models","name":"LexModelBuildingService","cors":true},"marketplaceentitlementservice":{"prefix":"entitlement.marketplace","name":"MarketplaceEntitlementService"},"athena":{"name":"Athena"},"greengrass":{"name":"Greengrass"},"dax":{"name":"DAX"},"migrationhub":{"prefix":"AWSMigrationHub","name":"MigrationHub"},"cloudhsmv2":{"name":"CloudHSMV2"},"glue":{"name":"Glue"},"mobile":{"name":"Mobile"},"pricing":{"name":"Pricing","cors":true},"costexplorer":{"prefix":"ce","name":"CostExplorer","cors":true},"mediaconvert":{"name":"MediaConvert"},"medialive":{"name":"MediaLive"},"mediapackage":{"name":"MediaPackage"},"mediastore":{"name":"MediaStore"},"mediastoredata":{"prefix":"mediastore-data","name":"MediaStoreData","cors":true},"appsync":{"name":"AppSync"},"guardduty":{"name":"GuardDuty"},"mq":{"name":"MQ"},"comprehend":{"name":"Comprehend","cors":true},"iotjobsdataplane":{"prefix":"iot-jobs-data","name":"IoTJobsDataPlane"},"kinesisvideoarchivedmedia":{"prefix":"kinesis-video-archived-media","name":"KinesisVideoArchivedMedia","cors":true},"kinesisvideomedia":{"prefix":"kinesis-video-media","name":"KinesisVideoMedia","cors":true},"kinesisvideo":{"name":"KinesisVideo","cors":true},"sagemakerruntime":{"prefix":"runtime.sagemaker","name":"SageMakerRuntime"},"sagemaker":{"name":"SageMaker"},"translate":{"name":"Translate","cors":true},"resourcegroups":{"prefix":"resource-groups","name":"ResourceGroups","cors":true},"alexaforbusiness":{"name":"AlexaForBusiness"},"cloud9":{"name":"Cloud9"},"serverlessapplicationrepository":{"prefix":"serverlessrepo","name":"ServerlessApplicationRepository"},"servicediscovery":{"name":"ServiceDiscovery"},"workmail":{"name":"WorkMail"},"autoscalingplans":{"prefix":"autoscaling-plans","name":"AutoScalingPlans"},"transcribeservice":{"prefix":"transcribe","name":"TranscribeService"},"connect":{"name":"Connect","cors":true},"acmpca":{"prefix":"acm-pca","name":"ACMPCA"},"fms":{"name":"FMS"},"secretsmanager":{"name":"SecretsManager","cors":true},"iotanalytics":{"name":"IoTAnalytics","cors":true},"iot1clickdevicesservice":{"prefix":"iot1click-devices","name":"IoT1ClickDevicesService"},"iot1clickprojects":{"prefix":"iot1click-projects","name":"IoT1ClickProjects"},"pi":{"name":"PI"},"neptune":{"name":"Neptune"},"mediatailor":{"name":"MediaTailor"},"eks":{"name":"EKS"},"macie":{"name":"Macie"},"dlm":{"name":"DLM"},"signer":{"name":"Signer"},"chime":{"name":"Chime"},"pinpointemail":{"prefix":"pinpoint-email","name":"PinpointEmail"},"ram":{"name":"RAM"},"route53resolver":{"name":"Route53Resolver"},"pinpointsmsvoice":{"prefix":"sms-voice","name":"PinpointSMSVoice"},"quicksight":{"name":"QuickSight"},"rdsdataservice":{"prefix":"rds-data","name":"RDSDataService"},"amplify":{"name":"Amplify"},"datasync":{"name":"DataSync"},"robomaker":{"name":"RoboMaker"},"transfer":{"name":"Transfer"},"globalaccelerator":{"name":"GlobalAccelerator"},"comprehendmedical":{"name":"ComprehendMedical","cors":true},"kinesisanalyticsv2":{"name":"KinesisAnalyticsV2"},"mediaconnect":{"name":"MediaConnect"},"fsx":{"name":"FSx"},"securityhub":{"name":"SecurityHub"},"appmesh":{"name":"AppMesh","versions":["2018-10-01*"]},"licensemanager":{"prefix":"license-manager","name":"LicenseManager"},"kafka":{"name":"Kafka"},"apigatewaymanagementapi":{"name":"ApiGatewayManagementApi"},"apigatewayv2":{"name":"ApiGatewayV2"},"docdb":{"name":"DocDB"},"backup":{"name":"Backup"},"worklink":{"name":"WorkLink"},"textract":{"name":"Textract"},"managedblockchain":{"name":"ManagedBlockchain"},"mediapackagevod":{"prefix":"mediapackage-vod","name":"MediaPackageVod"},"groundstation":{"name":"GroundStation"},"iotthingsgraph":{"name":"IoTThingsGraph"},"iotevents":{"name":"IoTEvents"},"ioteventsdata":{"prefix":"iotevents-data","name":"IoTEventsData"},"personalize":{"name":"Personalize","cors":true},"personalizeevents":{"prefix":"personalize-events","name":"PersonalizeEvents","cors":true},"personalizeruntime":{"prefix":"personalize-runtime","name":"PersonalizeRuntime","cors":true},"applicationinsights":{"prefix":"application-insights","name":"ApplicationInsights"},"servicequotas":{"prefix":"service-quotas","name":"ServiceQuotas"},"ec2instanceconnect":{"prefix":"ec2-instance-connect","name":"EC2InstanceConnect"},"eventbridge":{"name":"EventBridge"},"lakeformation":{"name":"LakeFormation"},"forecastservice":{"prefix":"forecast","name":"ForecastService","cors":true},"forecastqueryservice":{"prefix":"forecastquery","name":"ForecastQueryService","cors":true},"qldb":{"name":"QLDB"},"qldbsession":{"prefix":"qldb-session","name":"QLDBSession"},"workmailmessageflow":{"name":"WorkMailMessageFlow"},"codestarnotifications":{"prefix":"codestar-notifications","name":"CodeStarNotifications"},"savingsplans":{"name":"SavingsPlans"},"sso":{"name":"SSO"},"ssooidc":{"prefix":"sso-oidc","name":"SSOOIDC"},"marketplacecatalog":{"prefix":"marketplace-catalog","name":"MarketplaceCatalog"},"dataexchange":{"name":"DataExchange"},"sesv2":{"name":"SESV2"},"migrationhubconfig":{"prefix":"migrationhub-config","name":"MigrationHubConfig"},"connectparticipant":{"name":"ConnectParticipant"},"appconfig":{"name":"AppConfig"},"iotsecuretunneling":{"name":"IoTSecureTunneling"},"wafv2":{"name":"WAFV2"},"elasticinference":{"prefix":"elastic-inference","name":"ElasticInference"},"imagebuilder":{"name":"Imagebuilder"},"schemas":{"name":"Schemas"},"accessanalyzer":{"name":"AccessAnalyzer"},"codegurureviewer":{"prefix":"codeguru-reviewer","name":"CodeGuruReviewer"},"codeguruprofiler":{"name":"CodeGuruProfiler"},"computeoptimizer":{"prefix":"compute-optimizer","name":"ComputeOptimizer"},"frauddetector":{"name":"FraudDetector"},"kendra":{"name":"Kendra"},"networkmanager":{"name":"NetworkManager"},"outposts":{"name":"Outposts"},"augmentedairuntime":{"prefix":"sagemaker-a2i-runtime","name":"AugmentedAIRuntime"},"ebs":{"name":"EBS"},"kinesisvideosignalingchannels":{"prefix":"kinesis-video-signaling","name":"KinesisVideoSignalingChannels","cors":true},"detective":{"name":"Detective"},"codestarconnections":{"prefix":"codestar-connections","name":"CodeStarconnections"},"synthetics":{"name":"Synthetics"},"iotsitewise":{"name":"IoTSiteWise"},"macie2":{"name":"Macie2"},"codeartifact":{"name":"CodeArtifact"},"honeycode":{"name":"Honeycode"},"ivs":{"name":"IVS"},"braket":{"name":"Braket"},"identitystore":{"name":"IdentityStore"},"appflow":{"name":"Appflow"},"redshiftdata":{"prefix":"redshift-data","name":"RedshiftData"},"ssoadmin":{"prefix":"sso-admin","name":"SSOAdmin"},"timestreamquery":{"prefix":"timestream-query","name":"TimestreamQuery"},"timestreamwrite":{"prefix":"timestream-write","name":"TimestreamWrite"},"s3outposts":{"name":"S3Outposts"},"databrew":{"name":"DataBrew"},"servicecatalogappregistry":{"prefix":"servicecatalog-appregistry","name":"ServiceCatalogAppRegistry"},"networkfirewall":{"prefix":"network-firewall","name":"NetworkFirewall"},"mwaa":{"name":"MWAA"},"amplifybackend":{"name":"AmplifyBackend"},"appintegrations":{"name":"AppIntegrations"},"connectcontactlens":{"prefix":"connect-contact-lens","name":"ConnectContactLens"},"devopsguru":{"prefix":"devops-guru","name":"DevOpsGuru"},"ecrpublic":{"prefix":"ecr-public","name":"ECRPUBLIC"},"lookoutvision":{"name":"LookoutVision"},"sagemakerfeaturestoreruntime":{"prefix":"sagemaker-featurestore-runtime","name":"SageMakerFeatureStoreRuntime"},"customerprofiles":{"prefix":"customer-profiles","name":"CustomerProfiles"}}')
}, function (e, t, r) {
    var n = r(9);
    n.SequentialExecutor = n.util.inherit({
        constructor: function () {
            this._events = {}
        }, listeners: function (e) {
            return this._events[e] ? this._events[e].slice(0) : []
        }, on: function (e, t, r) {
            return this._events[e] ? r ? this._events[e].unshift(t) : this._events[e].push(t) : this._events[e] = [t], this
        }, onAsync: function (e, t, r) {
            return t._isAsync = !0, this.on(e, t, r)
        }, removeListener: function (e, t) {
            var r = this._events[e];
            if (r) {
                for (var n = r.length, i = -1, o = 0; o < n; ++o) r[o] === t && (i = o);
                i > -1 && r.splice(i, 1)
            }
            return this
        }, removeAllListeners: function (e) {
            return e ? delete this._events[e] : this._events = {}, this
        }, emit: function (e, t, r) {
            r || (r = function () {
            });
            var n = this.listeners(e), i = n.length;
            return this.callListeners(n, t, r), i > 0
        }, callListeners: function (e, t, r, i) {
            var o = this, s = i || null;

            function a(i) {
                if (i && (s = n.util.error(s || new Error, i), o._haltHandlersOnError)) return r.call(o, s);
                o.callListeners(e, t, r, s)
            }

            for (; e.length > 0;) {
                var c = e.shift();
                if (c._isAsync) return void c.apply(o, t.concat([a]));
                try {
                    c.apply(o, t)
                } catch (e) {
                    s = n.util.error(s || new Error, e)
                }
                if (s && o._haltHandlersOnError) return void r.call(o, s)
            }
            r.call(o, s)
        }, addListeners: function (e) {
            var t = this;
            return e._events && (e = e._events), n.util.each(e, function (e, r) {
                "function" == typeof r && (r = [r]), n.util.arrayEach(r, function (r) {
                    t.on(e, r)
                })
            }), t
        }, addNamedListener: function (e, t, r, n) {
            return this[e] = r, this.addListener(t, r, n), this
        }, addNamedAsyncListener: function (e, t, r, n) {
            return r._isAsync = !0, this.addNamedListener(e, t, r, n)
        }, addNamedListeners: function (e) {
            var t = this;
            return e(function () {
                t.addNamedListener.apply(t, arguments)
            }, function () {
                t.addNamedAsyncListener.apply(t, arguments)
            }), this
        }
    }), n.SequentialExecutor.prototype.addListener = n.SequentialExecutor.prototype.on, e.exports = n.SequentialExecutor
}, function (e, t, r) {
    var n = r(9);
    n.Credentials = n.util.inherit({
        constructor: function () {
            if (n.util.hideProperties(this, ["secretAccessKey"]), this.expired = !1, this.expireTime = null, this.refreshCallbacks = [], 1 === arguments.length && "object" == typeof arguments[0]) {
                var e = arguments[0].credentials || arguments[0];
                this.accessKeyId = e.accessKeyId, this.secretAccessKey = e.secretAccessKey, this.sessionToken = e.sessionToken
            } else this.accessKeyId = arguments[0], this.secretAccessKey = arguments[1], this.sessionToken = arguments[2]
        }, expiryWindow: 15, needsRefresh: function () {
            var e = n.util.date.getDate().getTime(), t = new Date(e + 1e3 * this.expiryWindow);
            return !!(this.expireTime && t > this.expireTime) || (this.expired || !this.accessKeyId || !this.secretAccessKey)
        }, get: function (e) {
            var t = this;
            this.needsRefresh() ? this.refresh(function (r) {
                r || (t.expired = !1), e && e(r)
            }) : e && e()
        }, refresh: function (e) {
            this.expired = !1, e()
        }, coalesceRefresh: function (e, t) {
            var r = this;
            1 === r.refreshCallbacks.push(e) && r.load(function (e) {
                n.util.arrayEach(r.refreshCallbacks, function (r) {
                    t ? r(e) : n.util.defer(function () {
                        r(e)
                    })
                }), r.refreshCallbacks.length = 0
            })
        }, load: function (e) {
            e()
        }
    }), n.Credentials.addPromisesToClass = function (e) {
        this.prototype.getPromise = n.util.promisifyMethod("get", e), this.prototype.refreshPromise = n.util.promisifyMethod("refresh", e)
    }, n.Credentials.deletePromisesFromClass = function () {
        delete this.prototype.getPromise, delete this.prototype.refreshPromise
    }, n.util.addPromises(n.Credentials)
}, function (e, t, r) {
    var n = r(9);
    n.CredentialProviderChain = n.util.inherit(n.Credentials, {
        constructor: function (e) {
            this.providers = e || n.CredentialProviderChain.defaultProviders.slice(0), this.resolveCallbacks = []
        }, resolve: function (e) {
            var t = this;
            if (0 === t.providers.length) return e(new Error("No providers")), t;
            if (1 === t.resolveCallbacks.push(e)) {
                var r = 0, i = t.providers.slice(0);
                !function e(o, s) {
                    if (!o && s || r === i.length) return n.util.arrayEach(t.resolveCallbacks, function (e) {
                        e(o, s)
                    }), void (t.resolveCallbacks.length = 0);
                    var a = i[r++];
                    (s = "function" == typeof a ? a.call() : a).get ? s.get(function (t) {
                        e(t, t ? null : s)
                    }) : e(null, s)
                }()
            }
            return t
        }
    }), n.CredentialProviderChain.defaultProviders = [], n.CredentialProviderChain.addPromisesToClass = function (e) {
        this.prototype.resolvePromise = n.util.promisifyMethod("resolve", e)
    }, n.CredentialProviderChain.deletePromisesFromClass = function () {
        delete this.prototype.resolvePromise
    }, n.util.addPromises(n.CredentialProviderChain)
}, function (e, t, r) {
    var n = r(9), i = n.util.inherit;
    n.Endpoint = i({
        constructor: function (e, t) {
            if (n.util.hideProperties(this, ["slashes", "auth", "hash", "search", "query"]), void 0 === e || null === e) throw new Error("Invalid endpoint: " + e);
            if ("string" != typeof e) return n.util.copy(e);
            e.match(/^http/) || (e = ((t && void 0 !== t.sslEnabled ? t.sslEnabled : n.config.sslEnabled) ? "https" : "http") + "://" + e);
            n.util.update(this, n.util.urlParse(e)), this.port ? this.port = parseInt(this.port, 10) : this.port = "https:" === this.protocol ? 443 : 80
        }
    }), n.HttpRequest = i({
        constructor: function (e, t) {
            e = new n.Endpoint(e), this.method = "POST", this.path = e.path || "/", this.headers = {}, this.body = "", this.endpoint = e, this.region = t, this._userAgent = "", this.setUserAgent()
        }, setUserAgent: function () {
            this._userAgent = this.headers[this.getUserAgentHeaderName()] = n.util.userAgent()
        }, getUserAgentHeaderName: function () {
            return (n.util.isBrowser() ? "X-Amz-" : "") + "User-Agent"
        }, appendToUserAgent: function (e) {
            "string" == typeof e && e && (this._userAgent += " " + e), this.headers[this.getUserAgentHeaderName()] = this._userAgent
        }, getUserAgent: function () {
            return this._userAgent
        }, pathname: function () {
            return this.path.split("?", 1)[0]
        }, search: function () {
            var e = this.path.split("?", 2)[1];
            return e ? (e = n.util.queryStringParse(e), n.util.queryParamsToString(e)) : ""
        }, updateEndpoint: function (e) {
            var t = new n.Endpoint(e);
            this.endpoint = t, this.path = t.path || "/", this.headers.Host && (this.headers.Host = t.host)
        }
    }), n.HttpResponse = i({
        constructor: function () {
            this.statusCode = void 0, this.headers = {}, this.body = void 0, this.streaming = !1, this.stream = null
        }, createUnbufferedStream: function () {
            return this.streaming = !0, this.stream
        }
    }), n.HttpClient = i({}), n.HttpClient.getInstance = function () {
        return void 0 === this.singleton && (this.singleton = new this), this.singleton
    }
}, function (e, t, r) {
    var n = r(9), i = n.util.inherit;
    n.Signers.V3 = i(n.Signers.RequestSigner, {
        addAuthorization: function (e, t) {
            var r = n.util.date.rfc822(t);
            this.request.headers["X-Amz-Date"] = r, e.sessionToken && (this.request.headers["x-amz-security-token"] = e.sessionToken), this.request.headers["X-Amzn-Authorization"] = this.authorization(e, r)
        }, authorization: function (e) {
            return "AWS3 AWSAccessKeyId=" + e.accessKeyId + ",Algorithm=HmacSHA256,SignedHeaders=" + this.signedHeaders() + ",Signature=" + this.signature(e)
        }, signedHeaders: function () {
            var e = [];
            return n.util.arrayEach(this.headersToSign(), function (t) {
                e.push(t.toLowerCase())
            }), e.sort().join(";")
        }, canonicalHeaders: function () {
            var e = this.request.headers, t = [];
            return n.util.arrayEach(this.headersToSign(), function (r) {
                t.push(r.toLowerCase().trim() + ":" + String(e[r]).trim())
            }), t.sort().join("\n") + "\n"
        }, headersToSign: function () {
            var e = [];
            return n.util.each(this.request.headers, function (t) {
                ("Host" === t || "Content-Encoding" === t || t.match(/^X-Amz/i)) && e.push(t)
            }), e
        }, signature: function (e) {
            return n.util.crypto.hmac(e.secretAccessKey, this.stringToSign(), "base64")
        }, stringToSign: function () {
            var e = [];
            return e.push(this.request.method), e.push("/"), e.push(""), e.push(this.canonicalHeaders()), e.push(this.request.body), n.util.crypto.sha256(e.join("\n"))
        }
    }), e.exports = n.Signers.V3
}, function (e, t) {
    var r = {}.toString;
    e.exports = Array.isArray || function (e) {
        return "[object Array]" == r.call(e)
    }
}, function (e, t, r) {
    "use strict";
    t.decode = t.parse = r(256), t.encode = t.stringify = r(257)
}, function (e, t, r) {
    "use strict";
    (function (t) {
        var n = r(89), i = r(56).Readable, o = {objectMode: !0}, s = {clean: !0}, a = r(288);

        function c(e) {
            if (!(this instanceof c)) return new c(e);
            this.options = e || {}, this.options = n(s, e), this._inflights = new a
        }

        c.prototype.put = function (e, t) {
            return this._inflights.set(e.messageId, e), t && t(), this
        }, c.prototype.createStream = function () {
            var e = new i(o), r = !1, n = [], s = 0;
            return this._inflights.forEach(function (e, t) {
                n.push(e)
            }), e._read = function () {
                !r && s < n.length ? this.push(n[s++]) : this.push(null)
            }, e.destroy = function () {
                if (!r) {
                    var e = this;
                    r = !0, t.nextTick(function () {
                        e.emit("close")
                    })
                }
            }, e
        }, c.prototype.del = function (e, t) {
            return (e = this._inflights.get(e.messageId)) ? (this._inflights.delete(e.messageId), t(null, e)) : t && t(new Error("missing packet")), this
        }, c.prototype.get = function (e, t) {
            return (e = this._inflights.get(e.messageId)) ? t(null, e) : t && t(new Error("missing packet")), this
        }, c.prototype.close = function (e) {
            this.options.clean && (this._inflights = null), e && e()
        }, e.exports = c
    }).call(this, r(14))
}, function (e, t, r) {
    "use strict";
    (function (t, n) {
        var i = r(52);
        e.exports = E;
        var o, s = r(128);
        E.ReadableState = g;
        r(29).EventEmitter;
        var a = function (e, t) {
            return e.listeners(t).length
        }, c = r(132), u = r(27).Buffer, d = t.Uint8Array || function () {
        };
        var l = Object.create(r(53));
        l.inherits = r(26);
        var h = r(283), p = void 0;
        p = h && h.debuglog ? h.debuglog("stream") : function () {
        };
        var f, m = r(284), _ = r(133);
        l.inherits(E, c);
        var v = ["error", "close", "destroy", "pause", "resume"];

        function g(e, t) {
            o = o || r(36), e = e || {};
            var n = t instanceof o;
            this.objectMode = !!e.objectMode, n && (this.objectMode = this.objectMode || !!e.readableObjectMode);
            var i = e.highWaterMark, s = e.readableHighWaterMark, a = this.objectMode ? 16 : 16384;
            this.highWaterMark = i || 0 === i ? i : n && (s || 0 === s) ? s : a, this.highWaterMark = Math.floor(this.highWaterMark), this.buffer = new m, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.destroyed = !1, this.defaultEncoding = e.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, e.encoding && (f || (f = r(135).StringDecoder), this.decoder = new f(e.encoding), this.encoding = e.encoding)
        }

        function E(e) {
            if (o = o || r(36), !(this instanceof E)) return new E(e);
            this._readableState = new g(e, this), this.readable = !0, e && ("function" == typeof e.read && (this._read = e.read), "function" == typeof e.destroy && (this._destroy = e.destroy)), c.call(this)
        }

        function y(e, t, r, n, i) {
            var o, s = e._readableState;
            null === t ? (s.reading = !1, function (e, t) {
                if (t.ended) return;
                if (t.decoder) {
                    var r = t.decoder.end();
                    r && r.length && (t.buffer.push(r), t.length += t.objectMode ? 1 : r.length)
                }
                t.ended = !0, R(e)
            }(e, s)) : (i || (o = function (e, t) {
                var r;
                (function (e) {
                    return u.isBuffer(e) || e instanceof d
                })(t) || "string" == typeof t || void 0 === t || e.objectMode || (r = new TypeError("Invalid non-string/buffer chunk"));
                return r
            }(s, t)), o ? e.emit("error", o) : s.objectMode || t && t.length > 0 ? ("string" == typeof t || s.objectMode || Object.getPrototypeOf(t) === u.prototype || (t = function (e) {
                return u.from(e)
            }(t)), n ? s.endEmitted ? e.emit("error", new Error("stream.unshift() after end event")) : S(e, s, t, !0) : s.ended ? e.emit("error", new Error("stream.push() after EOF")) : (s.reading = !1, s.decoder && !r ? (t = s.decoder.write(t), s.objectMode || 0 !== t.length ? S(e, s, t, !1) : w(e, s)) : S(e, s, t, !1))) : n || (s.reading = !1));
            return function (e) {
                return !e.ended && (e.needReadable || e.length < e.highWaterMark || 0 === e.length)
            }(s)
        }

        function S(e, t, r, n) {
            t.flowing && 0 === t.length && !t.sync ? (e.emit("data", r), e.read(0)) : (t.length += t.objectMode ? 1 : r.length, n ? t.buffer.unshift(r) : t.buffer.push(r), t.needReadable && R(e)), w(e, t)
        }

        Object.defineProperty(E.prototype, "destroyed", {
            get: function () {
                return void 0 !== this._readableState && this._readableState.destroyed
            }, set: function (e) {
                this._readableState && (this._readableState.destroyed = e)
            }
        }), E.prototype.destroy = _.destroy, E.prototype._undestroy = _.undestroy, E.prototype._destroy = function (e, t) {
            this.push(null), t(e)
        }, E.prototype.push = function (e, t) {
            var r, n = this._readableState;
            return n.objectMode ? r = !0 : "string" == typeof e && ((t = t || n.defaultEncoding) !== n.encoding && (e = u.from(e, t), t = ""), r = !0), y(this, e, t, !1, r)
        }, E.prototype.unshift = function (e) {
            return y(this, e, null, !0, !1)
        }, E.prototype.isPaused = function () {
            return !1 === this._readableState.flowing
        }, E.prototype.setEncoding = function (e) {
            return f || (f = r(135).StringDecoder), this._readableState.decoder = new f(e), this._readableState.encoding = e, this
        };
        var b = 8388608;

        function T(e, t) {
            return e <= 0 || 0 === t.length && t.ended ? 0 : t.objectMode ? 1 : e != e ? t.flowing && t.length ? t.buffer.head.data.length : t.length : (e > t.highWaterMark && (t.highWaterMark = function (e) {
                return e >= b ? e = b : (e--, e |= e >>> 1, e |= e >>> 2, e |= e >>> 4, e |= e >>> 8, e |= e >>> 16, e++), e
            }(e)), e <= t.length ? e : t.ended ? t.length : (t.needReadable = !0, 0))
        }

        function R(e) {
            var t = e._readableState;
            t.needReadable = !1, t.emittedReadable || (p("emitReadable", t.flowing), t.emittedReadable = !0, t.sync ? i.nextTick(I, e) : I(e))
        }

        function I(e) {
            p("emit readable"), e.emit("readable"), N(e)
        }

        function w(e, t) {
            t.readingMore || (t.readingMore = !0, i.nextTick(C, e, t))
        }

        function C(e, t) {
            for (var r = t.length; !t.reading && !t.flowing && !t.ended && t.length < t.highWaterMark && (p("maybeReadMore read 0"), e.read(0), r !== t.length);) r = t.length;
            t.readingMore = !1
        }

        function A(e) {
            p("readable nexttick read 0"), e.read(0)
        }

        function O(e, t) {
            t.reading || (p("resume read 0"), e.read(0)), t.resumeScheduled = !1, t.awaitDrain = 0, e.emit("resume"), N(e), t.flowing && !t.reading && e.read(0)
        }

        function N(e) {
            var t = e._readableState;
            for (p("flow", t.flowing); t.flowing && null !== e.read();) ;
        }

        function P(e, t) {
            return 0 === t.length ? null : (t.objectMode ? r = t.buffer.shift() : !e || e >= t.length ? (r = t.decoder ? t.buffer.join("") : 1 === t.buffer.length ? t.buffer.head.data : t.buffer.concat(t.length), t.buffer.clear()) : r = function (e, t, r) {
                var n;
                e < t.head.data.length ? (n = t.head.data.slice(0, e), t.head.data = t.head.data.slice(e)) : n = e === t.head.data.length ? t.shift() : r ? function (e, t) {
                    var r = t.head, n = 1, i = r.data;
                    e -= i.length;
                    for (; r = r.next;) {
                        var o = r.data, s = e > o.length ? o.length : e;
                        if (s === o.length ? i += o : i += o.slice(0, e), 0 === (e -= s)) {
                            s === o.length ? (++n, r.next ? t.head = r.next : t.head = t.tail = null) : (t.head = r, r.data = o.slice(s));
                            break
                        }
                        ++n
                    }
                    return t.length -= n, i
                }(e, t) : function (e, t) {
                    var r = u.allocUnsafe(e), n = t.head, i = 1;
                    n.data.copy(r), e -= n.data.length;
                    for (; n = n.next;) {
                        var o = n.data, s = e > o.length ? o.length : e;
                        if (o.copy(r, r.length - e, 0, s), 0 === (e -= s)) {
                            s === o.length ? (++i, n.next ? t.head = n.next : t.head = t.tail = null) : (t.head = n, n.data = o.slice(s));
                            break
                        }
                        ++i
                    }
                    return t.length -= i, r
                }(e, t);
                return n
            }(e, t.buffer, t.decoder), r);
            var r
        }

        function D(e) {
            var t = e._readableState;
            if (t.length > 0) throw new Error('"endReadable()" called on non-empty stream');
            t.endEmitted || (t.ended = !0, i.nextTick(k, t, e))
        }

        function k(e, t) {
            e.endEmitted || 0 !== e.length || (e.endEmitted = !0, t.readable = !1, t.emit("end"))
        }

        function L(e, t) {
            for (var r = 0, n = e.length; r < n; r++) if (e[r] === t) return r;
            return -1
        }

        E.prototype.read = function (e) {
            p("read", e), e = parseInt(e, 10);
            var t = this._readableState, r = e;
            if (0 !== e && (t.emittedReadable = !1), 0 === e && t.needReadable && (t.length >= t.highWaterMark || t.ended)) return p("read: emitReadable", t.length, t.ended), 0 === t.length && t.ended ? D(this) : R(this), null;
            if (0 === (e = T(e, t)) && t.ended) return 0 === t.length && D(this), null;
            var n, i = t.needReadable;
            return p("need readable", i), (0 === t.length || t.length - e < t.highWaterMark) && p("length less than watermark", i = !0), t.ended || t.reading ? p("reading or ended", i = !1) : i && (p("do read"), t.reading = !0, t.sync = !0, 0 === t.length && (t.needReadable = !0), this._read(t.highWaterMark), t.sync = !1, t.reading || (e = T(r, t))), null === (n = e > 0 ? P(e, t) : null) ? (t.needReadable = !0, e = 0) : t.length -= e, 0 === t.length && (t.ended || (t.needReadable = !0), r !== e && t.ended && D(this)), null !== n && this.emit("data", n), n
        }, E.prototype._read = function (e) {
            this.emit("error", new Error("_read() is not implemented"))
        }, E.prototype.pipe = function (e, t) {
            var r = this, o = this._readableState;
            switch (o.pipesCount) {
                case 0:
                    o.pipes = e;
                    break;
                case 1:
                    o.pipes = [o.pipes, e];
                    break;
                default:
                    o.pipes.push(e)
            }
            o.pipesCount += 1, p("pipe count=%d opts=%j", o.pipesCount, t);
            var c = (!t || !1 !== t.end) && e !== n.stdout && e !== n.stderr ? d : E;

            function u(t, n) {
                p("onunpipe"), t === r && n && !1 === n.hasUnpiped && (n.hasUnpiped = !0, p("cleanup"), e.removeListener("close", v), e.removeListener("finish", g), e.removeListener("drain", l), e.removeListener("error", _), e.removeListener("unpipe", u), r.removeListener("end", d), r.removeListener("end", E), r.removeListener("data", m), h = !0, !o.awaitDrain || e._writableState && !e._writableState.needDrain || l())
            }

            function d() {
                p("onend"), e.end()
            }

            o.endEmitted ? i.nextTick(c) : r.once("end", c), e.on("unpipe", u);
            var l = function (e) {
                return function () {
                    var t = e._readableState;
                    p("pipeOnDrain", t.awaitDrain), t.awaitDrain && t.awaitDrain--, 0 === t.awaitDrain && a(e, "data") && (t.flowing = !0, N(e))
                }
            }(r);
            e.on("drain", l);
            var h = !1;
            var f = !1;

            function m(t) {
                p("ondata"), f = !1, !1 !== e.write(t) || f || ((1 === o.pipesCount && o.pipes === e || o.pipesCount > 1 && -1 !== L(o.pipes, e)) && !h && (p("false write response, pause", r._readableState.awaitDrain), r._readableState.awaitDrain++, f = !0), r.pause())
            }

            function _(t) {
                p("onerror", t), E(), e.removeListener("error", _), 0 === a(e, "error") && e.emit("error", t)
            }

            function v() {
                e.removeListener("finish", g), E()
            }

            function g() {
                p("onfinish"), e.removeListener("close", v), E()
            }

            function E() {
                p("unpipe"), r.unpipe(e)
            }

            return r.on("data", m), function (e, t, r) {
                if ("function" == typeof e.prependListener) return e.prependListener(t, r);
                e._events && e._events[t] ? s(e._events[t]) ? e._events[t].unshift(r) : e._events[t] = [r, e._events[t]] : e.on(t, r)
            }(e, "error", _), e.once("close", v), e.once("finish", g), e.emit("pipe", r), o.flowing || (p("pipe resume"), r.resume()), e
        }, E.prototype.unpipe = function (e) {
            var t = this._readableState, r = {hasUnpiped: !1};
            if (0 === t.pipesCount) return this;
            if (1 === t.pipesCount) return e && e !== t.pipes ? this : (e || (e = t.pipes), t.pipes = null, t.pipesCount = 0, t.flowing = !1, e && e.emit("unpipe", this, r), this);
            if (!e) {
                var n = t.pipes, i = t.pipesCount;
                t.pipes = null, t.pipesCount = 0, t.flowing = !1;
                for (var o = 0; o < i; o++) n[o].emit("unpipe", this, r);
                return this
            }
            var s = L(t.pipes, e);
            return -1 === s ? this : (t.pipes.splice(s, 1), t.pipesCount -= 1, 1 === t.pipesCount && (t.pipes = t.pipes[0]), e.emit("unpipe", this, r), this)
        }, E.prototype.on = function (e, t) {
            var r = c.prototype.on.call(this, e, t);
            if ("data" === e) !1 !== this._readableState.flowing && this.resume(); else if ("readable" === e) {
                var n = this._readableState;
                n.endEmitted || n.readableListening || (n.readableListening = n.needReadable = !0, n.emittedReadable = !1, n.reading ? n.length && R(this) : i.nextTick(A, this))
            }
            return r
        }, E.prototype.addListener = E.prototype.on, E.prototype.resume = function () {
            var e = this._readableState;
            return e.flowing || (p("resume"), e.flowing = !0, function (e, t) {
                t.resumeScheduled || (t.resumeScheduled = !0, i.nextTick(O, e, t))
            }(this, e)), this
        }, E.prototype.pause = function () {
            return p("call pause flowing=%j", this._readableState.flowing), !1 !== this._readableState.flowing && (p("pause"), this._readableState.flowing = !1, this.emit("pause")), this
        }, E.prototype.wrap = function (e) {
            var t = this, r = this._readableState, n = !1;
            for (var i in e.on("end", function () {
                if (p("wrapped end"), r.decoder && !r.ended) {
                    var e = r.decoder.end();
                    e && e.length && t.push(e)
                }
                t.push(null)
            }), e.on("data", function (i) {
                (p("wrapped data"), r.decoder && (i = r.decoder.write(i)), !r.objectMode || null !== i && void 0 !== i) && ((r.objectMode || i && i.length) && (t.push(i) || (n = !0, e.pause())))
            }), e) void 0 === this[i] && "function" == typeof e[i] && (this[i] = function (t) {
                return function () {
                    return e[t].apply(e, arguments)
                }
            }(i));
            for (var o = 0; o < v.length; o++) e.on(v[o], this.emit.bind(this, v[o]));
            return this._read = function (t) {
                p("wrapped _read", t), n && (n = !1, e.resume())
            }, this
        }, Object.defineProperty(E.prototype, "readableHighWaterMark", {
            enumerable: !1, get: function () {
                return this._readableState.highWaterMark
            }
        }), E._fromList = P
    }).call(this, r(25), r(14))
}, function (e, t, r) {
    e.exports = r(29).EventEmitter
}, function (e, t, r) {
    "use strict";
    var n = r(52);

    function i(e, t) {
        e.emit("error", t)
    }

    e.exports = {
        destroy: function (e, t) {
            var r = this, o = this._readableState && this._readableState.destroyed,
                s = this._writableState && this._writableState.destroyed;
            return o || s ? (t ? t(e) : !e || this._writableState && this._writableState.errorEmitted || n.nextTick(i, this, e), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(e || null, function (e) {
                !t && e ? (n.nextTick(i, r, e), r._writableState && (r._writableState.errorEmitted = !0)) : t && t(e)
            }), this)
        }, undestroy: function () {
            this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1)
        }
    }
}, function (e, t, r) {
    "use strict";
    (function (t, n, i) {
        var o = r(52);

        function s(e) {
            var t = this;
            this.next = null, this.entry = null, this.finish = function () {
                !function (e, t, r) {
                    var n = e.entry;
                    e.entry = null;
                    for (; n;) {
                        var i = n.callback;
                        t.pendingcb--, i(r), n = n.next
                    }
                    t.corkedRequestsFree ? t.corkedRequestsFree.next = e : t.corkedRequestsFree = e
                }(t, e)
            }
        }

        e.exports = g;
        var a, c = !t.browser && ["v0.10", "v0.9."].indexOf(t.version.slice(0, 5)) > -1 ? n : o.nextTick;
        g.WritableState = v;
        var u = Object.create(r(53));
        u.inherits = r(26);
        var d = {deprecate: r(286)}, l = r(132), h = r(27).Buffer, p = i.Uint8Array || function () {
        };
        var f, m = r(133);

        function _() {
        }

        function v(e, t) {
            a = a || r(36), e = e || {};
            var n = t instanceof a;
            this.objectMode = !!e.objectMode, n && (this.objectMode = this.objectMode || !!e.writableObjectMode);
            var i = e.highWaterMark, u = e.writableHighWaterMark, d = this.objectMode ? 16 : 16384;
            this.highWaterMark = i || 0 === i ? i : n && (u || 0 === u) ? u : d, this.highWaterMark = Math.floor(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
            var l = !1 === e.decodeStrings;
            this.decodeStrings = !l, this.defaultEncoding = e.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function (e) {
                !function (e, t) {
                    var r = e._writableState, n = r.sync, i = r.writecb;
                    if (function (e) {
                        e.writing = !1, e.writecb = null, e.length -= e.writelen, e.writelen = 0
                    }(r), t) !function (e, t, r, n, i) {
                        --t.pendingcb, r ? (o.nextTick(i, n), o.nextTick(R, e, t), e._writableState.errorEmitted = !0, e.emit("error", n)) : (i(n), e._writableState.errorEmitted = !0, e.emit("error", n), R(e, t))
                    }(e, r, n, t, i); else {
                        var s = b(r);
                        s || r.corked || r.bufferProcessing || !r.bufferedRequest || S(e, r), n ? c(y, e, r, s, i) : y(e, r, s, i)
                    }
                }(t, e)
            }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new s(this)
        }

        function g(e) {
            if (a = a || r(36), !(f.call(g, this) || this instanceof a)) return new g(e);
            this._writableState = new v(e, this), this.writable = !0, e && ("function" == typeof e.write && (this._write = e.write), "function" == typeof e.writev && (this._writev = e.writev), "function" == typeof e.destroy && (this._destroy = e.destroy), "function" == typeof e.final && (this._final = e.final)), l.call(this)
        }

        function E(e, t, r, n, i, o, s) {
            t.writelen = n, t.writecb = s, t.writing = !0, t.sync = !0, r ? e._writev(i, t.onwrite) : e._write(i, o, t.onwrite), t.sync = !1
        }

        function y(e, t, r, n) {
            r || function (e, t) {
                0 === t.length && t.needDrain && (t.needDrain = !1, e.emit("drain"))
            }(e, t), t.pendingcb--, n(), R(e, t)
        }

        function S(e, t) {
            t.bufferProcessing = !0;
            var r = t.bufferedRequest;
            if (e._writev && r && r.next) {
                var n = t.bufferedRequestCount, i = new Array(n), o = t.corkedRequestsFree;
                o.entry = r;
                for (var a = 0, c = !0; r;) i[a] = r, r.isBuf || (c = !1), r = r.next, a += 1;
                i.allBuffers = c, E(e, t, !0, t.length, i, "", o.finish), t.pendingcb++, t.lastBufferedRequest = null, o.next ? (t.corkedRequestsFree = o.next, o.next = null) : t.corkedRequestsFree = new s(t), t.bufferedRequestCount = 0
            } else {
                for (; r;) {
                    var u = r.chunk, d = r.encoding, l = r.callback;
                    if (E(e, t, !1, t.objectMode ? 1 : u.length, u, d, l), r = r.next, t.bufferedRequestCount--, t.writing) break
                }
                null === r && (t.lastBufferedRequest = null)
            }
            t.bufferedRequest = r, t.bufferProcessing = !1
        }

        function b(e) {
            return e.ending && 0 === e.length && null === e.bufferedRequest && !e.finished && !e.writing
        }

        function T(e, t) {
            e._final(function (r) {
                t.pendingcb--, r && e.emit("error", r), t.prefinished = !0, e.emit("prefinish"), R(e, t)
            })
        }

        function R(e, t) {
            var r = b(t);
            return r && (!function (e, t) {
                t.prefinished || t.finalCalled || ("function" == typeof e._final ? (t.pendingcb++, t.finalCalled = !0, o.nextTick(T, e, t)) : (t.prefinished = !0, e.emit("prefinish")))
            }(e, t), 0 === t.pendingcb && (t.finished = !0, e.emit("finish"))), r
        }

        u.inherits(g, l), v.prototype.getBuffer = function () {
            for (var e = this.bufferedRequest, t = []; e;) t.push(e), e = e.next;
            return t
        }, function () {
            try {
                Object.defineProperty(v.prototype, "buffer", {
                    get: d.deprecate(function () {
                        return this.getBuffer()
                    }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
                })
            } catch (e) {
            }
        }(), "function" == typeof Symbol && Symbol.hasInstance && "function" == typeof Function.prototype[Symbol.hasInstance] ? (f = Function.prototype[Symbol.hasInstance], Object.defineProperty(g, Symbol.hasInstance, {
            value: function (e) {
                return !!f.call(this, e) || this === g && (e && e._writableState instanceof v)
            }
        })) : f = function (e) {
            return e instanceof this
        }, g.prototype.pipe = function () {
            this.emit("error", new Error("Cannot pipe, not readable"))
        }, g.prototype.write = function (e, t, r) {
            var n = this._writableState, i = !1, s = !n.objectMode && function (e) {
                return h.isBuffer(e) || e instanceof p
            }(e);
            return s && !h.isBuffer(e) && (e = function (e) {
                return h.from(e)
            }(e)), "function" == typeof t && (r = t, t = null), s ? t = "buffer" : t || (t = n.defaultEncoding), "function" != typeof r && (r = _), n.ended ? function (e, t) {
                var r = new Error("write after end");
                e.emit("error", r), o.nextTick(t, r)
            }(this, r) : (s || function (e, t, r, n) {
                var i = !0, s = !1;
                return null === r ? s = new TypeError("May not write null values to stream") : "string" == typeof r || void 0 === r || t.objectMode || (s = new TypeError("Invalid non-string/buffer chunk")), s && (e.emit("error", s), o.nextTick(n, s), i = !1), i
            }(this, n, e, r)) && (n.pendingcb++, i = function (e, t, r, n, i, o) {
                if (!r) {
                    var s = function (e, t, r) {
                        e.objectMode || !1 === e.decodeStrings || "string" != typeof t || (t = h.from(t, r));
                        return t
                    }(t, n, i);
                    n !== s && (r = !0, i = "buffer", n = s)
                }
                var a = t.objectMode ? 1 : n.length;
                t.length += a;
                var c = t.length < t.highWaterMark;
                c || (t.needDrain = !0);
                if (t.writing || t.corked) {
                    var u = t.lastBufferedRequest;
                    t.lastBufferedRequest = {
                        chunk: n,
                        encoding: i,
                        isBuf: r,
                        callback: o,
                        next: null
                    }, u ? u.next = t.lastBufferedRequest : t.bufferedRequest = t.lastBufferedRequest, t.bufferedRequestCount += 1
                } else E(e, t, !1, a, n, i, o);
                return c
            }(this, n, s, e, t, r)), i
        }, g.prototype.cork = function () {
            this._writableState.corked++
        }, g.prototype.uncork = function () {
            var e = this._writableState;
            e.corked && (e.corked--, e.writing || e.corked || e.finished || e.bufferProcessing || !e.bufferedRequest || S(this, e))
        }, g.prototype.setDefaultEncoding = function (e) {
            if ("string" == typeof e && (e = e.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((e + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + e);
            return this._writableState.defaultEncoding = e, this
        }, Object.defineProperty(g.prototype, "writableHighWaterMark", {
            enumerable: !1, get: function () {
                return this._writableState.highWaterMark
            }
        }), g.prototype._write = function (e, t, r) {
            r(new Error("_write() is not implemented"))
        }, g.prototype._writev = null, g.prototype.end = function (e, t, r) {
            var n = this._writableState;
            "function" == typeof e ? (r = e, e = null, t = null) : "function" == typeof t && (r = t, t = null), null !== e && void 0 !== e && this.write(e, t), n.corked && (n.corked = 1, this.uncork()), n.ending || n.finished || function (e, t, r) {
                t.ending = !0, R(e, t), r && (t.finished ? o.nextTick(r) : e.once("finish", r));
                t.ended = !0, e.writable = !1
            }(this, n, r)
        }, Object.defineProperty(g.prototype, "destroyed", {
            get: function () {
                return void 0 !== this._writableState && this._writableState.destroyed
            }, set: function (e) {
                this._writableState && (this._writableState.destroyed = e)
            }
        }), g.prototype.destroy = m.destroy, g.prototype._undestroy = m.undestroy, g.prototype._destroy = function (e, t) {
            this.end(), t(e)
        }
    }).call(this, r(14), r(113).setImmediate, r(25))
}, function (e, t, r) {
    "use strict";
    var n = r(27).Buffer, i = n.isEncoding || function (e) {
        switch ((e = "" + e) && e.toLowerCase()) {
            case"hex":
            case"utf8":
            case"utf-8":
            case"ascii":
            case"binary":
            case"base64":
            case"ucs2":
            case"ucs-2":
            case"utf16le":
            case"utf-16le":
            case"raw":
                return !0;
            default:
                return !1
        }
    };

    function o(e) {
        var t;
        switch (this.encoding = function (e) {
            var t = function (e) {
                if (!e) return "utf8";
                for (var t; ;) switch (e) {
                    case"utf8":
                    case"utf-8":
                        return "utf8";
                    case"ucs2":
                    case"ucs-2":
                    case"utf16le":
                    case"utf-16le":
                        return "utf16le";
                    case"latin1":
                    case"binary":
                        return "latin1";
                    case"base64":
                    case"ascii":
                    case"hex":
                        return e;
                    default:
                        if (t) return;
                        e = ("" + e).toLowerCase(), t = !0
                }
            }(e);
            if ("string" != typeof t && (n.isEncoding === i || !i(e))) throw new Error("Unknown encoding: " + e);
            return t || e
        }(e), this.encoding) {
            case"utf16le":
                this.text = c, this.end = u, t = 4;
                break;
            case"utf8":
                this.fillLast = a, t = 4;
                break;
            case"base64":
                this.text = d, this.end = l, t = 3;
                break;
            default:
                return this.write = h, void (this.end = p)
        }
        this.lastNeed = 0, this.lastTotal = 0, this.lastChar = n.allocUnsafe(t)
    }

    function s(e) {
        return e <= 127 ? 0 : e >> 5 == 6 ? 2 : e >> 4 == 14 ? 3 : e >> 3 == 30 ? 4 : e >> 6 == 2 ? -1 : -2
    }

    function a(e) {
        var t = this.lastTotal - this.lastNeed, r = function (e, t, r) {
            if (128 != (192 & t[0])) return e.lastNeed = 0, "";
            if (e.lastNeed > 1 && t.length > 1) {
                if (128 != (192 & t[1])) return e.lastNeed = 1, "";
                if (e.lastNeed > 2 && t.length > 2 && 128 != (192 & t[2])) return e.lastNeed = 2, ""
            }
        }(this, e);
        return void 0 !== r ? r : this.lastNeed <= e.length ? (e.copy(this.lastChar, t, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : (e.copy(this.lastChar, t, 0, e.length), void (this.lastNeed -= e.length))
    }

    function c(e, t) {
        if ((e.length - t) % 2 == 0) {
            var r = e.toString("utf16le", t);
            if (r) {
                var n = r.charCodeAt(r.length - 1);
                if (n >= 55296 && n <= 56319) return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = e[e.length - 2], this.lastChar[1] = e[e.length - 1], r.slice(0, -1)
            }
            return r
        }
        return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = e[e.length - 1], e.toString("utf16le", t, e.length - 1)
    }

    function u(e) {
        var t = e && e.length ? this.write(e) : "";
        if (this.lastNeed) {
            var r = this.lastTotal - this.lastNeed;
            return t + this.lastChar.toString("utf16le", 0, r)
        }
        return t
    }

    function d(e, t) {
        var r = (e.length - t) % 3;
        return 0 === r ? e.toString("base64", t) : (this.lastNeed = 3 - r, this.lastTotal = 3, 1 === r ? this.lastChar[0] = e[e.length - 1] : (this.lastChar[0] = e[e.length - 2], this.lastChar[1] = e[e.length - 1]), e.toString("base64", t, e.length - r))
    }

    function l(e) {
        var t = e && e.length ? this.write(e) : "";
        return this.lastNeed ? t + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : t
    }

    function h(e) {
        return e.toString(this.encoding)
    }

    function p(e) {
        return e && e.length ? this.write(e) : ""
    }

    t.StringDecoder = o, o.prototype.write = function (e) {
        if (0 === e.length) return "";
        var t, r;
        if (this.lastNeed) {
            if (void 0 === (t = this.fillLast(e))) return "";
            r = this.lastNeed, this.lastNeed = 0
        } else r = 0;
        return r < e.length ? t ? t + this.text(e, r) : this.text(e, r) : t || ""
    }, o.prototype.end = function (e) {
        var t = e && e.length ? this.write(e) : "";
        return this.lastNeed ? t + "" : t
    }, o.prototype.text = function (e, t) {
        var r = function (e, t, r) {
            var n = t.length - 1;
            if (n < r) return 0;
            var i = s(t[n]);
            if (i >= 0) return i > 0 && (e.lastNeed = i - 1), i;
            if (--n < r || -2 === i) return 0;
            if ((i = s(t[n])) >= 0) return i > 0 && (e.lastNeed = i - 2), i;
            if (--n < r || -2 === i) return 0;
            if ((i = s(t[n])) >= 0) return i > 0 && (2 === i ? i = 0 : e.lastNeed = i - 3), i;
            return 0
        }(this, e, t);
        if (!this.lastNeed) return e.toString("utf8", t);
        this.lastTotal = r;
        var n = e.length - (r - this.lastNeed);
        return e.copy(this.lastChar, 0, n), e.toString("utf8", t, n)
    }, o.prototype.fillLast = function (e) {
        if (this.lastNeed <= e.length) return e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
        e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, e.length), this.lastNeed -= e.length
    }
}, function (e, t, r) {
    "use strict";
    e.exports = o;
    var n = r(36), i = Object.create(r(53));

    function o(e) {
        if (!(this instanceof o)) return new o(e);
        n.call(this, e), this._transformState = {
            afterTransform: function (e, t) {
                var r = this._transformState;
                r.transforming = !1;
                var n = r.writecb;
                if (!n) return this.emit("error", new Error("write callback called multiple times"));
                r.writechunk = null, r.writecb = null, null != t && this.push(t), n(e);
                var i = this._readableState;
                i.reading = !1, (i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark)
            }.bind(this), needTransform: !1, transforming: !1, writecb: null, writechunk: null, writeencoding: null
        }, this._readableState.needReadable = !0, this._readableState.sync = !1, e && ("function" == typeof e.transform && (this._transform = e.transform), "function" == typeof e.flush && (this._flush = e.flush)), this.on("prefinish", s)
    }

    function s() {
        var e = this;
        "function" == typeof this._flush ? this._flush(function (t, r) {
            a(e, t, r)
        }) : a(this, null, null)
    }

    function a(e, t, r) {
        if (t) return e.emit("error", t);
        if (null != r && e.push(r), e._writableState.length) throw new Error("Calling transform done when ws.length != 0");
        if (e._transformState.transforming) throw new Error("Calling transform done when still transforming");
        return e.push(null)
    }

    i.inherits = r(26), i.inherits(o, n), o.prototype.push = function (e, t) {
        return this._transformState.needTransform = !1, n.prototype.push.call(this, e, t)
    }, o.prototype._transform = function (e, t, r) {
        throw new Error("_transform() is not implemented")
    }, o.prototype._write = function (e, t, r) {
        var n = this._transformState;
        if (n.writecb = r, n.writechunk = e, n.writeencoding = t, !n.transforming) {
            var i = this._readableState;
            (n.needTransform || i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark)
        }
    }, o.prototype._read = function (e) {
        var t = this._transformState;
        null !== t.writechunk && t.writecb && !t.transforming ? (t.transforming = !0, this._transform(t.writechunk, t.writeencoding, t.afterTransform)) : t.needTransform = !0
    }, o.prototype._destroy = function (e, t) {
        var r = this;
        n.prototype._destroy.call(this, e, function (e) {
            t(e), r.emit("close")
        })
    }
}, function (e, t, r) {
    "use strict";
    var n = r(30);
    e.exports = function () {
        return n(this).length = 0, this
    }
}, function (e, t, r) {
    "use strict";
    var n = r(296), i = Math.max;
    e.exports = function (e) {
        return i(0, n(e))
    }
}, function (e, t, r) {
    "use strict";
    var n = Object.create, i = Object.getPrototypeOf, o = {};
    e.exports = function () {
        var e = Object.setPrototypeOf, t = arguments[0] || n;
        return "function" == typeof e && i(e(t(null), o)) === o
    }
}, function (e, t, r) {
    "use strict";
    var n, i = r(300), o = r(30), s = Object.prototype.isPrototypeOf, a = Object.defineProperty,
        c = {configurable: !0, enumerable: !1, writable: !0, value: void 0};
    n = function (e, t) {
        if (o(e), null === t || i(t)) return e;
        throw new TypeError("Prototype must be null or an object")
    }, e.exports = function (e) {
        var t, r;
        return e ? (2 === e.level ? e.set ? (r = e.set, t = function (e, t) {
            return r.call(n(e, t), t), e
        }) : t = function (e, t) {
            return n(e, t).__proto__ = t, e
        } : t = function e(t, r) {
            var i;
            return n(t, r), (i = s.call(e.nullPolyfill, t)) && delete e.nullPolyfill.__proto__, null === r && (r = e.nullPolyfill), t.__proto__ = r, i && a(e.nullPolyfill, "__proto__", c), t
        }, Object.defineProperty(t, "level", {configurable: !1, enumerable: !1, writable: !1, value: e.level})) : null
    }(function () {
        var e, t = Object.create(null), r = {}, n = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__");
        if (n) {
            try {
                (e = n.set).call(t, r)
            } catch (e) {
            }
            if (Object.getPrototypeOf(t) === r) return {set: e, level: 2}
        }
        return t.__proto__ = r, Object.getPrototypeOf(t) === r ? {level: 2} : ((t = {}).__proto__ = r, Object.getPrototypeOf(t) === r && {level: 1})
    }()), r(301)
}, function (e, t, r) {
    "use strict";
    var n = r(302), i = /^\s*class[\s{/}]/, o = Function.prototype.toString;
    e.exports = function (e) {
        return !!n(e) && !i.test(o.call(e))
    }
}, function (e, t, r) {
    "use strict";
    var n = r(42), i = Array.prototype.forEach, o = Object.create;
    e.exports = function (e) {
        var t = o(null);
        return i.call(arguments, function (e) {
            n(e) && function (e, t) {
                var r;
                for (r in e) t[r] = e[r]
            }(Object(e), t)
        }), t
    }
}, function (e, t, r) {
    "use strict";
    e.exports = r(309)() ? String.prototype.contains : r(310)
}, function (e, t, r) {
    "use strict";
    var n = r(316);
    e.exports = function (e) {
        if (!n(e)) throw new TypeError(e + " is not a symbol");
        return e
    }
}, function (e, t, r) {
    "use strict";
    var n = r(320);
    e.exports = function (e) {
        if (!n(e)) throw new TypeError(e + " is not iterable");
        return e
    }
}, function (e, t, r) {
    "use strict";
    var n = r(43), i = r(90), o = r(326), s = r(327), a = function (e, t) {
        return e.replace("%v", s(t))
    };
    e.exports = function (e, t, r) {
        if (!i(r)) throw new TypeError(a(t, e));
        if (!n(e)) {
            if ("default" in r) return r.default;
            if (r.isOptional) return null
        }
        var s = o(r.errorMessage);
        throw n(s) || (s = t), new TypeError(a(s, e))
    }
}, function (e, t, r) {
    (function (t) {
        var n = r(343), i = function () {
        }, o = function (e, r, s) {
            if ("function" == typeof r) return o(e, null, r);
            r || (r = {}), s = n(s || i);
            var a = e._writableState, c = e._readableState, u = r.readable || !1 !== r.readable && e.readable,
                d = r.writable || !1 !== r.writable && e.writable, l = !1, h = function () {
                    e.writable || p()
                }, p = function () {
                    d = !1, u || s.call(e)
                }, f = function () {
                    u = !1, d || s.call(e)
                }, m = function (t) {
                    s.call(e, t ? new Error("exited with error code: " + t) : null)
                }, _ = function (t) {
                    s.call(e, t)
                }, v = function () {
                    t.nextTick(g)
                }, g = function () {
                    if (!l) return (!u || c && c.ended && !c.destroyed) && (!d || a && a.ended && !a.destroyed) ? void 0 : s.call(e, new Error("premature close"))
                }, E = function () {
                    e.req.on("finish", p)
                };
            return !function (e) {
                return e.setHeader && "function" == typeof e.abort
            }(e) ? d && !a && (e.on("end", h), e.on("close", h)) : (e.on("complete", p), e.on("abort", v), e.req ? E() : e.on("request", E)), function (e) {
                return e.stdio && Array.isArray(e.stdio) && 3 === e.stdio.length
            }(e) && e.on("exit", m), e.on("end", f), e.on("finish", p), !1 !== r.error && e.on("error", _), e.on("close", v), function () {
                l = !0, e.removeListener("complete", p), e.removeListener("abort", v), e.removeListener("request", E), e.req && e.req.removeListener("finish", p), e.removeListener("end", h), e.removeListener("close", h), e.removeListener("finish", p), e.removeListener("exit", m), e.removeListener("end", f), e.removeListener("error", _), e.removeListener("close", v)
            }
        };
        e.exports = o
    }).call(this, r(14))
}, function (e, t, r) {
    "use strict";
    var n = r(27).Buffer, i = e.exports;
    for (var o in i.types = {
        0: "reserved",
        1: "connect",
        2: "connack",
        3: "publish",
        4: "puback",
        5: "pubrec",
        6: "pubrel",
        7: "pubcomp",
        8: "subscribe",
        9: "suback",
        10: "unsubscribe",
        11: "unsuback",
        12: "pingreq",
        13: "pingresp",
        14: "disconnect",
        15: "reserved"
    }, i.codes = {}, i.types) {
        var s = i.types[o];
        i.codes[s] = o
    }

    function a(e) {
        return [0, 1, 2].map(function (t) {
            return [0, 1].map(function (r) {
                return [0, 1].map(function (o) {
                    var s = new n(1);
                    return s.writeUInt8(i.codes[e] << i.CMD_SHIFT | (r ? i.DUP_MASK : 0) | t << i.QOS_SHIFT | o, 0, !0), s
                })
            })
        })
    }

    i.CMD_SHIFT = 4, i.CMD_MASK = 240, i.DUP_MASK = 8, i.QOS_MASK = 3, i.QOS_SHIFT = 1, i.RETAIN_MASK = 1, i.LENGTH_MASK = 127, i.LENGTH_FIN_MASK = 128, i.SESSIONPRESENT_MASK = 1, i.SESSIONPRESENT_HEADER = n.from([i.SESSIONPRESENT_MASK]), i.CONNACK_HEADER = n.from([i.codes.connack << i.CMD_SHIFT]), i.USERNAME_MASK = 128, i.PASSWORD_MASK = 64, i.WILL_RETAIN_MASK = 32, i.WILL_QOS_MASK = 24, i.WILL_QOS_SHIFT = 3, i.WILL_FLAG_MASK = 4, i.CLEAN_SESSION_MASK = 2, i.CONNECT_HEADER = n.from([i.codes.connect << i.CMD_SHIFT]), i.PUBLISH_HEADER = a("publish"), i.SUBSCRIBE_HEADER = a("subscribe"), i.UNSUBSCRIBE_HEADER = a("unsubscribe"), i.ACKS = {
        unsuback: a("unsuback"),
        puback: a("puback"),
        pubcomp: a("pubcomp"),
        pubrel: a("pubrel"),
        pubrec: a("pubrec")
    }, i.SUBACK_HEADER = n.from([i.codes.suback << i.CMD_SHIFT]), i.VERSION3 = n.from([3]), i.VERSION4 = n.from([4]), i.QOS = [0, 1, 2].map(function (e) {
        return n.from([e])
    }), i.EMPTY = {
        pingreq: n.from([i.codes.pingreq << 4, 0]),
        pingresp: n.from([i.codes.pingresp << 4, 0]),
        disconnect: n.from([i.codes.disconnect << 4, 0])
    }
}, function (e, t, r) {
    "use strict";
    var n = r(148), i = r(27).Buffer, o = i.allocUnsafe(0), s = i.from([0]), a = r(351), c = r(52).nextTick,
        u = a.cache, d = a.generateNumber, l = a.generateCache, h = E, p = !0;

    function f(e, t) {
        switch (t.cork && (t.cork(), c(m, t)), p && (p = !1, l()), e.cmd) {
            case"connect":
                return function (e, t) {
                    var r = e || {}, o = r.protocolId || "MQTT", s = r.protocolVersion || 4, a = r.will, c = r.clean,
                        u = r.keepalive || 0, d = r.clientId || "", l = r.username, p = r.password;
                    void 0 === c && (c = !0);
                    var f = 0;
                    if (!o || "string" != typeof o && !i.isBuffer(o)) return t.emit("error", new Error("Invalid protocolId")), !1;
                    f += o.length + 2;
                    if (3 !== s && 4 !== s) return t.emit("error", new Error("Invalid protocol version")), !1;
                    f += 1;
                    if ("string" != typeof d && !i.isBuffer(d) || !d && 4 !== s || !d && !c) {
                        if (s < 4) return t.emit("error", new Error("clientId must be supplied before 3.1.1")), !1;
                        if (1 * c == 0) return t.emit("error", new Error("clientId must be given if cleanSession set to 0")), !1
                    } else f += d.length + 2;
                    if ("number" != typeof u || u < 0 || u > 65535 || u % 1 != 0) return t.emit("error", new Error("Invalid keepalive")), !1;
                    f += 2;
                    if (f += 1, a) {
                        if ("object" != typeof a) return t.emit("error", new Error("Invalid will")), !1;
                        if (!a.topic || "string" != typeof a.topic) return t.emit("error", new Error("Invalid will topic")), !1;
                        if (f += i.byteLength(a.topic) + 2, a.payload && a.payload) {
                            if (!(a.payload.length >= 0)) return t.emit("error", new Error("Invalid will payload")), !1;
                            "string" == typeof a.payload ? f += i.byteLength(a.payload) + 2 : f += a.payload.length + 2
                        } else f += 2
                    }
                    var m = !1;
                    if (null != l) {
                        if (!T(l)) return t.emit("error", new Error("Invalid username")), !1;
                        m = !0, f += i.byteLength(l) + 2
                    }
                    if (null != p) {
                        if (!m) return t.emit("error", new Error("Username is required to use password")), !1;
                        if (!T(p)) return t.emit("error", new Error("Invalid password")), !1;
                        f += b(p) + 2
                    }
                    t.write(n.CONNECT_HEADER), v(t, f), S(t, o), t.write(4 === s ? n.VERSION4 : n.VERSION3);
                    var _ = 0;
                    _ |= null != l ? n.USERNAME_MASK : 0, _ |= null != p ? n.PASSWORD_MASK : 0, _ |= a && a.retain ? n.WILL_RETAIN_MASK : 0, _ |= a && a.qos ? a.qos << n.WILL_QOS_SHIFT : 0, _ |= a ? n.WILL_FLAG_MASK : 0, _ |= c ? n.CLEAN_SESSION_MASK : 0, t.write(i.from([_])), h(t, u), S(t, d), a && (g(t, a.topic), S(t, a.payload));
                    null != l && S(t, l);
                    null != p && S(t, p);
                    return !0
                }(e, t);
            case"connack":
                return function (e, t) {
                    var r = (e || {}).returnCode;
                    if ("number" != typeof r) return t.emit("error", new Error("Invalid return code")), !1;
                    return t.write(n.CONNACK_HEADER), v(t, 2), t.write(e.sessionPresent ? n.SESSIONPRESENT_HEADER : s), t.write(i.from([r]))
                }(e, t);
            case"publish":
                return function (e, t) {
                    var r = e || {}, s = r.qos || 0, a = r.retain ? n.RETAIN_MASK : 0, c = r.topic, u = r.payload || o,
                        d = r.messageId, l = 0;
                    if ("string" == typeof c) l += i.byteLength(c) + 2; else {
                        if (!i.isBuffer(c)) return t.emit("error", new Error("Invalid topic")), !1;
                        l += c.length + 2
                    }
                    i.isBuffer(u) ? l += u.length : l += i.byteLength(u);
                    if (s && "number" != typeof d) return t.emit("error", new Error("Invalid messageId")), !1;
                    s && (l += 2);
                    t.write(n.PUBLISH_HEADER[s][e.dup ? 1 : 0][a ? 1 : 0]), v(t, l), h(t, b(c)), t.write(c), s > 0 && h(t, d);
                    return t.write(u)
                }(e, t);
            case"puback":
            case"pubrec":
            case"pubrel":
            case"pubcomp":
            case"unsuback":
                return function (e, t) {
                    var r = e || {}, i = r.cmd || "puback", o = r.messageId,
                        s = r.dup && "pubrel" === i ? n.DUP_MASK : 0, a = 0;
                    "pubrel" === i && (a = 1);
                    if ("number" != typeof o) return t.emit("error", new Error("Invalid messageId")), !1;
                    return t.write(n.ACKS[i][a][s][0]), v(t, 2), h(t, o)
                }(e, t);
            case"subscribe":
                return function (e, t) {
                    var r = e || {}, o = r.dup ? n.DUP_MASK : 0, s = r.messageId, a = r.subscriptions, c = 0;
                    if ("number" != typeof s) return t.emit("error", new Error("Invalid messageId")), !1;
                    c += 2;
                    if ("object" != typeof a || !a.length) return t.emit("error", new Error("Invalid subscriptions")), !1;
                    for (var u = 0; u < a.length; u += 1) {
                        var d = a[u].topic, l = a[u].qos;
                        if ("string" != typeof d) return t.emit("error", new Error("Invalid subscriptions - invalid topic")), !1;
                        if ("number" != typeof l) return t.emit("error", new Error("Invalid subscriptions - invalid qos")), !1;
                        c += i.byteLength(d) + 2 + 1
                    }
                    t.write(n.SUBSCRIBE_HEADER[1][o ? 1 : 0][0]), v(t, c), h(t, s);
                    for (var p = !0, f = 0; f < a.length; f++) {
                        var m = a[f], _ = m.topic, E = m.qos;
                        g(t, _), p = t.write(n.QOS[E])
                    }
                    return p
                }(e, t);
            case"suback":
                return function (e, t) {
                    var r = e || {}, o = r.messageId, s = r.granted, a = 0;
                    if ("number" != typeof o) return t.emit("error", new Error("Invalid messageId")), !1;
                    a += 2;
                    if ("object" != typeof s || !s.length) return t.emit("error", new Error("Invalid qos vector")), !1;
                    for (var c = 0; c < s.length; c += 1) {
                        if ("number" != typeof s[c]) return t.emit("error", new Error("Invalid qos vector")), !1;
                        a += 1
                    }
                    return t.write(n.SUBACK_HEADER), v(t, a), h(t, o), t.write(i.from(s))
                }(e, t);
            case"unsubscribe":
                return function (e, t) {
                    var r = e || {}, o = r.messageId, s = r.dup ? n.DUP_MASK : 0, a = r.unsubscriptions, c = 0;
                    if ("number" != typeof o) return t.emit("error", new Error("Invalid messageId")), !1;
                    c += 2;
                    if ("object" != typeof a || !a.length) return t.emit("error", new Error("Invalid unsubscriptions")), !1;
                    for (var u = 0; u < a.length; u += 1) {
                        if ("string" != typeof a[u]) return t.emit("error", new Error("Invalid unsubscriptions")), !1;
                        c += i.byteLength(a[u]) + 2
                    }
                    t.write(n.UNSUBSCRIBE_HEADER[1][s ? 1 : 0][0]), v(t, c), h(t, o);
                    for (var d = !0, l = 0; l < a.length; l++) d = g(t, a[l]);
                    return d
                }(e, t);
            case"pingreq":
            case"pingresp":
            case"disconnect":
                return function (e, t) {
                    return t.write(n.EMPTY[e.cmd])
                }(e, t);
            default:
                return t.emit("error", new Error("Unknown command")), !1
        }
    }

    function m(e) {
        e.uncork()
    }

    Object.defineProperty(f, "cacheNumbers", {
        get: function () {
            return h === E
        }, set: function (e) {
            e ? (u && 0 !== Object.keys(u).length || (p = !0), h = E) : (p = !1, h = y)
        }
    });
    var _ = {};

    function v(e, t) {
        var r = _[t];
        r || (r = function (e) {
            var t = 0, r = 0, n = i.allocUnsafe(function (e) {
                return e >= 0 && e < 128 ? 1 : e >= 128 && e < 16384 ? 2 : e >= 16384 && e < 2097152 ? 3 : e >= 2097152 && e < 268435456 ? 4 : 0
            }(e));
            do {
                t = e % 128 | 0, (e = e / 128 | 0) > 0 && (t |= 128), n.writeUInt8(t, r++)
            } while (e > 0);
            return n
        }(t), t < 16384 && (_[t] = r)), e.write(r)
    }

    function g(e, t) {
        var r = i.byteLength(t);
        h(e, r), e.write(t, "utf8")
    }

    function E(e, t) {
        return e.write(u[t])
    }

    function y(e, t) {
        return e.write(d(t))
    }

    function S(e, t) {
        "string" == typeof t ? g(e, t) : t ? (h(e, t.length), e.write(t)) : h(e, 0)
    }

    function b(e) {
        return e ? e instanceof i ? e.length : i.byteLength(e) : 0
    }

    function T(e) {
        return "string" == typeof e || e instanceof i
    }

    e.exports = f
}, function (e, t, r) {
    "use strict";
    var n = r(354);
    e.exports = function (e, t) {
        var r, i;
        return t.port = t.port || 1883, t.hostname = t.hostname || t.host || "localhost", r = t.port, i = t.hostname, n.createConnection(r, i)
    }
}, function (e, t, r) {
    "use strict";
    var n = !1, i = [];

    function o(e) {
        n ? wx.sendSocketMessage({data: e.buffer || e}) : i.push(e)
    }

    var s = r(94);

    function a(e, t) {
        var r = "MQIsdp" === t.protocolId && 3 === t.protocolVersion ? "mqttv3.1" : "mqtt";
        !function (e) {
            e.hostname || (e.hostname = "localhost"), e.path || (e.path = "/"), e.wsOptions || (e.wsOptions = {})
        }(t);
        var a = function (e, t) {
            var r = "wxs" === e.protocol ? "wss" : "ws", n = r + "://" + e.hostname + e.path;
            return e.port && 80 !== e.port && 443 !== e.port && (n = r + "://" + e.hostname + ":" + e.port + e.path), "function" == typeof e.transformWsUrl && (n = e.transformWsUrl(n, e, t)), n
        }(t, e);
        return s(function (e, t) {
            var r = {
                OPEN: 1,
                CLOSING: 2,
                CLOSED: 3,
                readyState: n ? 1 : 0,
                send: o,
                close: wx.closeSocket,
                onopen: null,
                onmessage: null,
                onclose: null,
                onerror: null
            };
            return wx.connectSocket({url: e, protocols: t}), wx.onSocketOpen(function (e) {
                r.readyState = r.OPEN, n = !0;
                for (var t = 0; t < i.length; t++) o(i[t]);
                i = [], r.onopen && r.onopen.apply(r, arguments)
            }), wx.onSocketMessage(function (e) {
                r.onmessage && r.onmessage.apply(r, arguments)
            }), wx.onSocketClose(function () {
                r.onclose && r.onclose.apply(r, arguments), r.readyState = r.CLOSED, n = !1
            }), wx.onSocketError(function () {
                r.onerror && r.onerror.apply(r, arguments), r.readyState = r.CLOSED, n = !1
            }), r
        }(a, [r]))
    }

    e.exports = function (e, t) {
        if (t.hostname = t.hostname || t.host, !t.hostname) throw new Error("Could not determine host. Specify host manually.");
        return a(e, t)
    }
}, function (e, t, r) {
    "use strict";
    (function (t) {
        var n = r(94), i = r(87), o = ["rejectUnauthorized", "ca", "cert", "key", "pfx", "passphrase"],
            s = "browser" === t.title;

        function a(e, t) {
            var r = "MQIsdp" === t.protocolId && 3 === t.protocolVersion ? "mqttv3.1" : "mqtt";
            !function (e) {
                e.hostname || (e.hostname = "localhost"), e.port || ("wss" === e.protocol ? e.port = 443 : e.port = 80), e.path || (e.path = "/"), e.wsOptions || (e.wsOptions = {}), s || "wss" !== e.protocol || o.forEach(function (t) {
                    e.hasOwnProperty(t) && !e.wsOptions.hasOwnProperty(t) && (e.wsOptions[t] = e[t])
                })
            }(t);
            var i = function (e, t) {
                var r = e.protocol + "://" + e.hostname + ":" + e.port + e.path;
                return "function" == typeof e.transformWsUrl && (r = e.transformWsUrl(r, e, t)), r
            }(t, e);
            return n(i, [r], t.wsOptions)
        }

        e.exports = s ? function (e, t) {
            if (t.hostname || (t.hostname = t.host), !t.hostname) {
                if ("undefined" == typeof document) throw new Error("Could not determine host. Specify host manually.");
                var r = i.parse(document.URL);
                t.hostname = r.hostname, t.port || (t.port = r.port)
            }
            return a(e, t)
        } : function (e, t) {
            return a(e, t)
        }
    }).call(this, r(14))
}, function (e, t, r) {
    e.exports = function (e) {
        return function (t) {
            var r = e, n = r.lib, i = n.WordArray, o = n.Hasher, s = r.algo, a = [], c = [];
            !function () {
                function e(e) {
                    for (var r = t.sqrt(e), n = 2; n <= r; n++) if (!(e % n)) return !1;
                    return !0
                }

                function r(e) {
                    return 4294967296 * (e - (0 | e)) | 0
                }

                for (var n = 2, i = 0; i < 64;) e(n) && (i < 8 && (a[i] = r(t.pow(n, .5))), c[i] = r(t.pow(n, 1 / 3)), i++), n++
            }();
            var u = [], d = s.SHA256 = o.extend({
                _doReset: function () {
                    this._hash = new i.init(a.slice(0))
                }, _doProcessBlock: function (e, t) {
                    for (var r = this._hash.words, n = r[0], i = r[1], o = r[2], s = r[3], a = r[4], d = r[5], l = r[6], h = r[7], p = 0; p < 64; p++) {
                        if (p < 16) u[p] = 0 | e[t + p]; else {
                            var f = u[p - 15], m = (f << 25 | f >>> 7) ^ (f << 14 | f >>> 18) ^ f >>> 3, _ = u[p - 2],
                                v = (_ << 15 | _ >>> 17) ^ (_ << 13 | _ >>> 19) ^ _ >>> 10;
                            u[p] = m + u[p - 7] + v + u[p - 16]
                        }
                        var g = n & i ^ n & o ^ i & o,
                            E = (n << 30 | n >>> 2) ^ (n << 19 | n >>> 13) ^ (n << 10 | n >>> 22),
                            y = h + ((a << 26 | a >>> 6) ^ (a << 21 | a >>> 11) ^ (a << 7 | a >>> 25)) + (a & d ^ ~a & l) + c[p] + u[p];
                        h = l, l = d, d = a, a = s + y | 0, s = o, o = i, i = n, n = y + (E + g) | 0
                    }
                    r[0] = r[0] + n | 0, r[1] = r[1] + i | 0, r[2] = r[2] + o | 0, r[3] = r[3] + s | 0, r[4] = r[4] + a | 0, r[5] = r[5] + d | 0, r[6] = r[6] + l | 0, r[7] = r[7] + h | 0
                }, _doFinalize: function () {
                    var e = this._data, r = e.words, n = 8 * this._nDataBytes, i = 8 * e.sigBytes;
                    return r[i >>> 5] |= 128 << 24 - i % 32, r[14 + (i + 64 >>> 9 << 4)] = t.floor(n / 4294967296), r[15 + (i + 64 >>> 9 << 4)] = n, e.sigBytes = 4 * r.length, this._process(), this._hash
                }, clone: function () {
                    var e = o.clone.call(this);
                    return e._hash = this._hash.clone(), e
                }
            });
            r.SHA256 = o._createHelper(d), r.HmacSHA256 = o._createHmacHelper(d)
        }(Math), e.SHA256
    }(r(95))
}, function (e, t, r) {
    "use strict";
    r.r(t), r.d(t, "v1", function () {
        return u
    }), r.d(t, "v3", function () {
        return y
    }), r.d(t, "v4", function () {
        return S.a
    }), r.d(t, "v5", function () {
        return R
    }), r.d(t, "NIL", function () {
        return I
    }), r.d(t, "version", function () {
        return w
    }), r.d(t, "validate", function () {
        return d.a
    }), r.d(t, "stringify", function () {
        return s.a
    }), r.d(t, "parse", function () {
        return l
    });
    var n, i, o = r(71), s = r(32), a = 0, c = 0;
    var u = function (e, t, r) {
        var u = t && r || 0, d = t || new Array(16), l = (e = e || {}).node || n,
            h = void 0 !== e.clockseq ? e.clockseq : i;
        if (null == l || null == h) {
            var p = e.random || (e.rng || o.a)();
            null == l && (l = n = [1 | p[0], p[1], p[2], p[3], p[4], p[5]]), null == h && (h = i = 16383 & (p[6] << 8 | p[7]))
        }
        var f = void 0 !== e.msecs ? e.msecs : Date.now(), m = void 0 !== e.nsecs ? e.nsecs : c + 1,
            _ = f - a + (m - c) / 1e4;
        if (_ < 0 && void 0 === e.clockseq && (h = h + 1 & 16383), (_ < 0 || f > a) && void 0 === e.nsecs && (m = 0), m >= 1e4) throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
        a = f, c = m, i = h;
        var v = (1e4 * (268435455 & (f += 122192928e5)) + m) % 4294967296;
        d[u++] = v >>> 24 & 255, d[u++] = v >>> 16 & 255, d[u++] = v >>> 8 & 255, d[u++] = 255 & v;
        var g = f / 4294967296 * 1e4 & 268435455;
        d[u++] = g >>> 8 & 255, d[u++] = 255 & g, d[u++] = g >>> 24 & 15 | 16, d[u++] = g >>> 16 & 255, d[u++] = h >>> 8 | 128, d[u++] = 255 & h;
        for (var E = 0; E < 6; ++E) d[u + E] = l[E];
        return t || Object(s.a)(d)
    }, d = r(33);
    var l = function (e) {
        if (!Object(d.a)(e)) throw TypeError("Invalid UUID");
        var t, r = new Uint8Array(16);
        return r[0] = (t = parseInt(e.slice(0, 8), 16)) >>> 24, r[1] = t >>> 16 & 255, r[2] = t >>> 8 & 255, r[3] = 255 & t, r[4] = (t = parseInt(e.slice(9, 13), 16)) >>> 8, r[5] = 255 & t, r[6] = (t = parseInt(e.slice(14, 18), 16)) >>> 8, r[7] = 255 & t, r[8] = (t = parseInt(e.slice(19, 23), 16)) >>> 8, r[9] = 255 & t, r[10] = (t = parseInt(e.slice(24, 36), 16)) / 1099511627776 & 255, r[11] = t / 4294967296 & 255, r[12] = t >>> 24 & 255, r[13] = t >>> 16 & 255, r[14] = t >>> 8 & 255, r[15] = 255 & t, r
    };
    var h = function (e, t, r) {
        function n(e, n, i, o) {
            if ("string" == typeof e && (e = function (e) {
                e = unescape(encodeURIComponent(e));
                for (var t = [], r = 0; r < e.length; ++r) t.push(e.charCodeAt(r));
                return t
            }(e)), "string" == typeof n && (n = l(n)), 16 !== n.length) throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
            var a = new Uint8Array(16 + e.length);
            if (a.set(n), a.set(e, n.length), (a = r(a))[6] = 15 & a[6] | t, a[8] = 63 & a[8] | 128, i) {
                o = o || 0;
                for (var c = 0; c < 16; ++c) i[o + c] = a[c];
                return i
            }
            return Object(s.a)(a)
        }

        try {
            n.name = e
        } catch (e) {
        }
        return n.DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8", n.URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8", n
    };

    function p(e) {
        return 14 + (e + 64 >>> 9 << 4) + 1
    }

    function f(e, t) {
        var r = (65535 & e) + (65535 & t);
        return (e >> 16) + (t >> 16) + (r >> 16) << 16 | 65535 & r
    }

    function m(e, t, r, n, i, o) {
        return f(function (e, t) {
            return e << t | e >>> 32 - t
        }(f(f(t, e), f(n, o)), i), r)
    }

    function _(e, t, r, n, i, o, s) {
        return m(t & r | ~t & n, e, t, i, o, s)
    }

    function v(e, t, r, n, i, o, s) {
        return m(t & n | r & ~n, e, t, i, o, s)
    }

    function g(e, t, r, n, i, o, s) {
        return m(t ^ r ^ n, e, t, i, o, s)
    }

    function E(e, t, r, n, i, o, s) {
        return m(r ^ (t | ~n), e, t, i, o, s)
    }

    var y = h("v3", 48, function (e) {
        if ("string" == typeof e) {
            var t = unescape(encodeURIComponent(e));
            e = new Uint8Array(t.length);
            for (var r = 0; r < t.length; ++r) e[r] = t.charCodeAt(r)
        }
        return function (e) {
            for (var t = [], r = 32 * e.length, n = 0; n < r; n += 8) {
                var i = e[n >> 5] >>> n % 32 & 255,
                    o = parseInt("0123456789abcdef".charAt(i >>> 4 & 15) + "0123456789abcdef".charAt(15 & i), 16);
                t.push(o)
            }
            return t
        }(function (e, t) {
            e[t >> 5] |= 128 << t % 32, e[p(t) - 1] = t;
            for (var r = 1732584193, n = -271733879, i = -1732584194, o = 271733878, s = 0; s < e.length; s += 16) {
                var a = r, c = n, u = i, d = o;
                r = _(r, n, i, o, e[s], 7, -680876936), o = _(o, r, n, i, e[s + 1], 12, -389564586), i = _(i, o, r, n, e[s + 2], 17, 606105819), n = _(n, i, o, r, e[s + 3], 22, -1044525330), r = _(r, n, i, o, e[s + 4], 7, -176418897), o = _(o, r, n, i, e[s + 5], 12, 1200080426), i = _(i, o, r, n, e[s + 6], 17, -1473231341), n = _(n, i, o, r, e[s + 7], 22, -45705983), r = _(r, n, i, o, e[s + 8], 7, 1770035416), o = _(o, r, n, i, e[s + 9], 12, -1958414417), i = _(i, o, r, n, e[s + 10], 17, -42063), n = _(n, i, o, r, e[s + 11], 22, -1990404162), r = _(r, n, i, o, e[s + 12], 7, 1804603682), o = _(o, r, n, i, e[s + 13], 12, -40341101), i = _(i, o, r, n, e[s + 14], 17, -1502002290), n = _(n, i, o, r, e[s + 15], 22, 1236535329), r = v(r, n, i, o, e[s + 1], 5, -165796510), o = v(o, r, n, i, e[s + 6], 9, -1069501632), i = v(i, o, r, n, e[s + 11], 14, 643717713), n = v(n, i, o, r, e[s], 20, -373897302), r = v(r, n, i, o, e[s + 5], 5, -701558691), o = v(o, r, n, i, e[s + 10], 9, 38016083), i = v(i, o, r, n, e[s + 15], 14, -660478335), n = v(n, i, o, r, e[s + 4], 20, -405537848), r = v(r, n, i, o, e[s + 9], 5, 568446438), o = v(o, r, n, i, e[s + 14], 9, -1019803690), i = v(i, o, r, n, e[s + 3], 14, -187363961), n = v(n, i, o, r, e[s + 8], 20, 1163531501), r = v(r, n, i, o, e[s + 13], 5, -1444681467), o = v(o, r, n, i, e[s + 2], 9, -51403784), i = v(i, o, r, n, e[s + 7], 14, 1735328473), n = v(n, i, o, r, e[s + 12], 20, -1926607734), r = g(r, n, i, o, e[s + 5], 4, -378558), o = g(o, r, n, i, e[s + 8], 11, -2022574463), i = g(i, o, r, n, e[s + 11], 16, 1839030562), n = g(n, i, o, r, e[s + 14], 23, -35309556), r = g(r, n, i, o, e[s + 1], 4, -1530992060), o = g(o, r, n, i, e[s + 4], 11, 1272893353), i = g(i, o, r, n, e[s + 7], 16, -155497632), n = g(n, i, o, r, e[s + 10], 23, -1094730640), r = g(r, n, i, o, e[s + 13], 4, 681279174), o = g(o, r, n, i, e[s], 11, -358537222), i = g(i, o, r, n, e[s + 3], 16, -722521979), n = g(n, i, o, r, e[s + 6], 23, 76029189), r = g(r, n, i, o, e[s + 9], 4, -640364487), o = g(o, r, n, i, e[s + 12], 11, -421815835), i = g(i, o, r, n, e[s + 15], 16, 530742520), n = g(n, i, o, r, e[s + 2], 23, -995338651), r = E(r, n, i, o, e[s], 6, -198630844), o = E(o, r, n, i, e[s + 7], 10, 1126891415), i = E(i, o, r, n, e[s + 14], 15, -1416354905), n = E(n, i, o, r, e[s + 5], 21, -57434055), r = E(r, n, i, o, e[s + 12], 6, 1700485571), o = E(o, r, n, i, e[s + 3], 10, -1894986606), i = E(i, o, r, n, e[s + 10], 15, -1051523), n = E(n, i, o, r, e[s + 1], 21, -2054922799), r = E(r, n, i, o, e[s + 8], 6, 1873313359), o = E(o, r, n, i, e[s + 15], 10, -30611744), i = E(i, o, r, n, e[s + 6], 15, -1560198380), n = E(n, i, o, r, e[s + 13], 21, 1309151649), r = E(r, n, i, o, e[s + 4], 6, -145523070), o = E(o, r, n, i, e[s + 11], 10, -1120210379), i = E(i, o, r, n, e[s + 2], 15, 718787259), n = E(n, i, o, r, e[s + 9], 21, -343485551), r = f(r, a), n = f(n, c), i = f(i, u), o = f(o, d)
            }
            return [r, n, i, o]
        }(function (e) {
            if (0 === e.length) return [];
            for (var t = 8 * e.length, r = new Uint32Array(p(t)), n = 0; n < t; n += 8) r[n >> 5] |= (255 & e[n / 8]) << n % 32;
            return r
        }(e), 8 * e.length))
    }), S = r(97);

    function b(e, t, r, n) {
        switch (e) {
            case 0:
                return t & r ^ ~t & n;
            case 1:
                return t ^ r ^ n;
            case 2:
                return t & r ^ t & n ^ r & n;
            case 3:
                return t ^ r ^ n
        }
    }

    function T(e, t) {
        return e << t | e >>> 32 - t
    }

    var R = h("v5", 80, function (e) {
        var t = [1518500249, 1859775393, 2400959708, 3395469782],
            r = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
        if ("string" == typeof e) {
            var n = unescape(encodeURIComponent(e));
            e = [];
            for (var i = 0; i < n.length; ++i) e.push(n.charCodeAt(i))
        } else Array.isArray(e) || (e = Array.prototype.slice.call(e));
        e.push(128);
        for (var o = e.length / 4 + 2, s = Math.ceil(o / 16), a = new Array(s), c = 0; c < s; ++c) {
            for (var u = new Uint32Array(16), d = 0; d < 16; ++d) u[d] = e[64 * c + 4 * d] << 24 | e[64 * c + 4 * d + 1] << 16 | e[64 * c + 4 * d + 2] << 8 | e[64 * c + 4 * d + 3];
            a[c] = u
        }
        a[s - 1][14] = 8 * (e.length - 1) / Math.pow(2, 32), a[s - 1][14] = Math.floor(a[s - 1][14]), a[s - 1][15] = 8 * (e.length - 1) & 4294967295;
        for (var l = 0; l < s; ++l) {
            for (var h = new Uint32Array(80), p = 0; p < 16; ++p) h[p] = a[l][p];
            for (var f = 16; f < 80; ++f) h[f] = T(h[f - 3] ^ h[f - 8] ^ h[f - 14] ^ h[f - 16], 1);
            for (var m = r[0], _ = r[1], v = r[2], g = r[3], E = r[4], y = 0; y < 80; ++y) {
                var S = Math.floor(y / 20), R = T(m, 5) + b(S, _, v, g) + E + t[S] + h[y] >>> 0;
                E = g, g = v, v = T(_, 30) >>> 0, _ = m, m = R
            }
            r[0] = r[0] + m >>> 0, r[1] = r[1] + _ >>> 0, r[2] = r[2] + v >>> 0, r[3] = r[3] + g >>> 0, r[4] = r[4] + E >>> 0
        }
        return [r[0] >> 24 & 255, r[0] >> 16 & 255, r[0] >> 8 & 255, 255 & r[0], r[1] >> 24 & 255, r[1] >> 16 & 255, r[1] >> 8 & 255, 255 & r[1], r[2] >> 24 & 255, r[2] >> 16 & 255, r[2] >> 8 & 255, 255 & r[2], r[3] >> 24 & 255, r[3] >> 16 & 255, r[3] >> 8 & 255, 255 & r[3], r[4] >> 24 & 255, r[4] >> 16 & 255, r[4] >> 8 & 255, 255 & r[4]]
    }), I = "00000000-0000-0000-0000-000000000000";
    var w = function (e) {
        if (!Object(d.a)(e)) throw TypeError("Invalid UUID");
        return parseInt(e.substr(14, 1), 16)
    }
}, function (e, t, r) {
    var n = r(214), i = r(215), o = r(99), s = r(216);
    e.exports = function (e, t) {
        return n(e) || i(e, t) || o(e, t) || s()
    }
}, function (e, t, r) {
    "use strict";
    r.d(t, "a", function () {
        return j
    });
    var n = r(75), i = r(73), o = r(44), s = r(45), a = r(6), c = r.n(a), u = r(8), d = r.n(u), l = r(10), h = r.n(l),
        p = r(11), f = r.n(p), m = r(7), _ = r.n(m), v = r(3), g = r.n(v), E = r(16), y = r(2), S = r(0), b = r(4),
        T = r(1);

    function R(e) {
        var t = function () {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function () {
                })), !0
            } catch (e) {
                return !1
            }
        }();
        return function () {
            var r, n = _()(e);
            if (t) {
                var i = _()(this).constructor;
                r = Reflect.construct(n, arguments, i)
            } else r = n.apply(this, arguments);
            return f()(this, r)
        }
    }

    var I = y.a.LOG_LEVELS, w = (I.INFO, I.WARN, I.ERROR), C = function (e) {
        h()(r, e);
        var t = R(r);

        function r() {
            return c()(this, r), t.apply(this, arguments)
        }

        return d()(r, null, [{
            key: "getMessagingSenderId", value: function (e) {
                return Object(b.a)(e, function (e) {
                    if (!r.Client || !r.Client.getInstance()) return e(S.errors.NOT_INITIALIZED);
                    var t = r.Client.getInstance();
                    t.request(r.basePath, {method: "get", data: {}}).then(function (t) {
                        var r = t.data && t.data.firebase && t.data.firebase.messagingSenderId ? t.data.firebase.messagingSenderId : null;
                        return e(null, r)
                    }).catch(function (r) {
                        return T.a.log(w, S.errors.API_ERROR, {err: t.error(r)}), e(t.error(r))
                    })
                })
            }
        }, {
            key: "registerFCMToken", value: function (e, t, n) {
                return Object(b.a)(n, function (n) {
                    if (!r.Client || !r.Client.getInstance()) return n(S.errors.NOT_INITIALIZED);
                    var i = r.Client.getInstance();
                    if (!e || "string" != typeof e) return n(S.errors.INVALID_DEVICE_ID);
                    i.request(y.a.BASEPATH_PUSH_NOTIFICATION_TOKENS, {
                        method: "post",
                        data: {deviceId: e, token: t}
                    }).then(function (e) {
                        return n(null, e.data)
                    }).catch(function (e) {
                        return n(i.error(e))
                    })
                })
            }
        }]), r
    }(E.a);
    g()(C, "basePath", y.a.BASEPATH_PUSH_NOTIFICATION_SETTINGS);
    var A = r(35), O = r(17), N = r(46), P = r(47), D = r(64), k = r(66), L = r(69), x = r(68), M = r(67), U = r(70),
        j = {
            User: {Service: o.a, Model: O.a, ListQuery: D.a},
            LiveBroadcast: {
                Service: s.a,
                Model: N.a,
                ListQuery: k.a,
                MessageListQuery: L.a,
                BanListQuery: x.a,
                ViewersListQuery: M.a,
                ReactionsPlaybackQuery: U.a
            },
            PushNotification: {Service: C},
            Conversation: {ConversationModel: P.a},
            Module: {Service: A.a},
            Client: n.a,
            Server: i.a
        }
}, function (e, t, r) {
    "use strict";
    r.r(t), function (e) {
        r.d(t, "ChannelizeLiveBroadcast", function () {
            return s
        }), r.d(t, "core", function () {
            return c
        }), r.d(t, "client", function () {
            return u
        }), r.d(t, "server", function () {
            return d
        });
        var n = r(75), i = r(73), o = r(156);
        e.ChannelizeLiveBroadcast ? console.error("ERROR: It appears that you have multiple copies of the Channelize.io Live Broadcast WebSDK in your build!") : e.ChannelizeLiveBroadcast = {
            core: o.a,
            client: n.a,
            server: i.a
        };
        var s = e.ChannelizeLiveBroadcast, a = e.ChannelizeLiveBroadcast, c = a.core, u = a.client, d = a.server
    }.call(this, r(25))
}, function (e, t, r) {
    var n = r(98);
    e.exports = function (e) {
        if (Array.isArray(e)) return n(e)
    }
}, function (e, t) {
    e.exports = function (e) {
        if ("undefined" != typeof Symbol && Symbol.iterator in Object(e)) return Array.from(e)
    }
}, function (e, t) {
    e.exports = function () {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
    }
}, function (e, t, r) {
    var n = function (e) {
        "use strict";
        var t, r = Object.prototype, n = r.hasOwnProperty, i = "function" == typeof Symbol ? Symbol : {},
            o = i.iterator || "@@iterator", s = i.asyncIterator || "@@asyncIterator",
            a = i.toStringTag || "@@toStringTag";

        function c(e, t, r) {
            return Object.defineProperty(e, t, {value: r, enumerable: !0, configurable: !0, writable: !0}), e[t]
        }

        try {
            c({}, "")
        } catch (e) {
            c = function (e, t, r) {
                return e[t] = r
            }
        }

        function u(e, t, r, n) {
            var i = t && t.prototype instanceof _ ? t : _, o = Object.create(i.prototype), s = new A(n || []);
            return o._invoke = function (e, t, r) {
                var n = l;
                return function (i, o) {
                    if (n === p) throw new Error("Generator is already running");
                    if (n === f) {
                        if ("throw" === i) throw o;
                        return N()
                    }
                    for (r.method = i, r.arg = o; ;) {
                        var s = r.delegate;
                        if (s) {
                            var a = I(s, r);
                            if (a) {
                                if (a === m) continue;
                                return a
                            }
                        }
                        if ("next" === r.method) r.sent = r._sent = r.arg; else if ("throw" === r.method) {
                            if (n === l) throw n = f, r.arg;
                            r.dispatchException(r.arg)
                        } else "return" === r.method && r.abrupt("return", r.arg);
                        n = p;
                        var c = d(e, t, r);
                        if ("normal" === c.type) {
                            if (n = r.done ? f : h, c.arg === m) continue;
                            return {value: c.arg, done: r.done}
                        }
                        "throw" === c.type && (n = f, r.method = "throw", r.arg = c.arg)
                    }
                }
            }(e, r, s), o
        }

        function d(e, t, r) {
            try {
                return {type: "normal", arg: e.call(t, r)}
            } catch (e) {
                return {type: "throw", arg: e}
            }
        }

        e.wrap = u;
        var l = "suspendedStart", h = "suspendedYield", p = "executing", f = "completed", m = {};

        function _() {
        }

        function v() {
        }

        function g() {
        }

        var E = {};
        E[o] = function () {
            return this
        };
        var y = Object.getPrototypeOf, S = y && y(y(O([])));
        S && S !== r && n.call(S, o) && (E = S);
        var b = g.prototype = _.prototype = Object.create(E);

        function T(e) {
            ["next", "throw", "return"].forEach(function (t) {
                c(e, t, function (e) {
                    return this._invoke(t, e)
                })
            })
        }

        function R(e, t) {
            var r;
            this._invoke = function (i, o) {
                function s() {
                    return new t(function (r, s) {
                        !function r(i, o, s, a) {
                            var c = d(e[i], e, o);
                            if ("throw" !== c.type) {
                                var u = c.arg, l = u.value;
                                return l && "object" == typeof l && n.call(l, "__await") ? t.resolve(l.__await).then(function (e) {
                                    r("next", e, s, a)
                                }, function (e) {
                                    r("throw", e, s, a)
                                }) : t.resolve(l).then(function (e) {
                                    u.value = e, s(u)
                                }, function (e) {
                                    return r("throw", e, s, a)
                                })
                            }
                            a(c.arg)
                        }(i, o, r, s)
                    })
                }

                return r = r ? r.then(s, s) : s()
            }
        }

        function I(e, r) {
            var n = e.iterator[r.method];
            if (n === t) {
                if (r.delegate = null, "throw" === r.method) {
                    if (e.iterator.return && (r.method = "return", r.arg = t, I(e, r), "throw" === r.method)) return m;
                    r.method = "throw", r.arg = new TypeError("The iterator does not provide a 'throw' method")
                }
                return m
            }
            var i = d(n, e.iterator, r.arg);
            if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, m;
            var o = i.arg;
            return o ? o.done ? (r[e.resultName] = o.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, m) : o : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, m)
        }

        function w(e) {
            var t = {tryLoc: e[0]};
            1 in e && (t.catchLoc = e[1]), 2 in e && (t.finallyLoc = e[2], t.afterLoc = e[3]), this.tryEntries.push(t)
        }

        function C(e) {
            var t = e.completion || {};
            t.type = "normal", delete t.arg, e.completion = t
        }

        function A(e) {
            this.tryEntries = [{tryLoc: "root"}], e.forEach(w, this), this.reset(!0)
        }

        function O(e) {
            if (e) {
                var r = e[o];
                if (r) return r.call(e);
                if ("function" == typeof e.next) return e;
                if (!isNaN(e.length)) {
                    var i = -1, s = function r() {
                        for (; ++i < e.length;) if (n.call(e, i)) return r.value = e[i], r.done = !1, r;
                        return r.value = t, r.done = !0, r
                    };
                    return s.next = s
                }
            }
            return {next: N}
        }

        function N() {
            return {value: t, done: !0}
        }

        return v.prototype = b.constructor = g, g.constructor = v, v.displayName = c(g, a, "GeneratorFunction"), e.isGeneratorFunction = function (e) {
            var t = "function" == typeof e && e.constructor;
            return !!t && (t === v || "GeneratorFunction" === (t.displayName || t.name))
        }, e.mark = function (e) {
            return Object.setPrototypeOf ? Object.setPrototypeOf(e, g) : (e.__proto__ = g, c(e, a, "GeneratorFunction")), e.prototype = Object.create(b), e
        }, e.awrap = function (e) {
            return {__await: e}
        }, T(R.prototype), R.prototype[s] = function () {
            return this
        }, e.AsyncIterator = R, e.async = function (t, r, n, i, o) {
            void 0 === o && (o = Promise);
            var s = new R(u(t, r, n, i), o);
            return e.isGeneratorFunction(r) ? s : s.next().then(function (e) {
                return e.done ? e.value : s.next()
            })
        }, T(b), c(b, a, "Generator"), b[o] = function () {
            return this
        }, b.toString = function () {
            return "[object Generator]"
        }, e.keys = function (e) {
            var t = [];
            for (var r in e) t.push(r);
            return t.reverse(), function r() {
                for (; t.length;) {
                    var n = t.pop();
                    if (n in e) return r.value = n, r.done = !1, r
                }
                return r.done = !0, r
            }
        }, e.values = O, A.prototype = {
            constructor: A, reset: function (e) {
                if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(C), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t)
            }, stop: function () {
                this.done = !0;
                var e = this.tryEntries[0].completion;
                if ("throw" === e.type) throw e.arg;
                return this.rval
            }, dispatchException: function (e) {
                if (this.done) throw e;
                var r = this;

                function i(n, i) {
                    return a.type = "throw", a.arg = e, r.next = n, i && (r.method = "next", r.arg = t), !!i
                }

                for (var o = this.tryEntries.length - 1; o >= 0; --o) {
                    var s = this.tryEntries[o], a = s.completion;
                    if ("root" === s.tryLoc) return i("end");
                    if (s.tryLoc <= this.prev) {
                        var c = n.call(s, "catchLoc"), u = n.call(s, "finallyLoc");
                        if (c && u) {
                            if (this.prev < s.catchLoc) return i(s.catchLoc, !0);
                            if (this.prev < s.finallyLoc) return i(s.finallyLoc)
                        } else if (c) {
                            if (this.prev < s.catchLoc) return i(s.catchLoc, !0)
                        } else {
                            if (!u) throw new Error("try statement without catch or finally");
                            if (this.prev < s.finallyLoc) return i(s.finallyLoc)
                        }
                    }
                }
            }, abrupt: function (e, t) {
                for (var r = this.tryEntries.length - 1; r >= 0; --r) {
                    var i = this.tryEntries[r];
                    if (i.tryLoc <= this.prev && n.call(i, "finallyLoc") && this.prev < i.finallyLoc) {
                        var o = i;
                        break
                    }
                }
                o && ("break" === e || "continue" === e) && o.tryLoc <= t && t <= o.finallyLoc && (o = null);
                var s = o ? o.completion : {};
                return s.type = e, s.arg = t, o ? (this.method = "next", this.next = o.finallyLoc, m) : this.complete(s)
            }, complete: function (e, t) {
                if ("throw" === e.type) throw e.arg;
                return "break" === e.type || "continue" === e.type ? this.next = e.arg : "return" === e.type ? (this.rval = this.arg = e.arg, this.method = "return", this.next = "end") : "normal" === e.type && t && (this.next = t), m
            }, finish: function (e) {
                for (var t = this.tryEntries.length - 1; t >= 0; --t) {
                    var r = this.tryEntries[t];
                    if (r.finallyLoc === e) return this.complete(r.completion, r.afterLoc), C(r), m
                }
            }, catch: function (e) {
                for (var t = this.tryEntries.length - 1; t >= 0; --t) {
                    var r = this.tryEntries[t];
                    if (r.tryLoc === e) {
                        var n = r.completion;
                        if ("throw" === n.type) {
                            var i = n.arg;
                            C(r)
                        }
                        return i
                    }
                }
                throw new Error("illegal catch attempt")
            }, delegateYield: function (e, r, n) {
                return this.delegate = {
                    iterator: O(e),
                    resultName: r,
                    nextLoc: n
                }, "next" === this.method && (this.arg = t), m
            }
        }, e
    }(e.exports);
    try {
        regeneratorRuntime = n
    } catch (e) {
        Function("r", "regeneratorRuntime = r")(n)
    }
}, function (e, t, r) {
    "use strict";
    var n = r(21), i = r(100), o = r(164), s = r(76);

    function a(e) {
        var t = new o(e), r = i(o.prototype.request, t);
        return n.extend(r, o.prototype, t), n.extend(r, t), r
    }

    var c = a(s);
    c.Axios = o, c.create = function (e) {
        return a(n.merge(s, e))
    }, c.Cancel = r(104), c.CancelToken = r(177), c.isCancel = r(103), c.all = function (e) {
        return Promise.all(e)
    }, c.spread = r(178), e.exports = c, e.exports.default = c
}, function (e, t) {
    /*!
     * Determine if an object is a Buffer
     *
     * @author   Feross Aboukhadijeh <https://feross.org>
     * @license  MIT
     */
    e.exports = function (e) {
        return null != e && null != e.constructor && "function" == typeof e.constructor.isBuffer && e.constructor.isBuffer(e)
    }
}, function (e, t, r) {
    "use strict";
    var n = r(76), i = r(21), o = r(172), s = r(173);

    function a(e) {
        this.defaults = e, this.interceptors = {request: new o, response: new o}
    }

    a.prototype.request = function (e) {
        "string" == typeof e && (e = i.merge({url: arguments[0]}, arguments[1])), (e = i.merge(n, {method: "get"}, this.defaults, e)).method = e.method.toLowerCase();
        var t = [s, void 0], r = Promise.resolve(e);
        for (this.interceptors.request.forEach(function (e) {
            t.unshift(e.fulfilled, e.rejected)
        }), this.interceptors.response.forEach(function (e) {
            t.push(e.fulfilled, e.rejected)
        }); t.length;) r = r.then(t.shift(), t.shift());
        return r
    }, i.forEach(["delete", "get", "head", "options"], function (e) {
        a.prototype[e] = function (t, r) {
            return this.request(i.merge(r || {}, {method: e, url: t}))
        }
    }), i.forEach(["post", "put", "patch"], function (e) {
        a.prototype[e] = function (t, r, n) {
            return this.request(i.merge(n || {}, {method: e, url: t, data: r}))
        }
    }), e.exports = a
}, function (e, t, r) {
    "use strict";
    var n = r(21);
    e.exports = function (e, t) {
        n.forEach(e, function (r, n) {
            n !== t && n.toUpperCase() === t.toUpperCase() && (e[t] = r, delete e[n])
        })
    }
}, function (e, t, r) {
    "use strict";
    var n = r(102);
    e.exports = function (e, t, r) {
        var i = r.config.validateStatus;
        r.status && i && !i(r.status) ? t(n("Request failed with status code " + r.status, r.config, null, r.request, r)) : e(r)
    }
}, function (e, t, r) {
    "use strict";
    e.exports = function (e, t, r, n, i) {
        return e.config = t, r && (e.code = r), e.request = n, e.response = i, e
    }
}, function (e, t, r) {
    "use strict";
    var n = r(21);

    function i(e) {
        return encodeURIComponent(e).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]")
    }

    e.exports = function (e, t, r) {
        if (!t) return e;
        var o;
        if (r) o = r(t); else if (n.isURLSearchParams(t)) o = t.toString(); else {
            var s = [];
            n.forEach(t, function (e, t) {
                null !== e && void 0 !== e && (n.isArray(e) ? t += "[]" : e = [e], n.forEach(e, function (e) {
                    n.isDate(e) ? e = e.toISOString() : n.isObject(e) && (e = JSON.stringify(e)), s.push(i(t) + "=" + i(e))
                }))
            }), o = s.join("&")
        }
        return o && (e += (-1 === e.indexOf("?") ? "?" : "&") + o), e
    }
}, function (e, t, r) {
    "use strict";
    var n = r(21),
        i = ["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"];
    e.exports = function (e) {
        var t, r, o, s = {};
        return e ? (n.forEach(e.split("\n"), function (e) {
            if (o = e.indexOf(":"), t = n.trim(e.substr(0, o)).toLowerCase(), r = n.trim(e.substr(o + 1)), t) {
                if (s[t] && i.indexOf(t) >= 0) return;
                s[t] = "set-cookie" === t ? (s[t] ? s[t] : []).concat([r]) : s[t] ? s[t] + ", " + r : r
            }
        }), s) : s
    }
}, function (e, t, r) {
    "use strict";
    var n = r(21);
    e.exports = n.isStandardBrowserEnv() ? function () {
        var e, t = /(msie|trident)/i.test(navigator.userAgent), r = document.createElement("a");

        function i(e) {
            var n = e;
            return t && (r.setAttribute("href", n), n = r.href), r.setAttribute("href", n), {
                href: r.href,
                protocol: r.protocol ? r.protocol.replace(/:$/, "") : "",
                host: r.host,
                search: r.search ? r.search.replace(/^\?/, "") : "",
                hash: r.hash ? r.hash.replace(/^#/, "") : "",
                hostname: r.hostname,
                port: r.port,
                pathname: "/" === r.pathname.charAt(0) ? r.pathname : "/" + r.pathname
            }
        }

        return e = i(window.location.href), function (t) {
            var r = n.isString(t) ? i(t) : t;
            return r.protocol === e.protocol && r.host === e.host
        }
    }() : function () {
        return !0
    }
}, function (e, t, r) {
    "use strict";
    var n = r(21);
    e.exports = n.isStandardBrowserEnv() ? {
        write: function (e, t, r, i, o, s) {
            var a = [];
            a.push(e + "=" + encodeURIComponent(t)), n.isNumber(r) && a.push("expires=" + new Date(r).toGMTString()), n.isString(i) && a.push("path=" + i), n.isString(o) && a.push("domain=" + o), !0 === s && a.push("secure"), document.cookie = a.join("; ")
        }, read: function (e) {
            var t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)"));
            return t ? decodeURIComponent(t[3]) : null
        }, remove: function (e) {
            this.write(e, "", Date.now() - 864e5)
        }
    } : {
        write: function () {
        }, read: function () {
            return null
        }, remove: function () {
        }
    }
}, function (e, t, r) {
    "use strict";
    var n = r(21);

    function i() {
        this.handlers = []
    }

    i.prototype.use = function (e, t) {
        return this.handlers.push({fulfilled: e, rejected: t}), this.handlers.length - 1
    }, i.prototype.eject = function (e) {
        this.handlers[e] && (this.handlers[e] = null)
    }, i.prototype.forEach = function (e) {
        n.forEach(this.handlers, function (t) {
            null !== t && e(t)
        })
    }, e.exports = i
}, function (e, t, r) {
    "use strict";
    var n = r(21), i = r(174), o = r(103), s = r(76), a = r(175), c = r(176);

    function u(e) {
        e.cancelToken && e.cancelToken.throwIfRequested()
    }

    e.exports = function (e) {
        return u(e), e.baseURL && !a(e.url) && (e.url = c(e.baseURL, e.url)), e.headers = e.headers || {}, e.data = i(e.data, e.headers, e.transformRequest), e.headers = n.merge(e.headers.common || {}, e.headers[e.method] || {}, e.headers || {}), n.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function (t) {
            delete e.headers[t]
        }), (e.adapter || s.adapter)(e).then(function (t) {
            return u(e), t.data = i(t.data, t.headers, e.transformResponse), t
        }, function (t) {
            return o(t) || (u(e), t && t.response && (t.response.data = i(t.response.data, t.response.headers, e.transformResponse))), Promise.reject(t)
        })
    }
}, function (e, t, r) {
    "use strict";
    var n = r(21);
    e.exports = function (e, t, r) {
        return n.forEach(r, function (r) {
            e = r(e, t)
        }), e
    }
}, function (e, t, r) {
    "use strict";
    e.exports = function (e) {
        return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(e)
    }
}, function (e, t, r) {
    "use strict";
    e.exports = function (e, t) {
        return t ? e.replace(/\/+$/, "") + "/" + t.replace(/^\/+/, "") : e
    }
}, function (e, t, r) {
    "use strict";
    var n = r(104);

    function i(e) {
        if ("function" != typeof e) throw new TypeError("executor must be a function.");
        var t;
        this.promise = new Promise(function (e) {
            t = e
        });
        var r = this;
        e(function (e) {
            r.reason || (r.reason = new n(e), t(r.reason))
        })
    }

    i.prototype.throwIfRequested = function () {
        if (this.reason) throw this.reason
    }, i.source = function () {
        var e;
        return {
            token: new i(function (t) {
                e = t
            }), cancel: e
        }
    }, e.exports = i
}, function (e, t, r) {
    "use strict";
    e.exports = function (e) {
        return function (t) {
            return e.apply(null, t)
        }
    }
}, function (e, t) {
    function r(t, n) {
        return e.exports = r = Object.setPrototypeOf || function (e, t) {
            return e.__proto__ = t, e
        }, r(t, n)
    }

    e.exports = r
}, function (e, t, r) {
    "use strict";
    var n = r(181), i = r(77), o = r(185), s = r(105), a = r(106), c = r(186), u = r(187), d = r(208), l = r(41);
    e.exports = v, v.prototype.validate = function (e, t) {
        var r;
        if ("string" == typeof e) {
            if (!(r = this.getSchema(e))) throw new Error('no schema with key or ref "' + e + '"')
        } else {
            var n = this._addSchema(e);
            r = n.validate || this._compile(n)
        }
        var i = r(t);
        !0 !== r.$async && (this.errors = r.errors);
        return i
    }, v.prototype.compile = function (e, t) {
        var r = this._addSchema(e, void 0, t);
        return r.validate || this._compile(r)
    }, v.prototype.addSchema = function (e, t, r, n) {
        if (Array.isArray(e)) {
            for (var o = 0; o < e.length; o++) this.addSchema(e[o], void 0, r, n);
            return this
        }
        var s = this._getId(e);
        if (void 0 !== s && "string" != typeof s) throw new Error("schema id must be string");
        return T(this, t = i.normalizeId(t || s)), this._schemas[t] = this._addSchema(e, r, n, !0), this
    }, v.prototype.addMetaSchema = function (e, t, r) {
        return this.addSchema(e, t, r, !0), this
    }, v.prototype.validateSchema = function (e, t) {
        var r = e.$schema;
        if (void 0 !== r && "string" != typeof r) throw new Error("$schema must be a string");
        if (!(r = r || this._opts.defaultMeta || function (e) {
            var t = e._opts.meta;
            return e._opts.defaultMeta = "object" == typeof t ? e._getId(t) || t : e.getSchema(f) ? f : void 0, e._opts.defaultMeta
        }(this))) return this.logger.warn("meta-schema not available"), this.errors = null, !0;
        var n = this.validate(r, e);
        if (!n && t) {
            var i = "schema is invalid: " + this.errorsText();
            if ("log" != this._opts.validateSchema) throw new Error(i);
            this.logger.error(i)
        }
        return n
    }, v.prototype.getSchema = function (e) {
        var t = g(this, e);
        switch (typeof t) {
            case"object":
                return t.validate || this._compile(t);
            case"string":
                return this.getSchema(t);
            case"undefined":
                return function (e, t) {
                    var r = i.schema.call(e, {schema: {}}, t);
                    if (r) {
                        var o = r.schema, a = r.root, c = r.baseId, u = n.call(e, o, a, void 0, c);
                        return e._fragments[t] = new s({
                            ref: t,
                            fragment: !0,
                            schema: o,
                            root: a,
                            baseId: c,
                            validate: u
                        }), u
                    }
                }(this, e)
        }
    }, v.prototype.removeSchema = function (e) {
        if (e instanceof RegExp) return E(this, this._schemas, e), E(this, this._refs, e), this;
        switch (typeof e) {
            case"undefined":
                return E(this, this._schemas), E(this, this._refs), this._cache.clear(), this;
            case"string":
                var t = g(this, e);
                return t && this._cache.del(t.cacheKey), delete this._schemas[e], delete this._refs[e], this;
            case"object":
                var r = this._opts.serialize, n = r ? r(e) : e;
                this._cache.del(n);
                var o = this._getId(e);
                o && (o = i.normalizeId(o), delete this._schemas[o], delete this._refs[o])
        }
        return this
    }, v.prototype.addFormat = function (e, t) {
        "string" == typeof t && (t = new RegExp(t));
        return this._formats[e] = t, this
    }, v.prototype.errorsText = function (e, t) {
        if (!(e = e || this.errors)) return "No errors";
        for (var r = void 0 === (t = t || {}).separator ? ", " : t.separator, n = void 0 === t.dataVar ? "data" : t.dataVar, i = "", o = 0; o < e.length; o++) {
            var s = e[o];
            s && (i += n + s.dataPath + " " + s.message + r)
        }
        return i.slice(0, -r.length)
    }, v.prototype._addSchema = function (e, t, r, n) {
        if ("object" != typeof e && "boolean" != typeof e) throw new Error("schema should be object or boolean");
        var o = this._opts.serialize, a = o ? o(e) : e, c = this._cache.get(a);
        if (c) return c;
        n = n || !1 !== this._opts.addUsedSchema;
        var u = i.normalizeId(this._getId(e));
        u && n && T(this, u);
        var d, l = !1 !== this._opts.validateSchema && !t;
        l && !(d = u && u == i.normalizeId(e.$schema)) && this.validateSchema(e, !0);
        var h = i.ids.call(this, e), p = new s({id: u, schema: e, localRefs: h, cacheKey: a, meta: r});
        "#" != u[0] && n && (this._refs[u] = p);
        this._cache.put(a, p), l && d && this.validateSchema(e, !0);
        return p
    }, v.prototype._compile = function (e, t) {
        if (e.compiling) return e.validate = o, o.schema = e.schema, o.errors = null, o.root = t || o, !0 === e.schema.$async && (o.$async = !0), o;
        var r, i;
        e.compiling = !0, e.meta && (r = this._opts, this._opts = this._metaOpts);
        try {
            i = n.call(this, e.schema, t, e.localRefs)
        } catch (t) {
            throw delete e.validate, t
        } finally {
            e.compiling = !1, e.meta && (this._opts = r)
        }
        return e.validate = i, e.refs = i.refs, e.refVal = i.refVal, e.root = i.root, i;

        function o() {
            var t = e.validate, r = t.apply(this, arguments);
            return o.errors = t.errors, r
        }
    }, v.prototype.compileAsync = r(209);
    var h = r(210);
    v.prototype.addKeyword = h.add, v.prototype.getKeyword = h.get, v.prototype.removeKeyword = h.remove, v.prototype.validateKeyword = h.validate;
    var p = r(79);
    v.ValidationError = p.Validation, v.MissingRefError = p.MissingRef, v.$dataMetaSchema = d;
    var f = "http://json-schema.org/draft-07/schema",
        m = ["removeAdditional", "useDefaults", "coerceTypes", "strictDefaults"], _ = ["/properties"];

    function v(e) {
        if (!(this instanceof v)) return new v(e);
        e = this._opts = l.copy(e) || {}, function (e) {
            var t = e._opts.logger;
            if (!1 === t) e.logger = {log: R, warn: R, error: R}; else {
                if (void 0 === t && (t = console), !("object" == typeof t && t.log && t.warn && t.error)) throw new Error("logger must implement log, warn and error methods");
                e.logger = t
            }
        }(this), this._schemas = {}, this._refs = {}, this._fragments = {}, this._formats = c(e.format), this._cache = e.cache || new o, this._loadingSchemas = {}, this._compilations = [], this.RULES = u(), this._getId = function (e) {
            switch (e.schemaId) {
                case"auto":
                    return b;
                case"id":
                    return y;
                default:
                    return S
            }
        }(e), e.loopRequired = e.loopRequired || 1 / 0, "property" == e.errorDataPath && (e._errorDataPathProperty = !0), void 0 === e.serialize && (e.serialize = a), this._metaOpts = function (e) {
            for (var t = l.copy(e._opts), r = 0; r < m.length; r++) delete t[m[r]];
            return t
        }(this), e.formats && function (e) {
            for (var t in e._opts.formats) {
                var r = e._opts.formats[t];
                e.addFormat(t, r)
            }
        }(this), e.keywords && function (e) {
            for (var t in e._opts.keywords) {
                var r = e._opts.keywords[t];
                e.addKeyword(t, r)
            }
        }(this), function (e) {
            var t;
            e._opts.$data && (t = r(213), e.addMetaSchema(t, t.$id, !0));
            if (!1 === e._opts.meta) return;
            var n = r(112);
            e._opts.$data && (n = d(n, _));
            e.addMetaSchema(n, f, !0), e._refs["http://json-schema.org/schema"] = f
        }(this), "object" == typeof e.meta && this.addMetaSchema(e.meta), e.nullable && this.addKeyword("nullable", {metaSchema: {type: "boolean"}}), function (e) {
            var t = e._opts.schemas;
            if (!t) return;
            if (Array.isArray(t)) e.addSchema(t); else for (var r in t) e.addSchema(t[r], r)
        }(this)
    }

    function g(e, t) {
        return t = i.normalizeId(t), e._schemas[t] || e._refs[t] || e._fragments[t]
    }

    function E(e, t, r) {
        for (var n in t) {
            var i = t[n];
            i.meta || r && !r.test(n) || (e._cache.del(i.cacheKey), delete t[n])
        }
    }

    function y(e) {
        return e.$id && this.logger.warn("schema $id ignored", e.$id), e.id
    }

    function S(e) {
        return e.id && this.logger.warn("schema id ignored", e.id), e.$id
    }

    function b(e) {
        if (e.$id && e.id && e.$id != e.id) throw new Error("schema $id is different from id");
        return e.$id || e.id
    }

    function T(e, t) {
        if (e._schemas[t] || e._refs[t]) throw new Error('schema with key or id "' + t + '" already exists')
    }

    function R() {
    }
}, function (e, t, r) {
    "use strict";
    var n = r(77), i = r(41), o = r(79), s = r(106), a = r(107), c = i.ucs2length, u = r(78), d = o.Validation;

    function l(e, t, r) {
        for (var n = 0; n < this._compilations.length; n++) {
            var i = this._compilations[n];
            if (i.schema == e && i.root == t && i.baseId == r) return n
        }
        return -1
    }

    function h(e, t) {
        return "var pattern" + e + " = new RegExp(" + i.toQuotedString(t[e]) + ");"
    }

    function p(e) {
        return "var default" + e + " = defaults[" + e + "];"
    }

    function f(e, t) {
        return void 0 === t[e] ? "" : "var refVal" + e + " = refVal[" + e + "];"
    }

    function m(e) {
        return "var customRule" + e + " = customRules[" + e + "];"
    }

    function _(e, t) {
        if (!e.length) return "";
        for (var r = "", n = 0; n < e.length; n++) r += t(n, e);
        return r
    }

    e.exports = function e(t, r, v, g) {
        var E = this, y = this._opts, S = [void 0], b = {}, T = [], R = {}, I = [], w = {}, C = [];
        r = r || {schema: t, refVal: S, refs: b};
        var A = function (e, t, r) {
            var n = l.call(this, e, t, r);
            return n >= 0 ? {
                index: n,
                compiling: !0
            } : (n = this._compilations.length, this._compilations[n] = {schema: e, root: t, baseId: r}, {
                index: n,
                compiling: !1
            })
        }.call(this, t, r, g);
        var O = this._compilations[A.index];
        if (A.compiling) return O.callValidate = function e() {
            var t = O.validate;
            var r = t.apply(this, arguments);
            e.errors = t.errors;
            return r
        };
        var N = this._formats;
        var P = this.RULES;
        try {
            var D = L(t, r, v, g);
            O.validate = D;
            var k = O.callValidate;
            return k && (k.schema = D.schema, k.errors = null, k.refs = D.refs, k.refVal = D.refVal, k.root = D.root, k.$async = D.$async, y.sourceCode && (k.source = D.source)), D
        } finally {
            (function (e, t, r) {
                var n = l.call(this, e, t, r);
                n >= 0 && this._compilations.splice(n, 1)
            }).call(this, t, r, g)
        }

        function L(t, s, l, v) {
            var g = !s || s && s.schema == t;
            if (s.schema != r.schema) return e.call(E, t, s, l, v);
            var R, w = !0 === t.$async, A = a({
                isTop: !0,
                schema: t,
                isRoot: g,
                baseId: v,
                root: s,
                schemaPath: "",
                errSchemaPath: "#",
                errorPath: '""',
                MissingRefError: o.MissingRef,
                RULES: P,
                validate: a,
                util: i,
                resolve: n,
                resolveRef: x,
                usePattern: j,
                useDefault: V,
                useCustomRule: F,
                opts: y,
                formats: N,
                logger: E.logger,
                self: E
            });
            A = _(S, f) + _(T, h) + _(I, p) + _(C, m) + A, y.processCode && (A = y.processCode(A, t));
            try {
                var O = new Function("self", "RULES", "formats", "root", "refVal", "defaults", "customRules", "equal", "ucs2length", "ValidationError", A);
                R = O(E, P, N, r, S, I, C, u, c, d), S[0] = R
            } catch (e) {
                throw E.logger.error("Error compiling schema, function code:", A), e
            }
            return R.schema = t, R.errors = null, R.refs = b, R.refVal = S, R.root = g ? R : s, w && (R.$async = !0), !0 === y.sourceCode && (R.source = {
                code: A,
                patterns: T,
                defaults: I
            }), R
        }

        function x(t, i, o) {
            i = n.url(t, i);
            var s, a, c = b[i];
            if (void 0 !== c) return U(s = S[c], a = "refVal[" + c + "]");
            if (!o && r.refs) {
                var u = r.refs[i];
                if (void 0 !== u) return s = r.refVal[u], a = M(i, s), U(s, a)
            }
            a = M(i);
            var d = n.call(E, L, r, i);
            if (void 0 === d) {
                var l = v && v[i];
                l && (d = n.inlineRef(l, y.inlineRefs) ? l : e.call(E, l, r, v, t))
            }
            if (void 0 !== d) return function (e, t) {
                var r = b[e];
                S[r] = t
            }(i, d), U(d, a);
            !function (e) {
                delete b[e]
            }(i)
        }

        function M(e, t) {
            var r = S.length;
            return S[r] = t, b[e] = r, "refVal" + r
        }

        function U(e, t) {
            return "object" == typeof e || "boolean" == typeof e ? {code: t, schema: e, inline: !0} : {
                code: t,
                $async: e && !!e.$async
            }
        }

        function j(e) {
            var t = R[e];
            return void 0 === t && (t = R[e] = T.length, T[t] = e), "pattern" + t
        }

        function V(e) {
            switch (typeof e) {
                case"boolean":
                case"number":
                    return "" + e;
                case"string":
                    return i.toQuotedString(e);
                case"object":
                    if (null === e) return "null";
                    var t = s(e), r = w[t];
                    return void 0 === r && (r = w[t] = I.length, I[r] = e), "default" + r
            }
        }

        function F(e, t, r, n) {
            if (!1 !== E._opts.validateSchema) {
                var i = e.definition.dependencies;
                if (i && !i.every(function (e) {
                    return Object.prototype.hasOwnProperty.call(r, e)
                })) throw new Error("parent schema must have all required keywords: " + i.join(","));
                var o = e.definition.validateSchema;
                if (o) {
                    var s = o(t);
                    if (!s) {
                        var a = "keyword schema is invalid: " + E.errorsText(o.errors);
                        if ("log" != E._opts.validateSchema) throw new Error(a);
                        E.logger.error(a)
                    }
                }
            }
            var c, u = e.definition.compile, d = e.definition.inline, l = e.definition.macro;
            if (u) c = u.call(E, t, r, n); else if (l) c = l.call(E, t, r, n), !1 !== y.validateSchema && E.validateSchema(c, !0); else if (d) c = d.call(E, n, e.keyword, t, r); else if (!(c = e.definition.validate)) return;
            if (void 0 === c) throw new Error('custom keyword "' + e.keyword + '"failed to compile');
            var h = C.length;
            return C[h] = c, {code: "customRule" + h, validate: c}
        }
    }
}, function (e, t, r) {
    /** @license URI.js v4.4.0 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
    !function (e) {
        "use strict";

        function t() {
            for (var e = arguments.length, t = Array(e), r = 0; r < e; r++) t[r] = arguments[r];
            if (t.length > 1) {
                t[0] = t[0].slice(0, -1);
                for (var n = t.length - 1, i = 1; i < n; ++i) t[i] = t[i].slice(1, -1);
                return t[n] = t[n].slice(1), t.join("")
            }
            return t[0]
        }

        function r(e) {
            return "(?:" + e + ")"
        }

        function n(e) {
            return void 0 === e ? "undefined" : null === e ? "null" : Object.prototype.toString.call(e).split(" ").pop().split("]").shift().toLowerCase()
        }

        function i(e) {
            return e.toUpperCase()
        }

        function o(e) {
            var n = t("[0-9]", "[A-Fa-f]"),
                i = r(r("%[EFef]" + n + "%" + n + n + "%" + n + n) + "|" + r("%[89A-Fa-f]" + n + "%" + n + n) + "|" + r("%" + n + n)),
                o = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", s = t("[\\:\\/\\?\\#\\[\\]\\@]", o),
                a = e ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]",
                c = e ? "[\\uE000-\\uF8FF]" : "[]", u = t("[A-Za-z]", "[0-9]", "[\\-\\.\\_\\~]", a),
                d = r("[A-Za-z]" + t("[A-Za-z]", "[0-9]", "[\\+\\-\\.]") + "*"),
                l = r(r(i + "|" + t(u, o, "[\\:]")) + "*"),
                h = (r(r("25[0-5]") + "|" + r("2[0-4][0-9]") + "|" + r("1[0-9][0-9]") + "|" + r("[1-9][0-9]") + "|[0-9]"), r(r("25[0-5]") + "|" + r("2[0-4][0-9]") + "|" + r("1[0-9][0-9]") + "|" + r("0?[1-9][0-9]") + "|0?0?[0-9]")),
                p = r(h + "\\." + h + "\\." + h + "\\." + h), f = r(n + "{1,4}"), m = r(r(f + "\\:" + f) + "|" + p),
                _ = r(r(f + "\\:") + "{6}" + m), v = r("\\:\\:" + r(f + "\\:") + "{5}" + m),
                g = r(r(f) + "?\\:\\:" + r(f + "\\:") + "{4}" + m),
                E = r(r(r(f + "\\:") + "{0,1}" + f) + "?\\:\\:" + r(f + "\\:") + "{3}" + m),
                y = r(r(r(f + "\\:") + "{0,2}" + f) + "?\\:\\:" + r(f + "\\:") + "{2}" + m),
                S = r(r(r(f + "\\:") + "{0,3}" + f) + "?\\:\\:" + f + "\\:" + m),
                b = r(r(r(f + "\\:") + "{0,4}" + f) + "?\\:\\:" + m),
                T = r(r(r(f + "\\:") + "{0,5}" + f) + "?\\:\\:" + f), R = r(r(r(f + "\\:") + "{0,6}" + f) + "?\\:\\:"),
                I = r([_, v, g, E, y, S, b, T, R].join("|")), w = r(r(u + "|" + i) + "+"),
                C = (r(I + "\\%25" + w), r(I + r("\\%25|\\%(?!" + n + "{2})") + w)),
                A = r("[vV]" + n + "+\\." + t(u, o, "[\\:]") + "+"), O = r("\\[" + r(C + "|" + I + "|" + A) + "\\]"),
                N = r(r(i + "|" + t(u, o)) + "*"), P = r(O + "|" + p + "(?!" + N + ")|" + N), D = r("[0-9]*"),
                k = r(r(l + "@") + "?" + P + r("\\:" + D) + "?"), L = r(i + "|" + t(u, o, "[\\:\\@]")), x = r(L + "*"),
                M = r(L + "+"), U = r(r(i + "|" + t(u, o, "[\\@]")) + "+"), j = r(r("\\/" + x) + "*"),
                V = r("\\/" + r(M + j) + "?"), F = r(U + j), B = r(M + j), W = "(?!" + L + ")",
                G = (r(j + "|" + V + "|" + F + "|" + B + "|" + W), r(r(L + "|" + t("[\\/\\?]", c)) + "*")),
                q = r(r(L + "|[\\/\\?]") + "*"), H = r(r("\\/\\/" + k + j) + "|" + V + "|" + B + "|" + W),
                K = r(d + "\\:" + H + r("\\?" + G) + "?" + r("\\#" + q) + "?"),
                z = r(r("\\/\\/" + k + j) + "|" + V + "|" + F + "|" + W),
                Y = r(z + r("\\?" + G) + "?" + r("\\#" + q) + "?");
            return r(K + "|" + Y), r(d + "\\:" + H + r("\\?" + G) + "?"), r(r("\\/\\/(" + r("(" + l + ")@") + "?(" + P + ")" + r("\\:(" + D + ")") + "?)") + "?(" + j + "|" + V + "|" + B + "|" + W + ")"), r("\\?(" + G + ")"), r("\\#(" + q + ")"), r(r("\\/\\/(" + r("(" + l + ")@") + "?(" + P + ")" + r("\\:(" + D + ")") + "?)") + "?(" + j + "|" + V + "|" + F + "|" + W + ")"), r("\\?(" + G + ")"), r("\\#(" + q + ")"), r(r("\\/\\/(" + r("(" + l + ")@") + "?(" + P + ")" + r("\\:(" + D + ")") + "?)") + "?(" + j + "|" + V + "|" + B + "|" + W + ")"), r("\\?(" + G + ")"), r("\\#(" + q + ")"), r("(" + l + ")@"), r("\\:(" + D + ")"), {
                NOT_SCHEME: new RegExp(t("[^]", "[A-Za-z]", "[0-9]", "[\\+\\-\\.]"), "g"),
                NOT_USERINFO: new RegExp(t("[^\\%\\:]", u, o), "g"),
                NOT_HOST: new RegExp(t("[^\\%\\[\\]\\:]", u, o), "g"),
                NOT_PATH: new RegExp(t("[^\\%\\/\\:\\@]", u, o), "g"),
                NOT_PATH_NOSCHEME: new RegExp(t("[^\\%\\/\\@]", u, o), "g"),
                NOT_QUERY: new RegExp(t("[^\\%]", u, o, "[\\:\\@\\/\\?]", c), "g"),
                NOT_FRAGMENT: new RegExp(t("[^\\%]", u, o, "[\\:\\@\\/\\?]"), "g"),
                ESCAPE: new RegExp(t("[^]", u, o), "g"),
                UNRESERVED: new RegExp(u, "g"),
                OTHER_CHARS: new RegExp(t("[^\\%]", u, s), "g"),
                PCT_ENCODED: new RegExp(i, "g"),
                IPV4ADDRESS: new RegExp("^(" + p + ")$"),
                IPV6ADDRESS: new RegExp("^\\[?(" + I + ")" + r(r("\\%25|\\%(?!" + n + "{2})") + "(" + w + ")") + "?\\]?$")
            }
        }

        var s = o(!1), a = o(!0), c = function (e, t) {
            if (Array.isArray(e)) return e;
            if (Symbol.iterator in Object(e)) return function (e, t) {
                var r = [], n = !0, i = !1, o = void 0;
                try {
                    for (var s, a = e[Symbol.iterator](); !(n = (s = a.next()).done) && (r.push(s.value), !t || r.length !== t); n = !0) ;
                } catch (e) {
                    i = !0, o = e
                } finally {
                    try {
                        !n && a.return && a.return()
                    } finally {
                        if (i) throw o
                    }
                }
                return r
            }(e, t);
            throw new TypeError("Invalid attempt to destructure non-iterable instance")
        }, u = 2147483647, d = /^xn--/, l = /[^\0-\x7E]/, h = /[\x2E\u3002\uFF0E\uFF61]/g, p = {
            overflow: "Overflow: input needs wider integers to process",
            "not-basic": "Illegal input >= 0x80 (not a basic code point)",
            "invalid-input": "Invalid input"
        }, f = Math.floor, m = String.fromCharCode;

        function _(e) {
            throw new RangeError(p[e])
        }

        function v(e, t) {
            var r = e.split("@"), n = "";
            r.length > 1 && (n = r[0] + "@", e = r[1]);
            var i = (e = e.replace(h, ".")).split("."), o = function (e, t) {
                for (var r = [], n = e.length; n--;) r[n] = t(e[n]);
                return r
            }(i, t).join(".");
            return n + o
        }

        function g(e) {
            for (var t = [], r = 0, n = e.length; r < n;) {
                var i = e.charCodeAt(r++);
                if (i >= 55296 && i <= 56319 && r < n) {
                    var o = e.charCodeAt(r++);
                    56320 == (64512 & o) ? t.push(((1023 & i) << 10) + (1023 & o) + 65536) : (t.push(i), r--)
                } else t.push(i)
            }
            return t
        }

        var E = function (e) {
            return e - 48 < 10 ? e - 22 : e - 65 < 26 ? e - 65 : e - 97 < 26 ? e - 97 : 36
        }, y = function (e, t) {
            return e + 22 + 75 * (e < 26) - ((0 != t) << 5)
        }, S = function (e, t, r) {
            var n = 0;
            for (e = r ? f(e / 700) : e >> 1, e += f(e / t); e > 455; n += 36) e = f(e / 35);
            return f(n + 36 * e / (e + 38))
        }, b = function (e) {
            var t = [], r = e.length, n = 0, i = 128, o = 72, s = e.lastIndexOf("-");
            s < 0 && (s = 0);
            for (var a = 0; a < s; ++a) e.charCodeAt(a) >= 128 && _("not-basic"), t.push(e.charCodeAt(a));
            for (var c = s > 0 ? s + 1 : 0; c < r;) {
                for (var d = n, l = 1, h = 36; ; h += 36) {
                    c >= r && _("invalid-input");
                    var p = E(e.charCodeAt(c++));
                    (p >= 36 || p > f((u - n) / l)) && _("overflow"), n += p * l;
                    var m = h <= o ? 1 : h >= o + 26 ? 26 : h - o;
                    if (p < m) break;
                    var v = 36 - m;
                    l > f(u / v) && _("overflow"), l *= v
                }
                var g = t.length + 1;
                o = S(n - d, g, 0 == d), f(n / g) > u - i && _("overflow"), i += f(n / g), n %= g, t.splice(n++, 0, i)
            }
            return String.fromCodePoint.apply(String, t)
        }, T = function (e) {
            var t = [], r = (e = g(e)).length, n = 128, i = 0, o = 72, s = !0, a = !1, c = void 0;
            try {
                for (var d, l = e[Symbol.iterator](); !(s = (d = l.next()).done); s = !0) {
                    var h = d.value;
                    h < 128 && t.push(m(h))
                }
            } catch (e) {
                a = !0, c = e
            } finally {
                try {
                    !s && l.return && l.return()
                } finally {
                    if (a) throw c
                }
            }
            var p = t.length, v = p;
            for (p && t.push("-"); v < r;) {
                var E = u, b = !0, T = !1, R = void 0;
                try {
                    for (var I, w = e[Symbol.iterator](); !(b = (I = w.next()).done); b = !0) {
                        var C = I.value;
                        C >= n && C < E && (E = C)
                    }
                } catch (e) {
                    T = !0, R = e
                } finally {
                    try {
                        !b && w.return && w.return()
                    } finally {
                        if (T) throw R
                    }
                }
                var A = v + 1;
                E - n > f((u - i) / A) && _("overflow"), i += (E - n) * A, n = E;
                var O = !0, N = !1, P = void 0;
                try {
                    for (var D, k = e[Symbol.iterator](); !(O = (D = k.next()).done); O = !0) {
                        var L = D.value;
                        if (L < n && ++i > u && _("overflow"), L == n) {
                            for (var x = i, M = 36; ; M += 36) {
                                var U = M <= o ? 1 : M >= o + 26 ? 26 : M - o;
                                if (x < U) break;
                                var j = x - U, V = 36 - U;
                                t.push(m(y(U + j % V, 0))), x = f(j / V)
                            }
                            t.push(m(y(x, 0))), o = S(i, A, v == p), i = 0, ++v
                        }
                    }
                } catch (e) {
                    N = !0, P = e
                } finally {
                    try {
                        !O && k.return && k.return()
                    } finally {
                        if (N) throw P
                    }
                }
                ++i, ++n
            }
            return t.join("")
        }, R = {
            version: "2.1.0", ucs2: {
                decode: g, encode: function (e) {
                    return String.fromCodePoint.apply(String, function (e) {
                        if (Array.isArray(e)) {
                            for (var t = 0, r = Array(e.length); t < e.length; t++) r[t] = e[t];
                            return r
                        }
                        return Array.from(e)
                    }(e))
                }
            }, decode: b, encode: T, toASCII: function (e) {
                return v(e, function (e) {
                    return l.test(e) ? "xn--" + T(e) : e
                })
            }, toUnicode: function (e) {
                return v(e, function (e) {
                    return d.test(e) ? b(e.slice(4).toLowerCase()) : e
                })
            }
        }, I = {};

        function w(e) {
            var t = e.charCodeAt(0);
            return t < 16 ? "%0" + t.toString(16).toUpperCase() : t < 128 ? "%" + t.toString(16).toUpperCase() : t < 2048 ? "%" + (t >> 6 | 192).toString(16).toUpperCase() + "%" + (63 & t | 128).toString(16).toUpperCase() : "%" + (t >> 12 | 224).toString(16).toUpperCase() + "%" + (t >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (63 & t | 128).toString(16).toUpperCase()
        }

        function C(e) {
            for (var t = "", r = 0, n = e.length; r < n;) {
                var i = parseInt(e.substr(r + 1, 2), 16);
                if (i < 128) t += String.fromCharCode(i), r += 3; else if (i >= 194 && i < 224) {
                    if (n - r >= 6) {
                        var o = parseInt(e.substr(r + 4, 2), 16);
                        t += String.fromCharCode((31 & i) << 6 | 63 & o)
                    } else t += e.substr(r, 6);
                    r += 6
                } else if (i >= 224) {
                    if (n - r >= 9) {
                        var s = parseInt(e.substr(r + 4, 2), 16), a = parseInt(e.substr(r + 7, 2), 16);
                        t += String.fromCharCode((15 & i) << 12 | (63 & s) << 6 | 63 & a)
                    } else t += e.substr(r, 9);
                    r += 9
                } else t += e.substr(r, 3), r += 3
            }
            return t
        }

        function A(e, t) {
            function r(e) {
                var r = C(e);
                return r.match(t.UNRESERVED) ? r : e
            }

            return e.scheme && (e.scheme = String(e.scheme).replace(t.PCT_ENCODED, r).toLowerCase().replace(t.NOT_SCHEME, "")), void 0 !== e.userinfo && (e.userinfo = String(e.userinfo).replace(t.PCT_ENCODED, r).replace(t.NOT_USERINFO, w).replace(t.PCT_ENCODED, i)), void 0 !== e.host && (e.host = String(e.host).replace(t.PCT_ENCODED, r).toLowerCase().replace(t.NOT_HOST, w).replace(t.PCT_ENCODED, i)), void 0 !== e.path && (e.path = String(e.path).replace(t.PCT_ENCODED, r).replace(e.scheme ? t.NOT_PATH : t.NOT_PATH_NOSCHEME, w).replace(t.PCT_ENCODED, i)), void 0 !== e.query && (e.query = String(e.query).replace(t.PCT_ENCODED, r).replace(t.NOT_QUERY, w).replace(t.PCT_ENCODED, i)), void 0 !== e.fragment && (e.fragment = String(e.fragment).replace(t.PCT_ENCODED, r).replace(t.NOT_FRAGMENT, w).replace(t.PCT_ENCODED, i)), e
        }

        function O(e) {
            return e.replace(/^0*(.*)/, "$1") || "0"
        }

        function N(e, t) {
            var r = e.match(t.IPV4ADDRESS) || [], n = c(r, 2), i = n[1];
            return i ? i.split(".").map(O).join(".") : e
        }

        function P(e, t) {
            var r = e.match(t.IPV6ADDRESS) || [], n = c(r, 3), i = n[1], o = n[2];
            if (i) {
                for (var s = i.toLowerCase().split("::").reverse(), a = c(s, 2), u = a[0], d = a[1], l = d ? d.split(":").map(O) : [], h = u.split(":").map(O), p = t.IPV4ADDRESS.test(h[h.length - 1]), f = p ? 7 : 8, m = h.length - f, _ = Array(f), v = 0; v < f; ++v) _[v] = l[v] || h[m + v] || "";
                p && (_[f - 1] = N(_[f - 1], t));
                var g = _.reduce(function (e, t, r) {
                    if (!t || "0" === t) {
                        var n = e[e.length - 1];
                        n && n.index + n.length === r ? n.length++ : e.push({index: r, length: 1})
                    }
                    return e
                }, []), E = g.sort(function (e, t) {
                    return t.length - e.length
                })[0], y = void 0;
                if (E && E.length > 1) {
                    var S = _.slice(0, E.index), b = _.slice(E.index + E.length);
                    y = S.join(":") + "::" + b.join(":")
                } else y = _.join(":");
                return o && (y += "%" + o), y
            }
            return e
        }

        var D = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i,
            k = void 0 === "".match(/(){0}/)[1];

        function L(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r = {},
                n = !1 !== t.iri ? a : s;
            "suffix" === t.reference && (e = (t.scheme ? t.scheme + ":" : "") + "//" + e);
            var i = e.match(D);
            if (i) {
                k ? (r.scheme = i[1], r.userinfo = i[3], r.host = i[4], r.port = parseInt(i[5], 10), r.path = i[6] || "", r.query = i[7], r.fragment = i[8], isNaN(r.port) && (r.port = i[5])) : (r.scheme = i[1] || void 0, r.userinfo = -1 !== e.indexOf("@") ? i[3] : void 0, r.host = -1 !== e.indexOf("//") ? i[4] : void 0, r.port = parseInt(i[5], 10), r.path = i[6] || "", r.query = -1 !== e.indexOf("?") ? i[7] : void 0, r.fragment = -1 !== e.indexOf("#") ? i[8] : void 0, isNaN(r.port) && (r.port = e.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? i[4] : void 0)), r.host && (r.host = P(N(r.host, n), n)), void 0 !== r.scheme || void 0 !== r.userinfo || void 0 !== r.host || void 0 !== r.port || r.path || void 0 !== r.query ? void 0 === r.scheme ? r.reference = "relative" : void 0 === r.fragment ? r.reference = "absolute" : r.reference = "uri" : r.reference = "same-document", t.reference && "suffix" !== t.reference && t.reference !== r.reference && (r.error = r.error || "URI is not a " + t.reference + " reference.");
                var o = I[(t.scheme || r.scheme || "").toLowerCase()];
                if (t.unicodeSupport || o && o.unicodeSupport) A(r, n); else {
                    if (r.host && (t.domainHost || o && o.domainHost)) try {
                        r.host = R.toASCII(r.host.replace(n.PCT_ENCODED, C).toLowerCase())
                    } catch (e) {
                        r.error = r.error || "Host's domain name can not be converted to ASCII via punycode: " + e
                    }
                    A(r, s)
                }
                o && o.parse && o.parse(r, t)
            } else r.error = r.error || "URI can not be parsed.";
            return r
        }

        var x = /^\.\.?\//, M = /^\/\.(\/|$)/, U = /^\/\.\.(\/|$)/, j = /^\/?(?:.|\n)*?(?=\/|$)/;

        function V(e) {
            for (var t = []; e.length;) if (e.match(x)) e = e.replace(x, ""); else if (e.match(M)) e = e.replace(M, "/"); else if (e.match(U)) e = e.replace(U, "/"), t.pop(); else if ("." === e || ".." === e) e = ""; else {
                var r = e.match(j);
                if (!r) throw new Error("Unexpected dot segment condition");
                var n = r[0];
                e = e.slice(n.length), t.push(n)
            }
            return t.join("")
        }

        function F(e) {
            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r = t.iri ? a : s, n = [],
                i = I[(t.scheme || e.scheme || "").toLowerCase()];
            if (i && i.serialize && i.serialize(e, t), e.host) if (r.IPV6ADDRESS.test(e.host)) ; else if (t.domainHost || i && i.domainHost) try {
                e.host = t.iri ? R.toUnicode(e.host) : R.toASCII(e.host.replace(r.PCT_ENCODED, C).toLowerCase())
            } catch (r) {
                e.error = e.error || "Host's domain name can not be converted to " + (t.iri ? "Unicode" : "ASCII") + " via punycode: " + r
            }
            A(e, r), "suffix" !== t.reference && e.scheme && (n.push(e.scheme), n.push(":"));
            var o = function (e, t) {
                var r = !1 !== t.iri ? a : s, n = [];
                return void 0 !== e.userinfo && (n.push(e.userinfo), n.push("@")), void 0 !== e.host && n.push(P(N(String(e.host), r), r).replace(r.IPV6ADDRESS, function (e, t, r) {
                    return "[" + t + (r ? "%25" + r : "") + "]"
                })), "number" != typeof e.port && "string" != typeof e.port || (n.push(":"), n.push(String(e.port))), n.length ? n.join("") : void 0
            }(e, t);
            if (void 0 !== o && ("suffix" !== t.reference && n.push("//"), n.push(o), e.path && "/" !== e.path.charAt(0) && n.push("/")), void 0 !== e.path) {
                var c = e.path;
                t.absolutePath || i && i.absolutePath || (c = V(c)), void 0 === o && (c = c.replace(/^\/\//, "/%2F")), n.push(c)
            }
            return void 0 !== e.query && (n.push("?"), n.push(e.query)), void 0 !== e.fragment && (n.push("#"), n.push(e.fragment)), n.join("")
        }

        function B(e, t) {
            var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, n = arguments[3], i = {};
            return n || (e = L(F(e, r), r), t = L(F(t, r), r)), !(r = r || {}).tolerant && t.scheme ? (i.scheme = t.scheme, i.userinfo = t.userinfo, i.host = t.host, i.port = t.port, i.path = V(t.path || ""), i.query = t.query) : (void 0 !== t.userinfo || void 0 !== t.host || void 0 !== t.port ? (i.userinfo = t.userinfo, i.host = t.host, i.port = t.port, i.path = V(t.path || ""), i.query = t.query) : (t.path ? ("/" === t.path.charAt(0) ? i.path = V(t.path) : (void 0 === e.userinfo && void 0 === e.host && void 0 === e.port || e.path ? e.path ? i.path = e.path.slice(0, e.path.lastIndexOf("/") + 1) + t.path : i.path = t.path : i.path = "/" + t.path, i.path = V(i.path)), i.query = t.query) : (i.path = e.path, void 0 !== t.query ? i.query = t.query : i.query = e.query), i.userinfo = e.userinfo, i.host = e.host, i.port = e.port), i.scheme = e.scheme), i.fragment = t.fragment, i
        }

        function W(e, t) {
            return e && e.toString().replace(t && t.iri ? a.PCT_ENCODED : s.PCT_ENCODED, C)
        }

        var G = {
            scheme: "http", domainHost: !0, parse: function (e, t) {
                return e.host || (e.error = e.error || "HTTP URIs must have a host."), e
            }, serialize: function (e, t) {
                var r = "https" === String(e.scheme).toLowerCase();
                return e.port !== (r ? 443 : 80) && "" !== e.port || (e.port = void 0), e.path || (e.path = "/"), e
            }
        }, q = {scheme: "https", domainHost: G.domainHost, parse: G.parse, serialize: G.serialize};

        function H(e) {
            return "boolean" == typeof e.secure ? e.secure : "wss" === String(e.scheme).toLowerCase()
        }

        var K = {
                scheme: "ws", domainHost: !0, parse: function (e, t) {
                    var r = e;
                    return r.secure = H(r), r.resourceName = (r.path || "/") + (r.query ? "?" + r.query : ""), r.path = void 0, r.query = void 0, r
                }, serialize: function (e, t) {
                    if (e.port !== (H(e) ? 443 : 80) && "" !== e.port || (e.port = void 0), "boolean" == typeof e.secure && (e.scheme = e.secure ? "wss" : "ws", e.secure = void 0), e.resourceName) {
                        var r = e.resourceName.split("?"), n = c(r, 2), i = n[0], o = n[1];
                        e.path = i && "/" !== i ? i : void 0, e.query = o, e.resourceName = void 0
                    }
                    return e.fragment = void 0, e
                }
            }, z = {scheme: "wss", domainHost: K.domainHost, parse: K.parse, serialize: K.serialize}, Y = {},
            J = "[A-Za-z0-9\\-\\.\\_\\~\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]",
            X = "[0-9A-Fa-f]",
            Q = r(r("%[EFef][0-9A-Fa-f]%" + X + X + "%" + X + X) + "|" + r("%[89A-Fa-f][0-9A-Fa-f]%" + X + X) + "|" + r("%" + X + X)),
            $ = t("[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]", '[\\"\\\\]'), Z = new RegExp(J, "g"),
            ee = new RegExp(Q, "g"),
            te = new RegExp(t("[^]", "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]", "[\\.]", '[\\"]', $), "g"),
            re = new RegExp(t("[^]", J, "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]"), "g"), ne = re;

        function ie(e) {
            var t = C(e);
            return t.match(Z) ? t : e
        }

        var oe = {
            scheme: "mailto", parse: function (e, t) {
                var r = e, n = r.to = r.path ? r.path.split(",") : [];
                if (r.path = void 0, r.query) {
                    for (var i = !1, o = {}, s = r.query.split("&"), a = 0, c = s.length; a < c; ++a) {
                        var u = s[a].split("=");
                        switch (u[0]) {
                            case"to":
                                for (var d = u[1].split(","), l = 0, h = d.length; l < h; ++l) n.push(d[l]);
                                break;
                            case"subject":
                                r.subject = W(u[1], t);
                                break;
                            case"body":
                                r.body = W(u[1], t);
                                break;
                            default:
                                i = !0, o[W(u[0], t)] = W(u[1], t)
                        }
                    }
                    i && (r.headers = o)
                }
                r.query = void 0;
                for (var p = 0, f = n.length; p < f; ++p) {
                    var m = n[p].split("@");
                    if (m[0] = W(m[0]), t.unicodeSupport) m[1] = W(m[1], t).toLowerCase(); else try {
                        m[1] = R.toASCII(W(m[1], t).toLowerCase())
                    } catch (e) {
                        r.error = r.error || "Email address's domain name can not be converted to ASCII via punycode: " + e
                    }
                    n[p] = m.join("@")
                }
                return r
            }, serialize: function (e, t) {
                var r = e, n = function (e) {
                    return void 0 !== e && null !== e ? e instanceof Array ? e : "number" != typeof e.length || e.split || e.setInterval || e.call ? [e] : Array.prototype.slice.call(e) : []
                }(e.to);
                if (n) {
                    for (var o = 0, s = n.length; o < s; ++o) {
                        var a = String(n[o]), c = a.lastIndexOf("@"),
                            u = a.slice(0, c).replace(ee, ie).replace(ee, i).replace(te, w), d = a.slice(c + 1);
                        try {
                            d = t.iri ? R.toUnicode(d) : R.toASCII(W(d, t).toLowerCase())
                        } catch (e) {
                            r.error = r.error || "Email address's domain name can not be converted to " + (t.iri ? "Unicode" : "ASCII") + " via punycode: " + e
                        }
                        n[o] = u + "@" + d
                    }
                    r.path = n.join(",")
                }
                var l = e.headers = e.headers || {};
                e.subject && (l.subject = e.subject), e.body && (l.body = e.body);
                var h = [];
                for (var p in l) l[p] !== Y[p] && h.push(p.replace(ee, ie).replace(ee, i).replace(re, w) + "=" + l[p].replace(ee, ie).replace(ee, i).replace(ne, w));
                return h.length && (r.query = h.join("&")), r
            }
        }, se = /^([^\:]+)\:(.*)/, ae = {
            scheme: "urn", parse: function (e, t) {
                var r = e.path && e.path.match(se), n = e;
                if (r) {
                    var i = t.scheme || n.scheme || "urn", o = r[1].toLowerCase(), s = r[2], a = i + ":" + (t.nid || o),
                        c = I[a];
                    n.nid = o, n.nss = s, n.path = void 0, c && (n = c.parse(n, t))
                } else n.error = n.error || "URN can not be parsed.";
                return n
            }, serialize: function (e, t) {
                var r = t.scheme || e.scheme || "urn", n = e.nid, i = r + ":" + (t.nid || n), o = I[i];
                o && (e = o.serialize(e, t));
                var s = e, a = e.nss;
                return s.path = (n || t.nid) + ":" + a, s
            }
        }, ce = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/, ue = {
            scheme: "urn:uuid", parse: function (e, t) {
                var r = e;
                return r.uuid = r.nss, r.nss = void 0, t.tolerant || r.uuid && r.uuid.match(ce) || (r.error = r.error || "UUID is not valid."), r
            }, serialize: function (e, t) {
                var r = e;
                return r.nss = (e.uuid || "").toLowerCase(), r
            }
        };
        I[G.scheme] = G, I[q.scheme] = q, I[K.scheme] = K, I[z.scheme] = z, I[oe.scheme] = oe, I[ae.scheme] = ae, I[ue.scheme] = ue, e.SCHEMES = I, e.pctEncChar = w, e.pctDecChars = C, e.parse = L, e.removeDotSegments = V, e.serialize = F, e.resolveComponents = B, e.resolve = function (e, t, r) {
            var n = function (e, t) {
                var r = e;
                if (t) for (var n in t) r[n] = t[n];
                return r
            }({scheme: "null"}, r);
            return F(B(L(e, n), L(t, n), n, !0), n)
        }, e.normalize = function (e, t) {
            return "string" == typeof e ? e = F(L(e, t), t) : "object" === n(e) && (e = L(F(e, t), t)), e
        }, e.equal = function (e, t, r) {
            return "string" == typeof e ? e = F(L(e, r), r) : "object" === n(e) && (e = F(e, r)), "string" == typeof t ? t = F(L(t, r), r) : "object" === n(t) && (t = F(t, r)), e === t
        }, e.escapeComponent = function (e, t) {
            return e && e.toString().replace(t && t.iri ? a.ESCAPE : s.ESCAPE, w)
        }, e.unescapeComponent = W, Object.defineProperty(e, "__esModule", {value: !0})
    }(t)
}, function (e, t, r) {
    "use strict";
    e.exports = function (e) {
        for (var t, r = 0, n = e.length, i = 0; i < n;) r++, (t = e.charCodeAt(i++)) >= 55296 && t <= 56319 && i < n && 56320 == (64512 & (t = e.charCodeAt(i))) && i++;
        return r
    }
}, function (e, t, r) {
    "use strict";
    var n = e.exports = function (e, t, r) {
        "function" == typeof t && (r = t, t = {}), function e(t, r, o, s, a, c, u, d, l, h) {
            if (s && "object" == typeof s && !Array.isArray(s)) {
                for (var p in r(s, a, c, u, d, l, h), s) {
                    var f = s[p];
                    if (Array.isArray(f)) {
                        if (p in n.arrayKeywords) for (var m = 0; m < f.length; m++) e(t, r, o, f[m], a + "/" + p + "/" + m, c, a, p, s, m)
                    } else if (p in n.propsKeywords) {
                        if (f && "object" == typeof f) for (var _ in f) e(t, r, o, f[_], a + "/" + p + "/" + i(_), c, a, p, s, _)
                    } else (p in n.keywords || t.allKeys && !(p in n.skipKeywords)) && e(t, r, o, f, a + "/" + p, c, a, p, s)
                }
                o(s, a, c, u, d, l, h)
            }
        }(t, "function" == typeof (r = t.cb || r) ? r : r.pre || function () {
        }, r.post || function () {
        }, e, "", e)
    };

    function i(e) {
        return e.replace(/~/g, "~0").replace(/\//g, "~1")
    }

    n.keywords = {
        additionalItems: !0,
        items: !0,
        contains: !0,
        additionalProperties: !0,
        propertyNames: !0,
        not: !0
    }, n.arrayKeywords = {items: !0, allOf: !0, anyOf: !0, oneOf: !0}, n.propsKeywords = {
        definitions: !0,
        properties: !0,
        patternProperties: !0,
        dependencies: !0
    }, n.skipKeywords = {
        default: !0,
        enum: !0,
        const: !0,
        required: !0,
        maximum: !0,
        minimum: !0,
        exclusiveMaximum: !0,
        exclusiveMinimum: !0,
        multipleOf: !0,
        maxLength: !0,
        minLength: !0,
        pattern: !0,
        format: !0,
        maxItems: !0,
        minItems: !0,
        uniqueItems: !0,
        maxProperties: !0,
        minProperties: !0
    }
}, function (e, t, r) {
    "use strict";
    var n = e.exports = function () {
        this._cache = {}
    };
    n.prototype.put = function (e, t) {
        this._cache[e] = t
    }, n.prototype.get = function (e) {
        return this._cache[e]
    }, n.prototype.del = function (e) {
        delete this._cache[e]
    }, n.prototype.clear = function () {
        this._cache = {}
    }
}, function (e, t, r) {
    "use strict";
    var n = r(41), i = /^(\d\d\d\d)-(\d\d)-(\d\d)$/, o = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
        s = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i,
        a = /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
        c = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
        u = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
        d = /^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i,
        l = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i, h = /^(?:\/(?:[^~/]|~0|~1)*)*$/,
        p = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
        f = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;

    function m(e) {
        return e = "full" == e ? "full" : "fast", n.copy(m[e])
    }

    function _(e) {
        var t = e.match(i);
        if (!t) return !1;
        var r = +t[1], n = +t[2], s = +t[3];
        return n >= 1 && n <= 12 && s >= 1 && s <= (2 == n && function (e) {
            return e % 4 == 0 && (e % 100 != 0 || e % 400 == 0)
        }(r) ? 29 : o[n])
    }

    function v(e, t) {
        var r = e.match(s);
        if (!r) return !1;
        var n = r[1], i = r[2], o = r[3], a = r[5];
        return (n <= 23 && i <= 59 && o <= 59 || 23 == n && 59 == i && 60 == o) && (!t || a)
    }

    e.exports = m, m.fast = {
        date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/,
        time: /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i,
        "date-time": /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i,
        uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
        "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
        "uri-template": u,
        url: d,
        email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
        hostname: a,
        ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
        ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
        regex: S,
        uuid: l,
        "json-pointer": h,
        "json-pointer-uri-fragment": p,
        "relative-json-pointer": f
    }, m.full = {
        date: _,
        time: v,
        "date-time": function (e) {
            var t = e.split(g);
            return 2 == t.length && _(t[0]) && v(t[1], !0)
        },
        uri: function (e) {
            return E.test(e) && c.test(e)
        },
        "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
        "uri-template": u,
        url: d,
        email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
        hostname: a,
        ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
        ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
        regex: S,
        uuid: l,
        "json-pointer": h,
        "json-pointer-uri-fragment": p,
        "relative-json-pointer": f
    };
    var g = /t|\s/i;
    var E = /\/|:/;
    var y = /[^\\]\\Z/;

    function S(e) {
        if (y.test(e)) return !1;
        try {
            return new RegExp(e), !0
        } catch (e) {
            return !1
        }
    }
}, function (e, t, r) {
    "use strict";
    var n = r(188), i = r(41).toHash;
    e.exports = function () {
        var e = [{
            type: "number",
            rules: [{maximum: ["exclusiveMaximum"]}, {minimum: ["exclusiveMinimum"]}, "multipleOf", "format"]
        }, {type: "string", rules: ["maxLength", "minLength", "pattern", "format"]}, {
            type: "array",
            rules: ["maxItems", "minItems", "items", "contains", "uniqueItems"]
        }, {
            type: "object",
            rules: ["maxProperties", "minProperties", "required", "dependencies", "propertyNames", {properties: ["additionalProperties", "patternProperties"]}]
        }, {rules: ["$ref", "const", "enum", "not", "anyOf", "oneOf", "allOf", "if"]}], t = ["type", "$comment"];
        return e.all = i(t), e.types = i(["number", "integer", "string", "array", "object", "boolean", "null"]), e.forEach(function (r) {
            r.rules = r.rules.map(function (r) {
                var i;
                if ("object" == typeof r) {
                    var o = Object.keys(r)[0];
                    i = r[o], r = o, i.forEach(function (r) {
                        t.push(r), e.all[r] = !0
                    })
                }
                return t.push(r), e.all[r] = {keyword: r, code: n[r], implements: i}
            }), e.all.$comment = {keyword: "$comment", code: n.$comment}, r.type && (e.types[r.type] = r)
        }), e.keywords = i(t.concat(["$schema", "$id", "id", "$data", "$async", "title", "description", "default", "definitions", "examples", "readOnly", "writeOnly", "contentMediaType", "contentEncoding", "additionalItems", "then", "else"])), e.custom = {}, e
    }
}, function (e, t, r) {
    "use strict";
    e.exports = {
        $ref: r(189),
        allOf: r(190),
        anyOf: r(191),
        $comment: r(192),
        const: r(193),
        contains: r(194),
        dependencies: r(195),
        enum: r(196),
        format: r(197),
        if: r(198),
        items: r(199),
        maximum: r(108),
        minimum: r(108),
        maxItems: r(109),
        minItems: r(109),
        maxLength: r(110),
        minLength: r(110),
        maxProperties: r(111),
        minProperties: r(111),
        multipleOf: r(200),
        not: r(201),
        oneOf: r(202),
        pattern: r(203),
        properties: r(204),
        propertyNames: r(205),
        required: r(206),
        uniqueItems: r(207),
        validate: r(107)
    }
}, function (e, t, r) {
    "use strict";
    e.exports = function (e, t, r) {
        var n, i, o = " ", s = e.level, a = e.dataLevel, c = e.schema[t], u = e.errSchemaPath + "/" + t,
            d = !e.opts.allErrors, l = "data" + (a || ""), h = "valid" + s;
        if ("#" == c || "#/" == c) e.isRoot ? (n = e.async, i = "validate") : (n = !0 === e.root.schema.$async, i = "root.refVal[0]"); else {
            var p = e.resolveRef(e.baseId, c, e.isRoot);
            if (void 0 === p) {
                var f = e.MissingRefError.message(e.baseId, c);
                if ("fail" == e.opts.missingRefs) {
                    e.logger.error(f), (g = g || []).push(o), o = "", !1 !== e.createErrors ? (o += " { keyword: '$ref' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { ref: '" + e.util.escapeQuotes(c) + "' } ", !1 !== e.opts.messages && (o += " , message: 'can\\'t resolve reference " + e.util.escapeQuotes(c) + "' "), e.opts.verbose && (o += " , schema: " + e.util.toQuotedString(c) + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + l + " "), o += " } ") : o += " {} ";
                    var m = o;
                    o = g.pop(), !e.compositeRule && d ? e.async ? o += " throw new ValidationError([" + m + "]); " : o += " validate.errors = [" + m + "]; return false; " : o += " var err = " + m + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", d && (o += " if (false) { ")
                } else {
                    if ("ignore" != e.opts.missingRefs) throw new e.MissingRefError(e.baseId, c, f);
                    e.logger.warn(f), d && (o += " if (true) { ")
                }
            } else if (p.inline) {
                var _ = e.util.copy(e);
                _.level++;
                var v = "valid" + _.level;
                _.schema = p.schema, _.schemaPath = "", _.errSchemaPath = c, o += " " + e.validate(_).replace(/validate\.schema/g, p.code) + " ", d && (o += " if (" + v + ") { ")
            } else n = !0 === p.$async || e.async && !1 !== p.$async, i = p.code
        }
        if (i) {
            var g;
            (g = g || []).push(o), o = "", e.opts.passContext ? o += " " + i + ".call(this, " : o += " " + i + "( ", o += " " + l + ", (dataPath || '')", '""' != e.errorPath && (o += " + " + e.errorPath);
            var E = o += " , " + (a ? "data" + (a - 1 || "") : "parentData") + " , " + (a ? e.dataPathArr[a] : "parentDataProperty") + ", rootData)  ";
            if (o = g.pop(), n) {
                if (!e.async) throw new Error("async schema referenced by sync schema");
                d && (o += " var " + h + "; "), o += " try { await " + E + "; ", d && (o += " " + h + " = true; "), o += " } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ", d && (o += " " + h + " = false; "), o += " } ", d && (o += " if (" + h + ") { ")
            } else o += " if (!" + E + ") { if (vErrors === null) vErrors = " + i + ".errors; else vErrors = vErrors.concat(" + i + ".errors); errors = vErrors.length; } ", d && (o += " else { ")
        }
        return o
    }
}, function (e, t, r) {
    "use strict";
    e.exports = function (e, t, r) {
        var n = " ", i = e.schema[t], o = e.schemaPath + e.util.getProperty(t), s = e.errSchemaPath + "/" + t,
            a = !e.opts.allErrors, c = e.util.copy(e), u = "";
        c.level++;
        var d = "valid" + c.level, l = c.baseId, h = !0, p = i;
        if (p) for (var f, m = -1, _ = p.length - 1; m < _;) f = p[m += 1], (e.opts.strictKeywords ? "object" == typeof f && Object.keys(f).length > 0 || !1 === f : e.util.schemaHasRules(f, e.RULES.all)) && (h = !1, c.schema = f, c.schemaPath = o + "[" + m + "]", c.errSchemaPath = s + "/" + m, n += "  " + e.validate(c) + " ", c.baseId = l, a && (n += " if (" + d + ") { ", u += "}"));
        return a && (n += h ? " if (true) { " : " " + u.slice(0, -1) + " "), n
    }
}, function (e, t, r) {
    "use strict";
    e.exports = function (e, t, r) {
        var n = " ", i = e.level, o = e.dataLevel, s = e.schema[t], a = e.schemaPath + e.util.getProperty(t),
            c = e.errSchemaPath + "/" + t, u = !e.opts.allErrors, d = "data" + (o || ""), l = "valid" + i,
            h = "errs__" + i, p = e.util.copy(e), f = "";
        p.level++;
        var m = "valid" + p.level;
        if (s.every(function (t) {
            return e.opts.strictKeywords ? "object" == typeof t && Object.keys(t).length > 0 || !1 === t : e.util.schemaHasRules(t, e.RULES.all)
        })) {
            var _ = p.baseId;
            n += " var " + h + " = errors; var " + l + " = false;  ";
            var v = e.compositeRule;
            e.compositeRule = p.compositeRule = !0;
            var g = s;
            if (g) for (var E, y = -1, S = g.length - 1; y < S;) E = g[y += 1], p.schema = E, p.schemaPath = a + "[" + y + "]", p.errSchemaPath = c + "/" + y, n += "  " + e.validate(p) + " ", p.baseId = _, n += " " + l + " = " + l + " || " + m + "; if (!" + l + ") { ", f += "}";
            e.compositeRule = p.compositeRule = v, n += " " + f + " if (!" + l + ") {   var err =   ", !1 !== e.createErrors ? (n += " { keyword: 'anyOf' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(c) + " , params: {} ", !1 !== e.opts.messages && (n += " , message: 'should match some schema in anyOf' "), e.opts.verbose && (n += " , schema: validate.schema" + a + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + d + " "), n += " } ") : n += " {} ", n += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", !e.compositeRule && u && (e.async ? n += " throw new ValidationError(vErrors); " : n += " validate.errors = vErrors; return false; "), n += " } else {  errors = " + h + "; if (vErrors !== null) { if (" + h + ") vErrors.length = " + h + "; else vErrors = null; } ", e.opts.allErrors && (n += " } ")
        } else u && (n += " if (true) { ");
        return n
    }
}, function (e, t, r) {
    "use strict";
    e.exports = function (e, t, r) {
        var n = " ", i = e.schema[t], o = e.errSchemaPath + "/" + t, s = (e.opts.allErrors, e.util.toQuotedString(i));
        return !0 === e.opts.$comment ? n += " console.log(" + s + ");" : "function" == typeof e.opts.$comment && (n += " self._opts.$comment(" + s + ", " + e.util.toQuotedString(o) + ", validate.root.schema);"), n
    }
}, function (e, t, r) {
    "use strict";
    e.exports = function (e, t, r) {
        var n = " ", i = e.level, o = e.dataLevel, s = e.schema[t], a = e.schemaPath + e.util.getProperty(t),
            c = e.errSchemaPath + "/" + t, u = !e.opts.allErrors, d = "data" + (o || ""), l = "valid" + i,
            h = e.opts.$data && s && s.$data;
        h && (n += " var schema" + i + " = " + e.util.getData(s.$data, o, e.dataPathArr) + "; "), h || (n += " var schema" + i + " = validate.schema" + a + ";"), n += "var " + l + " = equal(" + d + ", schema" + i + "); if (!" + l + ") {   ";
        var p = p || [];
        p.push(n), n = "", !1 !== e.createErrors ? (n += " { keyword: 'const' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(c) + " , params: { allowedValue: schema" + i + " } ", !1 !== e.opts.messages && (n += " , message: 'should be equal to constant' "), e.opts.verbose && (n += " , schema: validate.schema" + a + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + d + " "), n += " } ") : n += " {} ";
        var f = n;
        return n = p.pop(), !e.compositeRule && u ? e.async ? n += " throw new ValidationError([" + f + "]); " : n += " validate.errors = [" + f + "]; return false; " : n += " var err = " + f + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", n += " }", u && (n += " else { "), n
    }
}, function (e, t, r) {
    "use strict";
    e.exports = function (e, t, r) {
        var n = " ", i = e.level, o = e.dataLevel, s = e.schema[t], a = e.schemaPath + e.util.getProperty(t),
            c = e.errSchemaPath + "/" + t, u = !e.opts.allErrors, d = "data" + (o || ""), l = "valid" + i,
            h = "errs__" + i, p = e.util.copy(e);
        p.level++;
        var f = "valid" + p.level, m = "i" + i, _ = p.dataLevel = e.dataLevel + 1, v = "data" + _, g = e.baseId,
            E = e.opts.strictKeywords ? "object" == typeof s && Object.keys(s).length > 0 || !1 === s : e.util.schemaHasRules(s, e.RULES.all);
        if (n += "var " + h + " = errors;var " + l + ";", E) {
            var y = e.compositeRule;
            e.compositeRule = p.compositeRule = !0, p.schema = s, p.schemaPath = a, p.errSchemaPath = c, n += " var " + f + " = false; for (var " + m + " = 0; " + m + " < " + d + ".length; " + m + "++) { ", p.errorPath = e.util.getPathExpr(e.errorPath, m, e.opts.jsonPointers, !0);
            var S = d + "[" + m + "]";
            p.dataPathArr[_] = m;
            var b = e.validate(p);
            p.baseId = g, e.util.varOccurences(b, v) < 2 ? n += " " + e.util.varReplace(b, v, S) + " " : n += " var " + v + " = " + S + "; " + b + " ", n += " if (" + f + ") break; }  ", e.compositeRule = p.compositeRule = y, n += "  if (!" + f + ") {"
        } else n += " if (" + d + ".length == 0) {";
        var T = T || [];
        T.push(n), n = "", !1 !== e.createErrors ? (n += " { keyword: 'contains' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(c) + " , params: {} ", !1 !== e.opts.messages && (n += " , message: 'should contain a valid item' "), e.opts.verbose && (n += " , schema: validate.schema" + a + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + d + " "), n += " } ") : n += " {} ";
        var R = n;
        return n = T.pop(), !e.compositeRule && u ? e.async ? n += " throw new ValidationError([" + R + "]); " : n += " validate.errors = [" + R + "]; return false; " : n += " var err = " + R + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", n += " } else { ", E && (n += "  errors = " + h + "; if (vErrors !== null) { if (" + h + ") vErrors.length = " + h + "; else vErrors = null; } "), e.opts.allErrors && (n += " } "), n
    }
}, function (e, t, r) {
    "use strict";
    e.exports = function (e, t, r) {
        var n = " ", i = e.level, o = e.dataLevel, s = e.schema[t], a = e.schemaPath + e.util.getProperty(t),
            c = e.errSchemaPath + "/" + t, u = !e.opts.allErrors, d = "data" + (o || ""), l = "errs__" + i,
            h = e.util.copy(e), p = "";
        h.level++;
        var f = "valid" + h.level, m = {}, _ = {}, v = e.opts.ownProperties;
        for (S in s) if ("__proto__" != S) {
            var g = s[S], E = Array.isArray(g) ? _ : m;
            E[S] = g
        }
        n += "var " + l + " = errors;";
        var y = e.errorPath;
        for (var S in n += "var missing" + i + ";", _) if ((E = _[S]).length) {
            if (n += " if ( " + d + e.util.getProperty(S) + " !== undefined ", v && (n += " && Object.prototype.hasOwnProperty.call(" + d + ", '" + e.util.escapeQuotes(S) + "') "), u) {
                n += " && ( ";
                var b = E;
                if (b) for (var T = -1, R = b.length - 1; T < R;) {
                    N = b[T += 1], T && (n += " || "), n += " ( ( " + (L = d + (k = e.util.getProperty(N))) + " === undefined ", v && (n += " || ! Object.prototype.hasOwnProperty.call(" + d + ", '" + e.util.escapeQuotes(N) + "') "), n += ") && (missing" + i + " = " + e.util.toQuotedString(e.opts.jsonPointers ? N : k) + ") ) "
                }
                n += ")) {  ";
                var I = "missing" + i, w = "' + " + I + " + '";
                e.opts._errorDataPathProperty && (e.errorPath = e.opts.jsonPointers ? e.util.getPathExpr(y, I, !0) : y + " + " + I);
                var C = C || [];
                C.push(n), n = "", !1 !== e.createErrors ? (n += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(c) + " , params: { property: '" + e.util.escapeQuotes(S) + "', missingProperty: '" + w + "', depsCount: " + E.length + ", deps: '" + e.util.escapeQuotes(1 == E.length ? E[0] : E.join(", ")) + "' } ", !1 !== e.opts.messages && (n += " , message: 'should have ", 1 == E.length ? n += "property " + e.util.escapeQuotes(E[0]) : n += "properties " + e.util.escapeQuotes(E.join(", ")), n += " when property " + e.util.escapeQuotes(S) + " is present' "), e.opts.verbose && (n += " , schema: validate.schema" + a + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + d + " "), n += " } ") : n += " {} ";
                var A = n;
                n = C.pop(), !e.compositeRule && u ? e.async ? n += " throw new ValidationError([" + A + "]); " : n += " validate.errors = [" + A + "]; return false; " : n += " var err = " + A + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "
            } else {
                n += " ) { ";
                var O = E;
                if (O) for (var N, P = -1, D = O.length - 1; P < D;) {
                    N = O[P += 1];
                    var k = e.util.getProperty(N), L = (w = e.util.escapeQuotes(N), d + k);
                    e.opts._errorDataPathProperty && (e.errorPath = e.util.getPath(y, N, e.opts.jsonPointers)), n += " if ( " + L + " === undefined ", v && (n += " || ! Object.prototype.hasOwnProperty.call(" + d + ", '" + e.util.escapeQuotes(N) + "') "), n += ") {  var err =   ", !1 !== e.createErrors ? (n += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(c) + " , params: { property: '" + e.util.escapeQuotes(S) + "', missingProperty: '" + w + "', depsCount: " + E.length + ", deps: '" + e.util.escapeQuotes(1 == E.length ? E[0] : E.join(", ")) + "' } ", !1 !== e.opts.messages && (n += " , message: 'should have ", 1 == E.length ? n += "property " + e.util.escapeQuotes(E[0]) : n += "properties " + e.util.escapeQuotes(E.join(", ")), n += " when property " + e.util.escapeQuotes(S) + " is present' "), e.opts.verbose && (n += " , schema: validate.schema" + a + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + d + " "), n += " } ") : n += " {} ", n += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } "
                }
            }
            n += " }   ", u && (p += "}", n += " else { ")
        }
        e.errorPath = y;
        var x = h.baseId;
        for (var S in m) {
            g = m[S];
            (e.opts.strictKeywords ? "object" == typeof g && Object.keys(g).length > 0 || !1 === g : e.util.schemaHasRules(g, e.RULES.all)) && (n += " " + f + " = true; if ( " + d + e.util.getProperty(S) + " !== undefined ", v && (n += " && Object.prototype.hasOwnProperty.call(" + d + ", '" + e.util.escapeQuotes(S) + "') "), n += ") { ", h.schema = g, h.schemaPath = a + e.util.getProperty(S), h.errSchemaPath = c + "/" + e.util.escapeFragment(S), n += "  " + e.validate(h) + " ", h.baseId = x, n += " }  ", u && (n += " if (" + f + ") { ", p += "}"))
        }
        return u && (n += "   " + p + " if (" + l + " == errors) {"), n
    }
}, function (e, t, r) {
    "use strict";
    e.exports = function (e, t, r) {
        var n = " ", i = e.level, o = e.dataLevel, s = e.schema[t], a = e.schemaPath + e.util.getProperty(t),
            c = e.errSchemaPath + "/" + t, u = !e.opts.allErrors, d = "data" + (o || ""), l = "valid" + i,
            h = e.opts.$data && s && s.$data;
        h && (n += " var schema" + i + " = " + e.util.getData(s.$data, o, e.dataPathArr) + "; ");
        var p = "i" + i, f = "schema" + i;
        h || (n += " var " + f + " = validate.schema" + a + ";"), n += "var " + l + ";", h && (n += " if (schema" + i + " === undefined) " + l + " = true; else if (!Array.isArray(schema" + i + ")) " + l + " = false; else {"), n += l + " = false;for (var " + p + "=0; " + p + "<" + f + ".length; " + p + "++) if (equal(" + d + ", " + f + "[" + p + "])) { " + l + " = true; break; }", h && (n += "  }  "), n += " if (!" + l + ") {   ";
        var m = m || [];
        m.push(n), n = "", !1 !== e.createErrors ? (n += " { keyword: 'enum' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(c) + " , params: { allowedValues: schema" + i + " } ", !1 !== e.opts.messages && (n += " , message: 'should be equal to one of the allowed values' "), e.opts.verbose && (n += " , schema: validate.schema" + a + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + d + " "), n += " } ") : n += " {} ";
        var _ = n;
        return n = m.pop(), !e.compositeRule && u ? e.async ? n += " throw new ValidationError([" + _ + "]); " : n += " validate.errors = [" + _ + "]; return false; " : n += " var err = " + _ + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", n += " }", u && (n += " else { "), n
    }
}, function (e, t, r) {
    "use strict";
    e.exports = function (e, t, r) {
        var n = " ", i = e.level, o = e.dataLevel, s = e.schema[t], a = e.schemaPath + e.util.getProperty(t),
            c = e.errSchemaPath + "/" + t, u = !e.opts.allErrors, d = "data" + (o || "");
        if (!1 === e.opts.format) return u && (n += " if (true) { "), n;
        var l, h = e.opts.$data && s && s.$data;
        h ? (n += " var schema" + i + " = " + e.util.getData(s.$data, o, e.dataPathArr) + "; ", l = "schema" + i) : l = s;
        var p = e.opts.unknownFormats, f = Array.isArray(p);
        if (h) {
            n += " var " + (m = "format" + i) + " = formats[" + l + "]; var " + (_ = "isObject" + i) + " = typeof " + m + " == 'object' && !(" + m + " instanceof RegExp) && " + m + ".validate; var " + (v = "formatType" + i) + " = " + _ + " && " + m + ".type || 'string'; if (" + _ + ") { ", e.async && (n += " var async" + i + " = " + m + ".async; "), n += " " + m + " = " + m + ".validate; } if (  ", h && (n += " (" + l + " !== undefined && typeof " + l + " != 'string') || "), n += " (", "ignore" != p && (n += " (" + l + " && !" + m + " ", f && (n += " && self._opts.unknownFormats.indexOf(" + l + ") == -1 "), n += ") || "), n += " (" + m + " && " + v + " == '" + r + "' && !(typeof " + m + " == 'function' ? ", e.async ? n += " (async" + i + " ? await " + m + "(" + d + ") : " + m + "(" + d + ")) " : n += " " + m + "(" + d + ") ", n += " : " + m + ".test(" + d + "))))) {"
        } else {
            var m;
            if (!(m = e.formats[s])) {
                if ("ignore" == p) return e.logger.warn('unknown format "' + s + '" ignored in schema at path "' + e.errSchemaPath + '"'), u && (n += " if (true) { "), n;
                if (f && p.indexOf(s) >= 0) return u && (n += " if (true) { "), n;
                throw new Error('unknown format "' + s + '" is used in schema at path "' + e.errSchemaPath + '"')
            }
            var _, v = (_ = "object" == typeof m && !(m instanceof RegExp) && m.validate) && m.type || "string";
            if (_) {
                var g = !0 === m.async;
                m = m.validate
            }
            if (v != r) return u && (n += " if (true) { "), n;
            if (g) {
                if (!e.async) throw new Error("async format in sync schema");
                n += " if (!(await " + (E = "formats" + e.util.getProperty(s) + ".validate") + "(" + d + "))) { "
            } else {
                n += " if (! ";
                var E = "formats" + e.util.getProperty(s);
                _ && (E += ".validate"), n += "function" == typeof m ? " " + E + "(" + d + ") " : " " + E + ".test(" + d + ") ", n += ") { "
            }
        }
        var y = y || [];
        y.push(n), n = "", !1 !== e.createErrors ? (n += " { keyword: 'format' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(c) + " , params: { format:  ", n += h ? "" + l : "" + e.util.toQuotedString(s), n += "  } ", !1 !== e.opts.messages && (n += " , message: 'should match format \"", n += h ? "' + " + l + " + '" : "" + e.util.escapeQuotes(s), n += "\"' "), e.opts.verbose && (n += " , schema:  ", n += h ? "validate.schema" + a : "" + e.util.toQuotedString(s), n += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + d + " "), n += " } ") : n += " {} ";
        var S = n;
        return n = y.pop(), !e.compositeRule && u ? e.async ? n += " throw new ValidationError([" + S + "]); " : n += " validate.errors = [" + S + "]; return false; " : n += " var err = " + S + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", n += " } ", u && (n += " else { "), n
    }
}, function (e, t, r) {
    "use strict";
    e.exports = function (e, t, r) {
        var n = " ", i = e.level, o = e.dataLevel, s = e.schema[t], a = e.schemaPath + e.util.getProperty(t),
            c = e.errSchemaPath + "/" + t, u = !e.opts.allErrors, d = "data" + (o || ""), l = "valid" + i,
            h = "errs__" + i, p = e.util.copy(e);
        p.level++;
        var f = "valid" + p.level, m = e.schema.then, _ = e.schema.else,
            v = void 0 !== m && (e.opts.strictKeywords ? "object" == typeof m && Object.keys(m).length > 0 || !1 === m : e.util.schemaHasRules(m, e.RULES.all)),
            g = void 0 !== _ && (e.opts.strictKeywords ? "object" == typeof _ && Object.keys(_).length > 0 || !1 === _ : e.util.schemaHasRules(_, e.RULES.all)),
            E = p.baseId;
        if (v || g) {
            var y;
            p.createErrors = !1, p.schema = s, p.schemaPath = a, p.errSchemaPath = c, n += " var " + h + " = errors; var " + l + " = true;  ";
            var S = e.compositeRule;
            e.compositeRule = p.compositeRule = !0, n += "  " + e.validate(p) + " ", p.baseId = E, p.createErrors = !0, n += "  errors = " + h + "; if (vErrors !== null) { if (" + h + ") vErrors.length = " + h + "; else vErrors = null; }  ", e.compositeRule = p.compositeRule = S, v ? (n += " if (" + f + ") {  ", p.schema = e.schema.then, p.schemaPath = e.schemaPath + ".then", p.errSchemaPath = e.errSchemaPath + "/then", n += "  " + e.validate(p) + " ", p.baseId = E, n += " " + l + " = " + f + "; ", v && g ? n += " var " + (y = "ifClause" + i) + " = 'then'; " : y = "'then'", n += " } ", g && (n += " else { ")) : n += " if (!" + f + ") { ", g && (p.schema = e.schema.else, p.schemaPath = e.schemaPath + ".else", p.errSchemaPath = e.errSchemaPath + "/else", n += "  " + e.validate(p) + " ", p.baseId = E, n += " " + l + " = " + f + "; ", v && g ? n += " var " + (y = "ifClause" + i) + " = 'else'; " : y = "'else'", n += " } "), n += " if (!" + l + ") {   var err =   ", !1 !== e.createErrors ? (n += " { keyword: 'if' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(c) + " , params: { failingKeyword: " + y + " } ", !1 !== e.opts.messages && (n += " , message: 'should match \"' + " + y + " + '\" schema' "), e.opts.verbose && (n += " , schema: validate.schema" + a + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + d + " "), n += " } ") : n += " {} ", n += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", !e.compositeRule && u && (e.async ? n += " throw new ValidationError(vErrors); " : n += " validate.errors = vErrors; return false; "), n += " }   ", u && (n += " else { ")
        } else u && (n += " if (true) { ");
        return n
    }
}, function (e, t, r) {
    "use strict";
    e.exports = function (e, t, r) {
        var n = " ", i = e.level, o = e.dataLevel, s = e.schema[t], a = e.schemaPath + e.util.getProperty(t),
            c = e.errSchemaPath + "/" + t, u = !e.opts.allErrors, d = "data" + (o || ""), l = "valid" + i,
            h = "errs__" + i, p = e.util.copy(e), f = "";
        p.level++;
        var m = "valid" + p.level, _ = "i" + i, v = p.dataLevel = e.dataLevel + 1, g = "data" + v, E = e.baseId;
        if (n += "var " + h + " = errors;var " + l + ";", Array.isArray(s)) {
            var y = e.schema.additionalItems;
            if (!1 === y) {
                n += " " + l + " = " + d + ".length <= " + s.length + "; ";
                var S = c;
                c = e.errSchemaPath + "/additionalItems", n += "  if (!" + l + ") {   ";
                var b = b || [];
                b.push(n), n = "", !1 !== e.createErrors ? (n += " { keyword: 'additionalItems' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(c) + " , params: { limit: " + s.length + " } ", !1 !== e.opts.messages && (n += " , message: 'should NOT have more than " + s.length + " items' "), e.opts.verbose && (n += " , schema: false , parentSchema: validate.schema" + e.schemaPath + " , data: " + d + " "), n += " } ") : n += " {} ";
                var T = n;
                n = b.pop(), !e.compositeRule && u ? e.async ? n += " throw new ValidationError([" + T + "]); " : n += " validate.errors = [" + T + "]; return false; " : n += " var err = " + T + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", n += " } ", c = S, u && (f += "}", n += " else { ")
            }
            var R = s;
            if (R) for (var I, w = -1, C = R.length - 1; w < C;) if (I = R[w += 1], e.opts.strictKeywords ? "object" == typeof I && Object.keys(I).length > 0 || !1 === I : e.util.schemaHasRules(I, e.RULES.all)) {
                n += " " + m + " = true; if (" + d + ".length > " + w + ") { ";
                var A = d + "[" + w + "]";
                p.schema = I, p.schemaPath = a + "[" + w + "]", p.errSchemaPath = c + "/" + w, p.errorPath = e.util.getPathExpr(e.errorPath, w, e.opts.jsonPointers, !0), p.dataPathArr[v] = w;
                var O = e.validate(p);
                p.baseId = E, e.util.varOccurences(O, g) < 2 ? n += " " + e.util.varReplace(O, g, A) + " " : n += " var " + g + " = " + A + "; " + O + " ", n += " }  ", u && (n += " if (" + m + ") { ", f += "}")
            }
            if ("object" == typeof y && (e.opts.strictKeywords ? "object" == typeof y && Object.keys(y).length > 0 || !1 === y : e.util.schemaHasRules(y, e.RULES.all))) {
                p.schema = y, p.schemaPath = e.schemaPath + ".additionalItems", p.errSchemaPath = e.errSchemaPath + "/additionalItems", n += " " + m + " = true; if (" + d + ".length > " + s.length + ") {  for (var " + _ + " = " + s.length + "; " + _ + " < " + d + ".length; " + _ + "++) { ", p.errorPath = e.util.getPathExpr(e.errorPath, _, e.opts.jsonPointers, !0);
                A = d + "[" + _ + "]";
                p.dataPathArr[v] = _;
                O = e.validate(p);
                p.baseId = E, e.util.varOccurences(O, g) < 2 ? n += " " + e.util.varReplace(O, g, A) + " " : n += " var " + g + " = " + A + "; " + O + " ", u && (n += " if (!" + m + ") break; "), n += " } }  ", u && (n += " if (" + m + ") { ", f += "}")
            }
        } else if (e.opts.strictKeywords ? "object" == typeof s && Object.keys(s).length > 0 || !1 === s : e.util.schemaHasRules(s, e.RULES.all)) {
            p.schema = s, p.schemaPath = a, p.errSchemaPath = c, n += "  for (var " + _ + " = 0; " + _ + " < " + d + ".length; " + _ + "++) { ", p.errorPath = e.util.getPathExpr(e.errorPath, _, e.opts.jsonPointers, !0);
            A = d + "[" + _ + "]";
            p.dataPathArr[v] = _;
            O = e.validate(p);
            p.baseId = E, e.util.varOccurences(O, g) < 2 ? n += " " + e.util.varReplace(O, g, A) + " " : n += " var " + g + " = " + A + "; " + O + " ", u && (n += " if (!" + m + ") break; "), n += " }"
        }
        return u && (n += " " + f + " if (" + h + " == errors) {"), n
    }
}, function (e, t, r) {
    "use strict";
    e.exports = function (e, t, r) {
        var n, i = " ", o = e.level, s = e.dataLevel, a = e.schema[t], c = e.schemaPath + e.util.getProperty(t),
            u = e.errSchemaPath + "/" + t, d = !e.opts.allErrors, l = "data" + (s || ""),
            h = e.opts.$data && a && a.$data;
        if (h ? (i += " var schema" + o + " = " + e.util.getData(a.$data, s, e.dataPathArr) + "; ", n = "schema" + o) : n = a, !h && "number" != typeof a) throw new Error(t + " must be number");
        i += "var division" + o + ";if (", h && (i += " " + n + " !== undefined && ( typeof " + n + " != 'number' || "), i += " (division" + o + " = " + l + " / " + n + ", ", e.opts.multipleOfPrecision ? i += " Math.abs(Math.round(division" + o + ") - division" + o + ") > 1e-" + e.opts.multipleOfPrecision + " " : i += " division" + o + " !== parseInt(division" + o + ") ", i += " ) ", h && (i += "  )  "), i += " ) {   ";
        var p = p || [];
        p.push(i), i = "", !1 !== e.createErrors ? (i += " { keyword: 'multipleOf' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { multipleOf: " + n + " } ", !1 !== e.opts.messages && (i += " , message: 'should be multiple of ", i += h ? "' + " + n : n + "'"), e.opts.verbose && (i += " , schema:  ", i += h ? "validate.schema" + c : "" + a, i += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + l + " "), i += " } ") : i += " {} ";
        var f = i;
        return i = p.pop(), !e.compositeRule && d ? e.async ? i += " throw new ValidationError([" + f + "]); " : i += " validate.errors = [" + f + "]; return false; " : i += " var err = " + f + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", i += "} ", d && (i += " else { "), i
    }
}, function (e, t, r) {
    "use strict";
    e.exports = function (e, t, r) {
        var n = " ", i = e.level, o = e.dataLevel, s = e.schema[t], a = e.schemaPath + e.util.getProperty(t),
            c = e.errSchemaPath + "/" + t, u = !e.opts.allErrors, d = "data" + (o || ""), l = "errs__" + i,
            h = e.util.copy(e);
        h.level++;
        var p = "valid" + h.level;
        if (e.opts.strictKeywords ? "object" == typeof s && Object.keys(s).length > 0 || !1 === s : e.util.schemaHasRules(s, e.RULES.all)) {
            h.schema = s, h.schemaPath = a, h.errSchemaPath = c, n += " var " + l + " = errors;  ";
            var f, m = e.compositeRule;
            e.compositeRule = h.compositeRule = !0, h.createErrors = !1, h.opts.allErrors && (f = h.opts.allErrors, h.opts.allErrors = !1), n += " " + e.validate(h) + " ", h.createErrors = !0, f && (h.opts.allErrors = f), e.compositeRule = h.compositeRule = m, n += " if (" + p + ") {   ";
            var _ = _ || [];
            _.push(n), n = "", !1 !== e.createErrors ? (n += " { keyword: 'not' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(c) + " , params: {} ", !1 !== e.opts.messages && (n += " , message: 'should NOT be valid' "), e.opts.verbose && (n += " , schema: validate.schema" + a + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + d + " "), n += " } ") : n += " {} ";
            var v = n;
            n = _.pop(), !e.compositeRule && u ? e.async ? n += " throw new ValidationError([" + v + "]); " : n += " validate.errors = [" + v + "]; return false; " : n += " var err = " + v + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", n += " } else {  errors = " + l + "; if (vErrors !== null) { if (" + l + ") vErrors.length = " + l + "; else vErrors = null; } ", e.opts.allErrors && (n += " } ")
        } else n += "  var err =   ", !1 !== e.createErrors ? (n += " { keyword: 'not' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(c) + " , params: {} ", !1 !== e.opts.messages && (n += " , message: 'should NOT be valid' "), e.opts.verbose && (n += " , schema: validate.schema" + a + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + d + " "), n += " } ") : n += " {} ", n += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", u && (n += " if (false) { ");
        return n
    }
}, function (e, t, r) {
    "use strict";
    e.exports = function (e, t, r) {
        var n = " ", i = e.level, o = e.dataLevel, s = e.schema[t], a = e.schemaPath + e.util.getProperty(t),
            c = e.errSchemaPath + "/" + t, u = !e.opts.allErrors, d = "data" + (o || ""), l = "valid" + i,
            h = "errs__" + i, p = e.util.copy(e), f = "";
        p.level++;
        var m = "valid" + p.level, _ = p.baseId, v = "prevValid" + i, g = "passingSchemas" + i;
        n += "var " + h + " = errors , " + v + " = false , " + l + " = false , " + g + " = null; ";
        var E = e.compositeRule;
        e.compositeRule = p.compositeRule = !0;
        var y = s;
        if (y) for (var S, b = -1, T = y.length - 1; b < T;) S = y[b += 1], (e.opts.strictKeywords ? "object" == typeof S && Object.keys(S).length > 0 || !1 === S : e.util.schemaHasRules(S, e.RULES.all)) ? (p.schema = S, p.schemaPath = a + "[" + b + "]", p.errSchemaPath = c + "/" + b, n += "  " + e.validate(p) + " ", p.baseId = _) : n += " var " + m + " = true; ", b && (n += " if (" + m + " && " + v + ") { " + l + " = false; " + g + " = [" + g + ", " + b + "]; } else { ", f += "}"), n += " if (" + m + ") { " + l + " = " + v + " = true; " + g + " = " + b + "; }";
        return e.compositeRule = p.compositeRule = E, n += f + "if (!" + l + ") {   var err =   ", !1 !== e.createErrors ? (n += " { keyword: 'oneOf' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(c) + " , params: { passingSchemas: " + g + " } ", !1 !== e.opts.messages && (n += " , message: 'should match exactly one schema in oneOf' "), e.opts.verbose && (n += " , schema: validate.schema" + a + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + d + " "), n += " } ") : n += " {} ", n += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", !e.compositeRule && u && (e.async ? n += " throw new ValidationError(vErrors); " : n += " validate.errors = vErrors; return false; "), n += "} else {  errors = " + h + "; if (vErrors !== null) { if (" + h + ") vErrors.length = " + h + "; else vErrors = null; }", e.opts.allErrors && (n += " } "), n
    }
}, function (e, t, r) {
    "use strict";
    e.exports = function (e, t, r) {
        var n, i = " ", o = e.level, s = e.dataLevel, a = e.schema[t], c = e.schemaPath + e.util.getProperty(t),
            u = e.errSchemaPath + "/" + t, d = !e.opts.allErrors, l = "data" + (s || ""),
            h = e.opts.$data && a && a.$data;
        h ? (i += " var schema" + o + " = " + e.util.getData(a.$data, s, e.dataPathArr) + "; ", n = "schema" + o) : n = a;
        var p = h ? "(new RegExp(" + n + "))" : e.usePattern(a);
        i += "if ( ", h && (i += " (" + n + " !== undefined && typeof " + n + " != 'string') || "), i += " !" + p + ".test(" + l + ") ) {   ";
        var f = f || [];
        f.push(i), i = "", !1 !== e.createErrors ? (i += " { keyword: 'pattern' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { pattern:  ", i += h ? "" + n : "" + e.util.toQuotedString(a), i += "  } ", !1 !== e.opts.messages && (i += " , message: 'should match pattern \"", i += h ? "' + " + n + " + '" : "" + e.util.escapeQuotes(a), i += "\"' "), e.opts.verbose && (i += " , schema:  ", i += h ? "validate.schema" + c : "" + e.util.toQuotedString(a), i += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + l + " "), i += " } ") : i += " {} ";
        var m = i;
        return i = f.pop(), !e.compositeRule && d ? e.async ? i += " throw new ValidationError([" + m + "]); " : i += " validate.errors = [" + m + "]; return false; " : i += " var err = " + m + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", i += "} ", d && (i += " else { "), i
    }
}, function (e, t, r) {
    "use strict";
    e.exports = function (e, t, r) {
        var n = " ", i = e.level, o = e.dataLevel, s = e.schema[t], a = e.schemaPath + e.util.getProperty(t),
            c = e.errSchemaPath + "/" + t, u = !e.opts.allErrors, d = "data" + (o || ""), l = "errs__" + i,
            h = e.util.copy(e), p = "";
        h.level++;
        var f = "valid" + h.level, m = "key" + i, _ = "idx" + i, v = h.dataLevel = e.dataLevel + 1, g = "data" + v,
            E = "dataProperties" + i, y = Object.keys(s || {}).filter(k), S = e.schema.patternProperties || {},
            b = Object.keys(S).filter(k), T = e.schema.additionalProperties, R = y.length || b.length, I = !1 === T,
            w = "object" == typeof T && Object.keys(T).length, C = e.opts.removeAdditional, A = I || w || C,
            O = e.opts.ownProperties, N = e.baseId, P = e.schema.required;
        if (P && (!e.opts.$data || !P.$data) && P.length < e.opts.loopRequired) var D = e.util.toHash(P);

        function k(e) {
            return "__proto__" !== e
        }

        if (n += "var " + l + " = errors;var " + f + " = true;", O && (n += " var " + E + " = undefined;"), A) {
            if (n += O ? " " + E + " = " + E + " || Object.keys(" + d + "); for (var " + _ + "=0; " + _ + "<" + E + ".length; " + _ + "++) { var " + m + " = " + E + "[" + _ + "]; " : " for (var " + m + " in " + d + ") { ", R) {
                if (n += " var isAdditional" + i + " = !(false ", y.length) if (y.length > 8) n += " || validate.schema" + a + ".hasOwnProperty(" + m + ") "; else {
                    var L = y;
                    if (L) for (var x = -1, M = L.length - 1; x < M;) J = L[x += 1], n += " || " + m + " == " + e.util.toQuotedString(J) + " "
                }
                if (b.length) {
                    var U = b;
                    if (U) for (var j = -1, V = U.length - 1; j < V;) oe = U[j += 1], n += " || " + e.usePattern(oe) + ".test(" + m + ") "
                }
                n += " ); if (isAdditional" + i + ") { "
            }
            if ("all" == C) n += " delete " + d + "[" + m + "]; "; else {
                var F = e.errorPath, B = "' + " + m + " + '";
                if (e.opts._errorDataPathProperty && (e.errorPath = e.util.getPathExpr(e.errorPath, m, e.opts.jsonPointers)), I) if (C) n += " delete " + d + "[" + m + "]; "; else {
                    n += " " + f + " = false; ";
                    var W = c;
                    c = e.errSchemaPath + "/additionalProperties", (re = re || []).push(n), n = "", !1 !== e.createErrors ? (n += " { keyword: 'additionalProperties' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(c) + " , params: { additionalProperty: '" + B + "' } ", !1 !== e.opts.messages && (n += " , message: '", e.opts._errorDataPathProperty ? n += "is an invalid additional property" : n += "should NOT have additional properties", n += "' "), e.opts.verbose && (n += " , schema: false , parentSchema: validate.schema" + e.schemaPath + " , data: " + d + " "), n += " } ") : n += " {} ";
                    var G = n;
                    n = re.pop(), !e.compositeRule && u ? e.async ? n += " throw new ValidationError([" + G + "]); " : n += " validate.errors = [" + G + "]; return false; " : n += " var err = " + G + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", c = W, u && (n += " break; ")
                } else if (w) if ("failing" == C) {
                    n += " var " + l + " = errors;  ";
                    var q = e.compositeRule;
                    e.compositeRule = h.compositeRule = !0, h.schema = T, h.schemaPath = e.schemaPath + ".additionalProperties", h.errSchemaPath = e.errSchemaPath + "/additionalProperties", h.errorPath = e.opts._errorDataPathProperty ? e.errorPath : e.util.getPathExpr(e.errorPath, m, e.opts.jsonPointers);
                    var H = d + "[" + m + "]";
                    h.dataPathArr[v] = m;
                    var K = e.validate(h);
                    h.baseId = N, e.util.varOccurences(K, g) < 2 ? n += " " + e.util.varReplace(K, g, H) + " " : n += " var " + g + " = " + H + "; " + K + " ", n += " if (!" + f + ") { errors = " + l + "; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete " + d + "[" + m + "]; }  ", e.compositeRule = h.compositeRule = q
                } else {
                    h.schema = T, h.schemaPath = e.schemaPath + ".additionalProperties", h.errSchemaPath = e.errSchemaPath + "/additionalProperties", h.errorPath = e.opts._errorDataPathProperty ? e.errorPath : e.util.getPathExpr(e.errorPath, m, e.opts.jsonPointers);
                    H = d + "[" + m + "]";
                    h.dataPathArr[v] = m;
                    K = e.validate(h);
                    h.baseId = N, e.util.varOccurences(K, g) < 2 ? n += " " + e.util.varReplace(K, g, H) + " " : n += " var " + g + " = " + H + "; " + K + " ", u && (n += " if (!" + f + ") break; ")
                }
                e.errorPath = F
            }
            R && (n += " } "), n += " }  ", u && (n += " if (" + f + ") { ", p += "}")
        }
        var z = e.opts.useDefaults && !e.compositeRule;
        if (y.length) {
            var Y = y;
            if (Y) for (var J, X = -1, Q = Y.length - 1; X < Q;) {
                var $ = s[J = Y[X += 1]];
                if (e.opts.strictKeywords ? "object" == typeof $ && Object.keys($).length > 0 || !1 === $ : e.util.schemaHasRules($, e.RULES.all)) {
                    var Z = e.util.getProperty(J), ee = (H = d + Z, z && void 0 !== $.default);
                    h.schema = $, h.schemaPath = a + Z, h.errSchemaPath = c + "/" + e.util.escapeFragment(J), h.errorPath = e.util.getPath(e.errorPath, J, e.opts.jsonPointers), h.dataPathArr[v] = e.util.toQuotedString(J);
                    K = e.validate(h);
                    if (h.baseId = N, e.util.varOccurences(K, g) < 2) {
                        K = e.util.varReplace(K, g, H);
                        var te = H
                    } else {
                        te = g;
                        n += " var " + g + " = " + H + "; "
                    }
                    if (ee) n += " " + K + " "; else {
                        if (D && D[J]) {
                            n += " if ( " + te + " === undefined ", O && (n += " || ! Object.prototype.hasOwnProperty.call(" + d + ", '" + e.util.escapeQuotes(J) + "') "), n += ") { " + f + " = false; ";
                            F = e.errorPath, W = c;
                            var re, ne = e.util.escapeQuotes(J);
                            e.opts._errorDataPathProperty && (e.errorPath = e.util.getPath(F, J, e.opts.jsonPointers)), c = e.errSchemaPath + "/required", (re = re || []).push(n), n = "", !1 !== e.createErrors ? (n += " { keyword: 'required' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(c) + " , params: { missingProperty: '" + ne + "' } ", !1 !== e.opts.messages && (n += " , message: '", e.opts._errorDataPathProperty ? n += "is a required property" : n += "should have required property \\'" + ne + "\\'", n += "' "), e.opts.verbose && (n += " , schema: validate.schema" + a + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + d + " "), n += " } ") : n += " {} ";
                            G = n;
                            n = re.pop(), !e.compositeRule && u ? e.async ? n += " throw new ValidationError([" + G + "]); " : n += " validate.errors = [" + G + "]; return false; " : n += " var err = " + G + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", c = W, e.errorPath = F, n += " } else { "
                        } else u ? (n += " if ( " + te + " === undefined ", O && (n += " || ! Object.prototype.hasOwnProperty.call(" + d + ", '" + e.util.escapeQuotes(J) + "') "), n += ") { " + f + " = true; } else { ") : (n += " if (" + te + " !== undefined ", O && (n += " &&   Object.prototype.hasOwnProperty.call(" + d + ", '" + e.util.escapeQuotes(J) + "') "), n += " ) { ");
                        n += " " + K + " } "
                    }
                }
                u && (n += " if (" + f + ") { ", p += "}")
            }
        }
        if (b.length) {
            var ie = b;
            if (ie) for (var oe, se = -1, ae = ie.length - 1; se < ae;) {
                $ = S[oe = ie[se += 1]];
                if (e.opts.strictKeywords ? "object" == typeof $ && Object.keys($).length > 0 || !1 === $ : e.util.schemaHasRules($, e.RULES.all)) {
                    h.schema = $, h.schemaPath = e.schemaPath + ".patternProperties" + e.util.getProperty(oe), h.errSchemaPath = e.errSchemaPath + "/patternProperties/" + e.util.escapeFragment(oe), n += O ? " " + E + " = " + E + " || Object.keys(" + d + "); for (var " + _ + "=0; " + _ + "<" + E + ".length; " + _ + "++) { var " + m + " = " + E + "[" + _ + "]; " : " for (var " + m + " in " + d + ") { ", n += " if (" + e.usePattern(oe) + ".test(" + m + ")) { ", h.errorPath = e.util.getPathExpr(e.errorPath, m, e.opts.jsonPointers);
                    H = d + "[" + m + "]";
                    h.dataPathArr[v] = m;
                    K = e.validate(h);
                    h.baseId = N, e.util.varOccurences(K, g) < 2 ? n += " " + e.util.varReplace(K, g, H) + " " : n += " var " + g + " = " + H + "; " + K + " ", u && (n += " if (!" + f + ") break; "), n += " } ", u && (n += " else " + f + " = true; "), n += " }  ", u && (n += " if (" + f + ") { ", p += "}")
                }
            }
        }
        return u && (n += " " + p + " if (" + l + " == errors) {"), n
    }
}, function (e, t, r) {
    "use strict";
    e.exports = function (e, t, r) {
        var n = " ", i = e.level, o = e.dataLevel, s = e.schema[t], a = e.schemaPath + e.util.getProperty(t),
            c = e.errSchemaPath + "/" + t, u = !e.opts.allErrors, d = "data" + (o || ""), l = "errs__" + i,
            h = e.util.copy(e);
        h.level++;
        var p = "valid" + h.level;
        if (n += "var " + l + " = errors;", e.opts.strictKeywords ? "object" == typeof s && Object.keys(s).length > 0 || !1 === s : e.util.schemaHasRules(s, e.RULES.all)) {
            h.schema = s, h.schemaPath = a, h.errSchemaPath = c;
            var f = "key" + i, m = "idx" + i, _ = "i" + i, v = "' + " + f + " + '",
                g = "data" + (h.dataLevel = e.dataLevel + 1), E = "dataProperties" + i, y = e.opts.ownProperties,
                S = e.baseId;
            y && (n += " var " + E + " = undefined; "), n += y ? " " + E + " = " + E + " || Object.keys(" + d + "); for (var " + m + "=0; " + m + "<" + E + ".length; " + m + "++) { var " + f + " = " + E + "[" + m + "]; " : " for (var " + f + " in " + d + ") { ", n += " var startErrs" + i + " = errors; ";
            var b = f, T = e.compositeRule;
            e.compositeRule = h.compositeRule = !0;
            var R = e.validate(h);
            h.baseId = S, e.util.varOccurences(R, g) < 2 ? n += " " + e.util.varReplace(R, g, b) + " " : n += " var " + g + " = " + b + "; " + R + " ", e.compositeRule = h.compositeRule = T, n += " if (!" + p + ") { for (var " + _ + "=startErrs" + i + "; " + _ + "<errors; " + _ + "++) { vErrors[" + _ + "].propertyName = " + f + "; }   var err =   ", !1 !== e.createErrors ? (n += " { keyword: 'propertyNames' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(c) + " , params: { propertyName: '" + v + "' } ", !1 !== e.opts.messages && (n += " , message: 'property name \\'" + v + "\\' is invalid' "), e.opts.verbose && (n += " , schema: validate.schema" + a + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + d + " "), n += " } ") : n += " {} ", n += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", !e.compositeRule && u && (e.async ? n += " throw new ValidationError(vErrors); " : n += " validate.errors = vErrors; return false; "), u && (n += " break; "), n += " } }"
        }
        return u && (n += "  if (" + l + " == errors) {"), n
    }
}, function (e, t, r) {
    "use strict";
    e.exports = function (e, t, r) {
        var n = " ", i = e.level, o = e.dataLevel, s = e.schema[t], a = e.schemaPath + e.util.getProperty(t),
            c = e.errSchemaPath + "/" + t, u = !e.opts.allErrors, d = "data" + (o || ""), l = "valid" + i,
            h = e.opts.$data && s && s.$data;
        h && (n += " var schema" + i + " = " + e.util.getData(s.$data, o, e.dataPathArr) + "; ");
        var p = "schema" + i;
        if (!h) if (s.length < e.opts.loopRequired && e.schema.properties && Object.keys(e.schema.properties).length) {
            var f = [], m = s;
            if (m) for (var _, v = -1, g = m.length - 1; v < g;) {
                _ = m[v += 1];
                var E = e.schema.properties[_];
                E && (e.opts.strictKeywords ? "object" == typeof E && Object.keys(E).length > 0 || !1 === E : e.util.schemaHasRules(E, e.RULES.all)) || (f[f.length] = _)
            }
        } else f = s;
        if (h || f.length) {
            var y = e.errorPath, S = h || f.length >= e.opts.loopRequired, b = e.opts.ownProperties;
            if (u) if (n += " var missing" + i + "; ", S) {
                h || (n += " var " + p + " = validate.schema" + a + "; ");
                var T = "' + " + (O = "schema" + i + "[" + (w = "i" + i) + "]") + " + '";
                e.opts._errorDataPathProperty && (e.errorPath = e.util.getPathExpr(y, O, e.opts.jsonPointers)), n += " var " + l + " = true; ", h && (n += " if (schema" + i + " === undefined) " + l + " = true; else if (!Array.isArray(schema" + i + ")) " + l + " = false; else {"), n += " for (var " + w + " = 0; " + w + " < " + p + ".length; " + w + "++) { " + l + " = " + d + "[" + p + "[" + w + "]] !== undefined ", b && (n += " &&   Object.prototype.hasOwnProperty.call(" + d + ", " + p + "[" + w + "]) "), n += "; if (!" + l + ") break; } ", h && (n += "  }  "), n += "  if (!" + l + ") {   ", (A = A || []).push(n), n = "", !1 !== e.createErrors ? (n += " { keyword: 'required' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(c) + " , params: { missingProperty: '" + T + "' } ", !1 !== e.opts.messages && (n += " , message: '", e.opts._errorDataPathProperty ? n += "is a required property" : n += "should have required property \\'" + T + "\\'", n += "' "), e.opts.verbose && (n += " , schema: validate.schema" + a + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + d + " "), n += " } ") : n += " {} ";
                var R = n;
                n = A.pop(), !e.compositeRule && u ? e.async ? n += " throw new ValidationError([" + R + "]); " : n += " validate.errors = [" + R + "]; return false; " : n += " var err = " + R + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", n += " } else { "
            } else {
                n += " if ( ";
                var I = f;
                if (I) for (var w = -1, C = I.length - 1; w < C;) {
                    P = I[w += 1], w && (n += " || "), n += " ( ( " + (x = d + (L = e.util.getProperty(P))) + " === undefined ", b && (n += " || ! Object.prototype.hasOwnProperty.call(" + d + ", '" + e.util.escapeQuotes(P) + "') "), n += ") && (missing" + i + " = " + e.util.toQuotedString(e.opts.jsonPointers ? P : L) + ") ) "
                }
                n += ") {  ";
                var A;
                T = "' + " + (O = "missing" + i) + " + '";
                e.opts._errorDataPathProperty && (e.errorPath = e.opts.jsonPointers ? e.util.getPathExpr(y, O, !0) : y + " + " + O), (A = A || []).push(n), n = "", !1 !== e.createErrors ? (n += " { keyword: 'required' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(c) + " , params: { missingProperty: '" + T + "' } ", !1 !== e.opts.messages && (n += " , message: '", e.opts._errorDataPathProperty ? n += "is a required property" : n += "should have required property \\'" + T + "\\'", n += "' "), e.opts.verbose && (n += " , schema: validate.schema" + a + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + d + " "), n += " } ") : n += " {} ";
                R = n;
                n = A.pop(), !e.compositeRule && u ? e.async ? n += " throw new ValidationError([" + R + "]); " : n += " validate.errors = [" + R + "]; return false; " : n += " var err = " + R + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", n += " } else { "
            } else if (S) {
                h || (n += " var " + p + " = validate.schema" + a + "; ");
                var O;
                T = "' + " + (O = "schema" + i + "[" + (w = "i" + i) + "]") + " + '";
                e.opts._errorDataPathProperty && (e.errorPath = e.util.getPathExpr(y, O, e.opts.jsonPointers)), h && (n += " if (" + p + " && !Array.isArray(" + p + ")) {  var err =   ", !1 !== e.createErrors ? (n += " { keyword: 'required' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(c) + " , params: { missingProperty: '" + T + "' } ", !1 !== e.opts.messages && (n += " , message: '", e.opts._errorDataPathProperty ? n += "is a required property" : n += "should have required property \\'" + T + "\\'", n += "' "), e.opts.verbose && (n += " , schema: validate.schema" + a + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + d + " "), n += " } ") : n += " {} ", n += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (" + p + " !== undefined) { "), n += " for (var " + w + " = 0; " + w + " < " + p + ".length; " + w + "++) { if (" + d + "[" + p + "[" + w + "]] === undefined ", b && (n += " || ! Object.prototype.hasOwnProperty.call(" + d + ", " + p + "[" + w + "]) "), n += ") {  var err =   ", !1 !== e.createErrors ? (n += " { keyword: 'required' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(c) + " , params: { missingProperty: '" + T + "' } ", !1 !== e.opts.messages && (n += " , message: '", e.opts._errorDataPathProperty ? n += "is a required property" : n += "should have required property \\'" + T + "\\'", n += "' "), e.opts.verbose && (n += " , schema: validate.schema" + a + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + d + " "), n += " } ") : n += " {} ", n += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ", h && (n += "  }  ")
            } else {
                var N = f;
                if (N) for (var P, D = -1, k = N.length - 1; D < k;) {
                    P = N[D += 1];
                    var L = e.util.getProperty(P), x = (T = e.util.escapeQuotes(P), d + L);
                    e.opts._errorDataPathProperty && (e.errorPath = e.util.getPath(y, P, e.opts.jsonPointers)), n += " if ( " + x + " === undefined ", b && (n += " || ! Object.prototype.hasOwnProperty.call(" + d + ", '" + e.util.escapeQuotes(P) + "') "), n += ") {  var err =   ", !1 !== e.createErrors ? (n += " { keyword: 'required' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(c) + " , params: { missingProperty: '" + T + "' } ", !1 !== e.opts.messages && (n += " , message: '", e.opts._errorDataPathProperty ? n += "is a required property" : n += "should have required property \\'" + T + "\\'", n += "' "), e.opts.verbose && (n += " , schema: validate.schema" + a + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + d + " "), n += " } ") : n += " {} ", n += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } "
                }
            }
            e.errorPath = y
        } else u && (n += " if (true) {");
        return n
    }
}, function (e, t, r) {
    "use strict";
    e.exports = function (e, t, r) {
        var n, i = " ", o = e.level, s = e.dataLevel, a = e.schema[t], c = e.schemaPath + e.util.getProperty(t),
            u = e.errSchemaPath + "/" + t, d = !e.opts.allErrors, l = "data" + (s || ""), h = "valid" + o,
            p = e.opts.$data && a && a.$data;
        if (p ? (i += " var schema" + o + " = " + e.util.getData(a.$data, s, e.dataPathArr) + "; ", n = "schema" + o) : n = a, (a || p) && !1 !== e.opts.uniqueItems) {
            p && (i += " var " + h + "; if (" + n + " === false || " + n + " === undefined) " + h + " = true; else if (typeof " + n + " != 'boolean') " + h + " = false; else { "), i += " var i = " + l + ".length , " + h + " = true , j; if (i > 1) { ";
            var f = e.schema.items && e.schema.items.type, m = Array.isArray(f);
            if (!f || "object" == f || "array" == f || m && (f.indexOf("object") >= 0 || f.indexOf("array") >= 0)) i += " outer: for (;i--;) { for (j = i; j--;) { if (equal(" + l + "[i], " + l + "[j])) { " + h + " = false; break outer; } } } "; else {
                i += " var itemIndices = {}, item; for (;i--;) { var item = " + l + "[i]; ";
                var _ = "checkDataType" + (m ? "s" : "");
                i += " if (" + e.util[_](f, "item", e.opts.strictNumbers, !0) + ") continue; ", m && (i += " if (typeof item == 'string') item = '\"' + item; "), i += " if (typeof itemIndices[item] == 'number') { " + h + " = false; j = itemIndices[item]; break; } itemIndices[item] = i; } "
            }
            i += " } ", p && (i += "  }  "), i += " if (!" + h + ") {   ";
            var v = v || [];
            v.push(i), i = "", !1 !== e.createErrors ? (i += " { keyword: 'uniqueItems' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { i: i, j: j } ", !1 !== e.opts.messages && (i += " , message: 'should NOT have duplicate items (items ## ' + j + ' and ' + i + ' are identical)' "), e.opts.verbose && (i += " , schema:  ", i += p ? "validate.schema" + c : "" + a, i += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + l + " "), i += " } ") : i += " {} ";
            var g = i;
            i = v.pop(), !e.compositeRule && d ? e.async ? i += " throw new ValidationError([" + g + "]); " : i += " validate.errors = [" + g + "]; return false; " : i += " var err = " + g + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", i += " } ", d && (i += " else { ")
        } else d && (i += " if (true) { ");
        return i
    }
}, function (e, t, r) {
    "use strict";
    var n = ["multipleOf", "maximum", "exclusiveMaximum", "minimum", "exclusiveMinimum", "maxLength", "minLength", "pattern", "additionalItems", "maxItems", "minItems", "uniqueItems", "maxProperties", "minProperties", "required", "additionalProperties", "enum", "format", "const"];
    e.exports = function (e, t) {
        for (var r = 0; r < t.length; r++) {
            e = JSON.parse(JSON.stringify(e));
            var i, o = t[r].split("/"), s = e;
            for (i = 1; i < o.length; i++) s = s[o[i]];
            for (i = 0; i < n.length; i++) {
                var a = n[i], c = s[a];
                c && (s[a] = {anyOf: [c, {$ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"}]})
            }
        }
        return e
    }
}, function (e, t, r) {
    "use strict";
    var n = r(79).MissingRef;
    e.exports = function e(t, r, i) {
        var o = this;
        if ("function" != typeof this._opts.loadSchema) throw new Error("options.loadSchema should be a function");
        "function" == typeof r && (i = r, r = void 0);
        var s = a(t).then(function () {
            var e = o._addSchema(t, void 0, r);
            return e.validate || function e(t) {
                try {
                    return o._compile(t)
                } catch (e) {
                    if (e instanceof n) return function i(e) {
                        var i = e.missingSchema;
                        if (u(i)) throw new Error("Schema " + i + " is loaded but " + e.missingRef + " cannot be resolved");
                        var s = o._loadingSchemas[i];
                        s || (s = o._loadingSchemas[i] = o._opts.loadSchema(i)).then(c, c);
                        return s.then(function (e) {
                            if (!u(i)) return a(e).then(function () {
                                u(i) || o.addSchema(e, i, void 0, r)
                            })
                        }).then(function () {
                            return function e(t) {
                                try {
                                    return o._compile(t)
                                } catch (e) {
                                    if (e instanceof n) return i(e);
                                    throw e
                                }

                                function i(n) {
                                    var i = n.missingSchema;
                                    if (u(i)) throw new Error("Schema " + i + " is loaded but " + n.missingRef + " cannot be resolved");
                                    var s = o._loadingSchemas[i];
                                    return s || (s = o._loadingSchemas[i] = o._opts.loadSchema(i)).then(c, c), s.then(function (e) {
                                        if (!u(i)) return a(e).then(function () {
                                            u(i) || o.addSchema(e, i, void 0, r)
                                        })
                                    }).then(function () {
                                        return e(t)
                                    });

                                    function c() {
                                        delete o._loadingSchemas[i]
                                    }

                                    function u(e) {
                                        return o._refs[e] || o._schemas[e]
                                    }
                                }
                            }(t)
                        });

                        function c() {
                            delete o._loadingSchemas[i]
                        }

                        function u(e) {
                            return o._refs[e] || o._schemas[e]
                        }
                    }(e);
                    throw e
                }

                function i(n) {
                    var i = n.missingSchema;
                    if (u(i)) throw new Error("Schema " + i + " is loaded but " + n.missingRef + " cannot be resolved");
                    var s = o._loadingSchemas[i];
                    return s || (s = o._loadingSchemas[i] = o._opts.loadSchema(i)).then(c, c), s.then(function (e) {
                        if (!u(i)) return a(e).then(function () {
                            u(i) || o.addSchema(e, i, void 0, r)
                        })
                    }).then(function () {
                        return e(t)
                    });

                    function c() {
                        delete o._loadingSchemas[i]
                    }

                    function u(e) {
                        return o._refs[e] || o._schemas[e]
                    }
                }
            }(e)
        });
        i && s.then(function (e) {
            i(null, e)
        }, i);
        return s;

        function a(t) {
            var r = t.$schema;
            return r && !o.getSchema(r) ? e.call(o, {$ref: r}, !0) : Promise.resolve()
        }
    }
}, function (e, t, r) {
    "use strict";
    var n = /^[a-z_$][a-z0-9_$-]*$/i, i = r(211), o = r(212);
    e.exports = {
        add: function (e, t) {
            var r = this.RULES;
            if (r.keywords[e]) throw new Error("Keyword " + e + " is already defined");
            if (!n.test(e)) throw new Error("Keyword " + e + " is not a valid identifier");
            if (t) {
                this.validateKeyword(t, !0);
                var o = t.type;
                if (Array.isArray(o)) for (var s = 0; s < o.length; s++) c(e, o[s], t); else c(e, o, t);
                var a = t.metaSchema;
                a && (t.$data && this._opts.$data && (a = {anyOf: [a, {$ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"}]}), t.validateSchema = this.compile(a, !0))
            }

            function c(e, t, n) {
                for (var o, s = 0; s < r.length; s++) {
                    var a = r[s];
                    if (a.type == t) {
                        o = a;
                        break
                    }
                }
                o || (o = {type: t, rules: []}, r.push(o));
                var c = {keyword: e, definition: n, custom: !0, code: i, implements: n.implements};
                o.rules.push(c), r.custom[e] = c
            }

            return r.keywords[e] = r.all[e] = !0, this
        }, get: function (e) {
            var t = this.RULES.custom[e];
            return t ? t.definition : this.RULES.keywords[e] || !1
        }, remove: function (e) {
            var t = this.RULES;
            delete t.keywords[e], delete t.all[e], delete t.custom[e];
            for (var r = 0; r < t.length; r++) for (var n = t[r].rules, i = 0; i < n.length; i++) if (n[i].keyword == e) {
                n.splice(i, 1);
                break
            }
            return this
        }, validate: function e(t, r) {
            e.errors = null;
            var n = this._validateKeyword = this._validateKeyword || this.compile(o, !0);
            if (n(t)) return !0;
            e.errors = n.errors;
            if (r) throw new Error("custom keyword definition is invalid: " + this.errorsText(n.errors));
            return !1
        }
    }
}, function (e, t, r) {
    "use strict";
    e.exports = function (e, t, r) {
        var n, i, o = " ", s = e.level, a = e.dataLevel, c = e.schema[t], u = e.schemaPath + e.util.getProperty(t),
            d = e.errSchemaPath + "/" + t, l = !e.opts.allErrors, h = "data" + (a || ""), p = "valid" + s,
            f = "errs__" + s, m = e.opts.$data && c && c.$data;
        m ? (o += " var schema" + s + " = " + e.util.getData(c.$data, a, e.dataPathArr) + "; ", i = "schema" + s) : i = c;
        var _, v, g, E, y, S = "definition" + s, b = this.definition, T = "";
        if (m && b.$data) {
            y = "keywordValidate" + s;
            var R = b.validateSchema;
            o += " var " + S + " = RULES.custom['" + t + "'].definition; var " + y + " = " + S + ".validate;"
        } else {
            if (!(E = e.useCustomRule(this, c, e.schema, e))) return;
            i = "validate.schema" + u, y = E.code, _ = b.compile, v = b.inline, g = b.macro
        }
        var I = y + ".errors", w = "i" + s, C = "ruleErr" + s, A = b.async;
        if (A && !e.async) throw new Error("async keyword in sync schema");
        if (v || g || (o += I + " = null;"), o += "var " + f + " = errors;var " + p + ";", m && b.$data && (T += "}", o += " if (" + i + " === undefined) { " + p + " = true; } else { ", R && (T += "}", o += " " + p + " = " + S + ".validateSchema(" + i + "); if (" + p + ") { ")), v) b.statements ? o += " " + E.validate + " " : o += " " + p + " = " + E.validate + "; "; else if (g) {
            var O = e.util.copy(e);
            T = "";
            O.level++;
            var N = "valid" + O.level;
            O.schema = E.validate, O.schemaPath = "";
            var P = e.compositeRule;
            e.compositeRule = O.compositeRule = !0;
            var D = e.validate(O).replace(/validate\.schema/g, y);
            e.compositeRule = O.compositeRule = P, o += " " + D
        } else {
            (M = M || []).push(o), o = "", o += "  " + y + ".call( ", e.opts.passContext ? o += "this" : o += "self", _ || !1 === b.schema ? o += " , " + h + " " : o += " , " + i + " , " + h + " , validate.schema" + e.schemaPath + " ", o += " , (dataPath || '')", '""' != e.errorPath && (o += " + " + e.errorPath);
            var k = a ? "data" + (a - 1 || "") : "parentData", L = a ? e.dataPathArr[a] : "parentDataProperty",
                x = o += " , " + k + " , " + L + " , rootData )  ";
            o = M.pop(), !1 === b.errors ? (o += " " + p + " = ", A && (o += "await "), o += x + "; ") : o += A ? " var " + (I = "customErrors" + s) + " = null; try { " + p + " = await " + x + "; } catch (e) { " + p + " = false; if (e instanceof ValidationError) " + I + " = e.errors; else throw e; } " : " " + I + " = null; " + p + " = " + x + "; "
        }
        if (b.modifying && (o += " if (" + k + ") " + h + " = " + k + "[" + L + "];"), o += "" + T, b.valid) l && (o += " if (true) { "); else {
            var M;
            o += " if ( ", void 0 === b.valid ? (o += " !", o += g ? "" + N : "" + p) : o += " " + !b.valid + " ", o += ") { ", n = this.keyword, (M = M || []).push(o), o = "", (M = M || []).push(o), o = "", !1 !== e.createErrors ? (o += " { keyword: '" + (n || "custom") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(d) + " , params: { keyword: '" + this.keyword + "' } ", !1 !== e.opts.messages && (o += " , message: 'should pass \"" + this.keyword + "\" keyword validation' "), e.opts.verbose && (o += " , schema: validate.schema" + u + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + h + " "), o += " } ") : o += " {} ";
            var U = o;
            o = M.pop(), !e.compositeRule && l ? e.async ? o += " throw new ValidationError([" + U + "]); " : o += " validate.errors = [" + U + "]; return false; " : o += " var err = " + U + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            var j = o;
            o = M.pop(), v ? b.errors ? "full" != b.errors && (o += "  for (var " + w + "=" + f + "; " + w + "<errors; " + w + "++) { var " + C + " = vErrors[" + w + "]; if (" + C + ".dataPath === undefined) " + C + ".dataPath = (dataPath || '') + " + e.errorPath + "; if (" + C + ".schemaPath === undefined) { " + C + '.schemaPath = "' + d + '"; } ', e.opts.verbose && (o += " " + C + ".schema = " + i + "; " + C + ".data = " + h + "; "), o += " } ") : !1 === b.errors ? o += " " + j + " " : (o += " if (" + f + " == errors) { " + j + " } else {  for (var " + w + "=" + f + "; " + w + "<errors; " + w + "++) { var " + C + " = vErrors[" + w + "]; if (" + C + ".dataPath === undefined) " + C + ".dataPath = (dataPath || '') + " + e.errorPath + "; if (" + C + ".schemaPath === undefined) { " + C + '.schemaPath = "' + d + '"; } ', e.opts.verbose && (o += " " + C + ".schema = " + i + "; " + C + ".data = " + h + "; "), o += " } } ") : g ? (o += "   var err =   ", !1 !== e.createErrors ? (o += " { keyword: '" + (n || "custom") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(d) + " , params: { keyword: '" + this.keyword + "' } ", !1 !== e.opts.messages && (o += " , message: 'should pass \"" + this.keyword + "\" keyword validation' "), e.opts.verbose && (o += " , schema: validate.schema" + u + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + h + " "), o += " } ") : o += " {} ", o += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", !e.compositeRule && l && (e.async ? o += " throw new ValidationError(vErrors); " : o += " validate.errors = vErrors; return false; ")) : !1 === b.errors ? o += " " + j + " " : (o += " if (Array.isArray(" + I + ")) { if (vErrors === null) vErrors = " + I + "; else vErrors = vErrors.concat(" + I + "); errors = vErrors.length;  for (var " + w + "=" + f + "; " + w + "<errors; " + w + "++) { var " + C + " = vErrors[" + w + "]; if (" + C + ".dataPath === undefined) " + C + ".dataPath = (dataPath || '') + " + e.errorPath + ";  " + C + '.schemaPath = "' + d + '";  ', e.opts.verbose && (o += " " + C + ".schema = " + i + "; " + C + ".data = " + h + "; "), o += " } } else { " + j + " } "), o += " } ", l && (o += " else { ")
        }
        return o
    }
}, function (e, t, r) {
    "use strict";
    var n = r(112);
    e.exports = {
        $id: "https://github.com/ajv-validator/ajv/blob/master/lib/definition_schema.js",
        definitions: {simpleTypes: n.definitions.simpleTypes},
        type: "object",
        dependencies: {
            schema: ["validate"],
            $data: ["validate"],
            statements: ["inline"],
            valid: {not: {required: ["macro"]}}
        },
        properties: {
            type: n.properties.type,
            schema: {type: "boolean"},
            statements: {type: "boolean"},
            dependencies: {type: "array", items: {type: "string"}},
            metaSchema: {type: "object"},
            modifying: {type: "boolean"},
            valid: {type: "boolean"},
            $data: {type: "boolean"},
            async: {type: "boolean"},
            errors: {anyOf: [{type: "boolean"}, {const: "full"}]}
        }
    }
}, function (e) {
    e.exports = JSON.parse('{"$schema":"http://json-schema.org/draft-07/schema#","$id":"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#","description":"Meta-schema for $data reference (JSON Schema extension proposal)","type":"object","required":["$data"],"properties":{"$data":{"type":"string","anyOf":[{"format":"relative-json-pointer"},{"format":"json-pointer"}]}},"additionalProperties":false}')
}, function (e, t) {
    e.exports = function (e) {
        if (Array.isArray(e)) return e
    }
}, function (e, t) {
    e.exports = function (e, t) {
        if ("undefined" != typeof Symbol && Symbol.iterator in Object(e)) {
            var r = [], n = !0, i = !1, o = void 0;
            try {
                for (var s, a = e[Symbol.iterator](); !(n = (s = a.next()).done) && (r.push(s.value), !t || r.length !== t); n = !0) ;
            } catch (e) {
                i = !0, o = e
            } finally {
                try {
                    n || null == a.return || a.return()
                } finally {
                    if (i) throw o
                }
            }
            return r
        }
    }
}, function (e, t) {
    e.exports = function () {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
    }
}, function (e, t, r) {
    (function (e, t) {
        !function (e, r) {
            "use strict";
            if (!e.setImmediate) {
                var n, i = 1, o = {}, s = !1, a = e.document, c = Object.getPrototypeOf && Object.getPrototypeOf(e);
                c = c && c.setTimeout ? c : e, "[object process]" === {}.toString.call(e.process) ? n = function (e) {
                    t.nextTick(function () {
                        d(e)
                    })
                } : function () {
                    if (e.postMessage && !e.importScripts) {
                        var t = !0, r = e.onmessage;
                        return e.onmessage = function () {
                            t = !1
                        }, e.postMessage("", "*"), e.onmessage = r, t
                    }
                }() ? function () {
                    var t = "setImmediate$" + Math.random() + "$", r = function (r) {
                        r.source === e && "string" == typeof r.data && 0 === r.data.indexOf(t) && d(+r.data.slice(t.length))
                    };
                    e.addEventListener ? e.addEventListener("message", r, !1) : e.attachEvent("onmessage", r), n = function (r) {
                        e.postMessage(t + r, "*")
                    }
                }() : e.MessageChannel ? function () {
                    var e = new MessageChannel;
                    e.port1.onmessage = function (e) {
                        d(e.data)
                    }, n = function (t) {
                        e.port2.postMessage(t)
                    }
                }() : a && "onreadystatechange" in a.createElement("script") ? function () {
                    var e = a.documentElement;
                    n = function (t) {
                        var r = a.createElement("script");
                        r.onreadystatechange = function () {
                            d(t), r.onreadystatechange = null, e.removeChild(r), r = null
                        }, e.appendChild(r)
                    }
                }() : n = function (e) {
                    setTimeout(d, 0, e)
                }, c.setImmediate = function (e) {
                    "function" != typeof e && (e = new Function("" + e));
                    for (var t = new Array(arguments.length - 1), r = 0; r < t.length; r++) t[r] = arguments[r + 1];
                    var s = {callback: e, args: t};
                    return o[i] = s, n(i), i++
                }, c.clearImmediate = u
            }

            function u(e) {
                delete o[e]
            }

            function d(e) {
                if (s) setTimeout(d, 0, e); else {
                    var t = o[e];
                    if (t) {
                        s = !0;
                        try {
                            !function (e) {
                                var t = e.callback, n = e.args;
                                switch (n.length) {
                                    case 0:
                                        t();
                                        break;
                                    case 1:
                                        t(n[0]);
                                        break;
                                    case 2:
                                        t(n[0], n[1]);
                                        break;
                                    case 3:
                                        t(n[0], n[1], n[2]);
                                        break;
                                    default:
                                        t.apply(r, n)
                                }
                            }(t)
                        } finally {
                            u(e), s = !1
                        }
                    }
                }
            }
        }("undefined" == typeof self ? void 0 === e ? this : e : self)
    }).call(this, r(25), r(14))
}, function (e, t, r) {
    var n = r(15);

    function i() {
    }

    function o(e) {
        return e.isQueryName || "ec2" !== e.api.protocol ? e.name : e.name[0].toUpperCase() + e.name.substr(1)
    }

    function s(e, t, r, i) {
        n.each(r.members, function (r, n) {
            var s = t[r];
            if (null !== s && void 0 !== s) {
                var c = o(n);
                a(c = e ? e + "." + c : c, s, n, i)
            }
        })
    }

    function a(e, t, r, i) {
        null !== t && void 0 !== t && ("structure" === r.type ? s(e, t, r, i) : "list" === r.type ? function (e, t, r, i) {
            var s = r.member || {};
            0 !== t.length ? n.arrayEach(t, function (t, n) {
                var c = "." + (n + 1);
                if ("ec2" === r.api.protocol) c += ""; else if (r.flattened) {
                    if (s.name) {
                        var u = e.split(".");
                        u.pop(), u.push(o(s)), e = u.join(".")
                    }
                } else c = "." + (s.name ? s.name : "member") + c;
                a(e + c, t, s, i)
            }) : i.call(this, e, null)
        }(e, t, r, i) : "map" === r.type ? function (e, t, r, i) {
            var o = 1;
            n.each(t, function (t, n) {
                var s = (r.flattened ? "." : ".entry.") + o++ + ".", c = s + (r.key.name || "key"),
                    u = s + (r.value.name || "value");
                a(e + c, t, r.key, i), a(e + u, n, r.value, i)
            })
        }(e, t, r, i) : i(e, r.toWireFormat(t).toString()))
    }

    i.prototype.serialize = function (e, t, r) {
        s("", e, t, r)
    }, e.exports = i
}, function (e, t, r) {
    var n = r(15), i = r(220).XmlNode, o = r(222).XmlText;

    function s() {
    }

    function a(e, t, r) {
        switch (r.type) {
            case"structure":
                return function (e, t, r) {
                    n.arrayEach(r.memberNames, function (n) {
                        var o = r.members[n];
                        if ("body" === o.location) {
                            var s = t[n], u = o.name;
                            if (void 0 !== s && null !== s) if (o.isXmlAttribute) e.addAttribute(u, s); else if (o.flattened) a(e, s, o); else {
                                var d = new i(u);
                                e.addChildNode(d), c(d, o), a(d, s, o)
                            }
                        }
                    })
                }(e, t, r);
            case"map":
                return function (e, t, r) {
                    var o = r.key.name || "key", s = r.value.name || "value";
                    n.each(t, function (t, n) {
                        var c = new i(r.flattened ? r.name : "entry");
                        e.addChildNode(c);
                        var u = new i(o), d = new i(s);
                        c.addChildNode(u), c.addChildNode(d), a(u, t, r.key), a(d, n, r.value)
                    })
                }(e, t, r);
            case"list":
                return function (e, t, r) {
                    r.flattened ? n.arrayEach(t, function (t) {
                        var n = r.member.name || r.name, o = new i(n);
                        e.addChildNode(o), a(o, t, r.member)
                    }) : n.arrayEach(t, function (t) {
                        var n = r.member.name || "member", o = new i(n);
                        e.addChildNode(o), a(o, t, r.member)
                    })
                }(e, t, r);
            default:
                return function (e, t, r) {
                    e.addChildNode(new o(r.toWireFormat(t)))
                }(e, t, r)
        }
    }

    function c(e, t, r) {
        var n, i = "xmlns";
        t.xmlNamespaceUri ? (n = t.xmlNamespaceUri, t.xmlNamespacePrefix && (i += ":" + t.xmlNamespacePrefix)) : r && t.api.xmlNamespaceUri && (n = t.api.xmlNamespaceUri), n && e.addAttribute(i, n)
    }

    s.prototype.toXML = function (e, t, r, n) {
        var o = new i(r);
        return c(o, t, !0), a(o, e, t), o.children.length > 0 || n ? o.toString() : ""
    }, e.exports = s
}, function (e, t, r) {
    var n = r(221).escapeAttribute;

    function i(e, t) {
        void 0 === t && (t = []), this.name = e, this.children = t, this.attributes = {}
    }

    i.prototype.addAttribute = function (e, t) {
        return this.attributes[e] = t, this
    }, i.prototype.addChildNode = function (e) {
        return this.children.push(e), this
    }, i.prototype.removeAttribute = function (e) {
        return delete this.attributes[e], this
    }, i.prototype.toString = function () {
        for (var e = Boolean(this.children.length), t = "<" + this.name, r = this.attributes, i = 0, o = Object.keys(r); i < o.length; i++) {
            var s = o[i], a = r[s];
            void 0 !== a && null !== a && (t += " " + s + '="' + n("" + a) + '"')
        }
        return t + (e ? ">" + this.children.map(function (e) {
            return e.toString()
        }).join("") + "</" + this.name + ">" : "/>")
    }, e.exports = {XmlNode: i}
}, function (e, t) {
    e.exports = {
        escapeAttribute: function (e) {
            return e.replace(/&/g, "&amp;").replace(/'/g, "&apos;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;")
        }
    }
}, function (e, t, r) {
    var n = r(223).escapeElement;

    function i(e) {
        this.value = e
    }

    i.prototype.toString = function () {
        return n("" + this.value)
    }, e.exports = {XmlText: i}
}, function (e, t) {
    e.exports = {
        escapeElement: function (e) {
            return e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;")
        }
    }
}, function (e, t) {
    function r(e, t) {
        if (!r.services.hasOwnProperty(e)) throw new Error("InvalidService: Failed to load api for " + e);
        return r.services[e][t]
    }

    r.services = {}, e.exports = r
}, function (e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", {value: !0});
    var n = r(226), i = 1e3, o = function () {
        function e(e) {
            void 0 === e && (e = i), this.maxSize = e, this.cache = new n.LRUCache(e)
        }

        return Object.defineProperty(e.prototype, "size", {
            get: function () {
                return this.cache.length
            }, enumerable: !0, configurable: !0
        }), e.prototype.put = function (t, r) {
            var n = "string" != typeof t ? e.getKeyString(t) : t, i = this.populateValue(r);
            this.cache.put(n, i)
        }, e.prototype.get = function (t) {
            var r = "string" != typeof t ? e.getKeyString(t) : t, n = Date.now(), i = this.cache.get(r);
            if (i) for (var o = 0; o < i.length; o++) {
                if (i[o].Expire < n) return void this.cache.remove(r)
            }
            return i
        }, e.getKeyString = function (e) {
            for (var t = [], r = Object.keys(e).sort(), n = 0; n < r.length; n++) {
                var i = r[n];
                void 0 !== e[i] && t.push(e[i])
            }
            return t.join(" ")
        }, e.prototype.populateValue = function (e) {
            var t = Date.now();
            return e.map(function (e) {
                return {Address: e.Address || "", Expire: t + 60 * (e.CachePeriodInMinutes || 1) * 1e3}
            })
        }, e.prototype.empty = function () {
            this.cache.empty()
        }, e.prototype.remove = function (t) {
            var r = "string" != typeof t ? e.getKeyString(t) : t;
            this.cache.remove(r)
        }, e
    }();
    t.EndpointCache = o
}, function (e, t, r) {
    "use strict";
    Object.defineProperty(t, "__esModule", {value: !0});
    var n = function () {
        return function (e, t) {
            this.key = e, this.value = t
        }
    }(), i = function () {
        function e(e) {
            if (this.nodeMap = {}, this.size = 0, "number" != typeof e || e < 1) throw new Error("Cache size can only be positive number");
            this.sizeLimit = e
        }

        return Object.defineProperty(e.prototype, "length", {
            get: function () {
                return this.size
            }, enumerable: !0, configurable: !0
        }), e.prototype.prependToList = function (e) {
            this.headerNode ? (this.headerNode.prev = e, e.next = this.headerNode) : this.tailNode = e, this.headerNode = e, this.size++
        }, e.prototype.removeFromTail = function () {
            if (this.tailNode) {
                var e = this.tailNode, t = e.prev;
                return t && (t.next = void 0), e.prev = void 0, this.tailNode = t, this.size--, e
            }
        }, e.prototype.detachFromList = function (e) {
            this.headerNode === e && (this.headerNode = e.next), this.tailNode === e && (this.tailNode = e.prev), e.prev && (e.prev.next = e.next), e.next && (e.next.prev = e.prev), e.next = void 0, e.prev = void 0, this.size--
        }, e.prototype.get = function (e) {
            if (this.nodeMap[e]) {
                var t = this.nodeMap[e];
                return this.detachFromList(t), this.prependToList(t), t.value
            }
        }, e.prototype.remove = function (e) {
            if (this.nodeMap[e]) {
                var t = this.nodeMap[e];
                this.detachFromList(t), delete this.nodeMap[e]
            }
        }, e.prototype.put = function (e, t) {
            if (this.nodeMap[e]) this.remove(e); else if (this.size === this.sizeLimit) {
                var r = this.removeFromTail().key;
                delete this.nodeMap[r]
            }
            var i = new n(e, t);
            this.nodeMap[e] = i, this.prependToList(i)
        }, e.prototype.empty = function () {
            for (var e = Object.keys(this.nodeMap), t = 0; t < e.length; t++) {
                var r = e[t], n = this.nodeMap[r];
                this.detachFromList(n), delete this.nodeMap[r]
            }
        }, e
    }();
    t.LRUCache = i
}, function (e, t, r) {
    (function (t) {
        var n = r(9), i = r(118), o = r(228), s = n.util.inherit, a = 0;
        n.Service = s({
            constructor: function (e) {
                if (!this.loadServiceClass) throw n.util.error(new Error, "Service must be constructed with `new' operator");
                var t = this.loadServiceClass(e || {});
                if (t) {
                    var r = n.util.copy(e), i = new t(e);
                    return Object.defineProperty(i, "_originalConfig", {
                        get: function () {
                            return r
                        }, enumerable: !1, configurable: !0
                    }), i._clientId = ++a, i
                }
                this.initialize(e)
            }, initialize: function (e) {
                var r = n.config[this.serviceIdentifier];
                if (this.config = new n.Config(n.config), r && this.config.update(r, !0), e && this.config.update(e, !0), this.validateService(), this.config.endpoint || o.configureEndpoint(this), this.config.endpoint = this.endpointFromTemplate(this.config.endpoint), this.setEndpoint(this.config.endpoint), n.SequentialExecutor.call(this), n.Service.addDefaultMonitoringListeners(this), (this.config.clientSideMonitoring || n.Service._clientSideMonitoring) && this.publisher) {
                    var i = this.publisher;
                    this.addNamedListener("PUBLISH_API_CALL", "apiCall", function (e) {
                        t.nextTick(function () {
                            i.eventHandler(e)
                        })
                    }), this.addNamedListener("PUBLISH_API_ATTEMPT", "apiCallAttempt", function (e) {
                        t.nextTick(function () {
                            i.eventHandler(e)
                        })
                    })
                }
            }, validateService: function () {
            }, loadServiceClass: function (e) {
                var t = e;
                if (n.util.isEmpty(this.api)) {
                    if (t.apiConfig) return n.Service.defineServiceApi(this.constructor, t.apiConfig);
                    if (this.constructor.services) {
                        (t = new n.Config(n.config)).update(e, !0);
                        var r = t.apiVersions[this.constructor.serviceIdentifier];
                        return r = r || t.apiVersion, this.getLatestServiceClass(r)
                    }
                    return null
                }
                return null
            }, getLatestServiceClass: function (e) {
                return e = this.getLatestServiceVersion(e), null === this.constructor.services[e] && n.Service.defineServiceApi(this.constructor, e), this.constructor.services[e]
            }, getLatestServiceVersion: function (e) {
                if (!this.constructor.services || 0 === this.constructor.services.length) throw new Error("No services defined on " + this.constructor.serviceIdentifier);
                if (e ? n.util.isType(e, Date) && (e = n.util.date.iso8601(e).split("T")[0]) : e = "latest", Object.hasOwnProperty(this.constructor.services, e)) return e;
                for (var t = Object.keys(this.constructor.services).sort(), r = null, i = t.length - 1; i >= 0; i--) if ("*" !== t[i][t[i].length - 1] && (r = t[i]), t[i].substr(0, 10) <= e) return r;
                throw new Error("Could not find " + this.constructor.serviceIdentifier + " API to satisfy version constraint `" + e + "'")
            }, api: {}, defaultRetryCount: 3, customizeRequests: function (e) {
                if (e) {
                    if ("function" != typeof e) throw new Error("Invalid callback type '" + typeof e + "' provided in customizeRequests");
                    this.customRequestHandler = e
                } else this.customRequestHandler = null
            }, makeRequest: function (e, t, r) {
                if ("function" == typeof t && (r = t, t = null), t = t || {}, this.config.params) {
                    var i = this.api.operations[e];
                    i && (t = n.util.copy(t), n.util.each(this.config.params, function (e, r) {
                        i.input.members[e] && (void 0 !== t[e] && null !== t[e] || (t[e] = r))
                    }))
                }
                var o = new n.Request(this, e, t);
                return this.addAllRequestListeners(o), this.attachMonitoringEmitter(o), r && o.send(r), o
            }, makeUnauthenticatedRequest: function (e, t, r) {
                "function" == typeof t && (r = t, t = {});
                var n = this.makeRequest(e, t).toUnauthenticated();
                return r ? n.send(r) : n
            }, waitFor: function (e, t, r) {
                return new n.ResourceWaiter(this, e).wait(t, r)
            }, addAllRequestListeners: function (e) {
                for (var t = [n.events, n.EventListeners.Core, this.serviceInterface(), n.EventListeners.CorePost], r = 0; r < t.length; r++) t[r] && e.addListeners(t[r]);
                this.config.paramValidation || e.removeListener("validate", n.EventListeners.Core.VALIDATE_PARAMETERS), this.config.logger && e.addListeners(n.EventListeners.Logger), this.setupRequestListeners(e), "function" == typeof this.constructor.prototype.customRequestHandler && this.constructor.prototype.customRequestHandler(e), Object.prototype.hasOwnProperty.call(this, "customRequestHandler") && "function" == typeof this.customRequestHandler && this.customRequestHandler(e)
            }, apiCallEvent: function (e) {
                var t = e.service.api.operations[e.operation], r = {
                    Type: "ApiCall",
                    Api: t ? t.name : e.operation,
                    Version: 1,
                    Service: e.service.api.serviceId || e.service.api.endpointPrefix,
                    Region: e.httpRequest.region,
                    MaxRetriesExceeded: 0,
                    UserAgent: e.httpRequest.getUserAgent()
                }, n = e.response;
                if (n.httpResponse.statusCode && (r.FinalHttpStatusCode = n.httpResponse.statusCode), n.error) {
                    var i = n.error;
                    n.httpResponse.statusCode > 299 ? (i.code && (r.FinalAwsException = i.code), i.message && (r.FinalAwsExceptionMessage = i.message)) : ((i.code || i.name) && (r.FinalSdkException = i.code || i.name), i.message && (r.FinalSdkExceptionMessage = i.message))
                }
                return r
            }, apiAttemptEvent: function (e) {
                var t = e.service.api.operations[e.operation], r = {
                    Type: "ApiCallAttempt",
                    Api: t ? t.name : e.operation,
                    Version: 1,
                    Service: e.service.api.serviceId || e.service.api.endpointPrefix,
                    Fqdn: e.httpRequest.endpoint.hostname,
                    UserAgent: e.httpRequest.getUserAgent()
                }, n = e.response;
                return n.httpResponse.statusCode && (r.HttpStatusCode = n.httpResponse.statusCode), !e._unAuthenticated && e.service.config.credentials && e.service.config.credentials.accessKeyId && (r.AccessKey = e.service.config.credentials.accessKeyId), n.httpResponse.headers ? (e.httpRequest.headers["x-amz-security-token"] && (r.SessionToken = e.httpRequest.headers["x-amz-security-token"]), n.httpResponse.headers["x-amzn-requestid"] && (r.XAmznRequestId = n.httpResponse.headers["x-amzn-requestid"]), n.httpResponse.headers["x-amz-request-id"] && (r.XAmzRequestId = n.httpResponse.headers["x-amz-request-id"]), n.httpResponse.headers["x-amz-id-2"] && (r.XAmzId2 = n.httpResponse.headers["x-amz-id-2"]), r) : r
            }, attemptFailEvent: function (e) {
                var t = this.apiAttemptEvent(e), r = e.response, n = r.error;
                return r.httpResponse.statusCode > 299 ? (n.code && (t.AwsException = n.code), n.message && (t.AwsExceptionMessage = n.message)) : ((n.code || n.name) && (t.SdkException = n.code || n.name), n.message && (t.SdkExceptionMessage = n.message)), t
            }, attachMonitoringEmitter: function (e) {
                var t, r, i, o, s, a, c = 0, u = this;
                e.on("validate", function () {
                    o = n.util.realClock.now(), a = Date.now()
                }, !0), e.on("sign", function () {
                    r = n.util.realClock.now(), t = Date.now(), s = e.httpRequest.region, c++
                }, !0), e.on("validateResponse", function () {
                    i = Math.round(n.util.realClock.now() - r)
                }), e.addNamedListener("API_CALL_ATTEMPT", "success", function () {
                    var r = u.apiAttemptEvent(e);
                    r.Timestamp = t, r.AttemptLatency = i >= 0 ? i : 0, r.Region = s, u.emit("apiCallAttempt", [r])
                }), e.addNamedListener("API_CALL_ATTEMPT_RETRY", "retry", function () {
                    var o = u.attemptFailEvent(e);
                    o.Timestamp = t, i = i || Math.round(n.util.realClock.now() - r), o.AttemptLatency = i >= 0 ? i : 0, o.Region = s, u.emit("apiCallAttempt", [o])
                }), e.addNamedListener("API_CALL", "complete", function () {
                    var t = u.apiCallEvent(e);
                    if (t.AttemptCount = c, !(t.AttemptCount <= 0)) {
                        t.Timestamp = a;
                        var r = Math.round(n.util.realClock.now() - o);
                        t.Latency = r >= 0 ? r : 0;
                        var i = e.response;
                        i.error && i.error.retryable && "number" == typeof i.retryCount && "number" == typeof i.maxRetries && i.retryCount >= i.maxRetries && (t.MaxRetriesExceeded = 1), u.emit("apiCall", [t])
                    }
                })
            }, setupRequestListeners: function (e) {
            }, getSigningName: function () {
                return this.api.signingName || this.api.endpointPrefix
            }, getSignerClass: function (e) {
                var t, r = null, i = "";
                e && (i = (r = (e.service.api.operations || {})[e.operation] || null) ? r.authtype : "");
                return t = this.config.signatureVersion ? this.config.signatureVersion : "v4" === i || "v4-unsigned-body" === i ? "v4" : this.api.signatureVersion, n.Signers.RequestSigner.getVersion(t)
            }, serviceInterface: function () {
                switch (this.api.protocol) {
                    case"ec2":
                    case"query":
                        return n.EventListeners.Query;
                    case"json":
                        return n.EventListeners.Json;
                    case"rest-json":
                        return n.EventListeners.RestJson;
                    case"rest-xml":
                        return n.EventListeners.RestXml
                }
                if (this.api.protocol) throw new Error("Invalid service `protocol' " + this.api.protocol + " in API config")
            }, successfulResponse: function (e) {
                return e.httpResponse.statusCode < 300
            }, numRetries: function () {
                return void 0 !== this.config.maxRetries ? this.config.maxRetries : this.defaultRetryCount
            }, retryDelays: function (e, t) {
                return n.util.calculateRetryDelay(e, this.config.retryDelayOptions, t)
            }, retryableError: function (e) {
                return !!this.timeoutError(e) || (!!this.networkingError(e) || (!!this.expiredCredentialsError(e) || (!!this.throttledError(e) || e.statusCode >= 500)))
            }, networkingError: function (e) {
                return "NetworkingError" === e.code
            }, timeoutError: function (e) {
                return "TimeoutError" === e.code
            }, expiredCredentialsError: function (e) {
                return "ExpiredTokenException" === e.code
            }, clockSkewError: function (e) {
                switch (e.code) {
                    case"RequestTimeTooSkewed":
                    case"RequestExpired":
                    case"InvalidSignatureException":
                    case"SignatureDoesNotMatch":
                    case"AuthFailure":
                    case"RequestInTheFuture":
                        return !0;
                    default:
                        return !1
                }
            }, getSkewCorrectedDate: function () {
                return new Date(Date.now() + this.config.systemClockOffset)
            }, applyClockOffset: function (e) {
                e && (this.config.systemClockOffset = e - Date.now())
            }, isClockSkewed: function (e) {
                if (e) return Math.abs(this.getSkewCorrectedDate().getTime() - e) >= 3e5
            }, throttledError: function (e) {
                if (429 === e.statusCode) return !0;
                switch (e.code) {
                    case"ProvisionedThroughputExceededException":
                    case"Throttling":
                    case"ThrottlingException":
                    case"RequestLimitExceeded":
                    case"RequestThrottled":
                    case"RequestThrottledException":
                    case"TooManyRequestsException":
                    case"TransactionInProgressException":
                    case"EC2ThrottledException":
                        return !0;
                    default:
                        return !1
                }
            }, endpointFromTemplate: function (e) {
                if ("string" != typeof e) return e;
                var t = e;
                return t = (t = (t = t.replace(/\{service\}/g, this.api.endpointPrefix)).replace(/\{region\}/g, this.config.region)).replace(/\{scheme\}/g, this.config.sslEnabled ? "https" : "http")
            }, setEndpoint: function (e) {
                this.endpoint = new n.Endpoint(e, this.config)
            }, paginationConfig: function (e, t) {
                var r = this.api.operations[e].paginator;
                if (!r) {
                    if (t) {
                        var i = new Error;
                        throw n.util.error(i, "No pagination configuration for " + e)
                    }
                    return null
                }
                return r
            }
        }), n.util.update(n.Service, {
            defineMethods: function (e) {
                n.util.each(e.prototype.api.operations, function (t) {
                    e.prototype[t] || ("none" === e.prototype.api.operations[t].authtype ? e.prototype[t] = function (e, r) {
                        return this.makeUnauthenticatedRequest(t, e, r)
                    } : e.prototype[t] = function (e, r) {
                        return this.makeRequest(t, e, r)
                    })
                })
            }, defineService: function (e, t, r) {
                n.Service._serviceMap[e] = !0, Array.isArray(t) || (r = t, t = []);
                var i = s(n.Service, r || {});
                if ("string" == typeof e) {
                    n.Service.addVersions(i, t);
                    var o = i.serviceIdentifier || e;
                    i.serviceIdentifier = o
                } else i.prototype.api = e, n.Service.defineMethods(i);
                if (n.SequentialExecutor.call(this.prototype), !this.prototype.publisher && n.util.clientSideMonitoring) {
                    var a = n.util.clientSideMonitoring.Publisher,
                        c = (0, n.util.clientSideMonitoring.configProvider)();
                    this.prototype.publisher = new a(c), c.enabled && (n.Service._clientSideMonitoring = !0)
                }
                return n.SequentialExecutor.call(i.prototype), n.Service.addDefaultMonitoringListeners(i.prototype), i
            }, addVersions: function (e, t) {
                Array.isArray(t) || (t = [t]), e.services = e.services || {};
                for (var r = 0; r < t.length; r++) void 0 === e.services[t[r]] && (e.services[t[r]] = null);
                e.apiVersions = Object.keys(e.services).sort()
            }, defineServiceApi: function (e, t, r) {
                var o = s(e, {serviceIdentifier: e.serviceIdentifier});

                function a(t) {
                    t.isApi ? o.prototype.api = t : o.prototype.api = new i(t, {serviceIdentifier: e.serviceIdentifier})
                }

                if ("string" == typeof t) {
                    if (r) a(r); else try {
                        a(n.apiLoader(e.serviceIdentifier, t))
                    } catch (r) {
                        throw n.util.error(r, {message: "Could not find API configuration " + e.serviceIdentifier + "-" + t})
                    }
                    Object.prototype.hasOwnProperty.call(e.services, t) || (e.apiVersions = e.apiVersions.concat(t).sort()), e.services[t] = o
                } else a(t);
                return n.Service.defineMethods(o), o
            }, hasService: function (e) {
                return Object.prototype.hasOwnProperty.call(n.Service._serviceMap, e)
            }, addDefaultMonitoringListeners: function (e) {
                e.addNamedListener("MONITOR_EVENTS_BUBBLE", "apiCallAttempt", function (t) {
                    var r = Object.getPrototypeOf(e);
                    r._events && r.emit("apiCallAttempt", [t])
                }), e.addNamedListener("CALL_EVENTS_BUBBLE", "apiCall", function (t) {
                    var r = Object.getPrototypeOf(e);
                    r._events && r.emit("apiCall", [t])
                })
            }, _serviceMap: {}
        }), n.util.mixin(n.Service, n.SequentialExecutor), e.exports = n.Service
    }).call(this, r(14))
}, function (e, t, r) {
    var n = r(15), i = r(229);

    function o(e, t) {
        n.each(t, function (t, r) {
            "globalEndpoint" !== t && (void 0 !== e.config[t] && null !== e.config[t] || (e.config[t] = r))
        })
    }

    e.exports = {
        configureEndpoint: function (e) {
            for (var t = function (e) {
                var t = e.config.region, r = function (e) {
                    if (!e) return null;
                    var t = e.split("-");
                    return t.length < 3 ? null : t.slice(0, t.length - 2).join("-") + "-*"
                }(t), n = e.api.endpointPrefix;
                return [[t, n], [r, n], [t, "*"], [r, "*"], ["*", n], ["*", "*"]].map(function (e) {
                    return e[0] && e[1] ? e.join("/") : null
                })
            }(e), r = 0; r < t.length; r++) {
                var s = t[r];
                if (s && Object.prototype.hasOwnProperty.call(i.rules, s)) {
                    var a = i.rules[s];
                    return "string" == typeof a && (a = i.patterns[a]), e.config.useDualstack && n.isDualstackAvailable(e) && ((a = n.copy(a)).endpoint = a.endpoint.replace(/{service}\.({region}\.)?/, "{service}.dualstack.{region}.")), e.isGlobalEndpoint = !!a.globalEndpoint, a.signingRegion && (e.signingRegion = a.signingRegion), a.signatureVersion || (a.signatureVersion = "v4"), void o(e, a)
                }
            }
        }, getEndpointSuffix: function (e) {
            for (var t = {
                "^(us|eu|ap|sa|ca|me)\\-\\w+\\-\\d+$": "amazonaws.com",
                "^cn\\-\\w+\\-\\d+$": "amazonaws.com.cn",
                "^us\\-gov\\-\\w+\\-\\d+$": "amazonaws.com",
                "^us\\-iso\\-\\w+\\-\\d+$": "c2s.ic.gov",
                "^us\\-isob\\-\\w+\\-\\d+$": "sc2s.sgov.gov"
            }, r = Object.keys(t), n = 0; n < r.length; n++) {
                var i = RegExp(r[n]), o = t[r[n]];
                if (i.test(e)) return o
            }
            return "amazonaws.com"
        }
    }
}, function (e) {
    e.exports = JSON.parse('{"rules":{"*/*":{"endpoint":"{service}.{region}.amazonaws.com"},"cn-*/*":{"endpoint":"{service}.{region}.amazonaws.com.cn"},"us-iso-*/*":{"endpoint":"{service}.{region}.c2s.ic.gov"},"us-isob-*/*":{"endpoint":"{service}.{region}.sc2s.sgov.gov"},"*/budgets":"globalSSL","*/cloudfront":"globalSSL","*/sts":"globalSSL","*/importexport":{"endpoint":"{service}.amazonaws.com","signatureVersion":"v2","globalEndpoint":true},"*/route53":"globalSSL","cn-*/route53":{"endpoint":"{service}.amazonaws.com.cn","globalEndpoint":true,"signingRegion":"cn-northwest-1"},"us-gov-*/route53":"globalGovCloud","*/waf":"globalSSL","*/iam":"globalSSL","cn-*/iam":{"endpoint":"{service}.cn-north-1.amazonaws.com.cn","globalEndpoint":true,"signingRegion":"cn-north-1"},"us-gov-*/iam":"globalGovCloud","us-gov-*/sts":{"endpoint":"{service}.{region}.amazonaws.com"},"us-gov-west-1/s3":"s3signature","us-west-1/s3":"s3signature","us-west-2/s3":"s3signature","eu-west-1/s3":"s3signature","ap-southeast-1/s3":"s3signature","ap-southeast-2/s3":"s3signature","ap-northeast-1/s3":"s3signature","sa-east-1/s3":"s3signature","us-east-1/s3":{"endpoint":"{service}.amazonaws.com","signatureVersion":"s3"},"us-east-1/sdb":{"endpoint":"{service}.amazonaws.com","signatureVersion":"v2"},"*/sdb":{"endpoint":"{service}.{region}.amazonaws.com","signatureVersion":"v2"}},"patterns":{"globalSSL":{"endpoint":"https://{service}.amazonaws.com","globalEndpoint":true,"signingRegion":"us-east-1"},"globalGovCloud":{"endpoint":"{service}.us-gov.amazonaws.com","globalEndpoint":true,"signingRegion":"us-gov-west-1"},"s3signature":{"endpoint":"{service}.{region}.amazonaws.com","signatureVersion":"s3"}}}')
}, function (e, t, r) {
    var n, i = r(9);
    r(124), r(125), i.Config = i.util.inherit({
        constructor: function (e) {
            void 0 === e && (e = {}), e = this.extractCredentials(e), i.util.each.call(this, this.keys, function (t, r) {
                this.set(t, e[t], r)
            })
        },
        getCredentials: function (e) {
            var t = this;

            function r(r) {
                e(r, r ? null : t.credentials)
            }

            function n(e, t) {
                return new i.util.error(t || new Error, {
                    code: "CredentialsError",
                    message: e,
                    name: "CredentialsError"
                })
            }

            t.credentials ? "function" == typeof t.credentials.get ? t.credentials.get(function (e) {
                e && (e = n("Could not load credentials from " + t.credentials.constructor.name, e)), r(e)
            }) : function () {
                var e = null;
                t.credentials.accessKeyId && t.credentials.secretAccessKey || (e = n("Missing credentials")), r(e)
            }() : t.credentialProvider ? t.credentialProvider.resolve(function (e, i) {
                e && (e = n("Could not load credentials from any providers", e)), t.credentials = i, r(e)
            }) : r(n("No credentials to load"))
        },
        update: function (e, t) {
            t = t || !1, e = this.extractCredentials(e), i.util.each.call(this, e, function (e, r) {
                (t || Object.prototype.hasOwnProperty.call(this.keys, e) || i.Service.hasService(e)) && this.set(e, r)
            })
        },
        loadFromPath: function (e) {
            this.clear();
            var t = JSON.parse(i.util.readFileSync(e)), r = new i.FileSystemCredentials(e),
                n = new i.CredentialProviderChain;
            return n.providers.unshift(r), n.resolve(function (e, r) {
                if (e) throw e;
                t.credentials = r
            }), this.constructor(t), this
        },
        clear: function () {
            i.util.each.call(this, this.keys, function (e) {
                delete this[e]
            }), this.set("credentials", void 0), this.set("credentialProvider", void 0)
        },
        set: function (e, t, r) {
            void 0 === t ? (void 0 === r && (r = this.keys[e]), this[e] = "function" == typeof r ? r.call(this) : r) : "httpOptions" === e && this[e] ? this[e] = i.util.merge(this[e], t) : this[e] = t
        },
        keys: {
            credentials: null,
            credentialProvider: null,
            region: null,
            logger: null,
            apiVersions: {},
            apiVersion: null,
            endpoint: void 0,
            httpOptions: {timeout: 12e4},
            maxRetries: void 0,
            maxRedirects: 10,
            paramValidation: !0,
            sslEnabled: !0,
            s3ForcePathStyle: !1,
            s3BucketEndpoint: !1,
            s3DisableBodySigning: !0,
            s3UsEast1RegionalEndpoint: "legacy",
            s3UseArnRegion: void 0,
            computeChecksums: !0,
            convertResponseTypes: !0,
            correctClockSkew: !1,
            customUserAgent: null,
            dynamoDbCrc32: !0,
            systemClockOffset: 0,
            signatureVersion: null,
            signatureCache: !0,
            retryDelayOptions: {},
            useAccelerateEndpoint: !1,
            clientSideMonitoring: !1,
            endpointDiscoveryEnabled: void 0,
            endpointCacheSize: 1e3,
            hostPrefixEnabled: !0,
            stsRegionalEndpoints: "legacy"
        },
        extractCredentials: function (e) {
            return e.accessKeyId && e.secretAccessKey && ((e = i.util.copy(e)).credentials = new i.Credentials(e)), e
        },
        setPromisesDependency: function (e) {
            n = e, null === e && "function" == typeof Promise && (n = Promise);
            var t = [i.Request, i.Credentials, i.CredentialProviderChain];
            i.S3 && (t.push(i.S3), i.S3.ManagedUpload && t.push(i.S3.ManagedUpload)), i.util.addPromises(t, n)
        },
        getPromisesDependency: function () {
            return n
        }
    }), i.config = new i.Config
}, function (e, t, r) {
    var n = r(9), i = r(123), o = r(232).discoverEndpoint;
    n.EventListeners = {Core: {}}, n.EventListeners = {
        Core: (new i).addNamedListeners(function (e, t) {
            t("VALIDATE_CREDENTIALS", "validate", function (e, t) {
                if (!e.service.api.signatureVersion && !e.service.config.signatureVersion) return t();
                e.service.config.getCredentials(function (r) {
                    r && (e.response.error = n.util.error(r, {
                        code: "CredentialsError",
                        message: "Missing credentials in config, if using AWS_CONFIG_FILE, set AWS_SDK_LOAD_CONFIG=1"
                    })), t()
                })
            }), e("VALIDATE_REGION", "validate", function (e) {
                if (!e.service.isGlobalEndpoint) {
                    var t = new RegExp(/^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9])$/);
                    e.service.config.region ? t.test(e.service.config.region) || (e.response.error = n.util.error(new Error, {
                        code: "ConfigError",
                        message: "Invalid region in config"
                    })) : e.response.error = n.util.error(new Error, {
                        code: "ConfigError",
                        message: "Missing region in config"
                    })
                }
            }), e("BUILD_IDEMPOTENCY_TOKENS", "validate", function (e) {
                if (e.service.api.operations) {
                    var t = e.service.api.operations[e.operation];
                    if (t) {
                        var r = t.idempotentMembers;
                        if (r.length) {
                            for (var i = n.util.copy(e.params), o = 0, s = r.length; o < s; o++) i[r[o]] || (i[r[o]] = n.util.uuid.v4());
                            e.params = i
                        }
                    }
                }
            }), e("VALIDATE_PARAMETERS", "validate", function (e) {
                if (e.service.api.operations) {
                    var t = e.service.api.operations[e.operation].input, r = e.service.config.paramValidation;
                    new n.ParamValidator(r).validate(t, e.params)
                }
            }), t("COMPUTE_SHA256", "afterBuild", function (e, t) {
                if (e.haltHandlersOnError(), e.service.api.operations) {
                    var r = e.service.api.operations[e.operation], i = r ? r.authtype : "";
                    if (!e.service.api.signatureVersion && !i && !e.service.config.signatureVersion) return t();
                    if (e.service.getSignerClass(e) === n.Signers.V4) {
                        var o = e.httpRequest.body || "";
                        if (i.indexOf("unsigned-body") >= 0) return e.httpRequest.headers["X-Amz-Content-Sha256"] = "UNSIGNED-PAYLOAD", t();
                        n.util.computeSha256(o, function (r, n) {
                            r ? t(r) : (e.httpRequest.headers["X-Amz-Content-Sha256"] = n, t())
                        })
                    } else t()
                }
            }), e("SET_CONTENT_LENGTH", "afterBuild", function (e) {
                var t = function (e) {
                    if (!e.service.api.operations) return "";
                    var t = e.service.api.operations[e.operation];
                    return t ? t.authtype : ""
                }(e), r = n.util.getRequestPayloadShape(e);
                if (void 0 === e.httpRequest.headers["Content-Length"]) try {
                    var i = n.util.string.byteLength(e.httpRequest.body);
                    e.httpRequest.headers["Content-Length"] = i
                } catch (n) {
                    if (r && r.isStreaming) {
                        if (r.requiresLength) throw n;
                        if (t.indexOf("unsigned-body") >= 0) return void (e.httpRequest.headers["Transfer-Encoding"] = "chunked");
                        throw n
                    }
                    throw n
                }
            }), e("SET_HTTP_HOST", "afterBuild", function (e) {
                e.httpRequest.headers.Host = e.httpRequest.endpoint.host
            }), e("RESTART", "restart", function () {
                var e = this.response.error;
                e && e.retryable && (this.httpRequest = new n.HttpRequest(this.service.endpoint, this.service.region), this.response.retryCount < this.service.config.maxRetries ? this.response.retryCount++ : this.response.error = null)
            });
            t("DISCOVER_ENDPOINT", "sign", o, !0), t("SIGN", "sign", function (e, t) {
                var r = e.service, n = (e.service.api.operations || {})[e.operation], i = n ? n.authtype : "";
                if (!r.api.signatureVersion && !i && !r.config.signatureVersion) return t();
                r.config.getCredentials(function (i, o) {
                    if (i) return e.response.error = i, t();
                    try {
                        var s = r.getSkewCorrectedDate(),
                            a = new (r.getSignerClass(e))(e.httpRequest, r.getSigningName(), {
                                signatureCache: r.config.signatureCache,
                                operation: n,
                                signatureVersion: r.api.signatureVersion
                            });
                        a.setServiceClientId(r._clientId), delete e.httpRequest.headers.Authorization, delete e.httpRequest.headers.Date, delete e.httpRequest.headers["X-Amz-Date"], a.addAuthorization(o, s), e.signedAt = s
                    } catch (t) {
                        e.response.error = t
                    }
                    t()
                })
            }), e("VALIDATE_RESPONSE", "validateResponse", function (e) {
                this.service.successfulResponse(e, this) ? (e.data = {}, e.error = null) : (e.data = null, e.error = n.util.error(new Error, {
                    code: "UnknownError",
                    message: "An unknown error occurred."
                }))
            }), t("SEND", "send", function (e, t) {
                function r(r) {
                    e.httpResponse.stream = r;
                    var i = e.request.httpRequest.stream, o = e.request.service, s = o.api, a = e.request.operation,
                        c = s.operations[a] || {};
                    r.on("headers", function (i, s, a) {
                        if (e.request.emit("httpHeaders", [i, s, e, a]), !e.httpResponse.streaming) if (2 === n.HttpClient.streamsApiVersion) {
                            if (c.hasEventOutput && o.successfulResponse(e)) return e.request.emit("httpDone"), void t();
                            r.on("readable", function () {
                                var t = r.read();
                                null !== t && e.request.emit("httpData", [t, e])
                            })
                        } else r.on("data", function (t) {
                            e.request.emit("httpData", [t, e])
                        })
                    }), r.on("end", function () {
                        if (!i || !i.didCallback) {
                            if (2 === n.HttpClient.streamsApiVersion && c.hasEventOutput && o.successfulResponse(e)) return;
                            e.request.emit("httpDone"), t()
                        }
                    })
                }

                function i(r) {
                    if ("RequestAbortedError" !== r.code) {
                        var i = "TimeoutError" === r.code ? r.code : "NetworkingError";
                        r = n.util.error(r, {
                            code: i,
                            region: e.request.httpRequest.region,
                            hostname: e.request.httpRequest.endpoint.hostname,
                            retryable: !0
                        })
                    }
                    e.error = r, e.request.emit("httpError", [e.error, e], function () {
                        t()
                    })
                }

                function o() {
                    var t = n.HttpClient.getInstance(), o = e.request.service.config.httpOptions || {};
                    try {
                        !function (t) {
                            t.on("sendProgress", function (t) {
                                e.request.emit("httpUploadProgress", [t, e])
                            }), t.on("receiveProgress", function (t) {
                                e.request.emit("httpDownloadProgress", [t, e])
                            })
                        }(t.handleRequest(e.request.httpRequest, o, r, i))
                    } catch (e) {
                        i(e)
                    }
                }

                e.httpResponse._abortCallback = t, e.error = null, e.data = null, (e.request.service.getSkewCorrectedDate() - this.signedAt) / 1e3 >= 600 ? this.emit("sign", [this], function (e) {
                    e ? t(e) : o()
                }) : o()
            }), e("HTTP_HEADERS", "httpHeaders", function (e, t, r, i) {
                r.httpResponse.statusCode = e, r.httpResponse.statusMessage = i, r.httpResponse.headers = t, r.httpResponse.body = n.util.buffer.toBuffer(""), r.httpResponse.buffers = [], r.httpResponse.numBytes = 0;
                var o = t.date || t.Date, s = r.request.service;
                if (o) {
                    var a = Date.parse(o);
                    s.config.correctClockSkew && s.isClockSkewed(a) && s.applyClockOffset(a)
                }
            }), e("HTTP_DATA", "httpData", function (e, t) {
                if (e) {
                    if (n.util.isNode()) {
                        t.httpResponse.numBytes += e.length;
                        var r = t.httpResponse.headers["content-length"],
                            i = {loaded: t.httpResponse.numBytes, total: r};
                        t.request.emit("httpDownloadProgress", [i, t])
                    }
                    t.httpResponse.buffers.push(n.util.buffer.toBuffer(e))
                }
            }), e("HTTP_DONE", "httpDone", function (e) {
                if (e.httpResponse.buffers && e.httpResponse.buffers.length > 0) {
                    var t = n.util.buffer.concat(e.httpResponse.buffers);
                    e.httpResponse.body = t
                }
                delete e.httpResponse.numBytes, delete e.httpResponse.buffers
            }), e("FINALIZE_ERROR", "retry", function (e) {
                e.httpResponse.statusCode && (e.error.statusCode = e.httpResponse.statusCode, void 0 === e.error.retryable && (e.error.retryable = this.service.retryableError(e.error, this)))
            }), e("INVALIDATE_CREDENTIALS", "retry", function (e) {
                if (e.error) switch (e.error.code) {
                    case"RequestExpired":
                    case"ExpiredTokenException":
                    case"ExpiredToken":
                        e.error.retryable = !0, e.request.service.config.credentials.expired = !0
                }
            }), e("EXPIRED_SIGNATURE", "retry", function (e) {
                var t = e.error;
                t && "string" == typeof t.code && "string" == typeof t.message && t.code.match(/Signature/) && t.message.match(/expired/) && (e.error.retryable = !0)
            }), e("CLOCK_SKEWED", "retry", function (e) {
                e.error && this.service.clockSkewError(e.error) && this.service.config.correctClockSkew && (e.error.retryable = !0)
            }), e("REDIRECT", "retry", function (e) {
                e.error && e.error.statusCode >= 300 && e.error.statusCode < 400 && e.httpResponse.headers.location && (this.httpRequest.endpoint = new n.Endpoint(e.httpResponse.headers.location), this.httpRequest.headers.Host = this.httpRequest.endpoint.host, e.error.redirect = !0, e.error.retryable = !0)
            }), e("RETRY_CHECK", "retry", function (e) {
                e.error && (e.error.redirect && e.redirectCount < e.maxRedirects ? e.error.retryDelay = 0 : e.retryCount < e.maxRetries && (e.error.retryDelay = this.service.retryDelays(e.retryCount, e.error) || 0))
            }), t("RESET_RETRY_STATE", "afterRetry", function (e, t) {
                var r, n = !1;
                e.error && (r = e.error.retryDelay || 0, e.error.retryable && e.retryCount < e.maxRetries ? (e.retryCount++, n = !0) : e.error.redirect && e.redirectCount < e.maxRedirects && (e.redirectCount++, n = !0)), n && r >= 0 ? (e.error = null, setTimeout(t, r)) : t()
            })
        }), CorePost: (new i).addNamedListeners(function (e) {
            e("EXTRACT_REQUEST_ID", "extractData", n.util.extractRequestId), e("EXTRACT_REQUEST_ID", "extractError", n.util.extractRequestId), e("ENOTFOUND_ERROR", "httpError", function (e) {
                if ("NetworkingError" === e.code && function (e) {
                    return "ENOTFOUND" === e.errno || "number" == typeof e.errno && "function" == typeof n.util.getSystemErrorName && ["EAI_NONAME", "EAI_NODATA"].indexOf(n.util.getSystemErrorName(e.errno) >= 0)
                }(e)) {
                    var t = "Inaccessible host: `" + e.hostname + "'. This service may not be available in the `" + e.region + "' region.";
                    this.response.error = n.util.error(new Error(t), {
                        code: "UnknownEndpoint",
                        region: e.region,
                        hostname: e.hostname,
                        retryable: !0,
                        originalError: e
                    })
                }
            })
        }), Logger: (new i).addNamedListeners(function (e) {
            e("LOG_REQUEST", "complete", function (e) {
                var t = e.request, i = t.service.config.logger;
                if (i) {
                    var o = function () {
                        var o = (e.request.service.getSkewCorrectedDate().getTime() - t.startTime.getTime()) / 1e3,
                            s = !!i.isTTY, a = e.httpResponse.statusCode, c = t.params;
                        t.service.api.operations && t.service.api.operations[t.operation] && t.service.api.operations[t.operation].input && (c = function e(t, r) {
                            if (!r) return r;
                            if (t.isSensitive) return "***SensitiveInformation***";
                            switch (t.type) {
                                case"structure":
                                    var i = {};
                                    return n.util.each(r, function (r, n) {
                                        Object.prototype.hasOwnProperty.call(t.members, r) ? i[r] = e(t.members[r], n) : i[r] = n
                                    }), i;
                                case"list":
                                    var o = [];
                                    return n.util.arrayEach(r, function (r, n) {
                                        o.push(e(t.member, r))
                                    }), o;
                                case"map":
                                    var s = {};
                                    return n.util.each(r, function (r, n) {
                                        s[r] = e(t.value, n)
                                    }), s;
                                default:
                                    return r
                            }
                        }(t.service.api.operations[t.operation].input, t.params));
                        var u = r(50).inspect(c, !0, null), d = "";
                        return s && (d += "[33m"), d += "[AWS " + t.service.serviceIdentifier + " " + a, d += " " + o.toString() + "s " + e.retryCount + " retries]", s && (d += "[0;1m"), d += " " + n.util.string.lowerFirst(t.operation), d += "(" + u + ")", s && (d += "[0m"), d
                    }();
                    "function" == typeof i.log ? i.log(o) : "function" == typeof i.write && i.write(o + "\n")
                }
            })
        }), Json: (new i).addNamedListeners(function (e) {
            var t = r(81);
            e("BUILD", "build", t.buildRequest), e("EXTRACT_DATA", "extractData", t.extractData), e("EXTRACT_ERROR", "extractError", t.extractError)
        }), Rest: (new i).addNamedListeners(function (e) {
            var t = r(54);
            e("BUILD", "build", t.buildRequest), e("EXTRACT_DATA", "extractData", t.extractData), e("EXTRACT_ERROR", "extractError", t.extractError)
        }), RestJson: (new i).addNamedListeners(function (e) {
            var t = r(116);
            e("BUILD", "build", t.buildRequest), e("EXTRACT_DATA", "extractData", t.extractData), e("EXTRACT_ERROR", "extractError", t.extractError)
        }), RestXml: (new i).addNamedListeners(function (e) {
            var t = r(117);
            e("BUILD", "build", t.buildRequest), e("EXTRACT_DATA", "extractData", t.extractData), e("EXTRACT_ERROR", "extractError", t.extractError)
        }), Query: (new i).addNamedListeners(function (e) {
            var t = r(114);
            e("BUILD", "build", t.buildRequest), e("EXTRACT_DATA", "extractData", t.extractData), e("EXTRACT_ERROR", "extractError", t.extractError)
        })
    }
}, function (e, t, r) {
    (function (t) {
        var n = r(9), i = r(15), o = ["AWS_ENABLE_ENDPOINT_DISCOVERY", "AWS_ENDPOINT_DISCOVERY_ENABLED"];

        function s(e) {
            var t = e.service, r = t.api || {}, n = (r.operations, {});
            return t.config.region && (n.region = t.config.region), r.serviceId && (n.serviceId = r.serviceId), t.config.credentials.accessKeyId && (n.accessKeyId = t.config.credentials.accessKeyId), n
        }

        function a(e, t) {
            var r = {};
            return function e(t, r, n) {
                n && void 0 !== r && null !== r && "structure" === n.type && n.required && n.required.length > 0 && i.arrayEach(n.required, function (i) {
                    var o = n.members[i];
                    if (!0 === o.endpointDiscoveryId) {
                        var s = o.isLocationName ? o.name : i;
                        t[s] = String(r[i])
                    } else e(t, r[i], o)
                })
            }(r, e.params, t), r
        }

        function c(e) {
            var t = e.service, r = t.api, o = r.operations ? r.operations[e.operation] : void 0,
                c = a(e, o ? o.input : void 0), u = s(e);
            Object.keys(c).length > 0 && (u = i.update(u, c), o && (u.operation = o.name));
            var d = n.endpointCache.get(u);
            if (!d || 1 !== d.length || "" !== d[0].Address) if (d && d.length > 0) e.httpRequest.updateEndpoint(d[0].Address); else {
                var h = t.makeRequest(r.endpointOperation, {Operation: o.name, Identifiers: c});
                l(h), h.removeListener("validate", n.EventListeners.Core.VALIDATE_PARAMETERS), h.removeListener("retry", n.EventListeners.Core.RETRY_CHECK), n.endpointCache.put(u, [{
                    Address: "",
                    CachePeriodInMinutes: 1
                }]), h.send(function (e, t) {
                    t && t.Endpoints ? n.endpointCache.put(u, t.Endpoints) : e && n.endpointCache.put(u, [{
                        Address: "",
                        CachePeriodInMinutes: 1
                    }])
                })
            }
        }

        var u = {};

        function d(e, t) {
            var r = e.service, o = r.api, c = o.operations ? o.operations[e.operation] : void 0,
                d = c ? c.input : void 0, h = a(e, d), p = s(e);
            Object.keys(h).length > 0 && (p = i.update(p, h), c && (p.operation = c.name));
            var f = n.EndpointCache.getKeyString(p), m = n.endpointCache.get(f);
            if (m && 1 === m.length && "" === m[0].Address) return u[f] || (u[f] = []), void u[f].push({
                request: e,
                callback: t
            });
            if (m && m.length > 0) e.httpRequest.updateEndpoint(m[0].Address), t(); else {
                var _ = r.makeRequest(o.endpointOperation, {Operation: c.name, Identifiers: h});
                _.removeListener("validate", n.EventListeners.Core.VALIDATE_PARAMETERS), l(_), n.endpointCache.put(f, [{
                    Address: "",
                    CachePeriodInMinutes: 60
                }]), _.send(function (r, o) {
                    if (r) {
                        if (e.response.error = i.error(r, {retryable: !1}), n.endpointCache.remove(p), u[f]) {
                            var s = u[f];
                            i.arrayEach(s, function (e) {
                                e.request.response.error = i.error(r, {retryable: !1}), e.callback()
                            }), delete u[f]
                        }
                    } else if (o && (n.endpointCache.put(f, o.Endpoints), e.httpRequest.updateEndpoint(o.Endpoints[0].Address), u[f])) {
                        s = u[f];
                        i.arrayEach(s, function (e) {
                            e.request.httpRequest.updateEndpoint(o.Endpoints[0].Address), e.callback()
                        }), delete u[f]
                    }
                    t()
                })
            }
        }

        function l(e) {
            var t = e.service.api.apiVersion;
            t && !e.httpRequest.headers["x-amz-api-version"] && (e.httpRequest.headers["x-amz-api-version"] = t)
        }

        function h(e) {
            var t = e.error, r = e.httpResponse;
            if (t && ("InvalidEndpointException" === t.code || 421 === r.statusCode)) {
                var o = e.request, c = o.service.api.operations || {},
                    u = a(o, c[o.operation] ? c[o.operation].input : void 0), d = s(o);
                Object.keys(u).length > 0 && (d = i.update(d, u), c[o.operation] && (d.operation = c[o.operation].name)), n.endpointCache.remove(d)
            }
        }

        function p(e) {
            return ["false", "0"].indexOf(e) >= 0
        }

        e.exports = {
            discoverEndpoint: function (e, r) {
                var s = e.service || {};
                if (function (e) {
                    if (e._originalConfig && e._originalConfig.endpoint && !0 === e._originalConfig.endpointDiscoveryEnabled) throw i.error(new Error, {
                        code: "ConfigurationException",
                        message: "Custom endpoint is supplied; endpointDiscoveryEnabled must not be true."
                    });
                    var t = n.config[e.serviceIdentifier] || {};
                    return Boolean(n.config.endpoint || t.endpoint || e._originalConfig && e._originalConfig.endpoint)
                }(s) || e.isPresigned()) return r();
                var a = (s.api.operations || {})[e.operation], u = a ? a.endpointDiscoveryRequired : "NULL",
                    l = function (e) {
                        var r = e.service || {};
                        if (void 0 !== r.config.endpointDiscoveryEnabled) return r.config.endpointDiscoveryEnabled;
                        if (!i.isBrowser()) {
                            for (var s = 0; s < o.length; s++) {
                                var a = o[s];
                                if (Object.prototype.hasOwnProperty.call(t.env, a)) {
                                    if ("" === t.env[a] || void 0 === t.env[a]) throw i.error(new Error, {
                                        code: "ConfigurationException",
                                        message: "environmental variable " + a + " cannot be set to nothing"
                                    });
                                    return !p(t.env[a])
                                }
                            }
                            var c = {};
                            try {
                                c = n.util.iniLoader ? n.util.iniLoader.loadFrom({
                                    isConfig: !0,
                                    filename: t.env[n.util.sharedConfigFileEnv]
                                }) : {}
                            } catch (e) {
                            }
                            var u = c[t.env.AWS_PROFILE || n.util.defaultProfile] || {};
                            if (Object.prototype.hasOwnProperty.call(u, "endpoint_discovery_enabled")) {
                                if (void 0 === u.endpoint_discovery_enabled) throw i.error(new Error, {
                                    code: "ConfigurationException",
                                    message: "config file entry 'endpoint_discovery_enabled' cannot be set to nothing"
                                });
                                return !p(u.endpoint_discovery_enabled)
                            }
                        }
                    }(e), f = s.api.hasRequiredEndpointDiscovery;
                switch ((l || f) && e.httpRequest.appendToUserAgent("endpoint-discovery"), u) {
                    case"OPTIONAL":
                        (l || f) && (c(e), e.addNamedListener("INVALIDATE_CACHED_ENDPOINTS", "extractError", h)), r();
                        break;
                    case"REQUIRED":
                        if (!1 === l) {
                            e.response.error = i.error(new Error, {
                                code: "ConfigurationException",
                                message: "Endpoint Discovery is disabled but " + s.api.className + "." + e.operation + "() requires it. Please check your configurations."
                            }), r();
                            break
                        }
                        e.addNamedListener("INVALIDATE_CACHED_ENDPOINTS", "extractError", h), d(e, r);
                        break;
                    case"NULL":
                    default:
                        r()
                }
            },
            requiredDiscoverEndpoint: d,
            optionalDiscoverEndpoint: c,
            marshallCustomIdentifiers: a,
            getCacheKey: s,
            invalidateCachedEndpoint: h
        }
    }).call(this, r(14))
}, function (e, t) {
    e.exports = function (e) {
        return e && "object" == typeof e && "function" == typeof e.copy && "function" == typeof e.fill && "function" == typeof e.readUInt8
    }
}, function (e, t, r) {
    (function (e) {
        var t = r(9), n = r(235), i = t.util.inherit, o = t.util.domain, s = r(85),
            a = {success: 1, error: 1, complete: 1};
        var c = new n;
        c.setupStates = function () {
            var e = function (e, t) {
                var r = this;
                r._haltHandlersOnError = !1, r.emit(r._asm.currentState, function (e) {
                    if (e) if (function (e) {
                        return Object.prototype.hasOwnProperty.call(a, e._asm.currentState)
                    }(r)) {
                        if (!(o && r.domain instanceof o.Domain)) throw e;
                        e.domainEmitter = r, e.domain = r.domain, e.domainThrown = !1, r.domain.emit("error", e)
                    } else r.response.error = e, t(e); else t(r.response.error)
                })
            };
            this.addState("validate", "build", "error", e), this.addState("build", "afterBuild", "restart", e), this.addState("afterBuild", "sign", "restart", e), this.addState("sign", "send", "retry", e), this.addState("retry", "afterRetry", "afterRetry", e), this.addState("afterRetry", "sign", "error", e), this.addState("send", "validateResponse", "retry", e), this.addState("validateResponse", "extractData", "extractError", e), this.addState("extractError", "extractData", "retry", e), this.addState("extractData", "success", "retry", e), this.addState("restart", "build", "error", e), this.addState("success", "complete", "complete", e), this.addState("error", "complete", "complete", e), this.addState("complete", null, null, e)
        }, c.setupStates(), t.Request = i({
            constructor: function (e, r, i) {
                var s = e.endpoint, a = e.config.region, u = e.config.customUserAgent;
                e.isGlobalEndpoint && (a = e.signingRegion ? e.signingRegion : "us-east-1"), this.domain = o && o.active, this.service = e, this.operation = r, this.params = i || {}, this.httpRequest = new t.HttpRequest(s, a), this.httpRequest.appendToUserAgent(u), this.startTime = e.getSkewCorrectedDate(), this.response = new t.Response(this), this._asm = new n(c.states, "validate"), this._haltHandlersOnError = !1, t.SequentialExecutor.call(this), this.emit = this.emitEvent
            }, send: function (e) {
                return e && (this.httpRequest.appendToUserAgent("callback"), this.on("complete", function (t) {
                    e.call(t, t.error, t.data)
                })), this.runTo(), this.response
            }, build: function (e) {
                return this.runTo("send", e)
            }, runTo: function (e, t) {
                return this._asm.runTo(e, t, this), this
            }, abort: function () {
                return this.removeAllListeners("validateResponse"), this.removeAllListeners("extractError"), this.on("validateResponse", function (e) {
                    e.error = t.util.error(new Error("Request aborted by user"), {
                        code: "RequestAbortedError",
                        retryable: !1
                    })
                }), this.httpRequest.stream && !this.httpRequest.stream.didCallback && (this.httpRequest.stream.abort(), this.httpRequest._abortCallback ? this.httpRequest._abortCallback() : this.removeAllListeners("send")), this
            }, eachPage: function (e) {
                e = t.util.fn.makeAsync(e, 3), this.on("complete", function r(n) {
                    e.call(n, n.error, n.data, function (i) {
                        !1 !== i && (n.hasNextPage() ? n.nextPage().on("complete", r).send() : e.call(n, null, null, t.util.fn.noop))
                    })
                }).send()
            }, eachItem: function (e) {
                var r = this;
                this.eachPage(function (n, i) {
                    if (n) return e(n, null);
                    if (null === i) return e(null, null);
                    var o = r.service.paginationConfig(r.operation).resultKey;
                    Array.isArray(o) && (o = o[0]);
                    var a = s.search(i, o), c = !0;
                    return t.util.arrayEach(a, function (r) {
                        if (!1 === (c = e(null, r))) return t.util.abort
                    }), c
                })
            }, isPageable: function () {
                return !!this.service.paginationConfig(this.operation)
            }, createReadStream: function () {
                var r = t.util.stream, n = this, i = null;
                return 2 === t.HttpClient.streamsApiVersion ? (i = new r.PassThrough, e.nextTick(function () {
                    n.send()
                })) : ((i = new r.Stream).readable = !0, i.sent = !1, i.on("newListener", function (t) {
                    i.sent || "data" !== t || (i.sent = !0, e.nextTick(function () {
                        n.send()
                    }))
                })), this.on("error", function (e) {
                    i.emit("error", e)
                }), this.on("httpHeaders", function (e, o, s) {
                    if (e < 300) {
                        n.removeListener("httpData", t.EventListeners.Core.HTTP_DATA), n.removeListener("httpError", t.EventListeners.Core.HTTP_ERROR), n.on("httpError", function (e) {
                            s.error = e, s.error.retryable = !1
                        });
                        var a, c = !1;
                        if ("HEAD" !== n.httpRequest.method && (a = parseInt(o["content-length"], 10)), void 0 !== a && !isNaN(a) && a >= 0) {
                            c = !0;
                            var u = 0
                        }
                        var d = function () {
                            c && u !== a ? i.emit("error", t.util.error(new Error("Stream content length mismatch. Received " + u + " of " + a + " bytes."), {code: "StreamContentLengthMismatch"})) : 2 === t.HttpClient.streamsApiVersion ? i.end() : i.emit("end")
                        }, l = s.httpResponse.createUnbufferedStream();
                        if (2 === t.HttpClient.streamsApiVersion) if (c) {
                            var h = new r.PassThrough;
                            h._write = function (e) {
                                return e && e.length && (u += e.length), r.PassThrough.prototype._write.apply(this, arguments)
                            }, h.on("end", d), i.on("error", function (e) {
                                c = !1, l.unpipe(h), h.emit("end"), h.end()
                            }), l.pipe(h).pipe(i, {end: !1})
                        } else l.pipe(i); else c && l.on("data", function (e) {
                            e && e.length && (u += e.length)
                        }), l.on("data", function (e) {
                            i.emit("data", e)
                        }), l.on("end", d);
                        l.on("error", function (e) {
                            c = !1, i.emit("error", e)
                        })
                    }
                }), i
            }, emitEvent: function (e, r, n) {
                "function" == typeof r && (n = r, r = null), n || (n = function () {
                }), r || (r = this.eventParameters(e, this.response)), t.SequentialExecutor.prototype.emit.call(this, e, r, function (e) {
                    e && (this.response.error = e), n.call(this, e)
                })
            }, eventParameters: function (e) {
                switch (e) {
                    case"restart":
                    case"validate":
                    case"sign":
                    case"build":
                    case"afterValidate":
                    case"afterBuild":
                        return [this];
                    case"error":
                        return [this.response.error, this.response];
                    default:
                        return [this.response]
                }
            }, presign: function (e, r) {
                return r || "function" != typeof e || (r = e, e = null), (new t.Signers.Presign).sign(this.toGet(), e, r)
            }, isPresigned: function () {
                return Object.prototype.hasOwnProperty.call(this.httpRequest.headers, "presigned-expires")
            }, toUnauthenticated: function () {
                return this._unAuthenticated = !0, this.removeListener("validate", t.EventListeners.Core.VALIDATE_CREDENTIALS), this.removeListener("sign", t.EventListeners.Core.SIGN), this
            }, toGet: function () {
                return "query" !== this.service.api.protocol && "ec2" !== this.service.api.protocol || (this.removeListener("build", this.buildAsGet), this.addListener("build", this.buildAsGet)), this
            }, buildAsGet: function (e) {
                e.httpRequest.method = "GET", e.httpRequest.path = e.service.endpoint.path + "?" + e.httpRequest.body, e.httpRequest.body = "", delete e.httpRequest.headers["Content-Length"], delete e.httpRequest.headers["Content-Type"]
            }, haltHandlersOnError: function () {
                this._haltHandlersOnError = !0
            }
        }), t.Request.addPromisesToClass = function (e) {
            this.prototype.promise = function () {
                var t = this;
                return this.httpRequest.appendToUserAgent("promise"), new e(function (e, r) {
                    t.on("complete", function (t) {
                        t.error ? r(t.error) : e(Object.defineProperty(t.data || {}, "$response", {value: t}))
                    }), t.runTo()
                })
            }
        }, t.Request.deletePromisesFromClass = function () {
            delete this.prototype.promise
        }, t.util.addPromises(t.Request), t.util.mixin(t.Request, t.SequentialExecutor)
    }).call(this, r(14))
}, function (e, t) {
    function r(e, t) {
        this.currentState = t || null, this.states = e || {}
    }

    r.prototype.runTo = function (e, t, r, n) {
        "function" == typeof e && (n = r, r = t, t = e, e = null);
        var i = this, o = i.states[i.currentState];
        o.fn.call(r || i, n, function (n) {
            if (n) {
                if (!o.fail) return t ? t.call(r, n) : null;
                i.currentState = o.fail
            } else {
                if (!o.accept) return t ? t.call(r) : null;
                i.currentState = o.accept
            }
            if (i.currentState === e) return t ? t.call(r, n) : null;
            i.runTo(e, t, r, n)
        })
    }, r.prototype.addState = function (e, t, r, n) {
        return "function" == typeof t ? (n = t, t = null, r = null) : "function" == typeof r && (n = r, r = null), this.currentState || (this.currentState = e), this.states[e] = {
            accept: t,
            fail: r,
            fn: n
        }, this
    }, e.exports = r
}, function (e, t, r) {
    var n = r(9), i = n.util.inherit, o = r(85);
    n.Response = i({
        constructor: function (e) {
            this.request = e, this.data = null, this.error = null, this.retryCount = 0, this.redirectCount = 0, this.httpResponse = new n.HttpResponse, e && (this.maxRetries = e.service.numRetries(), this.maxRedirects = e.service.config.maxRedirects)
        }, nextPage: function (e) {
            var t, r = this.request.service, i = this.request.operation;
            try {
                t = r.paginationConfig(i, !0)
            } catch (e) {
                this.error = e
            }
            if (!this.hasNextPage()) {
                if (e) e(this.error, null); else if (this.error) throw this.error;
                return null
            }
            var o = n.util.copy(this.request.params);
            if (this.nextPageTokens) {
                var s = t.inputToken;
                "string" == typeof s && (s = [s]);
                for (var a = 0; a < s.length; a++) o[s[a]] = this.nextPageTokens[a];
                return r.makeRequest(this.request.operation, o, e)
            }
            return e ? e(null, null) : null
        }, hasNextPage: function () {
            return this.cacheNextPageTokens(), !!this.nextPageTokens || void 0 === this.nextPageTokens && void 0
        }, cacheNextPageTokens: function () {
            if (Object.prototype.hasOwnProperty.call(this, "nextPageTokens")) return this.nextPageTokens;
            this.nextPageTokens = void 0;
            var e = this.request.service.paginationConfig(this.request.operation);
            if (!e) return this.nextPageTokens;
            if (this.nextPageTokens = null, e.moreResults && !o.search(this.data, e.moreResults)) return this.nextPageTokens;
            var t = e.outputToken;
            return "string" == typeof t && (t = [t]), n.util.arrayEach.call(this, t, function (e) {
                var t = o.search(this.data, e);
                t && (this.nextPageTokens = this.nextPageTokens || [], this.nextPageTokens.push(t))
            }), this.nextPageTokens
        }
    })
}, function (e, t, r) {
    var n = r(9), i = n.util.inherit, o = r(85);

    function s(e) {
        var t = e.request._waiter, r = !1, n = "retry";
        t.config.acceptors.forEach(function (i) {
            if (!r) {
                var o = t.matchers[i.matcher];
                o && o(e, i.expected, i.argument) && (r = !0, n = i.state)
            }
        }), !r && e.error && (n = "failure"), "success" === n ? t.setSuccess(e) : t.setError(e, "retry" === n)
    }

    n.ResourceWaiter = i({
        constructor: function (e, t) {
            this.service = e, this.state = t, this.loadWaiterConfig(this.state)
        }, service: null, state: null, config: null, matchers: {
            path: function (e, t, r) {
                try {
                    var n = o.search(e.data, r)
                } catch (e) {
                    return !1
                }
                return o.strictDeepEqual(n, t)
            }, pathAll: function (e, t, r) {
                try {
                    var n = o.search(e.data, r)
                } catch (e) {
                    return !1
                }
                Array.isArray(n) || (n = [n]);
                var i = n.length;
                if (!i) return !1;
                for (var s = 0; s < i; s++) if (!o.strictDeepEqual(n[s], t)) return !1;
                return !0
            }, pathAny: function (e, t, r) {
                try {
                    var n = o.search(e.data, r)
                } catch (e) {
                    return !1
                }
                Array.isArray(n) || (n = [n]);
                for (var i = n.length, s = 0; s < i; s++) if (o.strictDeepEqual(n[s], t)) return !0;
                return !1
            }, status: function (e, t) {
                var r = e.httpResponse.statusCode;
                return "number" == typeof r && r === t
            }, error: function (e, t) {
                return "string" == typeof t && e.error ? t === e.error.code : t === !!e.error
            }
        }, listeners: (new n.SequentialExecutor).addNamedListeners(function (e) {
            e("RETRY_CHECK", "retry", function (e) {
                var t = e.request._waiter;
                e.error && "ResourceNotReady" === e.error.code && (e.error.retryDelay = 1e3 * (t.config.delay || 0))
            }), e("CHECK_OUTPUT", "extractData", s), e("CHECK_ERROR", "extractError", s)
        }), wait: function (e, t) {
            "function" == typeof e && (t = e, e = void 0), e && e.$waiter && ("number" == typeof (e = n.util.copy(e)).$waiter.delay && (this.config.delay = e.$waiter.delay), "number" == typeof e.$waiter.maxAttempts && (this.config.maxAttempts = e.$waiter.maxAttempts), delete e.$waiter);
            var r = this.service.makeRequest(this.config.operation, e);
            return r._waiter = this, r.response.maxRetries = this.config.maxAttempts, r.addListeners(this.listeners), t && r.send(t), r
        }, setSuccess: function (e) {
            e.error = null, e.data = e.data || {}, e.request.removeAllListeners("extractData")
        }, setError: function (e, t) {
            e.data = null, e.error = n.util.error(e.error || new Error, {
                code: "ResourceNotReady",
                message: "Resource is not in the state " + this.state,
                retryable: t
            })
        }, loadWaiterConfig: function (e) {
            if (!this.service.api.waiters[e]) throw new n.util.error(new Error, {
                code: "StateNotFoundError",
                message: "State " + e + " not found."
            });
            this.config = n.util.copy(this.service.api.waiters[e])
        }
    })
}, function (e, t, r) {
    var n = r(9), i = n.util.inherit;
    n.Signers.RequestSigner = i({
        constructor: function (e) {
            this.request = e
        }, setServiceClientId: function (e) {
            this.serviceClientId = e
        }, getServiceClientId: function () {
            return this.serviceClientId
        }
    }), n.Signers.RequestSigner.getVersion = function (e) {
        switch (e) {
            case"v2":
                return n.Signers.V2;
            case"v3":
                return n.Signers.V3;
            case"s3v4":
            case"v4":
                return n.Signers.V4;
            case"s3":
                return n.Signers.S3;
            case"v3https":
                return n.Signers.V3Https
        }
        throw new Error("Unknown signing version " + e)
    }, r(239), r(127), r(240), r(241), r(243), r(244)
}, function (e, t, r) {
    var n = r(9), i = n.util.inherit;
    n.Signers.V2 = i(n.Signers.RequestSigner, {
        addAuthorization: function (e, t) {
            t || (t = n.util.date.getDate());
            var r = this.request;
            r.params.Timestamp = n.util.date.iso8601(t), r.params.SignatureVersion = "2", r.params.SignatureMethod = "HmacSHA256", r.params.AWSAccessKeyId = e.accessKeyId, e.sessionToken && (r.params.SecurityToken = e.sessionToken), delete r.params.Signature, r.params.Signature = this.signature(e), r.body = n.util.queryParamsToString(r.params), r.headers["Content-Length"] = r.body.length
        }, signature: function (e) {
            return n.util.crypto.hmac(e.secretAccessKey, this.stringToSign(), "base64")
        }, stringToSign: function () {
            var e = [];
            return e.push(this.request.method), e.push(this.request.endpoint.host.toLowerCase()), e.push(this.request.pathname()), e.push(n.util.queryParamsToString(this.request.params)), e.join("\n")
        }
    }), e.exports = n.Signers.V2
}, function (e, t, r) {
    var n = r(9), i = n.util.inherit;
    r(127), n.Signers.V3Https = i(n.Signers.V3, {
        authorization: function (e) {
            return "AWS3-HTTPS AWSAccessKeyId=" + e.accessKeyId + ",Algorithm=HmacSHA256,Signature=" + this.signature(e)
        }, stringToSign: function () {
            return this.request.headers["X-Amz-Date"]
        }
    }), e.exports = n.Signers.V3Https
}, function (e, t, r) {
    var n = r(9), i = r(242), o = n.util.inherit;
    n.Signers.V4 = o(n.Signers.RequestSigner, {
        constructor: function (e, t, r) {
            n.Signers.RequestSigner.call(this, e), this.serviceName = t, r = r || {}, this.signatureCache = "boolean" != typeof r.signatureCache || r.signatureCache, this.operation = r.operation, this.signatureVersion = r.signatureVersion
        },
        algorithm: "AWS4-HMAC-SHA256",
        addAuthorization: function (e, t) {
            var r = n.util.date.iso8601(t).replace(/[:\-]|\.\d{3}/g, "");
            this.isPresigned() ? this.updateForPresigned(e, r) : this.addHeaders(e, r), this.request.headers.Authorization = this.authorization(e, r)
        },
        addHeaders: function (e, t) {
            this.request.headers["X-Amz-Date"] = t, e.sessionToken && (this.request.headers["x-amz-security-token"] = e.sessionToken)
        },
        updateForPresigned: function (e, t) {
            var r = this.credentialString(t), i = {
                "X-Amz-Date": t,
                "X-Amz-Algorithm": this.algorithm,
                "X-Amz-Credential": e.accessKeyId + "/" + r,
                "X-Amz-Expires": this.request.headers["presigned-expires"],
                "X-Amz-SignedHeaders": this.signedHeaders()
            };
            e.sessionToken && (i["X-Amz-Security-Token"] = e.sessionToken), this.request.headers["Content-Type"] && (i["Content-Type"] = this.request.headers["Content-Type"]), this.request.headers["Content-MD5"] && (i["Content-MD5"] = this.request.headers["Content-MD5"]), this.request.headers["Cache-Control"] && (i["Cache-Control"] = this.request.headers["Cache-Control"]), n.util.each.call(this, this.request.headers, function (e, t) {
                if ("presigned-expires" !== e && this.isSignableHeader(e)) {
                    var r = e.toLowerCase();
                    0 === r.indexOf("x-amz-meta-") ? i[r] = t : 0 === r.indexOf("x-amz-") && (i[e] = t)
                }
            });
            var o = this.request.path.indexOf("?") >= 0 ? "&" : "?";
            this.request.path += o + n.util.queryParamsToString(i)
        },
        authorization: function (e, t) {
            var r = [], n = this.credentialString(t);
            return r.push(this.algorithm + " Credential=" + e.accessKeyId + "/" + n), r.push("SignedHeaders=" + this.signedHeaders()), r.push("Signature=" + this.signature(e, t)), r.join(", ")
        },
        signature: function (e, t) {
            var r = i.getSigningKey(e, t.substr(0, 8), this.request.region, this.serviceName, this.signatureCache);
            return n.util.crypto.hmac(r, this.stringToSign(t), "hex")
        },
        stringToSign: function (e) {
            var t = [];
            return t.push("AWS4-HMAC-SHA256"), t.push(e), t.push(this.credentialString(e)), t.push(this.hexEncodedHash(this.canonicalString())), t.join("\n")
        },
        canonicalString: function () {
            var e = [], t = this.request.pathname();
            return "s3" !== this.serviceName && "s3v4" !== this.signatureVersion && (t = n.util.uriEscapePath(t)), e.push(this.request.method), e.push(t), e.push(this.request.search()), e.push(this.canonicalHeaders() + "\n"), e.push(this.signedHeaders()), e.push(this.hexEncodedBodyHash()), e.join("\n")
        },
        canonicalHeaders: function () {
            var e = [];
            n.util.each.call(this, this.request.headers, function (t, r) {
                e.push([t, r])
            }), e.sort(function (e, t) {
                return e[0].toLowerCase() < t[0].toLowerCase() ? -1 : 1
            });
            var t = [];
            return n.util.arrayEach.call(this, e, function (e) {
                var r = e[0].toLowerCase();
                if (this.isSignableHeader(r)) {
                    var i = e[1];
                    if (void 0 === i || null === i || "function" != typeof i.toString) throw n.util.error(new Error("Header " + r + " contains invalid value"), {code: "InvalidHeader"});
                    t.push(r + ":" + this.canonicalHeaderValues(i.toString()))
                }
            }), t.join("\n")
        },
        canonicalHeaderValues: function (e) {
            return e.replace(/\s+/g, " ").replace(/^\s+|\s+$/g, "")
        },
        signedHeaders: function () {
            var e = [];
            return n.util.each.call(this, this.request.headers, function (t) {
                t = t.toLowerCase(), this.isSignableHeader(t) && e.push(t)
            }), e.sort().join(";")
        },
        credentialString: function (e) {
            return i.createScope(e.substr(0, 8), this.request.region, this.serviceName)
        },
        hexEncodedHash: function (e) {
            return n.util.crypto.sha256(e, "hex")
        },
        hexEncodedBodyHash: function () {
            var e = this.request;
            return this.isPresigned() && "s3" === this.serviceName && !e.body ? "UNSIGNED-PAYLOAD" : e.headers["X-Amz-Content-Sha256"] ? e.headers["X-Amz-Content-Sha256"] : this.hexEncodedHash(this.request.body || "")
        },
        unsignableHeaders: ["authorization", "content-type", "content-length", "user-agent", "presigned-expires", "expect", "x-amzn-trace-id"],
        isSignableHeader: function (e) {
            return 0 === e.toLowerCase().indexOf("x-amz-") || this.unsignableHeaders.indexOf(e) < 0
        },
        isPresigned: function () {
            return !!this.request.headers["presigned-expires"]
        }
    }), e.exports = n.Signers.V4
}, function (e, t, r) {
    var n = r(9), i = {}, o = [], s = "aws4_request";
    e.exports = {
        createScope: function (e, t, r) {
            return [e.substr(0, 8), t, r, s].join("/")
        }, getSigningKey: function (e, t, r, a, c) {
            var u = [n.util.crypto.hmac(e.secretAccessKey, e.accessKeyId, "base64"), t, r, a].join("_");
            if ((c = !1 !== c) && u in i) return i[u];
            var d = n.util.crypto.hmac("AWS4" + e.secretAccessKey, t, "buffer"), l = n.util.crypto.hmac(d, r, "buffer"),
                h = n.util.crypto.hmac(l, a, "buffer"), p = n.util.crypto.hmac(h, s, "buffer");
            return c && (i[u] = p, o.push(u), o.length > 50 && delete i[o.shift()]), p
        }, emptyCache: function () {
            i = {}, o = []
        }
    }
}, function (e, t, r) {
    var n = r(9), i = n.util.inherit;
    n.Signers.S3 = i(n.Signers.RequestSigner, {
        subResources: {
            acl: 1,
            accelerate: 1,
            analytics: 1,
            cors: 1,
            lifecycle: 1,
            delete: 1,
            inventory: 1,
            location: 1,
            logging: 1,
            metrics: 1,
            notification: 1,
            partNumber: 1,
            policy: 1,
            requestPayment: 1,
            replication: 1,
            restore: 1,
            tagging: 1,
            torrent: 1,
            uploadId: 1,
            uploads: 1,
            versionId: 1,
            versioning: 1,
            versions: 1,
            website: 1
        },
        responseHeaders: {
            "response-content-type": 1,
            "response-content-language": 1,
            "response-expires": 1,
            "response-cache-control": 1,
            "response-content-disposition": 1,
            "response-content-encoding": 1
        },
        addAuthorization: function (e, t) {
            this.request.headers["presigned-expires"] || (this.request.headers["X-Amz-Date"] = n.util.date.rfc822(t)), e.sessionToken && (this.request.headers["x-amz-security-token"] = e.sessionToken);
            var r = this.sign(e.secretAccessKey, this.stringToSign()), i = "AWS " + e.accessKeyId + ":" + r;
            this.request.headers.Authorization = i
        },
        stringToSign: function () {
            var e = this.request, t = [];
            t.push(e.method), t.push(e.headers["Content-MD5"] || ""), t.push(e.headers["Content-Type"] || ""), t.push(e.headers["presigned-expires"] || "");
            var r = this.canonicalizedAmzHeaders();
            return r && t.push(r), t.push(this.canonicalizedResource()), t.join("\n")
        },
        canonicalizedAmzHeaders: function () {
            var e = [];
            n.util.each(this.request.headers, function (t) {
                t.match(/^x-amz-/i) && e.push(t)
            }), e.sort(function (e, t) {
                return e.toLowerCase() < t.toLowerCase() ? -1 : 1
            });
            var t = [];
            return n.util.arrayEach.call(this, e, function (e) {
                t.push(e.toLowerCase() + ":" + String(this.request.headers[e]))
            }), t.join("\n")
        },
        canonicalizedResource: function () {
            var e = this.request, t = e.path.split("?"), r = t[0], i = t[1], o = "";
            if (e.virtualHostedBucket && (o += "/" + e.virtualHostedBucket), o += r, i) {
                var s = [];
                n.util.arrayEach.call(this, i.split("&"), function (e) {
                    var t = e.split("=")[0], r = e.split("=")[1];
                    if (this.subResources[t] || this.responseHeaders[t]) {
                        var n = {name: t};
                        void 0 !== r && (this.subResources[t] ? n.value = r : n.value = decodeURIComponent(r)), s.push(n)
                    }
                }), s.sort(function (e, t) {
                    return e.name < t.name ? -1 : 1
                }), s.length && (i = [], n.util.arrayEach(s, function (e) {
                    void 0 === e.value ? i.push(e.name) : i.push(e.name + "=" + e.value)
                }), o += "?" + i.join("&"))
            }
            return o
        },
        sign: function (e, t) {
            return n.util.crypto.hmac(e, t, "base64", "sha1")
        }
    }), e.exports = n.Signers.S3
}, function (e, t, r) {
    var n = r(9), i = n.util.inherit, o = "presigned-expires";

    function s(e) {
        var t = e.httpRequest.headers[o], r = e.service.getSignerClass(e);
        if (delete e.httpRequest.headers["User-Agent"], delete e.httpRequest.headers["X-Amz-User-Agent"], r === n.Signers.V4) {
            if (t > 604800) {
                throw n.util.error(new Error, {
                    code: "InvalidExpiryTime",
                    message: "Presigning does not support expiry time greater than a week with SigV4 signing.",
                    retryable: !1
                })
            }
            e.httpRequest.headers[o] = t
        } else {
            if (r !== n.Signers.S3) throw n.util.error(new Error, {
                message: "Presigning only supports S3 or SigV4 signing.",
                code: "UnsupportedSigner",
                retryable: !1
            });
            var i = e.service ? e.service.getSkewCorrectedDate() : n.util.date.getDate();
            e.httpRequest.headers[o] = parseInt(n.util.date.unixTimestamp(i) + t, 10).toString()
        }
    }

    function a(e) {
        var t = e.httpRequest.endpoint, r = n.util.urlParse(e.httpRequest.path), i = {};
        r.search && (i = n.util.queryStringParse(r.search.substr(1)));
        var s = e.httpRequest.headers.Authorization.split(" ");
        if ("AWS" === s[0]) s = s[1].split(":"), i.Signature = s.pop(), i.AWSAccessKeyId = s.join(":"), n.util.each(e.httpRequest.headers, function (e, t) {
            e === o && (e = "Expires"), 0 === e.indexOf("x-amz-meta-") && (delete i[e], e = e.toLowerCase()), i[e] = t
        }), delete e.httpRequest.headers[o], delete i.Authorization, delete i.Host; else if ("AWS4-HMAC-SHA256" === s[0]) {
            s.shift();
            var a = s.join(" ").match(/Signature=(.*?)(?:,|\s|\r?\n|$)/)[1];
            i["X-Amz-Signature"] = a, delete i.Expires
        }
        t.pathname = r.pathname, t.search = n.util.queryParamsToString(i)
    }

    n.Signers.Presign = i({
        sign: function (e, t, r) {
            if (e.httpRequest.headers[o] = t || 3600, e.on("build", s), e.on("sign", a), e.removeListener("afterBuild", n.EventListeners.Core.SET_CONTENT_LENGTH), e.removeListener("afterBuild", n.EventListeners.Core.COMPUTE_SHA256), e.emit("beforePresign", [e]), !r) {
                if (e.build(), e.response.error) throw e.response.error;
                return n.util.urlFormat(e.httpRequest.endpoint)
            }
            e.build(function () {
                this.response.error ? r(this.response.error) : r(null, n.util.urlFormat(e.httpRequest.endpoint))
            })
        }
    }), e.exports = n.Signers.Presign
}, function (e, t, r) {
    var n = r(9);
    n.ParamValidator = n.util.inherit({
        constructor: function (e) {
            !0 !== e && void 0 !== e || (e = {min: !0}), this.validation = e
        }, validate: function (e, t, r) {
            if (this.errors = [], this.validateMember(e, t || {}, r || "params"), this.errors.length > 1) {
                var i = this.errors.join("\n* ");
                throw i = "There were " + this.errors.length + " validation errors:\n* " + i, n.util.error(new Error(i), {
                    code: "MultipleValidationErrors",
                    errors: this.errors
                })
            }
            if (1 === this.errors.length) throw this.errors[0];
            return !0
        }, fail: function (e, t) {
            this.errors.push(n.util.error(new Error(t), {code: e}))
        }, validateStructure: function (e, t, r) {
            var n;
            this.validateType(t, r, ["object"], "structure");
            for (var i = 0; e.required && i < e.required.length; i++) {
                var o = t[n = e.required[i]];
                void 0 !== o && null !== o || this.fail("MissingRequiredParameter", "Missing required key '" + n + "' in " + r)
            }
            for (n in t) if (Object.prototype.hasOwnProperty.call(t, n)) {
                var s = t[n], a = e.members[n];
                if (void 0 !== a) {
                    var c = [r, n].join(".");
                    this.validateMember(a, s, c)
                } else this.fail("UnexpectedParameter", "Unexpected key '" + n + "' found in " + r)
            }
            return !0
        }, validateMember: function (e, t, r) {
            switch (e.type) {
                case"structure":
                    return this.validateStructure(e, t, r);
                case"list":
                    return this.validateList(e, t, r);
                case"map":
                    return this.validateMap(e, t, r);
                default:
                    return this.validateScalar(e, t, r)
            }
        }, validateList: function (e, t, r) {
            if (this.validateType(t, r, [Array])) {
                this.validateRange(e, t.length, r, "list member count");
                for (var n = 0; n < t.length; n++) this.validateMember(e.member, t[n], r + "[" + n + "]")
            }
        }, validateMap: function (e, t, r) {
            if (this.validateType(t, r, ["object"], "map")) {
                var n = 0;
                for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (this.validateMember(e.key, i, r + "[key='" + i + "']"), this.validateMember(e.value, t[i], r + "['" + i + "']"), n++);
                this.validateRange(e, n, r, "map member count")
            }
        }, validateScalar: function (e, t, r) {
            switch (e.type) {
                case null:
                case void 0:
                case"string":
                    return this.validateString(e, t, r);
                case"base64":
                case"binary":
                    return this.validatePayload(t, r);
                case"integer":
                case"float":
                    return this.validateNumber(e, t, r);
                case"boolean":
                    return this.validateType(t, r, ["boolean"]);
                case"timestamp":
                    return this.validateType(t, r, [Date, /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?Z$/, "number"], "Date object, ISO-8601 string, or a UNIX timestamp");
                default:
                    return this.fail("UnkownType", "Unhandled type " + e.type + " for " + r)
            }
        }, validateString: function (e, t, r) {
            var n = ["string"];
            e.isJsonValue && (n = n.concat(["number", "object", "boolean"])), null !== t && this.validateType(t, r, n) && (this.validateEnum(e, t, r), this.validateRange(e, t.length, r, "string length"), this.validatePattern(e, t, r), this.validateUri(e, t, r))
        }, validateUri: function (e, t, r) {
            "uri" === e.location && 0 === t.length && this.fail("UriParameterError", 'Expected uri parameter to have length >= 1, but found "' + t + '" for ' + r)
        }, validatePattern: function (e, t, r) {
            this.validation.pattern && void 0 !== e.pattern && (new RegExp(e.pattern).test(t) || this.fail("PatternMatchError", 'Provided value "' + t + '" does not match regex pattern /' + e.pattern + "/ for " + r))
        }, validateRange: function (e, t, r, n) {
            this.validation.min && void 0 !== e.min && t < e.min && this.fail("MinRangeError", "Expected " + n + " >= " + e.min + ", but found " + t + " for " + r), this.validation.max && void 0 !== e.max && t > e.max && this.fail("MaxRangeError", "Expected " + n + " <= " + e.max + ", but found " + t + " for " + r)
        }, validateEnum: function (e, t, r) {
            this.validation.enum && void 0 !== e.enum && -1 === e.enum.indexOf(t) && this.fail("EnumError", "Found string value of " + t + ", but expected " + e.enum.join("|") + " for " + r)
        }, validateType: function (e, t, r, i) {
            if (null === e || void 0 === e) return !1;
            for (var o = !1, s = 0; s < r.length; s++) {
                if ("string" == typeof r[s]) {
                    if (typeof e === r[s]) return !0
                } else if (r[s] instanceof RegExp) {
                    if ((e || "").toString().match(r[s])) return !0
                } else {
                    if (e instanceof r[s]) return !0;
                    if (n.util.isType(e, r[s])) return !0;
                    i || o || (r = r.slice()), r[s] = n.util.typeName(r[s])
                }
                o = !0
            }
            var a = i;
            a || (a = r.join(", ").replace(/,([^,]+)$/, ", or$1"));
            var c = a.match(/^[aeiou]/i) ? "n" : "";
            return this.fail("InvalidParameterType", "Expected " + t + " to be a" + c + " " + a), !1
        }, validateNumber: function (e, t, r) {
            if (null !== t && void 0 !== t) {
                if ("string" == typeof t) {
                    var n = parseFloat(t);
                    n.toString() === t && (t = n)
                }
                this.validateType(t, r, ["number"]) && this.validateRange(e, t, r, "numeric value")
            }
        }, validatePayload: function (e, t) {
            if (null !== e && void 0 !== e && "string" != typeof e && (!e || "number" != typeof e.byteLength)) {
                if (n.util.isNode()) {
                    var r = n.util.stream.Stream;
                    if (n.util.Buffer.isBuffer(e) || e instanceof r) return
                } else if (void 0 !== typeof Blob && e instanceof Blob) return;
                var i = ["Buffer", "Stream", "File", "Blob", "ArrayBuffer", "DataView"];
                if (e) for (var o = 0; o < i.length; o++) {
                    if (n.util.isType(e, i[o])) return;
                    if (n.util.typeName(e.constructor) === i[o]) return
                }
                this.fail("InvalidParameterType", "Expected " + t + " to be a string, Buffer, Stream, Blob, or typed array object")
            }
        }
    })
}, function (e, t, r) {
    var n = r(247), i = r(250), o = r(251), s = r(252);
    e.exports = {
        createHash: function (e) {
            if ("md5" === (e = e.toLowerCase())) return new i;
            if ("sha256" === e) return new s;
            if ("sha1" === e) return new o;
            throw new Error("Hash algorithm " + e + " is not supported in the browser SDK")
        }, createHmac: function (e, t) {
            if ("md5" === (e = e.toLowerCase())) return new n(i, t);
            if ("sha256" === e) return new n(s, t);
            if ("sha1" === e) return new n(o, t);
            throw new Error("HMAC algorithm " + e + " is not supported in the browser SDK")
        }, createSign: function () {
            throw new Error("createSign is not implemented in the browser")
        }
    }
}, function (e, t, r) {
    var n = r(55);

    function i(e, t) {
        this.hash = new e, this.outer = new e;
        var r = function (e, t) {
            var r = n.convertToBuffer(t);
            if (r.byteLength > e.BLOCK_SIZE) {
                var i = new e;
                i.update(r), r = i.digest()
            }
            var o = new Uint8Array(e.BLOCK_SIZE);
            return o.set(r), o
        }(e, t), i = new Uint8Array(e.BLOCK_SIZE);
        i.set(r);
        for (var o = 0; o < e.BLOCK_SIZE; o++) r[o] ^= 54, i[o] ^= 92;
        this.hash.update(r), this.outer.update(i);
        for (o = 0; o < r.byteLength; o++) r[o] = 0
    }

    e.exports = i, i.prototype.update = function (e) {
        if (n.isEmptyData(e) || this.error) return this;
        try {
            this.hash.update(n.convertToBuffer(e))
        } catch (e) {
            this.error = e
        }
        return this
    }, i.prototype.digest = function (e) {
        return this.outer.finished || this.outer.update(this.hash.digest()), this.outer.digest(e)
    }
}, function (e, t, r) {
    "use strict";
    t.byteLength = function (e) {
        var t = u(e), r = t[0], n = t[1];
        return 3 * (r + n) / 4 - n
    }, t.toByteArray = function (e) {
        var t, r, n = u(e), s = n[0], a = n[1], c = new o(function (e, t, r) {
            return 3 * (t + r) / 4 - r
        }(0, s, a)), d = 0, l = a > 0 ? s - 4 : s;
        for (r = 0; r < l; r += 4) t = i[e.charCodeAt(r)] << 18 | i[e.charCodeAt(r + 1)] << 12 | i[e.charCodeAt(r + 2)] << 6 | i[e.charCodeAt(r + 3)], c[d++] = t >> 16 & 255, c[d++] = t >> 8 & 255, c[d++] = 255 & t;
        2 === a && (t = i[e.charCodeAt(r)] << 2 | i[e.charCodeAt(r + 1)] >> 4, c[d++] = 255 & t);
        1 === a && (t = i[e.charCodeAt(r)] << 10 | i[e.charCodeAt(r + 1)] << 4 | i[e.charCodeAt(r + 2)] >> 2, c[d++] = t >> 8 & 255, c[d++] = 255 & t);
        return c
    }, t.fromByteArray = function (e) {
        for (var t, r = e.length, i = r % 3, o = [], s = 0, a = r - i; s < a; s += 16383) o.push(l(e, s, s + 16383 > a ? a : s + 16383));
        1 === i ? (t = e[r - 1], o.push(n[t >> 2] + n[t << 4 & 63] + "==")) : 2 === i && (t = (e[r - 2] << 8) + e[r - 1], o.push(n[t >> 10] + n[t >> 4 & 63] + n[t << 2 & 63] + "="));
        return o.join("")
    };
    for (var n = [], i = [], o = "undefined" != typeof Uint8Array ? Uint8Array : Array, s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", a = 0, c = s.length; a < c; ++a) n[a] = s[a], i[s.charCodeAt(a)] = a;

    function u(e) {
        var t = e.length;
        if (t % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
        var r = e.indexOf("=");
        return -1 === r && (r = t), [r, r === t ? 0 : 4 - r % 4]
    }

    function d(e) {
        return n[e >> 18 & 63] + n[e >> 12 & 63] + n[e >> 6 & 63] + n[63 & e]
    }

    function l(e, t, r) {
        for (var n, i = [], o = t; o < r; o += 3) n = (e[o] << 16 & 16711680) + (e[o + 1] << 8 & 65280) + (255 & e[o + 2]), i.push(d(n));
        return i.join("")
    }

    i["-".charCodeAt(0)] = 62, i["_".charCodeAt(0)] = 63
}, function (e, t) {
    t.read = function (e, t, r, n, i) {
        var o, s, a = 8 * i - n - 1, c = (1 << a) - 1, u = c >> 1, d = -7, l = r ? i - 1 : 0, h = r ? -1 : 1,
            p = e[t + l];
        for (l += h, o = p & (1 << -d) - 1, p >>= -d, d += a; d > 0; o = 256 * o + e[t + l], l += h, d -= 8) ;
        for (s = o & (1 << -d) - 1, o >>= -d, d += n; d > 0; s = 256 * s + e[t + l], l += h, d -= 8) ;
        if (0 === o) o = 1 - u; else {
            if (o === c) return s ? NaN : 1 / 0 * (p ? -1 : 1);
            s += Math.pow(2, n), o -= u
        }
        return (p ? -1 : 1) * s * Math.pow(2, o - n)
    }, t.write = function (e, t, r, n, i, o) {
        var s, a, c, u = 8 * o - i - 1, d = (1 << u) - 1, l = d >> 1,
            h = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0, p = n ? 0 : o - 1, f = n ? 1 : -1,
            m = t < 0 || 0 === t && 1 / t < 0 ? 1 : 0;
        for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (a = isNaN(t) ? 1 : 0, s = d) : (s = Math.floor(Math.log(t) / Math.LN2), t * (c = Math.pow(2, -s)) < 1 && (s--, c *= 2), (t += s + l >= 1 ? h / c : h * Math.pow(2, 1 - l)) * c >= 2 && (s++, c /= 2), s + l >= d ? (a = 0, s = d) : s + l >= 1 ? (a = (t * c - 1) * Math.pow(2, i), s += l) : (a = t * Math.pow(2, l - 1) * Math.pow(2, i), s = 0)); i >= 8; e[r + p] = 255 & a, p += f, a /= 256, i -= 8) ;
        for (s = s << i | a, u += i; u > 0; e[r + p] = 255 & s, p += f, s /= 256, u -= 8) ;
        e[r + p - f] |= 128 * m
    }
}, function (e, t, r) {
    var n = r(55), i = r(22).Buffer, o = 64;

    function s() {
        this.state = [1732584193, 4023233417, 2562383102, 271733878], this.buffer = new DataView(new ArrayBuffer(o)), this.bufferLength = 0, this.bytesHashed = 0, this.finished = !1
    }

    function a(e, t, r, n, i, o) {
        return ((t = (t + e & 4294967295) + (n + o & 4294967295) & 4294967295) << i | t >>> 32 - i) + r & 4294967295
    }

    function c(e, t, r, n, i, o, s) {
        return a(t & r | ~t & n, e, t, i, o, s)
    }

    function u(e, t, r, n, i, o, s) {
        return a(t & n | r & ~n, e, t, i, o, s)
    }

    function d(e, t, r, n, i, o, s) {
        return a(t ^ r ^ n, e, t, i, o, s)
    }

    function l(e, t, r, n, i, o, s) {
        return a(r ^ (t | ~n), e, t, i, o, s)
    }

    e.exports = s, s.BLOCK_SIZE = o, s.prototype.update = function (e) {
        if (n.isEmptyData(e)) return this;
        if (this.finished) throw new Error("Attempted to update an already finished hash.");
        var t = n.convertToBuffer(e), r = 0, i = t.byteLength;
        for (this.bytesHashed += i; i > 0;) this.buffer.setUint8(this.bufferLength++, t[r++]), i--, this.bufferLength === o && (this.hashBuffer(), this.bufferLength = 0);
        return this
    }, s.prototype.digest = function (e) {
        if (!this.finished) {
            var t = this.buffer, r = this.bufferLength, n = 8 * this.bytesHashed;
            if (t.setUint8(this.bufferLength++, 128), r % o >= o - 8) {
                for (var s = this.bufferLength; s < o; s++) t.setUint8(s, 0);
                this.hashBuffer(), this.bufferLength = 0
            }
            for (s = this.bufferLength; s < o - 8; s++) t.setUint8(s, 0);
            t.setUint32(o - 8, n >>> 0, !0), t.setUint32(o - 4, Math.floor(n / 4294967296), !0), this.hashBuffer(), this.finished = !0
        }
        var a = new DataView(new ArrayBuffer(16));
        for (s = 0; s < 4; s++) a.setUint32(4 * s, this.state[s], !0);
        var c = new i(a.buffer, a.byteOffset, a.byteLength);
        return e ? c.toString(e) : c
    }, s.prototype.hashBuffer = function () {
        var e = this.buffer, t = this.state, r = t[0], n = t[1], i = t[2], o = t[3];
        n = l(n = l(n = l(n = l(n = d(n = d(n = d(n = d(n = u(n = u(n = u(n = u(n = c(n = c(n = c(n = c(n, i = c(i, o = c(o, r = c(r, n, i, o, e.getUint32(0, !0), 7, 3614090360), n, i, e.getUint32(4, !0), 12, 3905402710), r, n, e.getUint32(8, !0), 17, 606105819), o, r, e.getUint32(12, !0), 22, 3250441966), i = c(i, o = c(o, r = c(r, n, i, o, e.getUint32(16, !0), 7, 4118548399), n, i, e.getUint32(20, !0), 12, 1200080426), r, n, e.getUint32(24, !0), 17, 2821735955), o, r, e.getUint32(28, !0), 22, 4249261313), i = c(i, o = c(o, r = c(r, n, i, o, e.getUint32(32, !0), 7, 1770035416), n, i, e.getUint32(36, !0), 12, 2336552879), r, n, e.getUint32(40, !0), 17, 4294925233), o, r, e.getUint32(44, !0), 22, 2304563134), i = c(i, o = c(o, r = c(r, n, i, o, e.getUint32(48, !0), 7, 1804603682), n, i, e.getUint32(52, !0), 12, 4254626195), r, n, e.getUint32(56, !0), 17, 2792965006), o, r, e.getUint32(60, !0), 22, 1236535329), i = u(i, o = u(o, r = u(r, n, i, o, e.getUint32(4, !0), 5, 4129170786), n, i, e.getUint32(24, !0), 9, 3225465664), r, n, e.getUint32(44, !0), 14, 643717713), o, r, e.getUint32(0, !0), 20, 3921069994), i = u(i, o = u(o, r = u(r, n, i, o, e.getUint32(20, !0), 5, 3593408605), n, i, e.getUint32(40, !0), 9, 38016083), r, n, e.getUint32(60, !0), 14, 3634488961), o, r, e.getUint32(16, !0), 20, 3889429448), i = u(i, o = u(o, r = u(r, n, i, o, e.getUint32(36, !0), 5, 568446438), n, i, e.getUint32(56, !0), 9, 3275163606), r, n, e.getUint32(12, !0), 14, 4107603335), o, r, e.getUint32(32, !0), 20, 1163531501), i = u(i, o = u(o, r = u(r, n, i, o, e.getUint32(52, !0), 5, 2850285829), n, i, e.getUint32(8, !0), 9, 4243563512), r, n, e.getUint32(28, !0), 14, 1735328473), o, r, e.getUint32(48, !0), 20, 2368359562), i = d(i, o = d(o, r = d(r, n, i, o, e.getUint32(20, !0), 4, 4294588738), n, i, e.getUint32(32, !0), 11, 2272392833), r, n, e.getUint32(44, !0), 16, 1839030562), o, r, e.getUint32(56, !0), 23, 4259657740), i = d(i, o = d(o, r = d(r, n, i, o, e.getUint32(4, !0), 4, 2763975236), n, i, e.getUint32(16, !0), 11, 1272893353), r, n, e.getUint32(28, !0), 16, 4139469664), o, r, e.getUint32(40, !0), 23, 3200236656), i = d(i, o = d(o, r = d(r, n, i, o, e.getUint32(52, !0), 4, 681279174), n, i, e.getUint32(0, !0), 11, 3936430074), r, n, e.getUint32(12, !0), 16, 3572445317), o, r, e.getUint32(24, !0), 23, 76029189), i = d(i, o = d(o, r = d(r, n, i, o, e.getUint32(36, !0), 4, 3654602809), n, i, e.getUint32(48, !0), 11, 3873151461), r, n, e.getUint32(60, !0), 16, 530742520), o, r, e.getUint32(8, !0), 23, 3299628645), i = l(i, o = l(o, r = l(r, n, i, o, e.getUint32(0, !0), 6, 4096336452), n, i, e.getUint32(28, !0), 10, 1126891415), r, n, e.getUint32(56, !0), 15, 2878612391), o, r, e.getUint32(20, !0), 21, 4237533241), i = l(i, o = l(o, r = l(r, n, i, o, e.getUint32(48, !0), 6, 1700485571), n, i, e.getUint32(12, !0), 10, 2399980690), r, n, e.getUint32(40, !0), 15, 4293915773), o, r, e.getUint32(4, !0), 21, 2240044497), i = l(i, o = l(o, r = l(r, n, i, o, e.getUint32(32, !0), 6, 1873313359), n, i, e.getUint32(60, !0), 10, 4264355552), r, n, e.getUint32(24, !0), 15, 2734768916), o, r, e.getUint32(52, !0), 21, 1309151649), i = l(i, o = l(o, r = l(r, n, i, o, e.getUint32(16, !0), 6, 4149444226), n, i, e.getUint32(44, !0), 10, 3174756917), r, n, e.getUint32(8, !0), 15, 718787259), o, r, e.getUint32(36, !0), 21, 3951481745), t[0] = r + t[0] & 4294967295, t[1] = n + t[1] & 4294967295, t[2] = i + t[2] & 4294967295, t[3] = o + t[3] & 4294967295
    }
}, function (e, t, r) {
    var n = r(22).Buffer, i = r(55);
    new Uint32Array([1518500249, 1859775393, -1894007588, -899497514]), Math.pow(2, 53);

    function o() {
        this.h0 = 1732584193, this.h1 = 4023233417, this.h2 = 2562383102, this.h3 = 271733878, this.h4 = 3285377520, this.block = new Uint32Array(80), this.offset = 0, this.shift = 24, this.totalLength = 0
    }

    e.exports = o, o.BLOCK_SIZE = 64, o.prototype.update = function (e) {
        if (this.finished) throw new Error("Attempted to update an already finished hash.");
        if (i.isEmptyData(e)) return this;
        var t = (e = i.convertToBuffer(e)).length;
        this.totalLength += 8 * t;
        for (var r = 0; r < t; r++) this.write(e[r]);
        return this
    }, o.prototype.write = function (e) {
        this.block[this.offset] |= (255 & e) << this.shift, this.shift ? this.shift -= 8 : (this.offset++, this.shift = 24), 16 === this.offset && this.processBlock()
    }, o.prototype.digest = function (e) {
        this.write(128), (this.offset > 14 || 14 === this.offset && this.shift < 24) && this.processBlock(), this.offset = 14, this.shift = 24, this.write(0), this.write(0), this.write(this.totalLength > 0xffffffffff ? this.totalLength / 1099511627776 : 0), this.write(this.totalLength > 4294967295 ? this.totalLength / 4294967296 : 0);
        for (var t = 24; t >= 0; t -= 8) this.write(this.totalLength >> t);
        var r = new n(20), i = new DataView(r.buffer);
        return i.setUint32(0, this.h0, !1), i.setUint32(4, this.h1, !1), i.setUint32(8, this.h2, !1), i.setUint32(12, this.h3, !1), i.setUint32(16, this.h4, !1), e ? r.toString(e) : r
    }, o.prototype.processBlock = function () {
        for (var e = 16; e < 80; e++) {
            var t = this.block[e - 3] ^ this.block[e - 8] ^ this.block[e - 14] ^ this.block[e - 16];
            this.block[e] = t << 1 | t >>> 31
        }
        var r, n, i = this.h0, o = this.h1, s = this.h2, a = this.h3, c = this.h4;
        for (e = 0; e < 80; e++) {
            e < 20 ? (r = a ^ o & (s ^ a), n = 1518500249) : e < 40 ? (r = o ^ s ^ a, n = 1859775393) : e < 60 ? (r = o & s | a & (o | s), n = 2400959708) : (r = o ^ s ^ a, n = 3395469782);
            var u = (i << 5 | i >>> 27) + r + c + n + (0 | this.block[e]);
            c = a, a = s, s = o << 30 | o >>> 2, o = i, i = u
        }
        for (this.h0 = this.h0 + i | 0, this.h1 = this.h1 + o | 0, this.h2 = this.h2 + s | 0, this.h3 = this.h3 + a | 0, this.h4 = this.h4 + c | 0, this.offset = 0, e = 0; e < 16; e++) this.block[e] = 0
    }
}, function (e, t, r) {
    var n = r(22).Buffer, i = r(55),
        o = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]),
        s = Math.pow(2, 53) - 1;

    function a() {
        this.state = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.temp = new Int32Array(64), this.buffer = new Uint8Array(64), this.bufferLength = 0, this.bytesHashed = 0, this.finished = !1
    }

    e.exports = a, a.BLOCK_SIZE = 64, a.prototype.update = function (e) {
        if (this.finished) throw new Error("Attempted to update an already finished hash.");
        if (i.isEmptyData(e)) return this;
        var t = 0, r = (e = i.convertToBuffer(e)).byteLength;
        if (this.bytesHashed += r, 8 * this.bytesHashed > s) throw new Error("Cannot hash more than 2^53 - 1 bits");
        for (; r > 0;) this.buffer[this.bufferLength++] = e[t++], r--, 64 === this.bufferLength && (this.hashBuffer(), this.bufferLength = 0);
        return this
    }, a.prototype.digest = function (e) {
        if (!this.finished) {
            var t = 8 * this.bytesHashed,
                r = new DataView(this.buffer.buffer, this.buffer.byteOffset, this.buffer.byteLength),
                i = this.bufferLength;
            if (r.setUint8(this.bufferLength++, 128), i % 64 >= 56) {
                for (var o = this.bufferLength; o < 64; o++) r.setUint8(o, 0);
                this.hashBuffer(), this.bufferLength = 0
            }
            for (o = this.bufferLength; o < 56; o++) r.setUint8(o, 0);
            r.setUint32(56, Math.floor(t / 4294967296), !0), r.setUint32(60, t), this.hashBuffer(), this.finished = !0
        }
        var s = new n(32);
        for (o = 0; o < 8; o++) s[4 * o] = this.state[o] >>> 24 & 255, s[4 * o + 1] = this.state[o] >>> 16 & 255, s[4 * o + 2] = this.state[o] >>> 8 & 255, s[4 * o + 3] = this.state[o] >>> 0 & 255;
        return e ? s.toString(e) : s
    }, a.prototype.hashBuffer = function () {
        for (var e = this.buffer, t = this.state, r = t[0], n = t[1], i = t[2], s = t[3], a = t[4], c = t[5], u = t[6], d = t[7], l = 0; l < 64; l++) {
            if (l < 16) this.temp[l] = (255 & e[4 * l]) << 24 | (255 & e[4 * l + 1]) << 16 | (255 & e[4 * l + 2]) << 8 | 255 & e[4 * l + 3]; else {
                var h = this.temp[l - 2], p = (h >>> 17 | h << 15) ^ (h >>> 19 | h << 13) ^ h >>> 10,
                    f = ((h = this.temp[l - 15]) >>> 7 | h << 25) ^ (h >>> 18 | h << 14) ^ h >>> 3;
                this.temp[l] = (p + this.temp[l - 7] | 0) + (f + this.temp[l - 16] | 0)
            }
            var m = (((a >>> 6 | a << 26) ^ (a >>> 11 | a << 21) ^ (a >>> 25 | a << 7)) + (a & c ^ ~a & u) | 0) + (d + (o[l] + this.temp[l] | 0) | 0) | 0,
                _ = ((r >>> 2 | r << 30) ^ (r >>> 13 | r << 19) ^ (r >>> 22 | r << 10)) + (r & n ^ r & i ^ n & i) | 0;
            d = u, u = c, c = a, a = s + m | 0, s = i, i = n, n = r, r = m + _ | 0
        }
        t[0] += r, t[1] += n, t[2] += i, t[3] += s, t[4] += a, t[5] += c, t[6] += u, t[7] += d
    }
}, function (e, t, r) {
    (function (e, n) {
        var i;/*! https://mths.be/punycode v1.4.1 by @mathias */
        !function (o) {
            t && t.nodeType, e && e.nodeType;
            var s = "object" == typeof n && n;
            s.global !== s && s.window !== s && s.self;
            var a, c = 2147483647, u = 36, d = 1, l = 26, h = 38, p = 700, f = 72, m = 128, _ = "-", v = /^xn--/,
                g = /[^\x20-\x7E]/, E = /[\x2E\u3002\uFF0E\uFF61]/g, y = {
                    overflow: "Overflow: input needs wider integers to process",
                    "not-basic": "Illegal input >= 0x80 (not a basic code point)",
                    "invalid-input": "Invalid input"
                }, S = u - d, b = Math.floor, T = String.fromCharCode;

            function R(e) {
                throw new RangeError(y[e])
            }

            function I(e, t) {
                for (var r = e.length, n = []; r--;) n[r] = t(e[r]);
                return n
            }

            function w(e, t) {
                var r = e.split("@"), n = "";
                return r.length > 1 && (n = r[0] + "@", e = r[1]), n + I((e = e.replace(E, ".")).split("."), t).join(".")
            }

            function C(e) {
                for (var t, r, n = [], i = 0, o = e.length; i < o;) (t = e.charCodeAt(i++)) >= 55296 && t <= 56319 && i < o ? 56320 == (64512 & (r = e.charCodeAt(i++))) ? n.push(((1023 & t) << 10) + (1023 & r) + 65536) : (n.push(t), i--) : n.push(t);
                return n
            }

            function A(e) {
                return I(e, function (e) {
                    var t = "";
                    return e > 65535 && (t += T((e -= 65536) >>> 10 & 1023 | 55296), e = 56320 | 1023 & e), t += T(e)
                }).join("")
            }

            function O(e) {
                return e - 48 < 10 ? e - 22 : e - 65 < 26 ? e - 65 : e - 97 < 26 ? e - 97 : u
            }

            function N(e, t) {
                return e + 22 + 75 * (e < 26) - ((0 != t) << 5)
            }

            function P(e, t, r) {
                var n = 0;
                for (e = r ? b(e / p) : e >> 1, e += b(e / t); e > S * l >> 1; n += u) e = b(e / S);
                return b(n + (S + 1) * e / (e + h))
            }

            function D(e) {
                var t, r, n, i, o, s, a, h, p, v, g = [], E = e.length, y = 0, S = m, T = f;
                for ((r = e.lastIndexOf(_)) < 0 && (r = 0), n = 0; n < r; ++n) e.charCodeAt(n) >= 128 && R("not-basic"), g.push(e.charCodeAt(n));
                for (i = r > 0 ? r + 1 : 0; i < E;) {
                    for (o = y, s = 1, a = u; i >= E && R("invalid-input"), ((h = O(e.charCodeAt(i++))) >= u || h > b((c - y) / s)) && R("overflow"), y += h * s, !(h < (p = a <= T ? d : a >= T + l ? l : a - T)); a += u) s > b(c / (v = u - p)) && R("overflow"), s *= v;
                    T = P(y - o, t = g.length + 1, 0 == o), b(y / t) > c - S && R("overflow"), S += b(y / t), y %= t, g.splice(y++, 0, S)
                }
                return A(g)
            }

            function k(e) {
                var t, r, n, i, o, s, a, h, p, v, g, E, y, S, I, w = [];
                for (E = (e = C(e)).length, t = m, r = 0, o = f, s = 0; s < E; ++s) (g = e[s]) < 128 && w.push(T(g));
                for (n = i = w.length, i && w.push(_); n < E;) {
                    for (a = c, s = 0; s < E; ++s) (g = e[s]) >= t && g < a && (a = g);
                    for (a - t > b((c - r) / (y = n + 1)) && R("overflow"), r += (a - t) * y, t = a, s = 0; s < E; ++s) if ((g = e[s]) < t && ++r > c && R("overflow"), g == t) {
                        for (h = r, p = u; !(h < (v = p <= o ? d : p >= o + l ? l : p - o)); p += u) I = h - v, S = u - v, w.push(T(N(v + I % S, 0))), h = b(I / S);
                        w.push(T(N(h, 0))), o = P(r, y, n == i), r = 0, ++n
                    }
                    ++r, ++t
                }
                return w.join("")
            }

            a = {
                version: "1.4.1", ucs2: {decode: C, encode: A}, decode: D, encode: k, toASCII: function (e) {
                    return w(e, function (e) {
                        return g.test(e) ? "xn--" + k(e) : e
                    })
                }, toUnicode: function (e) {
                    return w(e, function (e) {
                        return v.test(e) ? D(e.slice(4).toLowerCase()) : e
                    })
                }
            }, void 0 === (i = function () {
                return a
            }.call(t, r, t, e)) || (e.exports = i)
        }()
    }).call(this, r(254)(e), r(25))
}, function (e, t) {
    e.exports = function (e) {
        return e.webpackPolyfill || (e.deprecate = function () {
        }, e.paths = [], e.children || (e.children = []), Object.defineProperty(e, "loaded", {
            enumerable: !0,
            get: function () {
                return e.l
            }
        }), Object.defineProperty(e, "id", {
            enumerable: !0, get: function () {
                return e.i
            }
        }), e.webpackPolyfill = 1), e
    }
}, function (e, t, r) {
    "use strict";
    e.exports = {
        isString: function (e) {
            return "string" == typeof e
        }, isObject: function (e) {
            return "object" == typeof e && null !== e
        }, isNull: function (e) {
            return null === e
        }, isNullOrUndefined: function (e) {
            return null == e
        }
    }
}, function (e, t, r) {
    "use strict";

    function n(e, t) {
        return Object.prototype.hasOwnProperty.call(e, t)
    }

    e.exports = function (e, t, r, o) {
        t = t || "&", r = r || "=";
        var s = {};
        if ("string" != typeof e || 0 === e.length) return s;
        var a = /\+/g;
        e = e.split(t);
        var c = 1e3;
        o && "number" == typeof o.maxKeys && (c = o.maxKeys);
        var u = e.length;
        c > 0 && u > c && (u = c);
        for (var d = 0; d < u; ++d) {
            var l, h, p, f, m = e[d].replace(a, "%20"), _ = m.indexOf(r);
            _ >= 0 ? (l = m.substr(0, _), h = m.substr(_ + 1)) : (l = m, h = ""), p = decodeURIComponent(l), f = decodeURIComponent(h), n(s, p) ? i(s[p]) ? s[p].push(f) : s[p] = [s[p], f] : s[p] = f
        }
        return s
    };
    var i = Array.isArray || function (e) {
        return "[object Array]" === Object.prototype.toString.call(e)
    }
}, function (e, t, r) {
    "use strict";
    var n = function (e) {
        switch (typeof e) {
            case"string":
                return e;
            case"boolean":
                return e ? "true" : "false";
            case"number":
                return isFinite(e) ? e : "";
            default:
                return ""
        }
    };
    e.exports = function (e, t, r, a) {
        return t = t || "&", r = r || "=", null === e && (e = void 0), "object" == typeof e ? o(s(e), function (s) {
            var a = encodeURIComponent(n(s)) + r;
            return i(e[s]) ? o(e[s], function (e) {
                return a + encodeURIComponent(n(e))
            }).join(t) : a + encodeURIComponent(n(e[s]))
        }).join(t) : a ? encodeURIComponent(n(a)) + r + encodeURIComponent(n(e)) : ""
    };
    var i = Array.isArray || function (e) {
        return "[object Array]" === Object.prototype.toString.call(e)
    };

    function o(e, t) {
        if (e.map) return e.map(t);
        for (var r = [], n = 0; n < e.length; n++) r.push(t(e[n], n));
        return r
    }

    var s = Object.keys || function (e) {
        var t = [];
        for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.push(r);
        return t
    }
}, function (e, t) {
    e.exports = {
        now: function () {
            return "undefined" != typeof performance && "function" == typeof performance.now ? performance.now() : Date.now()
        }
    }
}, function (e, t, r) {
    var n = r(260).eventMessageChunker, i = r(261).parseEvent;
    e.exports = {
        createEventStream: function (e, t, r) {
            for (var o = n(e), s = [], a = 0; a < o.length; a++) s.push(i(t, o[a], r));
            return s
        }
    }
}, function (e, t) {
    e.exports = {
        eventMessageChunker: function (e) {
            for (var t = [], r = 0; r < e.length;) {
                var n = e.readInt32BE(r), i = e.slice(r, n + r);
                r += n, t.push(i)
            }
            return t
        }
    }
}, function (e, t, r) {
    var n = r(262).parseMessage;
    e.exports = {
        parseEvent: function (e, t, r) {
            var i = n(t), o = i.headers[":message-type"];
            if (o) {
                if ("error" === o.value) throw function (e) {
                    var t = e.headers[":error-code"], r = e.headers[":error-message"], n = new Error(r.value || r);
                    return n.code = n.name = t.value || t, n
                }(i);
                if ("event" !== o.value) return
            }
            var s = i.headers[":event-type"], a = r.members[s.value];
            if (a) {
                var c = {}, u = a.eventPayloadMemberName;
                if (u) {
                    var d = a.members[u];
                    "binary" === d.type ? c[u] = i.body : c[u] = e.parse(i.body.toString(), d)
                }
                for (var l = a.eventHeaderMemberNames, h = 0; h < l.length; h++) {
                    var p = l[h];
                    i.headers[p] && (c[p] = a.members[p].toType(i.headers[p].value))
                }
                var f = {};
                return f[s.value] = c, f
            }
        }
    }
}, function (e, t, r) {
    var n = r(263).Int64, i = r(264).splitMessage, o = "boolean", s = "byte", a = "short", c = "integer", u = "long",
        d = "binary", l = "string", h = "timestamp", p = "uuid";
    e.exports = {
        parseMessage: function (e) {
            var t = i(e);
            return {
                headers: function (e) {
                    for (var t = {}, r = 0; r < e.length;) {
                        var i = e.readUInt8(r++), f = e.slice(r, r + i).toString();
                        switch (r += i, e.readUInt8(r++)) {
                            case 0:
                                t[f] = {type: o, value: !0};
                                break;
                            case 1:
                                t[f] = {type: o, value: !1};
                                break;
                            case 2:
                                t[f] = {type: s, value: e.readInt8(r++)};
                                break;
                            case 3:
                                t[f] = {type: a, value: e.readInt16BE(r)}, r += 2;
                                break;
                            case 4:
                                t[f] = {type: c, value: e.readInt32BE(r)}, r += 4;
                                break;
                            case 5:
                                t[f] = {type: u, value: new n(e.slice(r, r + 8))}, r += 8;
                                break;
                            case 6:
                                var m = e.readUInt16BE(r);
                                r += 2, t[f] = {type: d, value: e.slice(r, r + m)}, r += m;
                                break;
                            case 7:
                                var _ = e.readUInt16BE(r);
                                r += 2, t[f] = {type: l, value: e.slice(r, r + _).toString()}, r += _;
                                break;
                            case 8:
                                t[f] = {type: h, value: new Date(new n(e.slice(r, r + 8)).valueOf())}, r += 8;
                                break;
                            case 9:
                                var v = e.slice(r, r + 16).toString("hex");
                                r += 16, t[f] = {
                                    type: p,
                                    value: v.substr(0, 8) + "-" + v.substr(8, 4) + "-" + v.substr(12, 4) + "-" + v.substr(16, 4) + "-" + v.substr(20)
                                };
                                break;
                            default:
                                throw new Error("Unrecognized header type tag")
                        }
                    }
                    return t
                }(t.headers), body: t.body
            }
        }
    }
}, function (e, t, r) {
    var n = r(9).util, i = n.buffer.toBuffer;

    function o(e) {
        if (8 !== e.length) throw new Error("Int64 buffers must be exactly 8 bytes");
        n.Buffer.isBuffer(e) || (e = i(e)), this.bytes = e
    }

    function s(e) {
        for (var t = 0; t < 8; t++) e[t] ^= 255;
        for (t = 7; t > -1 && (e[t]++, 0 === e[t]); t--) ;
    }

    o.fromNumber = function (e) {
        if (e > 0x8000000000000000 || e < -0x8000000000000000) throw new Error(e + " is too large (or, if negative, too small) to represent as an Int64");
        for (var t = new Uint8Array(8), r = 7, n = Math.abs(Math.round(e)); r > -1 && n > 0; r--, n /= 256) t[r] = n;
        return e < 0 && s(t), new o(t)
    }, o.prototype.valueOf = function () {
        var e = this.bytes.slice(0), t = 128 & e[0];
        return t && s(e), parseInt(e.toString("hex"), 16) * (t ? -1 : 1)
    }, o.prototype.toString = function () {
        return String(this.valueOf())
    }, e.exports = {Int64: o}
}, function (e, t, r) {
    var n = r(9).util, i = n.buffer.toBuffer, o = 4, s = 2 * o, a = 4, c = s + 2 * a;
    e.exports = {
        splitMessage: function (e) {
            if (n.Buffer.isBuffer(e) || (e = i(e)), e.length < c) throw new Error("Provided message too short to accommodate event stream message overhead");
            if (e.length !== e.readUInt32BE(0)) throw new Error("Reported message length does not match received message length");
            var t = e.readUInt32BE(s);
            if (t !== n.crypto.crc32(e.slice(0, s))) throw new Error("The prelude checksum specified in the message (" + t + ") does not match the calculated CRC32 checksum.");
            var r = e.readUInt32BE(e.length - a);
            if (r !== n.crypto.crc32(e.slice(0, e.length - a))) throw new Error("The message checksum did not match the expected value of " + r);
            var u = s + a, d = u + e.readUInt32BE(o);
            return {headers: e.slice(u, d), body: e.slice(d, e.length - a)}
        }
    }
}, function (e, t, r) {
    var n = r(9), i = r(51);
    n.TemporaryCredentials = n.util.inherit(n.Credentials, {
        constructor: function (e, t) {
            n.Credentials.call(this), this.loadMasterCredentials(t), this.expired = !0, this.params = e || {}, this.params.RoleArn && (this.params.RoleSessionName = this.params.RoleSessionName || "temporary-credentials")
        }, refresh: function (e) {
            this.coalesceRefresh(e || n.util.fn.callback)
        }, load: function (e) {
            var t = this;
            t.createClients(), t.masterCredentials.get(function () {
                t.service.config.credentials = t.masterCredentials, (t.params.RoleArn ? t.service.assumeRole : t.service.getSessionToken).call(t.service, function (r, n) {
                    r || t.service.credentialsFrom(n, t), e(r)
                })
            })
        }, loadMasterCredentials: function (e) {
            for (this.masterCredentials = e || n.config.credentials; this.masterCredentials.masterCredentials;) this.masterCredentials = this.masterCredentials.masterCredentials;
            "function" != typeof this.masterCredentials.get && (this.masterCredentials = new n.Credentials(this.masterCredentials))
        }, createClients: function () {
            this.service = this.service || new i({params: this.params})
        }
    })
}, function (e, t, r) {
    var n = r(9), i = r(267);
    n.util.update(n.STS.prototype, {
        credentialsFrom: function (e, t) {
            return e ? (t || (t = new n.TemporaryCredentials), t.expired = !1, t.accessKeyId = e.Credentials.AccessKeyId, t.secretAccessKey = e.Credentials.SecretAccessKey, t.sessionToken = e.Credentials.SessionToken, t.expireTime = e.Credentials.Expiration, t) : null
        }, assumeRoleWithWebIdentity: function (e, t) {
            return this.makeUnauthenticatedRequest("assumeRoleWithWebIdentity", e, t)
        }, assumeRoleWithSAML: function (e, t) {
            return this.makeUnauthenticatedRequest("assumeRoleWithSAML", e, t)
        }, setupRequestListeners: function (e) {
            e.addListener("validate", this.optInRegionalEndpoint, !0)
        }, optInRegionalEndpoint: function (e) {
            var t = e.service, r = t.config;
            if (r.stsRegionalEndpoints = i(t._originalConfig, {
                env: "AWS_STS_REGIONAL_ENDPOINTS",
                sharedConfig: "sts_regional_endpoints",
                clientConfig: "stsRegionalEndpoints"
            }), "regional" === r.stsRegionalEndpoints && t.isGlobalEndpoint) {
                if (!r.region) throw n.util.error(new Error, {
                    code: "ConfigError",
                    message: "Missing region in config"
                });
                var o = r.endpoint.indexOf(".amazonaws.com"),
                    s = r.endpoint.substring(0, o) + "." + r.region + r.endpoint.substring(o);
                e.httpRequest.updateEndpoint(s), e.httpRequest.region = r.region
            }
        }
    })
}, function (e, t, r) {
    (function (t) {
        var n = r(9);

        function i(e, t) {
            if ("string" == typeof e) {
                if (["legacy", "regional"].indexOf(e.toLowerCase()) >= 0) return e.toLowerCase();
                throw n.util.error(new Error, t)
            }
        }

        e.exports = function (e, r) {
            var o;
            if ((e = e || {})[r.clientConfig] && (o = i(e[r.clientConfig], {
                code: "InvalidConfiguration",
                message: 'invalid "' + r.clientConfig + '" configuration. Expect "legacy"  or "regional". Got "' + e[r.clientConfig] + '".'
            }))) return o;
            if (!n.util.isNode()) return o;
            if (Object.prototype.hasOwnProperty.call(t.env, r.env) && (o = i(t.env[r.env], {
                code: "InvalidEnvironmentalVariable",
                message: "invalid " + r.env + ' environmental variable. Expect "legacy"  or "regional". Got "' + t.env[r.env] + '".'
            }))) return o;
            var s = {};
            try {
                s = n.util.getProfilesFromSharedConfig(n.util.iniLoader)[t.env.AWS_PROFILE || n.util.defaultProfile]
            } catch (e) {
            }
            return s && Object.prototype.hasOwnProperty.call(s, r.sharedConfig) && (o = i(s[r.sharedConfig], {
                code: "InvalidConfiguration",
                message: "invalid " + r.sharedConfig + ' profile config. Expect "legacy"  or "regional". Got "' + s[r.sharedConfig] + '".'
            })), o
        }
    }).call(this, r(14))
}, function (e) {
    e.exports = JSON.parse('{"version":"2.0","metadata":{"apiVersion":"2011-06-15","endpointPrefix":"sts","globalEndpoint":"sts.amazonaws.com","protocol":"query","serviceAbbreviation":"AWS STS","serviceFullName":"AWS Security Token Service","serviceId":"STS","signatureVersion":"v4","uid":"sts-2011-06-15","xmlNamespace":"https://sts.amazonaws.com/doc/2011-06-15/"},"operations":{"AssumeRole":{"input":{"type":"structure","required":["RoleArn","RoleSessionName"],"members":{"RoleArn":{},"RoleSessionName":{},"PolicyArns":{"shape":"S4"},"Policy":{},"DurationSeconds":{"type":"integer"},"Tags":{"shape":"S8"},"TransitiveTagKeys":{"type":"list","member":{}},"ExternalId":{},"SerialNumber":{},"TokenCode":{}}},"output":{"resultWrapper":"AssumeRoleResult","type":"structure","members":{"Credentials":{"shape":"Sh"},"AssumedRoleUser":{"shape":"Sm"},"PackedPolicySize":{"type":"integer"}}}},"AssumeRoleWithSAML":{"input":{"type":"structure","required":["RoleArn","PrincipalArn","SAMLAssertion"],"members":{"RoleArn":{},"PrincipalArn":{},"SAMLAssertion":{},"PolicyArns":{"shape":"S4"},"Policy":{},"DurationSeconds":{"type":"integer"}}},"output":{"resultWrapper":"AssumeRoleWithSAMLResult","type":"structure","members":{"Credentials":{"shape":"Sh"},"AssumedRoleUser":{"shape":"Sm"},"PackedPolicySize":{"type":"integer"},"Subject":{},"SubjectType":{},"Issuer":{},"Audience":{},"NameQualifier":{}}}},"AssumeRoleWithWebIdentity":{"input":{"type":"structure","required":["RoleArn","RoleSessionName","WebIdentityToken"],"members":{"RoleArn":{},"RoleSessionName":{},"WebIdentityToken":{},"ProviderId":{},"PolicyArns":{"shape":"S4"},"Policy":{},"DurationSeconds":{"type":"integer"}}},"output":{"resultWrapper":"AssumeRoleWithWebIdentityResult","type":"structure","members":{"Credentials":{"shape":"Sh"},"SubjectFromWebIdentityToken":{},"AssumedRoleUser":{"shape":"Sm"},"PackedPolicySize":{"type":"integer"},"Provider":{},"Audience":{}}}},"DecodeAuthorizationMessage":{"input":{"type":"structure","required":["EncodedMessage"],"members":{"EncodedMessage":{}}},"output":{"resultWrapper":"DecodeAuthorizationMessageResult","type":"structure","members":{"DecodedMessage":{}}}},"GetAccessKeyInfo":{"input":{"type":"structure","required":["AccessKeyId"],"members":{"AccessKeyId":{}}},"output":{"resultWrapper":"GetAccessKeyInfoResult","type":"structure","members":{"Account":{}}}},"GetCallerIdentity":{"input":{"type":"structure","members":{}},"output":{"resultWrapper":"GetCallerIdentityResult","type":"structure","members":{"UserId":{},"Account":{},"Arn":{}}}},"GetFederationToken":{"input":{"type":"structure","required":["Name"],"members":{"Name":{},"Policy":{},"PolicyArns":{"shape":"S4"},"DurationSeconds":{"type":"integer"},"Tags":{"shape":"S8"}}},"output":{"resultWrapper":"GetFederationTokenResult","type":"structure","members":{"Credentials":{"shape":"Sh"},"FederatedUser":{"type":"structure","required":["FederatedUserId","Arn"],"members":{"FederatedUserId":{},"Arn":{}}},"PackedPolicySize":{"type":"integer"}}}},"GetSessionToken":{"input":{"type":"structure","members":{"DurationSeconds":{"type":"integer"},"SerialNumber":{},"TokenCode":{}}},"output":{"resultWrapper":"GetSessionTokenResult","type":"structure","members":{"Credentials":{"shape":"Sh"}}}}},"shapes":{"S4":{"type":"list","member":{"type":"structure","members":{"arn":{}}}},"S8":{"type":"list","member":{"type":"structure","required":["Key","Value"],"members":{"Key":{},"Value":{}}}},"Sh":{"type":"structure","required":["AccessKeyId","SecretAccessKey","SessionToken","Expiration"],"members":{"AccessKeyId":{},"SecretAccessKey":{},"SessionToken":{},"Expiration":{"type":"timestamp"}}},"Sm":{"type":"structure","required":["AssumedRoleId","Arn"],"members":{"AssumedRoleId":{},"Arn":{}}}}}')
}, function (e) {
    e.exports = JSON.parse('{"pagination":{}}')
}, function (e, t, r) {
    var n = r(9), i = r(51);
    n.ChainableTemporaryCredentials = n.util.inherit(n.Credentials, {
        constructor: function (e) {
            n.Credentials.call(this), e = e || {}, this.errorCode = "ChainableTemporaryCredentialsProviderFailure", this.expired = !0, this.tokenCodeFn = null;
            var t = n.util.copy(e.params) || {};
            if (t.RoleArn && (t.RoleSessionName = t.RoleSessionName || "temporary-credentials"), t.SerialNumber) {
                if (!e.tokenCodeFn || "function" != typeof e.tokenCodeFn) throw new n.util.error(new Error("tokenCodeFn must be a function when params.SerialNumber is given"), {code: this.errorCode});
                this.tokenCodeFn = e.tokenCodeFn
            }
            var r = n.util.merge({
                params: t,
                credentials: e.masterCredentials || n.config.credentials
            }, e.stsConfig || {});
            this.service = new i(r)
        }, refresh: function (e) {
            this.coalesceRefresh(e || n.util.fn.callback)
        }, load: function (e) {
            var t = this, r = t.service.config.params.RoleArn ? "assumeRole" : "getSessionToken";
            this.getTokenCode(function (n, i) {
                var o = {};
                n ? e(n) : (i && (o.TokenCode = i), t.service[r](o, function (r, n) {
                    r || t.service.credentialsFrom(n, t), e(r)
                }))
            })
        }, getTokenCode: function (e) {
            var t = this;
            this.tokenCodeFn ? this.tokenCodeFn(this.service.config.params.SerialNumber, function (r, i) {
                if (r) {
                    var o = r;
                    return r instanceof Error && (o = r.message), void e(n.util.error(new Error("Error fetching MFA token: " + o), {code: t.errorCode}))
                }
                e(null, i)
            }) : e(null)
        }
    })
}, function (e, t, r) {
    var n = r(9), i = r(51);
    n.WebIdentityCredentials = n.util.inherit(n.Credentials, {
        constructor: function (e, t) {
            n.Credentials.call(this), this.expired = !0, this.params = e, this.params.RoleSessionName = this.params.RoleSessionName || "web-identity", this.data = null, this._clientConfig = n.util.copy(t || {})
        }, refresh: function (e) {
            this.coalesceRefresh(e || n.util.fn.callback)
        }, load: function (e) {
            var t = this;
            t.createClients(), t.service.assumeRoleWithWebIdentity(function (r, n) {
                t.data = null, r || (t.data = n, t.service.credentialsFrom(n, t)), e(r)
            })
        }, createClients: function () {
            if (!this.service) {
                var e = n.util.merge({}, this._clientConfig);
                e.params = this.params, this.service = new i(e)
            }
        }
    })
}, function (e, t, r) {
    var n = r(9), i = r(273), o = r(51);
    n.CognitoIdentityCredentials = n.util.inherit(n.Credentials, {
        localStorageKey: {id: "aws.cognito.identity-id.", providers: "aws.cognito.identity-providers."},
        constructor: function (e, t) {
            n.Credentials.call(this), this.expired = !0, this.params = e, this.data = null, this._identityId = null, this._clientConfig = n.util.copy(t || {}), this.loadCachedId();
            var r = this;
            Object.defineProperty(this, "identityId", {
                get: function () {
                    return r.loadCachedId(), r._identityId || r.params.IdentityId
                }, set: function (e) {
                    r._identityId = e
                }
            })
        },
        refresh: function (e) {
            this.coalesceRefresh(e || n.util.fn.callback)
        },
        load: function (e) {
            var t = this;
            t.createClients(), t.data = null, t._identityId = null, t.getId(function (r) {
                r ? (t.clearIdOnNotAuthorized(r), e(r)) : t.params.RoleArn ? t.getCredentialsFromSTS(e) : t.getCredentialsForIdentity(e)
            })
        },
        clearCachedId: function () {
            this._identityId = null, delete this.params.IdentityId;
            var e = this.params.IdentityPoolId, t = this.params.LoginId || "";
            delete this.storage[this.localStorageKey.id + e + t], delete this.storage[this.localStorageKey.providers + e + t]
        },
        clearIdOnNotAuthorized: function (e) {
            "NotAuthorizedException" == e.code && this.clearCachedId()
        },
        getId: function (e) {
            var t = this;
            if ("string" == typeof t.params.IdentityId) return e(null, t.params.IdentityId);
            t.cognito.getId(function (r, n) {
                !r && n.IdentityId ? (t.params.IdentityId = n.IdentityId, e(null, n.IdentityId)) : e(r)
            })
        },
        loadCredentials: function (e, t) {
            e && t && (t.expired = !1, t.accessKeyId = e.Credentials.AccessKeyId, t.secretAccessKey = e.Credentials.SecretKey, t.sessionToken = e.Credentials.SessionToken, t.expireTime = e.Credentials.Expiration)
        },
        getCredentialsForIdentity: function (e) {
            var t = this;
            t.cognito.getCredentialsForIdentity(function (r, n) {
                r ? t.clearIdOnNotAuthorized(r) : (t.cacheId(n), t.data = n, t.loadCredentials(t.data, t)), e(r)
            })
        },
        getCredentialsFromSTS: function (e) {
            var t = this;
            t.cognito.getOpenIdToken(function (r, n) {
                r ? (t.clearIdOnNotAuthorized(r), e(r)) : (t.cacheId(n), t.params.WebIdentityToken = n.Token, t.webIdentityCredentials.refresh(function (r) {
                    r || (t.data = t.webIdentityCredentials.data, t.sts.credentialsFrom(t.data, t)), e(r)
                }))
            })
        },
        loadCachedId: function () {
            if (n.util.isBrowser() && !this.params.IdentityId) {
                var e = this.getStorage("id");
                if (e && this.params.Logins) {
                    var t = Object.keys(this.params.Logins);
                    0 !== (this.getStorage("providers") || "").split(",").filter(function (e) {
                        return -1 !== t.indexOf(e)
                    }).length && (this.params.IdentityId = e)
                } else e && (this.params.IdentityId = e)
            }
        },
        createClients: function () {
            var e = this._clientConfig;
            if (this.webIdentityCredentials = this.webIdentityCredentials || new n.WebIdentityCredentials(this.params, e), !this.cognito) {
                var t = n.util.merge({}, e);
                t.params = this.params, this.cognito = new i(t)
            }
            this.sts = this.sts || new o(e)
        },
        cacheId: function (e) {
            this._identityId = e.IdentityId, this.params.IdentityId = this._identityId, n.util.isBrowser() && (this.setStorage("id", e.IdentityId), this.params.Logins && this.setStorage("providers", Object.keys(this.params.Logins).join(",")))
        },
        getStorage: function (e) {
            return this.storage[this.localStorageKey[e] + this.params.IdentityPoolId + (this.params.LoginId || "")]
        },
        setStorage: function (e, t) {
            try {
                this.storage[this.localStorageKey[e] + this.params.IdentityPoolId + (this.params.LoginId || "")] = t
            } catch (e) {
            }
        },
        storage: function () {
            try {
                var e = n.util.isBrowser() && null !== window.localStorage && "object" == typeof window.localStorage ? window.localStorage : {};
                return e["aws.test-storage"] = "foobar", delete e["aws.test-storage"], e
            } catch (e) {
                return {}
            }
        }()
    })
}, function (e, t, r) {
    r(80);
    var n = r(9), i = n.Service, o = n.apiLoader;
    o.services.cognitoidentity = {}, n.CognitoIdentity = i.defineService("cognitoidentity", ["2014-06-30"]), r(274), Object.defineProperty(o.services.cognitoidentity, "2014-06-30", {
        get: function () {
            var e = r(275);
            return e.paginators = r(276).pagination, e
        }, enumerable: !0, configurable: !0
    }), e.exports = n.CognitoIdentity
}, function (e, t, r) {
    var n = r(9);
    n.util.update(n.CognitoIdentity.prototype, {
        getOpenIdToken: function (e, t) {
            return this.makeUnauthenticatedRequest("getOpenIdToken", e, t)
        }, getId: function (e, t) {
            return this.makeUnauthenticatedRequest("getId", e, t)
        }, getCredentialsForIdentity: function (e, t) {
            return this.makeUnauthenticatedRequest("getCredentialsForIdentity", e, t)
        }
    })
}, function (e) {
    e.exports = JSON.parse('{"version":"2.0","metadata":{"apiVersion":"2014-06-30","endpointPrefix":"cognito-identity","jsonVersion":"1.1","protocol":"json","serviceFullName":"Amazon Cognito Identity","serviceId":"Cognito Identity","signatureVersion":"v4","targetPrefix":"AWSCognitoIdentityService","uid":"cognito-identity-2014-06-30"},"operations":{"CreateIdentityPool":{"input":{"type":"structure","required":["IdentityPoolName","AllowUnauthenticatedIdentities"],"members":{"IdentityPoolName":{},"AllowUnauthenticatedIdentities":{"type":"boolean"},"AllowClassicFlow":{"type":"boolean"},"SupportedLoginProviders":{"shape":"S5"},"DeveloperProviderName":{},"OpenIdConnectProviderARNs":{"shape":"S9"},"CognitoIdentityProviders":{"shape":"Sb"},"SamlProviderARNs":{"shape":"Sg"},"IdentityPoolTags":{"shape":"Sh"}}},"output":{"shape":"Sk"}},"DeleteIdentities":{"input":{"type":"structure","required":["IdentityIdsToDelete"],"members":{"IdentityIdsToDelete":{"type":"list","member":{}}}},"output":{"type":"structure","members":{"UnprocessedIdentityIds":{"type":"list","member":{"type":"structure","members":{"IdentityId":{},"ErrorCode":{}}}}}}},"DeleteIdentityPool":{"input":{"type":"structure","required":["IdentityPoolId"],"members":{"IdentityPoolId":{}}}},"DescribeIdentity":{"input":{"type":"structure","required":["IdentityId"],"members":{"IdentityId":{}}},"output":{"shape":"Sv"}},"DescribeIdentityPool":{"input":{"type":"structure","required":["IdentityPoolId"],"members":{"IdentityPoolId":{}}},"output":{"shape":"Sk"}},"GetCredentialsForIdentity":{"input":{"type":"structure","required":["IdentityId"],"members":{"IdentityId":{},"Logins":{"shape":"S10"},"CustomRoleArn":{}}},"output":{"type":"structure","members":{"IdentityId":{},"Credentials":{"type":"structure","members":{"AccessKeyId":{},"SecretKey":{},"SessionToken":{},"Expiration":{"type":"timestamp"}}}}},"authtype":"none"},"GetId":{"input":{"type":"structure","required":["IdentityPoolId"],"members":{"AccountId":{},"IdentityPoolId":{},"Logins":{"shape":"S10"}}},"output":{"type":"structure","members":{"IdentityId":{}}},"authtype":"none"},"GetIdentityPoolRoles":{"input":{"type":"structure","required":["IdentityPoolId"],"members":{"IdentityPoolId":{}}},"output":{"type":"structure","members":{"IdentityPoolId":{},"Roles":{"shape":"S1c"},"RoleMappings":{"shape":"S1e"}}}},"GetOpenIdToken":{"input":{"type":"structure","required":["IdentityId"],"members":{"IdentityId":{},"Logins":{"shape":"S10"}}},"output":{"type":"structure","members":{"IdentityId":{},"Token":{}}},"authtype":"none"},"GetOpenIdTokenForDeveloperIdentity":{"input":{"type":"structure","required":["IdentityPoolId","Logins"],"members":{"IdentityPoolId":{},"IdentityId":{},"Logins":{"shape":"S10"},"TokenDuration":{"type":"long"}}},"output":{"type":"structure","members":{"IdentityId":{},"Token":{}}}},"ListIdentities":{"input":{"type":"structure","required":["IdentityPoolId","MaxResults"],"members":{"IdentityPoolId":{},"MaxResults":{"type":"integer"},"NextToken":{},"HideDisabled":{"type":"boolean"}}},"output":{"type":"structure","members":{"IdentityPoolId":{},"Identities":{"type":"list","member":{"shape":"Sv"}},"NextToken":{}}}},"ListIdentityPools":{"input":{"type":"structure","required":["MaxResults"],"members":{"MaxResults":{"type":"integer"},"NextToken":{}}},"output":{"type":"structure","members":{"IdentityPools":{"type":"list","member":{"type":"structure","members":{"IdentityPoolId":{},"IdentityPoolName":{}}}},"NextToken":{}}}},"ListTagsForResource":{"input":{"type":"structure","required":["ResourceArn"],"members":{"ResourceArn":{}}},"output":{"type":"structure","members":{"Tags":{"shape":"Sh"}}}},"LookupDeveloperIdentity":{"input":{"type":"structure","required":["IdentityPoolId"],"members":{"IdentityPoolId":{},"IdentityId":{},"DeveloperUserIdentifier":{},"MaxResults":{"type":"integer"},"NextToken":{}}},"output":{"type":"structure","members":{"IdentityId":{},"DeveloperUserIdentifierList":{"type":"list","member":{}},"NextToken":{}}}},"MergeDeveloperIdentities":{"input":{"type":"structure","required":["SourceUserIdentifier","DestinationUserIdentifier","DeveloperProviderName","IdentityPoolId"],"members":{"SourceUserIdentifier":{},"DestinationUserIdentifier":{},"DeveloperProviderName":{},"IdentityPoolId":{}}},"output":{"type":"structure","members":{"IdentityId":{}}}},"SetIdentityPoolRoles":{"input":{"type":"structure","required":["IdentityPoolId","Roles"],"members":{"IdentityPoolId":{},"Roles":{"shape":"S1c"},"RoleMappings":{"shape":"S1e"}}}},"TagResource":{"input":{"type":"structure","required":["ResourceArn","Tags"],"members":{"ResourceArn":{},"Tags":{"shape":"Sh"}}},"output":{"type":"structure","members":{}}},"UnlinkDeveloperIdentity":{"input":{"type":"structure","required":["IdentityId","IdentityPoolId","DeveloperProviderName","DeveloperUserIdentifier"],"members":{"IdentityId":{},"IdentityPoolId":{},"DeveloperProviderName":{},"DeveloperUserIdentifier":{}}}},"UnlinkIdentity":{"input":{"type":"structure","required":["IdentityId","Logins","LoginsToRemove"],"members":{"IdentityId":{},"Logins":{"shape":"S10"},"LoginsToRemove":{"shape":"Sw"}}},"authtype":"none"},"UntagResource":{"input":{"type":"structure","required":["ResourceArn","TagKeys"],"members":{"ResourceArn":{},"TagKeys":{"type":"list","member":{}}}},"output":{"type":"structure","members":{}}},"UpdateIdentityPool":{"input":{"shape":"Sk"},"output":{"shape":"Sk"}}},"shapes":{"S5":{"type":"map","key":{},"value":{}},"S9":{"type":"list","member":{}},"Sb":{"type":"list","member":{"type":"structure","members":{"ProviderName":{},"ClientId":{},"ServerSideTokenCheck":{"type":"boolean"}}}},"Sg":{"type":"list","member":{}},"Sh":{"type":"map","key":{},"value":{}},"Sk":{"type":"structure","required":["IdentityPoolId","IdentityPoolName","AllowUnauthenticatedIdentities"],"members":{"IdentityPoolId":{},"IdentityPoolName":{},"AllowUnauthenticatedIdentities":{"type":"boolean"},"AllowClassicFlow":{"type":"boolean"},"SupportedLoginProviders":{"shape":"S5"},"DeveloperProviderName":{},"OpenIdConnectProviderARNs":{"shape":"S9"},"CognitoIdentityProviders":{"shape":"Sb"},"SamlProviderARNs":{"shape":"Sg"},"IdentityPoolTags":{"shape":"Sh"}}},"Sv":{"type":"structure","members":{"IdentityId":{},"Logins":{"shape":"Sw"},"CreationDate":{"type":"timestamp"},"LastModifiedDate":{"type":"timestamp"}}},"Sw":{"type":"list","member":{}},"S10":{"type":"map","key":{},"value":{}},"S1c":{"type":"map","key":{},"value":{}},"S1e":{"type":"map","key":{},"value":{"type":"structure","required":["Type"],"members":{"Type":{},"AmbiguousRoleResolution":{},"RulesConfiguration":{"type":"structure","required":["Rules"],"members":{"Rules":{"type":"list","member":{"type":"structure","required":["Claim","MatchType","Value","RoleARN"],"members":{"Claim":{},"MatchType":{},"Value":{},"RoleARN":{}}}}}}}}}}}')
}, function (e) {
    e.exports = JSON.parse('{"pagination":{"ListIdentityPools":{"input_token":"NextToken","limit_key":"MaxResults","output_token":"NextToken","result_key":"IdentityPools"}}}')
}, function (e, t, r) {
    var n = r(9), i = r(51);
    n.SAMLCredentials = n.util.inherit(n.Credentials, {
        constructor: function (e) {
            n.Credentials.call(this), this.expired = !0, this.params = e
        }, refresh: function (e) {
            this.coalesceRefresh(e || n.util.fn.callback)
        }, load: function (e) {
            var t = this;
            t.createClients(), t.service.assumeRoleWithSAML(function (r, n) {
                r || t.service.credentialsFrom(n, t), e(r)
            })
        }, createClients: function () {
            this.service = this.service || new i({params: this.params})
        }
    })
}, function (e, t, r) {
    var n = r(15), i = r(49);

    function o() {
    }

    function s(e, t) {
        for (var r = e.getElementsByTagName(t), n = 0, i = r.length; n < i; n++) if (r[n].parentNode === e) return r[n]
    }

    function a(e, t) {
        switch (t || (t = {}), t.type) {
            case"structure":
                return c(e, t);
            case"map":
                return function (e, t) {
                    var r = {}, n = t.key.name || "key", i = t.value.name || "value",
                        o = t.flattened ? t.name : "entry", c = e.firstElementChild;
                    for (; c;) {
                        if (c.nodeName === o) {
                            var u = s(c, n).textContent, d = s(c, i);
                            r[u] = a(d, t.value)
                        }
                        c = c.nextElementSibling
                    }
                    return r
                }(e, t);
            case"list":
                return function (e, t) {
                    var r = [], n = t.flattened ? t.name : t.member.name || "member", i = e.firstElementChild;
                    for (; i;) i.nodeName === n && r.push(a(i, t.member)), i = i.nextElementSibling;
                    return r
                }(e, t);
            case void 0:
            case null:
                return function (e) {
                    if (void 0 === e || null === e) return "";
                    if (!e.firstElementChild) return null === e.parentNode.parentNode ? {} : 0 === e.childNodes.length ? "" : e.textContent;
                    var t = {type: "structure", members: {}}, r = e.firstElementChild;
                    for (; r;) {
                        var n = r.nodeName;
                        Object.prototype.hasOwnProperty.call(t.members, n) ? t.members[n].type = "list" : t.members[n] = {name: n}, r = r.nextElementSibling
                    }
                    return c(e, t)
                }(e);
            default:
                return function (e, t) {
                    if (e.getAttribute) {
                        var r = e.getAttribute("encoding");
                        "base64" === r && (t = new i.create({type: r}))
                    }
                    var n = e.textContent;
                    "" === n && (n = null);
                    return "function" == typeof t.toType ? t.toType(n) : n
                }(e, t)
        }
    }

    function c(e, t) {
        var r = {};
        return null === e ? r : (n.each(t.members, function (n, i) {
            if (i.isXmlAttribute) {
                if (Object.prototype.hasOwnProperty.call(e.attributes, i.name)) {
                    var o = e.attributes[i.name].value;
                    r[n] = a({textContent: o}, i)
                }
            } else {
                var c = i.flattened ? e : s(e, i.name);
                c ? r[n] = a(c, i) : i.flattened || "list" !== i.type || t.api.xmlNoDefaultLists || (r[n] = i.defaultValue)
            }
        }), r)
    }

    o.prototype.parse = function (e, t) {
        if ("" === e.replace(/^\s+/, "")) return {};
        var r, i;
        try {
            if (window.DOMParser) {
                try {
                    r = (new DOMParser).parseFromString(e, "text/xml")
                } catch (e) {
                    throw n.error(new Error("Parse error in document"), {
                        originalError: e,
                        code: "XMLParserError",
                        retryable: !0
                    })
                }
                if (null === r.documentElement) throw n.error(new Error("Cannot parse empty document."), {
                    code: "XMLParserError",
                    retryable: !0
                });
                var o = r.getElementsByTagName("parsererror")[0];
                if (o && (o.parentNode === r || "body" === o.parentNode.nodeName || o.parentNode.parentNode === r || "body" === o.parentNode.parentNode.nodeName)) {
                    var c = o.getElementsByTagName("div")[0] || o;
                    throw n.error(new Error(c.textContent || "Parser error in document"), {
                        code: "XMLParserError",
                        retryable: !0
                    })
                }
            } else {
                if (!window.ActiveXObject) throw new Error("Cannot load XML parser");
                if ((r = new window.ActiveXObject("Microsoft.XMLDOM")).async = !1, !r.loadXML(e)) throw n.error(new Error("Parse error in document"), {
                    code: "XMLParserError",
                    retryable: !0
                })
            }
        } catch (e) {
            i = e
        }
        if (r && r.documentElement && !i) {
            var u = a(r.documentElement, t), d = s(r.documentElement, "ResponseMetadata");
            return d && (u.ResponseMetadata = a(d, {})), u
        }
        if (i) throw n.error(i || new Error, {code: "XMLParserError", retryable: !0});
        return {}
    }, e.exports = o
}, function (e, t, r) {
    var n = r(9), i = r(29).EventEmitter;
    r(126), n.XHRClient = n.util.inherit({
        handleRequest: function (e, t, r, o) {
            var s = this, a = e.endpoint, c = new i, u = a.protocol + "//" + a.hostname;
            80 !== a.port && 443 !== a.port && (u += ":" + a.port), u += e.path;
            var d = new XMLHttpRequest, l = !1;
            e.stream = d, d.addEventListener("readystatechange", function () {
                try {
                    if (0 === d.status) return
                } catch (e) {
                    return
                }
                this.readyState >= this.HEADERS_RECEIVED && !l && (c.statusCode = d.status, c.headers = s.parseHeaders(d.getAllResponseHeaders()), c.emit("headers", c.statusCode, c.headers, d.statusText), l = !0), this.readyState === this.DONE && s.finishRequest(d, c)
            }, !1), d.upload.addEventListener("progress", function (e) {
                c.emit("sendProgress", e)
            }), d.addEventListener("progress", function (e) {
                c.emit("receiveProgress", e)
            }, !1), d.addEventListener("timeout", function () {
                o(n.util.error(new Error("Timeout"), {code: "TimeoutError"}))
            }, !1), d.addEventListener("error", function () {
                o(n.util.error(new Error("Network Failure"), {code: "NetworkingError"}))
            }, !1), d.addEventListener("abort", function () {
                o(n.util.error(new Error("Request aborted"), {code: "RequestAbortedError"}))
            }, !1), r(c), d.open(e.method, u, !1 !== t.xhrAsync), n.util.each(e.headers, function (e, t) {
                "Content-Length" !== e && "User-Agent" !== e && "Host" !== e && d.setRequestHeader(e, t)
            }), t.timeout && !1 !== t.xhrAsync && (d.timeout = t.timeout), t.xhrWithCredentials && (d.withCredentials = !0);
            try {
                d.responseType = "arraybuffer"
            } catch (e) {
            }
            try {
                e.body ? d.send(e.body) : d.send()
            } catch (t) {
                if (!e.body || "object" != typeof e.body.buffer) throw t;
                d.send(e.body.buffer)
            }
            return c
        }, parseHeaders: function (e) {
            var t = {};
            return n.util.arrayEach(e.split(/\r?\n/), function (e) {
                var r = e.split(":", 1)[0], n = e.substring(r.length + 2);
                r.length > 0 && (t[r.toLowerCase()] = n)
            }), t
        }, finishRequest: function (e, t) {
            var r;
            if ("arraybuffer" === e.responseType && e.response) {
                var i = e.response;
                r = new n.util.Buffer(i.byteLength);
                for (var o = new Uint8Array(i), s = 0; s < r.length; ++s) r[s] = o[s]
            }
            try {
                r || "string" != typeof e.responseText || (r = new n.util.Buffer(e.responseText))
            } catch (e) {
            }
            r && t.emit("data", r), t.emit("end")
        }
    }), n.HttpClient.prototype = n.XHRClient.prototype, n.HttpClient.streamsApiVersion = 1
}, function (e, t, r) {
    e.exports.device = r(88), e.exports.thingShadow = r(368), e.exports.jobs = r(369)
}, function (e, t, r) {
    "use strict";
    (function (t) {
        var n = r(282), i = r(130), o = r(87), s = r(89), a = {};

        function c(e, t) {
            if ("object" != typeof e || t || (t = e, e = null), t = t || {}, e) {
                var r = o.parse(e, !0);
                if (null != r.port && (r.port = Number(r.port)), null === (t = s(r, t)).protocol) throw new Error("Missing protocol");
                t.protocol = t.protocol.replace(/:$/, "")
            }
            if (function (e) {
                var t;
                e.auth && ((t = e.auth.match(/^(.+):(.+)$/)) ? (e.username = t[1], e.password = t[2]) : e.username = e.auth)
            }(t), t.query && "string" == typeof t.query.clientId && (t.clientId = t.query.clientId), t.cert && t.key) {
                if (!t.protocol) throw new Error("Missing secure protocol key");
                if (-1 === ["mqtts", "wss", "wxs"].indexOf(t.protocol)) switch (t.protocol) {
                    case"mqtt":
                        t.protocol = "mqtts";
                        break;
                    case"ws":
                        t.protocol = "wss";
                        break;
                    case"wx":
                        t.protocol = "wxs";
                        break;
                    default:
                        throw new Error('Unknown protocol for secure connection: "' + t.protocol + '"!')
                }
            }
            if (!a[t.protocol]) {
                var i = -1 !== ["mqtts", "wss"].indexOf(t.protocol);
                t.protocol = ["mqtt", "mqtts", "ws", "wss", "wx", "wxs"].filter(function (e, t) {
                    return (!i || t % 2 != 0) && "function" == typeof a[e]
                })[0]
            }
            if (!1 === t.clean && !t.clientId) throw new Error("Missing clientId for unclean clients");
            return t.protocol && (t.defaultProtocol = t.protocol), new n(function (e) {
                return t.servers && (e._reconnectCount && e._reconnectCount !== t.servers.length || (e._reconnectCount = 0), t.host = t.servers[e._reconnectCount].host, t.port = t.servers[e._reconnectCount].port, t.protocol = t.servers[e._reconnectCount].protocol ? t.servers[e._reconnectCount].protocol : t.defaultProtocol, t.hostname = t.host, e._reconnectCount++), a[t.protocol](e, t)
            }, t)
        }

        "browser" !== t.title ? (a.mqtt = r(150), a.tcp = r(150), a.ssl = r(93), a.tls = r(93), a.mqtts = r(93)) : (a.wx = r(151), a.wxs = r(151)), a.ws = r(152), a.wss = r(152), e.exports = c, e.exports.connect = c, e.exports.MqttClient = n, e.exports.Store = i
    }).call(this, r(14))
}, function (e, t, r) {
    "use strict";
    (function (t, n) {
        var i = r(29), o = r(130), s = r(147), a = r(345), c = r(56).Writable, u = r(26), d = r(352), l = r(353),
            h = r(89), p = t.setImmediate || function (e) {
                n.nextTick(e)
            }, f = {
                keepalive: 60,
                reschedulePings: !0,
                protocolId: "MQTT",
                protocolVersion: 4,
                reconnectPeriod: 1e3,
                connectTimeout: 3e4,
                clean: !0,
                resubscribe: !0
            };

        function m(e, t, r) {
            e.emit("packetsend", t), !a.writeToStream(t, e.stream) && r ? e.stream.once("drain", r) : r && r()
        }

        function _(e, t, r) {
            e.outgoingStore.put(t, function (n) {
                if (n) return r && r(n);
                m(e, t, r)
            })
        }

        function v() {
        }

        function g(e, t) {
            var r, n = this;
            if (!(this instanceof g)) return new g(e, t);
            for (r in this.options = t || {}, f) void 0 === this.options[r] ? this.options[r] = f[r] : this.options[r] = t[r];
            this.options.clientId = "string" == typeof this.options.clientId ? this.options.clientId : "mqttjs_" + Math.random().toString(16).substr(2, 8), this.streamBuilder = e, this.outgoingStore = this.options.outgoingStore || new o, this.incomingStore = this.options.incomingStore || new o, this.queueQoSZero = void 0 === this.options.queueQoSZero || this.options.queueQoSZero, this._resubscribeTopics = {}, this.messageIdToTopic = {}, this.pingTimer = null, this.connected = !1, this.disconnecting = !1, this.queue = [], this.connackTimer = null, this.reconnectTimer = null, this.nextId = Math.max(1, Math.floor(65535 * Math.random())), this.outgoing = {}, this.on("connect", function () {
                if (!this.disconnected) {
                    this.connected = !0;
                    var e = this.outgoingStore.createStream();
                    this.once("close", t), e.on("end", function () {
                        n.removeListener("close", t)
                    }), e.on("error", function (e) {
                        n.removeListener("close", t), n.emit("error", e)
                    }), function t() {
                        if (e) {
                            var r, i = e.read(1);
                            i ? n.disconnecting || n.reconnectTimer ? e.destroy && e.destroy() : (r = n.outgoing[i.messageId], n.outgoing[i.messageId] = function (e, n) {
                                r && r(e, n), t()
                            }, n._sendPacket(i)) : e.once("readable", t)
                        }
                    }()
                }

                function t() {
                    e.destroy(), e = null
                }
            }), this.on("close", function () {
                this.connected = !1, clearTimeout(this.connackTimer)
            }), this.on("connect", this._setupPingTimer), this.on("connect", function () {
                var e = this.queue;
                !function t() {
                    var r, i = e.shift();
                    i && (r = i.packet, n._sendPacket(r, function (e) {
                        i.cb && i.cb(e), t()
                    }))
                }()
            });
            var s = !0;
            this.on("connect", function () {
                !s && this.options.clean && Object.keys(this._resubscribeTopics).length > 0 && (this.options.resubscribe ? (this._resubscribeTopics.resubscribe = !0, this.subscribe(this._resubscribeTopics)) : this._resubscribeTopics = {}), s = !1
            }), this.on("close", function () {
                null !== n.pingTimer && (n.pingTimer.clear(), n.pingTimer = null)
            }), this.on("close", this._setupReconnect), i.EventEmitter.call(this), this._setupStream()
        }

        u(g, i.EventEmitter), g.prototype._setupStream = function () {
            var e, t = this, r = new c, i = a.parser(this.options), o = null, u = [];

            function d() {
                n.nextTick(l)
            }

            function l() {
                var e = u.shift(), r = o;
                e ? t._handlePacket(e, d) : (o = null, r())
            }

            this._clearReconnect(), this.stream = this.streamBuilder(this), i.on("packet", function (e) {
                u.push(e)
            }), r._write = function (e, t, r) {
                o = r, i.parse(e), l()
            }, this.stream.pipe(r), this.stream.on("error", v), s(this.stream, this.emit.bind(this, "close")), (e = Object.create(this.options)).cmd = "connect", m(this, e), i.on("error", this.emit.bind(this, "error")), this.stream.setMaxListeners(1e3), clearTimeout(this.connackTimer), this.connackTimer = setTimeout(function () {
                t._cleanUp(!0)
            }, this.options.connectTimeout)
        }, g.prototype._handlePacket = function (e, t) {
            switch (this.emit("packetreceive", e), e.cmd) {
                case"publish":
                    this._handlePublish(e, t);
                    break;
                case"puback":
                case"pubrec":
                case"pubcomp":
                case"suback":
                case"unsuback":
                    this._handleAck(e), t();
                    break;
                case"pubrel":
                    this._handlePubrel(e, t);
                    break;
                case"connack":
                    this._handleConnack(e), t();
                    break;
                case"pingresp":
                    this._handlePingresp(e), t()
            }
        }, g.prototype._checkDisconnecting = function (e) {
            return this.disconnecting && (e ? e(new Error("client disconnecting")) : this.emit("error", new Error("client disconnecting"))), this.disconnecting
        }, g.prototype.publish = function (e, t, r, n) {
            var i;
            "function" == typeof r && (n = r, r = null);
            if (r = h({qos: 0, retain: !1, dup: !1}, r), this._checkDisconnecting(n)) return this;
            switch (i = {
                cmd: "publish",
                topic: e,
                payload: t,
                qos: r.qos,
                retain: r.retain,
                messageId: this._nextId(),
                dup: r.dup
            }, r.qos) {
                case 1:
                case 2:
                    this.outgoing[i.messageId] = n || v, this._sendPacket(i);
                    break;
                default:
                    this._sendPacket(i, n)
            }
            return this
        }, g.prototype.subscribe = function () {
            var e, t, r = Array.prototype.slice.call(arguments), n = [], i = r.shift(), o = i.resubscribe,
                s = r.pop() || v, a = r.pop(), c = this;
            if (delete i.resubscribe, "string" == typeof i && (i = [i]), "function" != typeof s && (a = s, s = v), null !== (t = l.validateTopics(i))) return p(s, new Error("Invalid topic " + t)), this;
            if (this._checkDisconnecting(s)) return this;
            if (a = h({qos: 0}, a), Array.isArray(i) ? i.forEach(function (e) {
                (c._resubscribeTopics[e] < a.qos || !c._resubscribeTopics.hasOwnProperty(e) || o) && n.push({
                    topic: e,
                    qos: a.qos
                })
            }) : Object.keys(i).forEach(function (e) {
                (c._resubscribeTopics[e] < i[e] || !c._resubscribeTopics.hasOwnProperty(e) || o) && n.push({
                    topic: e,
                    qos: i[e]
                })
            }), e = {
                cmd: "subscribe",
                subscriptions: n,
                qos: 1,
                retain: !1,
                dup: !1,
                messageId: this._nextId()
            }, n.length) {
                if (this.options.resubscribe) {
                    var u = [];
                    n.forEach(function (e) {
                        c.options.reconnectPeriod > 0 && (c._resubscribeTopics[e.topic] = e.qos, u.push(e.topic))
                    }), c.messageIdToTopic[e.messageId] = u
                }
                return this.outgoing[e.messageId] = function (e, t) {
                    if (!e) for (var r = t.granted, i = 0; i < r.length; i += 1) n[i].qos = r[i];
                    s(e, n)
                }, this._sendPacket(e), this
            }
            s(null, [])
        }, g.prototype.unsubscribe = function (e, t) {
            var r = {cmd: "unsubscribe", qos: 1, messageId: this._nextId()}, n = this;
            return t = t || v, this._checkDisconnecting(t) ? this : ("string" == typeof e ? r.unsubscriptions = [e] : "object" == typeof e && e.length && (r.unsubscriptions = e), this.options.resubscribe && r.unsubscriptions.forEach(function (e) {
                delete n._resubscribeTopics[e]
            }), this.outgoing[r.messageId] = t, this._sendPacket(r), this)
        }, g.prototype.end = function (e, t) {
            var r = this;

            function n() {
                r.disconnected = !0, r.incomingStore.close(function () {
                    r.outgoingStore.close(function () {
                        t && t.apply(null, arguments), r.emit("end")
                    })
                }), r._deferredReconnect && r._deferredReconnect()
            }

            function i() {
                r._cleanUp(e, p.bind(null, n))
            }

            return "function" == typeof e && (t = e, e = !1), this.disconnecting ? this : (this._clearReconnect(), this.disconnecting = !0, !e && Object.keys(this.outgoing).length > 0 ? this.once("outgoingEmpty", setTimeout.bind(null, i, 10)) : i(), this)
        }, g.prototype.removeOutgoingMessage = function (e) {
            var t = this.outgoing[e];
            return delete this.outgoing[e], this.outgoingStore.del({messageId: e}, function () {
                t(new Error("Message removed"))
            }), this
        }, g.prototype.reconnect = function (e) {
            var t = this, r = function () {
                e ? (t.options.incomingStore = e.incomingStore, t.options.outgoingStore = e.outgoingStore) : (t.options.incomingStore = null, t.options.outgoingStore = null), t.incomingStore = t.options.incomingStore || new o, t.outgoingStore = t.options.outgoingStore || new o, t.disconnecting = !1, t.disconnected = !1, t._deferredReconnect = null, t._reconnect()
            };
            return this.disconnecting && !this.disconnected ? this._deferredReconnect = r : r(), this
        }, g.prototype._reconnect = function () {
            this.emit("reconnect"), this._setupStream()
        }, g.prototype._setupReconnect = function () {
            var e = this;
            !e.disconnecting && !e.reconnectTimer && e.options.reconnectPeriod > 0 && (this.reconnecting || (this.emit("offline"), this.reconnecting = !0), e.reconnectTimer = setInterval(function () {
                e._reconnect()
            }, e.options.reconnectPeriod))
        }, g.prototype._clearReconnect = function () {
            this.reconnectTimer && (clearInterval(this.reconnectTimer), this.reconnectTimer = null)
        }, g.prototype._cleanUp = function (e, t) {
            t && this.stream.on("close", t), e ? (0 === this.options.reconnectPeriod && this.options.clean && function (e) {
                e && Object.keys(e).forEach(function (t) {
                    "function" == typeof e[t] && (e[t](new Error("Connection closed")), delete e[t])
                })
            }(this.outgoing), this.stream.destroy()) : this._sendPacket({cmd: "disconnect"}, p.bind(null, this.stream.end.bind(this.stream))), this.disconnecting || (this._clearReconnect(), this._setupReconnect()), null !== this.pingTimer && (this.pingTimer.clear(), this.pingTimer = null), t && !this.connected && (this.stream.removeListener("close", t), t())
        }, g.prototype._sendPacket = function (e, t) {
            if (this.connected) {
                switch (this._shiftPingInterval(), e.cmd) {
                    case"publish":
                        break;
                    case"pubrel":
                        return void _(this, e, t);
                    default:
                        return void m(this, e, t)
                }
                switch (e.qos) {
                    case 2:
                    case 1:
                        _(this, e, t);
                        break;
                    case 0:
                    default:
                        m(this, e, t)
                }
            } else 0 === (e.qos || 0) && this.queueQoSZero || "publish" !== e.cmd ? this.queue.push({
                packet: e,
                cb: t
            }) : e.qos > 0 ? (t = this.outgoing[e.messageId], this.outgoingStore.put(e, function (e) {
                if (e) return t && t(e)
            })) : t && t(new Error("No connection to broker"))
        }, g.prototype._setupPingTimer = function () {
            var e = this;
            !this.pingTimer && this.options.keepalive && (this.pingResp = !0, this.pingTimer = d(function () {
                e._checkPing()
            }, 1e3 * this.options.keepalive))
        }, g.prototype._shiftPingInterval = function () {
            this.pingTimer && this.options.keepalive && this.options.reschedulePings && this.pingTimer.reschedule(1e3 * this.options.keepalive)
        }, g.prototype._checkPing = function () {
            this.pingResp ? (this.pingResp = !1, this._sendPacket({cmd: "pingreq"})) : this._cleanUp(!0)
        }, g.prototype._handlePingresp = function () {
            this.pingResp = !0
        }, g.prototype._handleConnack = function (e) {
            var t = e.returnCode;
            if (clearTimeout(this.connackTimer), 0 === t) this.reconnecting = !1, this.emit("connect", e); else if (t > 0) {
                var r = new Error("Connection refused: " + ["", "Unacceptable protocol version", "Identifier rejected", "Server unavailable", "Bad username or password", "Not authorized"][t]);
                r.code = t, this.emit("error", r)
            }
        }, g.prototype._handlePublish = function (e, t) {
            t = void 0 !== t ? t : v;
            var r = e.topic.toString(), n = e.payload, i = e.qos, o = e.messageId, s = this;
            switch (i) {
                case 2:
                    this.incomingStore.put(e, function (e) {
                        if (e) return t(e);
                        s._sendPacket({cmd: "pubrec", messageId: o}, t)
                    });
                    break;
                case 1:
                    this.emit("message", r, n, e), this.handleMessage(e, function (e) {
                        if (e) return t(e);
                        s._sendPacket({cmd: "puback", messageId: o}, t)
                    });
                    break;
                case 0:
                    this.emit("message", r, n, e), this.handleMessage(e, t)
            }
        }, g.prototype.handleMessage = function (e, t) {
            t()
        }, g.prototype._handleAck = function (e) {
            var t = e.messageId, r = e.cmd, n = null, i = this.outgoing[t], o = this;
            if (i) {
                switch (r) {
                    case"pubcomp":
                    case"puback":
                        delete this.outgoing[t], this.outgoingStore.del(e, i);
                        break;
                    case"pubrec":
                        n = {cmd: "pubrel", qos: 2, messageId: t}, this._sendPacket(n);
                        break;
                    case"suback":
                        if (delete this.outgoing[t], 1 === e.granted.length && 0 != (128 & e.granted[0])) {
                            var s = this.messageIdToTopic[t];
                            s && s.forEach(function (e) {
                                delete o._resubscribeTopics[e]
                            })
                        }
                        i(null, e);
                        break;
                    case"unsuback":
                        delete this.outgoing[t], i(null);
                        break;
                    default:
                        o.emit("error", new Error("unrecognized packet type"))
                }
                this.disconnecting && 0 === Object.keys(this.outgoing).length && this.emit("outgoingEmpty")
            }
        }, g.prototype._handlePubrel = function (e, t) {
            t = void 0 !== t ? t : v;
            var r = this, n = {cmd: "pubcomp", messageId: e.messageId};
            r.incomingStore.get(e, function (i, o) {
                i || "pubrel" === o.cmd ? r._sendPacket(n, t) : (r.emit("message", o.topic, o.payload, o), r.incomingStore.put(e, function (e) {
                    if (e) return t(e);
                    r.handleMessage(o, function (e) {
                        if (e) return t(e);
                        r._sendPacket(n, t)
                    })
                }))
            })
        }, g.prototype._nextId = function () {
            var e = this.nextId++;
            return 65536 === this.nextId && (this.nextId = 1), e
        }, g.prototype.getLastMessageId = function () {
            return 1 === this.nextId ? 65535 : this.nextId - 1
        }, e.exports = g
    }).call(this, r(25), r(14))
}, function (e, t) {
}, function (e, t, r) {
    "use strict";
    var n = r(27).Buffer, i = r(285);

    function o(e, t, r) {
        e.copy(t, r)
    }

    e.exports = function () {
        function e() {
            !function (e, t) {
                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
            }(this, e), this.head = null, this.tail = null, this.length = 0
        }

        return e.prototype.push = function (e) {
            var t = {data: e, next: null};
            this.length > 0 ? this.tail.next = t : this.head = t, this.tail = t, ++this.length
        }, e.prototype.unshift = function (e) {
            var t = {data: e, next: this.head};
            0 === this.length && (this.tail = t), this.head = t, ++this.length
        }, e.prototype.shift = function () {
            if (0 !== this.length) {
                var e = this.head.data;
                return 1 === this.length ? this.head = this.tail = null : this.head = this.head.next, --this.length, e
            }
        }, e.prototype.clear = function () {
            this.head = this.tail = null, this.length = 0
        }, e.prototype.join = function (e) {
            if (0 === this.length) return "";
            for (var t = this.head, r = "" + t.data; t = t.next;) r += e + t.data;
            return r
        }, e.prototype.concat = function (e) {
            if (0 === this.length) return n.alloc(0);
            if (1 === this.length) return this.head.data;
            for (var t = n.allocUnsafe(e >>> 0), r = this.head, i = 0; r;) o(r.data, t, i), i += r.data.length, r = r.next;
            return t
        }, e
    }(), i && i.inspect && i.inspect.custom && (e.exports.prototype[i.inspect.custom] = function () {
        var e = i.inspect({length: this.length});
        return this.constructor.name + " " + e
    })
}, function (e, t) {
}, function (e, t, r) {
    (function (t) {
        function r(e) {
            try {
                if (!t.localStorage) return !1
            } catch (e) {
                return !1
            }
            var r = t.localStorage[e];
            return null != r && "true" === String(r).toLowerCase()
        }

        e.exports = function (e, t) {
            if (r("noDeprecation")) return e;
            var n = !1;
            return function () {
                if (!n) {
                    if (r("throwDeprecation")) throw new Error(t);
                    r("traceDeprecation") ? console.trace(t) : console.warn(t), n = !0
                }
                return e.apply(this, arguments)
            }
        }
    }).call(this, r(25))
}, function (e, t, r) {
    "use strict";
    e.exports = o;
    var n = r(136), i = Object.create(r(53));

    function o(e) {
        if (!(this instanceof o)) return new o(e);
        n.call(this, e)
    }

    i.inherits = r(26), i.inherits(o, n), o.prototype._transform = function (e, t, r) {
        r(null, e)
    }
}, function (e, t, r) {
    "use strict";
    e.exports = r(289)() ? Map : r(290)
}, function (e, t, r) {
    "use strict";
    e.exports = function () {
        var e, t;
        if ("function" != typeof Map) return !1;
        try {
            e = new Map([["raz", "one"], ["dwa", "two"], ["trzy", "three"]])
        } catch (e) {
            return !1
        }
        return "[object Map]" === String(e) && (3 === e.size && ("function" == typeof e.clear && ("function" == typeof e.delete && ("function" == typeof e.entries && ("function" == typeof e.forEach && ("function" == typeof e.get && ("function" == typeof e.has && ("function" == typeof e.keys && ("function" == typeof e.set && ("function" == typeof e.values && (!1 === (t = e.entries().next()).done && (!!t.value && ("raz" === t.value[0] && "one" === t.value[1])))))))))))))
    }
}, function (e, t, r) {
    "use strict";
    var n, i = r(137), o = r(292), s = r(57), a = r(37), c = r(30), u = r(28), d = r(311), l = r(31), h = r(145),
        p = r(321), f = r(339), m = r(342), _ = Function.prototype.call, v = Object.defineProperties,
        g = Object.getPrototypeOf;
    e.exports = n = function () {
        var e, t, r, i = arguments[0];
        if (!(this instanceof n)) throw new TypeError("Constructor requires 'new'");
        return r = m && s && Map !== n ? s(new Map, g(this)) : this, null != i && h(i), v(r, {
            __mapKeysData__: u("c", e = []),
            __mapValuesData__: u("c", t = [])
        }), i ? (p(i, function (r) {
            var n = c(r)[0];
            r = r[1], -1 === o.call(e, n) && (e.push(n), t.push(r))
        }, r), r) : r
    }, m && (s && s(n, Map), n.prototype = Object.create(Map.prototype, {constructor: u(n)})), d(v(n.prototype, {
        clear: u(function () {
            this.__mapKeysData__.length && (i.call(this.__mapKeysData__), i.call(this.__mapValuesData__), this.emit("_clear"))
        }), delete: u(function (e) {
            var t = o.call(this.__mapKeysData__, e);
            return -1 !== t && (this.__mapKeysData__.splice(t, 1), this.__mapValuesData__.splice(t, 1), this.emit("_delete", t, e), !0)
        }), entries: u(function () {
            return new f(this, "key+value")
        }), forEach: u(function (e) {
            var t, r, n = arguments[1];
            for (a(e), r = (t = this.entries())._next(); void 0 !== r;) _.call(e, n, this.__mapValuesData__[r], this.__mapKeysData__[r], this), r = t._next()
        }), get: u(function (e) {
            var t = o.call(this.__mapKeysData__, e);
            if (-1 !== t) return this.__mapValuesData__[t]
        }), has: u(function (e) {
            return -1 !== o.call(this.__mapKeysData__, e)
        }), keys: u(function () {
            return new f(this, "key")
        }), set: u(function (e, t) {
            var r, n = o.call(this.__mapKeysData__, e);
            return -1 === n && (n = this.__mapKeysData__.push(e) - 1, r = !0), this.__mapValuesData__[n] = t, r && this.emit("_add", n, e), this
        }), size: u.gs(function () {
            return this.__mapKeysData__.length
        }), values: u(function () {
            return new f(this, "value")
        }), toString: u(function () {
            return "[object Map]"
        })
    })), Object.defineProperty(n.prototype, l.iterator, u(function () {
        return this.entries()
    })), Object.defineProperty(n.prototype, l.toStringTag, u("c", "Map"))
}, function (e, t, r) {
    "use strict";
    e.exports = function () {
    }
}, function (e, t, r) {
    "use strict";
    var n = r(293), i = r(138), o = r(30), s = Array.prototype.indexOf, a = Object.prototype.hasOwnProperty,
        c = Math.abs, u = Math.floor;
    e.exports = function (e) {
        var t, r, d, l;
        if (!n(e)) return s.apply(this, arguments);
        for (r = i(o(this).length), d = arguments[1], t = d = isNaN(d) ? 0 : d >= 0 ? u(d) : i(this.length) - u(c(d)); t < r; ++t) if (a.call(this, t) && (l = this[t], n(l))) return t;
        return -1
    }
}, function (e, t, r) {
    "use strict";
    e.exports = r(294)() ? Number.isNaN : r(295)
}, function (e, t, r) {
    "use strict";
    e.exports = function () {
        var e = Number.isNaN;
        return "function" == typeof e && (!e({}) && e(NaN) && !e(34))
    }
}, function (e, t, r) {
    "use strict";
    e.exports = function (e) {
        return e != e
    }
}, function (e, t, r) {
    "use strict";
    var n = r(297), i = Math.abs, o = Math.floor;
    e.exports = function (e) {
        return isNaN(e) ? 0 : 0 !== (e = Number(e)) && isFinite(e) ? n(e) * o(i(e)) : e
    }
}, function (e, t, r) {
    "use strict";
    e.exports = r(298)() ? Math.sign : r(299)
}, function (e, t, r) {
    "use strict";
    e.exports = function () {
        var e = Math.sign;
        return "function" == typeof e && (1 === e(10) && -1 === e(-20))
    }
}, function (e, t, r) {
    "use strict";
    e.exports = function (e) {
        return e = Number(e), isNaN(e) || 0 === e ? e : e > 0 ? 1 : -1
    }
}, function (e, t, r) {
    "use strict";
    var n = r(42), i = {function: !0, object: !0};
    e.exports = function (e) {
        return n(e) && i[typeof e] || !1
    }
}, function (e, t, r) {
    "use strict";
    var n, i = Object.create;
    r(139)() || (n = r(140)), e.exports = function () {
        var e, t, r;
        return n ? 1 !== n.level ? i : (e = {}, t = {}, r = {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: void 0
        }, Object.getOwnPropertyNames(Object.prototype).forEach(function (e) {
            t[e] = "__proto__" !== e ? r : {configurable: !0, enumerable: !1, writable: !0, value: void 0}
        }), Object.defineProperties(e, t), Object.defineProperty(n, "nullPolyfill", {
            configurable: !1,
            enumerable: !1,
            writable: !1,
            value: e
        }), function (t, r) {
            return i(null === t ? e : t, r)
        }) : i
    }()
}, function (e, t, r) {
    "use strict";
    var n = r(303);
    e.exports = function (e) {
        if ("function" != typeof e) return !1;
        if (!hasOwnProperty.call(e, "length")) return !1;
        try {
            if ("number" != typeof e.length) return !1;
            if ("function" != typeof e.call) return !1;
            if ("function" != typeof e.apply) return !1
        } catch (e) {
            return !1
        }
        return !n(e)
    }
}, function (e, t, r) {
    "use strict";
    var n = r(90);
    e.exports = function (e) {
        if (!n(e)) return !1;
        try {
            return !!e.constructor && e.constructor.prototype === e
        } catch (e) {
            return !1
        }
    }
}, function (e, t, r) {
    "use strict";
    e.exports = function () {
        var e, t = Object.assign;
        return "function" == typeof t && (t(e = {foo: "raz"}, {bar: "dwa"}, {trzy: "trzy"}), e.foo + e.bar + e.trzy === "razdwatrzy")
    }
}, function (e, t, r) {
    "use strict";
    var n = r(306), i = r(30), o = Math.max;
    e.exports = function (e, t) {
        var r, s, a, c = o(arguments.length, 2);
        for (e = Object(i(e)), a = function (n) {
            try {
                e[n] = t[n]
            } catch (e) {
                r || (r = e)
            }
        }, s = 1; s < c; ++s) t = arguments[s], n(t).forEach(a);
        if (void 0 !== r) throw r;
        return e
    }
}, function (e, t, r) {
    "use strict";
    e.exports = r(307)() ? Object.keys : r(308)
}, function (e, t, r) {
    "use strict";
    e.exports = function () {
        try {
            return Object.keys("primitive"), !0
        } catch (e) {
            return !1
        }
    }
}, function (e, t, r) {
    "use strict";
    var n = r(42), i = Object.keys;
    e.exports = function (e) {
        return i(n(e) ? Object(e) : e)
    }
}, function (e, t, r) {
    "use strict";
    var n = "razdwatrzy";
    e.exports = function () {
        return "function" == typeof n.contains && (!0 === n.contains("dwa") && !1 === n.contains("foo"))
    }
}, function (e, t, r) {
    "use strict";
    var n = String.prototype.indexOf;
    e.exports = function (e) {
        return n.call(this, e, arguments[1]) > -1
    }
}, function (e, t, r) {
    "use strict";
    var n, i, o, s, a, c, u, d = r(28), l = r(37), h = Function.prototype.apply, p = Function.prototype.call,
        f = Object.create, m = Object.defineProperty, _ = Object.defineProperties, v = Object.prototype.hasOwnProperty,
        g = {configurable: !0, enumerable: !1, writable: !0};
    a = {
        on: n = function (e, t) {
            var r;
            return l(t), v.call(this, "__ee__") ? r = this.__ee__ : (r = g.value = f(null), m(this, "__ee__", g), g.value = null), r[e] ? "object" == typeof r[e] ? r[e].push(t) : r[e] = [r[e], t] : r[e] = t, this
        }, once: i = function (e, t) {
            var r, i;
            return l(t), i = this, n.call(this, e, r = function () {
                o.call(i, e, r), h.call(t, this, arguments)
            }), r.__eeOnceListener__ = t, this
        }, off: o = function (e, t) {
            var r, n, i, o;
            if (l(t), !v.call(this, "__ee__")) return this;
            if (!(r = this.__ee__)[e]) return this;
            if ("object" == typeof (n = r[e])) for (o = 0; i = n[o]; ++o) i !== t && i.__eeOnceListener__ !== t || (2 === n.length ? r[e] = n[o ? 0 : 1] : n.splice(o, 1)); else n !== t && n.__eeOnceListener__ !== t || delete r[e];
            return this
        }, emit: s = function (e) {
            var t, r, n, i, o;
            if (v.call(this, "__ee__") && (i = this.__ee__[e])) if ("object" == typeof i) {
                for (r = arguments.length, o = new Array(r - 1), t = 1; t < r; ++t) o[t - 1] = arguments[t];
                for (i = i.slice(), t = 0; n = i[t]; ++t) h.call(n, this, o)
            } else switch (arguments.length) {
                case 1:
                    p.call(i, this);
                    break;
                case 2:
                    p.call(i, this, arguments[1]);
                    break;
                case 3:
                    p.call(i, this, arguments[1], arguments[2]);
                    break;
                default:
                    for (r = arguments.length, o = new Array(r - 1), t = 1; t < r; ++t) o[t - 1] = arguments[t];
                    h.call(i, this, o)
            }
        }
    }, c = {on: d(n), once: d(i), off: d(o), emit: d(s)}, u = _({}, c), e.exports = t = function (e) {
        return null == e ? f(u) : _(Object(e), c)
    }, t.methods = a
}, function (e, t, r) {
    "use strict";
    var n = r(58), i = {object: !0, symbol: !0};
    e.exports = function () {
        var e, t = n.Symbol;
        if ("function" != typeof t) return !1;
        e = t("test symbol");
        try {
            String(e)
        } catch (e) {
            return !1
        }
        return !!i[typeof t.iterator] && (!!i[typeof t.toPrimitive] && !!i[typeof t.toStringTag])
    }
}, function (e, t, r) {
    "use strict";
    e.exports = function () {
        return "object" == typeof globalThis && (!!globalThis && globalThis.Array === Array)
    }
}, function (e, t) {
    var r = function () {
        if ("object" == typeof self && self) return self;
        if ("object" == typeof window && window) return window;
        throw new Error("Unable to resolve global `this`")
    };
    e.exports = function () {
        if (this) return this;
        try {
            Object.defineProperty(Object.prototype, "__global__", {
                get: function () {
                    return this
                }, configurable: !0
            })
        } catch (e) {
            return r()
        }
        try {
            return __global__ || r()
        } finally {
            delete Object.prototype.__global__
        }
    }()
}, function (e, t, r) {
    "use strict";
    var n, i, o, s = r(28), a = r(144), c = r(58).Symbol, u = r(317), d = r(318), l = r(319), h = Object.create,
        p = Object.defineProperties, f = Object.defineProperty;
    if ("function" == typeof c) try {
        String(c()), o = !0
    } catch (e) {
    } else c = null;
    i = function (e) {
        if (this instanceof i) throw new TypeError("Symbol is not a constructor");
        return n(e)
    }, e.exports = n = function e(t) {
        var r;
        if (this instanceof e) throw new TypeError("Symbol is not a constructor");
        return o ? c(t) : (r = h(i.prototype), t = void 0 === t ? "" : String(t), p(r, {
            __description__: s("", t),
            __name__: s("", u(t))
        }))
    }, d(n), l(n), p(i.prototype, {
        constructor: s(n), toString: s("", function () {
            return this.__name__
        })
    }), p(n.prototype, {
        toString: s(function () {
            return "Symbol (" + a(this).__description__ + ")"
        }), valueOf: s(function () {
            return a(this)
        })
    }), f(n.prototype, n.toPrimitive, s("", function () {
        var e = a(this);
        return "symbol" == typeof e ? e : e.toString()
    })), f(n.prototype, n.toStringTag, s("c", "Symbol")), f(i.prototype, n.toStringTag, s("c", n.prototype[n.toStringTag])), f(i.prototype, n.toPrimitive, s("c", n.prototype[n.toPrimitive]))
}, function (e, t, r) {
    "use strict";
    e.exports = function (e) {
        return !!e && ("symbol" == typeof e || !!e.constructor && ("Symbol" === e.constructor.name && "Symbol" === e[e.constructor.toStringTag]))
    }
}, function (e, t, r) {
    "use strict";
    var n = r(28), i = Object.create, o = Object.defineProperty, s = Object.prototype, a = i(null);
    e.exports = function (e) {
        for (var t, r, i = 0; a[e + (i || "")];) ++i;
        return a[e += i || ""] = !0, o(s, t = "@@" + e, n.gs(null, function (e) {
            r || (r = !0, o(this, t, n(e)), r = !1)
        })), t
    }
}, function (e, t, r) {
    "use strict";
    var n = r(28), i = r(58).Symbol;
    e.exports = function (e) {
        return Object.defineProperties(e, {
            hasInstance: n("", i && i.hasInstance || e("hasInstance")),
            isConcatSpreadable: n("", i && i.isConcatSpreadable || e("isConcatSpreadable")),
            iterator: n("", i && i.iterator || e("iterator")),
            match: n("", i && i.match || e("match")),
            replace: n("", i && i.replace || e("replace")),
            search: n("", i && i.search || e("search")),
            species: n("", i && i.species || e("species")),
            split: n("", i && i.split || e("split")),
            toPrimitive: n("", i && i.toPrimitive || e("toPrimitive")),
            toStringTag: n("", i && i.toStringTag || e("toStringTag")),
            unscopables: n("", i && i.unscopables || e("unscopables"))
        })
    }
}, function (e, t, r) {
    "use strict";
    var n = r(28), i = r(144), o = Object.create(null);
    e.exports = function (e) {
        return Object.defineProperties(e, {
            for: n(function (t) {
                return o[t] ? o[t] : o[t] = e(String(t))
            }), keyFor: n(function (e) {
                var t;
                for (t in i(e), o) if (o[t] === e) return t
            })
        })
    }
}, function (e, t, r) {
    "use strict";
    var n = r(59), i = r(42), o = r(60), s = r(31).iterator, a = Array.isArray;
    e.exports = function (e) {
        return !!i(e) && (!!a(e) || (!!o(e) || (!!n(e) || "function" == typeof e[s])))
    }
}, function (e, t, r) {
    "use strict";
    var n = r(59), i = r(37), o = r(60), s = r(322), a = Array.isArray, c = Function.prototype.call,
        u = Array.prototype.some;
    e.exports = function (e, t) {
        var r, d, l, h, p, f, m, _, v = arguments[2];
        if (a(e) || n(e) ? r = "array" : o(e) ? r = "string" : e = s(e), i(t), l = function () {
            h = !0
        }, "array" !== r) if ("string" !== r) for (d = e.next(); !d.done;) {
            if (c.call(t, v, d.value, l), h) return;
            d = e.next()
        } else for (f = e.length, p = 0; p < f && (m = e[p], p + 1 < f && (_ = m.charCodeAt(0)) >= 55296 && _ <= 56319 && (m += e[++p]), c.call(t, v, m, l), !h); ++p) ; else u.call(e, function (e) {
            return c.call(t, v, e, l), h
        })
    }
}, function (e, t, r) {
    "use strict";
    var n = r(59), i = r(60), o = r(323), s = r(338), a = r(145), c = r(31).iterator;
    e.exports = function (e) {
        return "function" == typeof a(e)[c] ? e[c]() : n(e) ? new o(e) : i(e) ? new s(e) : new o(e)
    }
}, function (e, t, r) {
    "use strict";
    var n, i = r(57), o = r(143), s = r(28), a = r(31), c = r(92), u = Object.defineProperty;
    n = e.exports = function (e, t) {
        if (!(this instanceof n)) throw new TypeError("Constructor requires 'new'");
        c.call(this, e), t = t ? o.call(t, "key+value") ? "key+value" : o.call(t, "key") ? "key" : "value" : "value", u(this, "__kind__", s("", t))
    }, i && i(n, c), delete n.prototype.constructor, n.prototype = Object.create(c.prototype, {
        _resolve: s(function (e) {
            return "value" === this.__kind__ ? this.__list__[e] : "key+value" === this.__kind__ ? [e, this.__list__[e]] : e
        })
    }), u(n.prototype, a.toStringTag, s("c", "Array Iterator"))
}, function (e, t, r) {
    "use strict";
    var n, i = r(43), o = r(325), s = r(329), a = r(330), c = r(142), u = r(335), d = Function.prototype.bind,
        l = Object.defineProperty, h = Object.prototype.hasOwnProperty;
    n = function (e, t, r) {
        var n, i = o(t) && s(t.value);
        return delete (n = a(t)).writable, delete n.value, n.get = function () {
            return !r.overwriteDefinition && h.call(this, e) ? i : (t.value = d.call(i, r.resolveContext ? r.resolveContext(this) : this), l(this, e, t), this[e])
        }, n
    }, e.exports = function (e) {
        var t = c(arguments[1]);
        return i(t.resolveContext) && s(t.resolveContext), u(e, function (e, r) {
            return n(r, e, t)
        })
    }
}, function (e, t, r) {
    "use strict";
    var n = r(146), i = r(43);
    e.exports = function (e) {
        return i(e) ? e : n(e, "Cannot use %v", arguments[1])
    }
}, function (e, t, r) {
    "use strict";
    var n = r(43), i = r(90), o = Object.prototype.toString;
    e.exports = function (e) {
        if (!n(e)) return null;
        if (i(e)) {
            var t = e.toString;
            if ("function" != typeof t) return null;
            if (t === o) return null
        }
        try {
            return "" + e
        } catch (e) {
            return null
        }
    }
}, function (e, t, r) {
    "use strict";
    var n = r(328), i = /[\n\r\u2028\u2029]/g;
    e.exports = function (e) {
        var t = n(e);
        return null === t ? "<Non-coercible to string value>" : (t.length > 100 && (t = t.slice(0, 99) + "?"), t = t.replace(i, function (e) {
            switch (e) {
                case"\n":
                    return "\\n";
                case"\r":
                    return "\\r";
                case"\u2028":
                    return "\\u2028";
                case"\u2029":
                    return "\\u2029";
                default:
                    throw new Error("Unexpected character")
            }
        }))
    }
}, function (e, t, r) {
    "use strict";
    e.exports = function (e) {
        try {
            return e.toString()
        } catch (t) {
            try {
                return String(e)
            } catch (e) {
                return null
            }
        }
    }
}, function (e, t, r) {
    "use strict";
    var n = r(146), i = r(141);
    e.exports = function (e) {
        return i(e) ? e : n(e, "%v is not a plain function", arguments[1])
    }
}, function (e, t, r) {
    "use strict";
    var n = r(331), i = r(91), o = r(30);
    e.exports = function (e) {
        var t = Object(o(e)), r = arguments[1], s = Object(arguments[2]);
        if (t !== e && !r) return t;
        var a = {};
        return r ? n(r, function (t) {
            (s.ensure || t in e) && (a[t] = e[t])
        }) : i(a, e), a
    }
}, function (e, t, r) {
    "use strict";
    e.exports = r(332)() ? Array.from : r(333)
}, function (e, t, r) {
    "use strict";
    e.exports = function () {
        var e, t, r = Array.from;
        return "function" == typeof r && (t = r(e = ["raz", "dwa"]), Boolean(t && t !== e && "dwa" === t[1]))
    }
}, function (e, t, r) {
    "use strict";
    var n = r(31).iterator, i = r(59), o = r(334), s = r(138), a = r(37), c = r(30), u = r(42), d = r(60),
        l = Array.isArray, h = Function.prototype.call,
        p = {configurable: !0, enumerable: !0, writable: !0, value: null}, f = Object.defineProperty;
    e.exports = function (e) {
        var t, r, m, _, v, g, E, y, S, b, T = arguments[1], R = arguments[2];
        if (e = Object(c(e)), u(T) && a(T), this && this !== Array && o(this)) t = this; else {
            if (!T) {
                if (i(e)) return 1 !== (v = e.length) ? Array.apply(null, e) : ((_ = new Array(1))[0] = e[0], _);
                if (l(e)) {
                    for (_ = new Array(v = e.length), r = 0; r < v; ++r) _[r] = e[r];
                    return _
                }
            }
            _ = []
        }
        if (!l(e)) if (void 0 !== (S = e[n])) {
            for (E = a(S).call(e), t && (_ = new t), y = E.next(), r = 0; !y.done;) b = T ? h.call(T, R, y.value, r) : y.value, t ? (p.value = b, f(_, r, p)) : _[r] = b, y = E.next(), ++r;
            v = r
        } else if (d(e)) {
            for (v = e.length, t && (_ = new t), r = 0, m = 0; r < v; ++r) b = e[r], r + 1 < v && (g = b.charCodeAt(0)) >= 55296 && g <= 56319 && (b += e[++r]), b = T ? h.call(T, R, b, m) : b, t ? (p.value = b, f(_, m, p)) : _[m] = b, ++m;
            v = m
        }
        if (void 0 === v) for (v = s(e.length), t && (_ = new t(v)), r = 0; r < v; ++r) b = T ? h.call(T, R, e[r], r) : e[r], t ? (p.value = b, f(_, r, p)) : _[r] = b;
        return t && (p.value = null, _.length = v), _
    }
}, function (e, t, r) {
    "use strict";
    var n = Object.prototype.toString, i = RegExp.prototype.test.bind(/^[object [A-Za-z0-9]*Function]$/);
    e.exports = function (e) {
        return "function" == typeof e && i(n.call(e))
    }
}, function (e, t, r) {
    "use strict";
    var n = r(37), i = r(336), o = Function.prototype.call;
    e.exports = function (e, t) {
        var r = {}, s = arguments[2];
        return n(t), i(e, function (e, n, i, a) {
            r[n] = o.call(t, s, e, n, i, a)
        }), r
    }
}, function (e, t, r) {
    "use strict";
    e.exports = r(337)("forEach")
}, function (e, t, r) {
    "use strict";
    var n = r(37), i = r(30), o = Function.prototype.bind, s = Function.prototype.call, a = Object.keys,
        c = Object.prototype.propertyIsEnumerable;
    e.exports = function (e, t) {
        return function (r, u) {
            var d, l = arguments[2], h = arguments[3];
            return r = Object(i(r)), n(u), d = a(r), h && d.sort("function" == typeof h ? o.call(h, r) : void 0), "function" != typeof e && (e = d[e]), s.call(e, d, function (e, n) {
                return c.call(r, e) ? s.call(u, l, r[e], e, r, n) : t
            })
        }
    }
}, function (e, t, r) {
    "use strict";
    var n, i = r(57), o = r(28), s = r(31), a = r(92), c = Object.defineProperty;
    n = e.exports = function (e) {
        if (!(this instanceof n)) throw new TypeError("Constructor requires 'new'");
        e = String(e), a.call(this, e), c(this, "__length__", o("", e.length))
    }, i && i(n, a), delete n.prototype.constructor, n.prototype = Object.create(a.prototype, {
        _next: o(function () {
            if (this.__list__) return this.__nextIndex__ < this.__length__ ? this.__nextIndex__++ : void this._unBind()
        }), _resolve: o(function (e) {
            var t, r = this.__list__[e];
            return this.__nextIndex__ === this.__length__ ? r : (t = r.charCodeAt(0)) >= 55296 && t <= 56319 ? r + this.__list__[this.__nextIndex__++] : r
        })
    }), c(n.prototype, s.toStringTag, o("c", "String Iterator"))
}, function (e, t, r) {
    "use strict";
    var n, i = r(57), o = r(28), s = r(92), a = r(31).toStringTag, c = r(340), u = Object.defineProperties,
        d = s.prototype._unBind;
    n = e.exports = function (e, t) {
        if (!(this instanceof n)) return new n(e, t);
        s.call(this, e.__mapKeysData__, e), t && c[t] || (t = "key+value"), u(this, {
            __kind__: o("", t),
            __values__: o("w", e.__mapValuesData__)
        })
    }, i && i(n, s), n.prototype = Object.create(s.prototype, {
        constructor: o(n), _resolve: o(function (e) {
            return "value" === this.__kind__ ? this.__values__[e] : "key" === this.__kind__ ? this.__list__[e] : [this.__list__[e], this.__values__[e]]
        }), _unBind: o(function () {
            this.__values__ = null, d.call(this)
        }), toString: o(function () {
            return "[object Map Iterator]"
        })
    }), Object.defineProperty(n.prototype, a, o("c", "Map Iterator"))
}, function (e, t, r) {
    "use strict";
    e.exports = r(341)("key", "value", "key+value")
}, function (e, t, r) {
    "use strict";
    var n = Array.prototype.forEach, i = Object.create;
    e.exports = function (e) {
        var t = i(null);
        return n.call(arguments, function (e) {
            t[e] = !0
        }), t
    }
}, function (e, t, r) {
    "use strict";
    e.exports = "undefined" != typeof Map && "[object Map]" === Object.prototype.toString.call(new Map)
}, function (e, t, r) {
    var n = r(344);

    function i(e) {
        var t = function () {
            return t.called ? t.value : (t.called = !0, t.value = e.apply(this, arguments))
        };
        return t.called = !1, t
    }

    function o(e) {
        var t = function () {
            if (t.called) throw new Error(t.onceError);
            return t.called = !0, t.value = e.apply(this, arguments)
        }, r = e.name || "Function wrapped with `once`";
        return t.onceError = r + " shouldn't be called more than once", t.called = !1, t
    }

    e.exports = n(i), e.exports.strict = n(o), i.proto = i(function () {
        Object.defineProperty(Function.prototype, "once", {
            value: function () {
                return i(this)
            }, configurable: !0
        }), Object.defineProperty(Function.prototype, "onceStrict", {
            value: function () {
                return o(this)
            }, configurable: !0
        })
    })
}, function (e, t) {
    e.exports = function e(t, r) {
        if (t && r) return e(t)(r);
        if ("function" != typeof t) throw new TypeError("need wrapper function");
        Object.keys(t).forEach(function (e) {
            n[e] = t[e]
        });
        return n;

        function n() {
            for (var e = new Array(arguments.length), r = 0; r < e.length; r++) e[r] = arguments[r];
            var n = t.apply(this, e), i = e[e.length - 1];
            return "function" == typeof n && n !== i && Object.keys(i).forEach(function (e) {
                n[e] = i[e]
            }), n
        }
    }
}, function (e, t, r) {
    "use strict";
    t.parser = r(346), t.generate = r(350), t.writeToStream = r(149)
}, function (e, t, r) {
    "use strict";
    var n = r(347), i = r(26), o = r(29).EventEmitter, s = r(349), a = r(148);

    function c() {
        if (!(this instanceof c)) return new c;
        this._states = ["_parseHeader", "_parseLength", "_parsePayload", "_newPacket"], this._resetState()
    }

    i(c, o), c.prototype._resetState = function () {
        this.packet = new s, this.error = null, this._list = n(), this._stateCounter = 0
    }, c.prototype.parse = function (e) {
        for (this.error && this._resetState(), this._list.append(e); (-1 !== this.packet.length || this._list.length > 0) && this[this._states[this._stateCounter]]() && !this.error;) this._stateCounter++, this._stateCounter >= this._states.length && (this._stateCounter = 0);
        return this._list.length
    }, c.prototype._parseHeader = function () {
        var e = this._list.readUInt8(0);
        return this.packet.cmd = a.types[e >> a.CMD_SHIFT], this.packet.retain = 0 != (e & a.RETAIN_MASK), this.packet.qos = e >> a.QOS_SHIFT & a.QOS_MASK, this.packet.dup = 0 != (e & a.DUP_MASK), this._list.consume(1), !0
    }, c.prototype._parseLength = function () {
        for (var e, t = 0, r = 1, n = 0, i = !0; t < 5 && (n += r * ((e = this._list.readUInt8(t++)) & a.LENGTH_MASK), r *= 128, 0 != (e & a.LENGTH_FIN_MASK));) if (this._list.length <= t) {
            i = !1;
            break
        }
        return i && (this.packet.length = n, this._list.consume(t)), i
    }, c.prototype._parsePayload = function () {
        var e = !1;
        if (0 === this.packet.length || this._list.length >= this.packet.length) {
            switch (this._pos = 0, this.packet.cmd) {
                case"connect":
                    this._parseConnect();
                    break;
                case"connack":
                    this._parseConnack();
                    break;
                case"publish":
                    this._parsePublish();
                    break;
                case"puback":
                case"pubrec":
                case"pubrel":
                case"pubcomp":
                    this._parseMessageId();
                    break;
                case"subscribe":
                    this._parseSubscribe();
                    break;
                case"suback":
                    this._parseSuback();
                    break;
                case"unsubscribe":
                    this._parseUnsubscribe();
                    break;
                case"unsuback":
                    this._parseUnsuback();
                    break;
                case"pingreq":
                case"pingresp":
                case"disconnect":
                    break;
                default:
                    this._emitError(new Error("Not supported"))
            }
            e = !0
        }
        return e
    }, c.prototype._parseConnect = function () {
        var e, t, r, n, i, o, s = {}, c = this.packet;
        if (null === (e = this._parseString())) return this._emitError(new Error("Cannot parse protocolId"));
        if ("MQTT" !== e && "MQIsdp" !== e) return this._emitError(new Error("Invalid protocolId"));
        if (c.protocolId = e, this._pos >= this._list.length) return this._emitError(new Error("Packet too short"));
        if (c.protocolVersion = this._list.readUInt8(this._pos), 3 !== c.protocolVersion && 4 !== c.protocolVersion) return this._emitError(new Error("Invalid protocol version"));
        if (this._pos++, this._pos >= this._list.length) return this._emitError(new Error("Packet too short"));
        if (s.username = this._list.readUInt8(this._pos) & a.USERNAME_MASK, s.password = this._list.readUInt8(this._pos) & a.PASSWORD_MASK, s.will = this._list.readUInt8(this._pos) & a.WILL_FLAG_MASK, s.will && (c.will = {}, c.will.retain = 0 != (this._list.readUInt8(this._pos) & a.WILL_RETAIN_MASK), c.will.qos = (this._list.readUInt8(this._pos) & a.WILL_QOS_MASK) >> a.WILL_QOS_SHIFT), c.clean = 0 != (this._list.readUInt8(this._pos) & a.CLEAN_SESSION_MASK), this._pos++, c.keepalive = this._parseNum(), -1 === c.keepalive) return this._emitError(new Error("Packet too short"));
        if (null === (t = this._parseString())) return this._emitError(new Error("Packet too short"));
        if (c.clientId = t, s.will) {
            if (null === (r = this._parseString())) return this._emitError(new Error("Cannot parse will topic"));
            if (c.will.topic = r, null === (n = this._parseBuffer())) return this._emitError(new Error("Cannot parse will payload"));
            c.will.payload = n
        }
        if (s.username) {
            if (null === (o = this._parseString())) return this._emitError(new Error("Cannot parse username"));
            c.username = o
        }
        if (s.password) {
            if (null === (i = this._parseBuffer())) return this._emitError(new Error("Cannot parse password"));
            c.password = i
        }
        return c
    }, c.prototype._parseConnack = function () {
        var e = this.packet;
        return this._list.length < 2 ? null : (e.sessionPresent = !!(this._list.readUInt8(this._pos++) & a.SESSIONPRESENT_MASK), e.returnCode = this._list.readUInt8(this._pos), -1 === e.returnCode ? this._emitError(new Error("Cannot parse return code")) : void 0)
    }, c.prototype._parsePublish = function () {
        var e = this.packet;
        if (e.topic = this._parseString(), null === e.topic) return this._emitError(new Error("Cannot parse topic"));
        e.qos > 0 && !this._parseMessageId() || (e.payload = this._list.slice(this._pos, e.length))
    }, c.prototype._parseSubscribe = function () {
        var e, t, r = this.packet;
        if (1 !== r.qos) return this._emitError(new Error("Wrong subscribe header"));
        if (r.subscriptions = [], this._parseMessageId()) for (; this._pos < r.length;) {
            if (null === (e = this._parseString())) return this._emitError(new Error("Cannot parse topic"));
            if (this._pos >= r.length) return this._emitError(new Error("Malformed Subscribe Payload"));
            t = this._list.readUInt8(this._pos++), r.subscriptions.push({topic: e, qos: t})
        }
    }, c.prototype._parseSuback = function () {
        if (this.packet.granted = [], this._parseMessageId()) for (; this._pos < this.packet.length;) this.packet.granted.push(this._list.readUInt8(this._pos++))
    }, c.prototype._parseUnsubscribe = function () {
        var e = this.packet;
        if (e.unsubscriptions = [], this._parseMessageId()) for (; this._pos < e.length;) {
            var t;
            if (null === (t = this._parseString())) return this._emitError(new Error("Cannot parse topic"));
            e.unsubscriptions.push(t)
        }
    }, c.prototype._parseUnsuback = function () {
        if (!this._parseMessageId()) return this._emitError(new Error("Cannot parse messageId"))
    }, c.prototype._parseMessageId = function () {
        var e = this.packet;
        return e.messageId = this._parseNum(), null !== e.messageId || (this._emitError(new Error("Cannot parse messageId")), !1)
    }, c.prototype._parseString = function (e) {
        var t, r = this._parseNum(), n = r + this._pos;
        return -1 === r || n > this._list.length || n > this.packet.length ? null : (t = this._list.toString("utf8", this._pos, n), this._pos += r, t)
    }, c.prototype._parseBuffer = function () {
        var e, t = this._parseNum(), r = t + this._pos;
        return -1 === t || r > this._list.length || r > this.packet.length ? null : (e = this._list.slice(this._pos, r), this._pos += t, e)
    }, c.prototype._parseNum = function () {
        if (this._list.length - this._pos < 2) return -1;
        var e = this._list.readUInt16BE(this._pos);
        return this._pos += 2, e
    }, c.prototype._newPacket = function () {
        return this.packet && (this._list.consume(this.packet.length), this.emit("packet", this.packet)), this.packet = new s, !0
    }, c.prototype._emitError = function (e) {
        this.error = e, this.emit("error", e)
    }, e.exports = c
}, function (e, t, r) {
    var n = r(348), i = r(50), o = r(27).Buffer;

    function s(e) {
        if (!(this instanceof s)) return new s(e);
        if (this._bufs = [], this.length = 0, "function" == typeof e) {
            this._callback = e;
            var t = function (e) {
                this._callback && (this._callback(e), this._callback = null)
            }.bind(this);
            this.on("pipe", function (e) {
                e.on("error", t)
            }), this.on("unpipe", function (e) {
                e.removeListener("error", t)
            })
        } else this.append(e);
        n.call(this)
    }

    i.inherits(s, n), s.prototype._offset = function (e) {
        var t, r = 0, n = 0;
        if (0 === e) return [0, 0];
        for (; n < this._bufs.length; n++) {
            if (e < (t = r + this._bufs[n].length) || n == this._bufs.length - 1) return [n, e - r];
            r = t
        }
    }, s.prototype.append = function (e) {
        var t = 0;
        if (o.isBuffer(e)) this._appendBuffer(e); else if (Array.isArray(e)) for (; t < e.length; t++) this.append(e[t]); else if (e instanceof s) for (; t < e._bufs.length; t++) this.append(e._bufs[t]); else null != e && ("number" == typeof e && (e = e.toString()), this._appendBuffer(o.from(e)));
        return this
    }, s.prototype._appendBuffer = function (e) {
        this._bufs.push(e), this.length += e.length
    }, s.prototype._write = function (e, t, r) {
        this._appendBuffer(e), "function" == typeof r && r()
    }, s.prototype._read = function (e) {
        if (!this.length) return this.push(null);
        e = Math.min(e, this.length), this.push(this.slice(0, e)), this.consume(e)
    }, s.prototype.end = function (e) {
        n.prototype.end.call(this, e), this._callback && (this._callback(null, this.slice()), this._callback = null)
    }, s.prototype.get = function (e) {
        return this.slice(e, e + 1)[0]
    }, s.prototype.slice = function (e, t) {
        return "number" == typeof e && e < 0 && (e += this.length), "number" == typeof t && t < 0 && (t += this.length), this.copy(null, 0, e, t)
    }, s.prototype.copy = function (e, t, r, n) {
        if (("number" != typeof r || r < 0) && (r = 0), ("number" != typeof n || n > this.length) && (n = this.length), r >= this.length) return e || o.alloc(0);
        if (n <= 0) return e || o.alloc(0);
        var i, s, a = !!e, c = this._offset(r), u = n - r, d = u, l = a && t || 0, h = c[1];
        if (0 === r && n == this.length) {
            if (!a) return 1 === this._bufs.length ? this._bufs[0] : o.concat(this._bufs, this.length);
            for (s = 0; s < this._bufs.length; s++) this._bufs[s].copy(e, l), l += this._bufs[s].length;
            return e
        }
        if (d <= this._bufs[c[0]].length - h) return a ? this._bufs[c[0]].copy(e, t, h, h + d) : this._bufs[c[0]].slice(h, h + d);
        for (a || (e = o.allocUnsafe(u)), s = c[0]; s < this._bufs.length; s++) {
            if (!(d > (i = this._bufs[s].length - h))) {
                this._bufs[s].copy(e, l, h, h + d), l += i;
                break
            }
            this._bufs[s].copy(e, l, h), l += i, d -= i, h && (h = 0)
        }
        return e.length > l ? e.slice(0, l) : e
    }, s.prototype.shallowSlice = function (e, t) {
        e = e || 0, t = t || this.length, e < 0 && (e += this.length), t < 0 && (t += this.length);
        var r = this._offset(e), n = this._offset(t), i = this._bufs.slice(r[0], n[0] + 1);
        return 0 == n[1] ? i.pop() : i[i.length - 1] = i[i.length - 1].slice(0, n[1]), 0 != r[1] && (i[0] = i[0].slice(r[1])), new s(i)
    }, s.prototype.toString = function (e, t, r) {
        return this.slice(t, r).toString(e)
    }, s.prototype.consume = function (e) {
        if (e = Math.trunc(e), Number.isNaN(e) || e <= 0) return this;
        for (; this._bufs.length;) {
            if (!(e >= this._bufs[0].length)) {
                this._bufs[0] = this._bufs[0].slice(e), this.length -= e;
                break
            }
            e -= this._bufs[0].length, this.length -= this._bufs[0].length, this._bufs.shift()
        }
        return this
    }, s.prototype.duplicate = function () {
        for (var e = 0, t = new s; e < this._bufs.length; e++) t.append(this._bufs[e]);
        return t
    }, s.prototype.destroy = function () {
        this._bufs.length = 0, this.length = 0, this.push(null)
    }, function () {
        var e = {
            readDoubleBE: 8,
            readDoubleLE: 8,
            readFloatBE: 4,
            readFloatLE: 4,
            readInt32BE: 4,
            readInt32LE: 4,
            readUInt32BE: 4,
            readUInt32LE: 4,
            readInt16BE: 2,
            readInt16LE: 2,
            readUInt16BE: 2,
            readUInt16LE: 2,
            readInt8: 1,
            readUInt8: 1
        };
        for (var t in e) !function (t) {
            s.prototype[t] = function (r) {
                return this.slice(r, r + e[t])[t](0)
            }
        }(t)
    }(), e.exports = s
}, function (e, t, r) {
    e.exports = r(36)
}, function (e, t) {
    e.exports = function () {
        this.cmd = null, this.retain = !1, this.qos = 0, this.dup = !1, this.length = -1, this.topic = null, this.payload = null
    }
}, function (e, t, r) {
    "use strict";
    var n = r(27).Buffer, i = r(149), o = r(29).EventEmitter;

    function s() {
        this._array = new Array(20), this._i = 0
    }

    r(26)(s, o), s.prototype.write = function (e) {
        return this._array[this._i++] = e, !0
    }, s.prototype.concat = function () {
        var e, t, r = 0, i = new Array(this._array.length), o = this._array, s = 0;
        for (e = 0; e < o.length && void 0 !== o[e]; e++) "string" != typeof o[e] ? i[e] = o[e].length : i[e] = n.byteLength(o[e]), r += i[e];
        for (t = n.allocUnsafe(r), e = 0; e < o.length && void 0 !== o[e]; e++) "string" != typeof o[e] ? (o[e].copy(t, s), s += i[e]) : (t.write(o[e], s), s += i[e]);
        return t
    }, e.exports = function (e) {
        var t = new s;
        return i(e, t), t.concat()
    }
}, function (e, t, r) {
    "use strict";
    var n = r(27).Buffer, i = 65536, o = {};

    function s(e) {
        var t = n.allocUnsafe(2);
        return t.writeUInt8(e >> 8, 0), t.writeUInt8(255 & e, 1), t
    }

    e.exports = {
        cache: o, generateCache: function () {
            for (var e = 0; e < i; e++) o[e] = s(e)
        }, generateNumber: s
    }
}, function (e, t, r) {
    "use strict";
    e.exports = function () {
        if ("function" != typeof arguments[0]) throw new Error("callback needed");
        if ("number" != typeof arguments[1]) throw new Error("interval needed");
        var e;
        if (arguments.length > 0) {
            e = new Array(arguments.length - 2);
            for (var t = 0; t < e.length; t++) e[t] = arguments[t + 2]
        }
        return new function (e, t, r) {
            var n = this;
            this._callback = e, this._args = r, this._interval = setInterval(e, t, this._args), this.reschedule = function (e) {
                e || (e = n._interval), n._interval && clearInterval(n._interval), n._interval = setInterval(n._callback, e, n._args)
            }, this.clear = function () {
                n._interval && (clearInterval(n._interval), n._interval = void 0)
            }, this.destroy = function () {
                n._interval && clearInterval(n._interval), n._callback = void 0, n._interval = void 0, n._args = void 0
            }
        }(arguments[0], arguments[1], e)
    }
}, function (e, t, r) {
    "use strict";

    function n(e) {
        for (var t = e.split("/"), r = 0; r < t.length; r++) if ("+" !== t[r]) {
            if ("#" === t[r]) return r === t.length - 1;
            if (-1 !== t[r].indexOf("+") || -1 !== t[r].indexOf("#")) return !1
        }
        return !0
    }

    e.exports = {
        validateTopics: function (e) {
            if (0 === e.length) return "empty_topic_list";
            for (var t = 0; t < e.length; t++) if (!n(e[t])) return e[t];
            return null
        }
    }
}, function (e, t) {
}, function (e, t) {
}, function (e, t, r) {
    (function (t, n) {
        var i = r(56), o = r(147), s = r(26), a = r(357),
            c = t.from && t.from !== Uint8Array.from ? t.from([0]) : new t([0]), u = function (e, t) {
                e._corked ? e.once("uncork", t) : t()
            }, d = function (e, t) {
                return function (r) {
                    r ? function (e, t) {
                        e._autoDestroy && e.destroy(t)
                    }(e, "premature close" === r.message ? null : r) : t && !e._ended && e.end()
                }
            }, l = function (e, t, r) {
                if (!(this instanceof l)) return new l(e, t, r);
                i.Duplex.call(this, r), this._writable = null, this._readable = null, this._readable2 = null, this._autoDestroy = !r || !1 !== r.autoDestroy, this._forwardDestroy = !r || !1 !== r.destroy, this._forwardEnd = !r || !1 !== r.end, this._corked = 1, this._ondrain = null, this._drained = !1, this._forwarding = !1, this._unwrite = null, this._unread = null, this._ended = !1, this.destroyed = !1, e && this.setWritable(e), t && this.setReadable(t)
            };
        s(l, i.Duplex), l.obj = function (e, t, r) {
            return r || (r = {}), r.objectMode = !0, r.highWaterMark = 16, new l(e, t, r)
        }, l.prototype.cork = function () {
            1 == ++this._corked && this.emit("cork")
        }, l.prototype.uncork = function () {
            this._corked && 0 == --this._corked && this.emit("uncork")
        }, l.prototype.setWritable = function (e) {
            if (this._unwrite && this._unwrite(), this.destroyed) e && e.destroy && e.destroy(); else if (null !== e && !1 !== e) {
                var t = this, r = o(e, {writable: !0, readable: !1}, d(this, this._forwardEnd)), i = function () {
                    var e = t._ondrain;
                    t._ondrain = null, e && e()
                };
                this._unwrite && n.nextTick(i), this._writable = e, this._writable.on("drain", i), this._unwrite = function () {
                    t._writable.removeListener("drain", i), r()
                }, this.uncork()
            } else this.end()
        }, l.prototype.setReadable = function (e) {
            if (this._unread && this._unread(), this.destroyed) e && e.destroy && e.destroy(); else {
                if (null === e || !1 === e) return this.push(null), void this.resume();
                var t = this, r = o(e, {writable: !1, readable: !0}, d(this)), n = function () {
                    t._forward()
                }, s = function () {
                    t.push(null)
                };
                this._drained = !0, this._readable = e, this._readable2 = e._readableState ? e : function (e) {
                    return new i.Readable({objectMode: !0, highWaterMark: 16}).wrap(e)
                }(e), this._readable2.on("readable", n), this._readable2.on("end", s), this._unread = function () {
                    t._readable2.removeListener("readable", n), t._readable2.removeListener("end", s), r()
                }, this._forward()
            }
        }, l.prototype._read = function () {
            this._drained = !0, this._forward()
        }, l.prototype._forward = function () {
            if (!this._forwarding && this._readable2 && this._drained) {
                var e;
                for (this._forwarding = !0; this._drained && null !== (e = a(this._readable2));) this.destroyed || (this._drained = this.push(e));
                this._forwarding = !1
            }
        }, l.prototype.destroy = function (e) {
            if (!this.destroyed) {
                this.destroyed = !0;
                var t = this;
                n.nextTick(function () {
                    t._destroy(e)
                })
            }
        }, l.prototype._destroy = function (e) {
            if (e) {
                var t = this._ondrain;
                this._ondrain = null, t ? t(e) : this.emit("error", e)
            }
            this._forwardDestroy && (this._readable && this._readable.destroy && this._readable.destroy(), this._writable && this._writable.destroy && this._writable.destroy()), this.emit("close")
        }, l.prototype._write = function (e, t, r) {
            return this.destroyed ? r() : this._corked ? u(this, this._write.bind(this, e, t, r)) : e === c ? this._finish(r) : this._writable ? void (!1 === this._writable.write(e) ? this._ondrain = r : r()) : r()
        }, l.prototype._finish = function (e) {
            var t = this;
            this.emit("preend"), u(this, function () {
                !function (e, t) {
                    e ? e._writableState && e._writableState.finished ? t() : e._writableState ? e.end(t) : (e.end(), t()) : t()
                }(t._forwardEnd && t._writable, function () {
                    !1 === t._writableState.prefinished && (t._writableState.prefinished = !0), t.emit("prefinish"), u(t, e)
                })
            })
        }, l.prototype.end = function (e, t, r) {
            return "function" == typeof e ? this.end(null, null, e) : "function" == typeof t ? this.end(e, null, t) : (this._ended = !0, e && this.write(e), this._writableState.ending || this.write(c), i.Writable.prototype.end.call(this, r))
        }, e.exports = l
    }).call(this, r(22).Buffer, r(14))
}, function (e, t) {
    e.exports = function (e) {
        var t = e._readableState;
        return t ? t.objectMode || "number" == typeof e._duplexState ? e.read() : e.read(function (e) {
            return e.buffer.length ? e.buffer.head ? e.buffer.head.data.length : e.buffer[0].length : e.length
        }(t)) : null
    }
}, function (e, t) {
    var r = null;
    "undefined" != typeof WebSocket ? r = WebSocket : "undefined" != typeof MozWebSocket ? r = MozWebSocket : "undefined" != typeof window && (r = window.WebSocket || window.MozWebSocket), e.exports = r
}, function (e, t, r) {
    e.exports = function (e) {
        return e.HmacSHA256
    }(r(95), r(153), r(360))
}, function (e, t, r) {
    e.exports = function (e) {
        !function () {
            var t = e, r = t.lib, n = r.Base, i = t.enc, o = i.Utf8, s = t.algo;
            s.HMAC = n.extend({
                init: function (e, t) {
                    e = this._hasher = new e.init, "string" == typeof t && (t = o.parse(t));
                    var r = e.blockSize, n = 4 * r;
                    t.sigBytes > n && (t = e.finalize(t)), t.clamp();
                    for (var i = this._oKey = t.clone(), s = this._iKey = t.clone(), a = i.words, c = s.words, u = 0; u < r; u++) a[u] ^= 1549556828, c[u] ^= 909522486;
                    i.sigBytes = s.sigBytes = n, this.reset()
                }, reset: function () {
                    var e = this._hasher;
                    e.reset(), e.update(this._iKey)
                }, update: function (e) {
                    return this._hasher.update(e), this
                }, finalize: function (e) {
                    var t = this._hasher, r = t.finalize(e);
                    t.reset();
                    var n = t.finalize(this._oKey.clone().concat(r));
                    return n
                }
            })
        }()
    }(r(95))
}, function (e, t) {
    e.exports = {
        INVALID_CONNECT_OPTIONS: "Invalid connect options supplied.",
        INVALID_CLIENT_ID_OPTION: 'Invalid "clientId" (mqtt client id) option supplied.',
        INVALID_RECONNECT_TIMING: "Invalid reconnect timing options supplied.",
        INVALID_OFFLINE_QUEUEING_PARAMETERS: "Invalid offline queueing options supplied."
    }
}, function (e, t, r) {
    (function (t) {
        var n = r(96), i = r(61), o = r(363);
        e.exports = function (e) {
            if (i(e.keyPath) && i(e.privateKey)) throw new Error(o.NO_KEY_OPTION);
            if (i(e.certPath) && i(e.clientCert)) throw new Error(o.NO_CERT_OPTION);
            if (i(e.caPath) && i(e.caCert)) throw new Error(o.NO_CA_OPTION);
            if (!i(e.caCert)) if (t.isBuffer(e.caCert)) e.ca = e.caCert; else {
                if (!n.existsSync(e.caCert)) throw new Error(o.INVALID_CA_CERT_OPTION);
                e.ca = n.readFileSync(e.caCert)
            }
            if (!i(e.privateKey)) if (t.isBuffer(e.privateKey)) e.key = e.privateKey; else {
                if (!n.existsSync(e.privateKey)) throw new Error(o.INVALID_PRIVATE_KEY_OPTION);
                e.key = n.readFileSync(e.privateKey)
            }
            if (!i(e.clientCert)) if (t.isBuffer(e.clientCert)) e.cert = e.clientCert; else {
                if (!n.existsSync(e.clientCert)) throw new Error(o.INVALID_CLIENT_CERT_OPTION);
                e.cert = n.readFileSync(e.clientCert)
            }
            if (n.existsSync(e.keyPath)) e.key = n.readFileSync(e.keyPath); else if (!i(e.keyPath)) throw new Error(o.INVALID_KEY_PATH_OPTION);
            if (n.existsSync(e.certPath)) e.cert = n.readFileSync(e.certPath); else if (!i(e.certPath)) throw new Error(o.INVALID_CERT_PATH_OPTION);
            if (n.existsSync(e.caPath)) e.ca = n.readFileSync(e.caPath); else if (!i(e.caPath)) throw new Error(o.INVALID_CA_PATH_OPTION);
            e.requestCert = !0, e.rejectUnauthorized = !0
        }
    }).call(this, r(22).Buffer)
}, function (e, t) {
    e.exports = {
        NO_KEY_OPTION: 'No "keyPath" or "privateKey" option supplied.',
        NO_CERT_OPTION: 'No "certPath" or "clientCert" option supplied.',
        NO_CA_OPTION: 'No "caPath" or "caCert" option supplied.',
        INVALID_KEY_PATH_OPTION: 'Invalid "keyPath" option supplied.',
        INVALID_CERT_PATH_OPTION: 'Invalid "certPath" option supplied.',
        INVALID_CA_PATH_OPTION: 'Invalid "caPath" option supplied.',
        INVALID_CLIENT_CERT_OPTION: 'Invalid "clientCert" option supplied.',
        INVALID_PRIVATE_KEY_OPTION: 'Invalid "privateKey" option supplied.',
        INVALID_CA_CERT_OPTION: 'Invalid "caCert" option supplied.'
    }
}, function (e, t, r) {
    (function (e) {
        function r(e, t) {
            for (var r = 0, n = e.length - 1; n >= 0; n--) {
                var i = e[n];
                "." === i ? e.splice(n, 1) : ".." === i ? (e.splice(n, 1), r++) : r && (e.splice(n, 1), r--)
            }
            if (t) for (; r--; r) e.unshift("..");
            return e
        }

        function n(e, t) {
            if (e.filter) return e.filter(t);
            for (var r = [], n = 0; n < e.length; n++) t(e[n], n, e) && r.push(e[n]);
            return r
        }

        t.resolve = function () {
            for (var t = "", i = !1, o = arguments.length - 1; o >= -1 && !i; o--) {
                var s = o >= 0 ? arguments[o] : e.cwd();
                if ("string" != typeof s) throw new TypeError("Arguments to path.resolve must be strings");
                s && (t = s + "/" + t, i = "/" === s.charAt(0))
            }
            return t = r(n(t.split("/"), function (e) {
                return !!e
            }), !i).join("/"), (i ? "/" : "") + t || "."
        }, t.normalize = function (e) {
            var o = t.isAbsolute(e), s = "/" === i(e, -1);
            return (e = r(n(e.split("/"), function (e) {
                return !!e
            }), !o).join("/")) || o || (e = "."), e && s && (e += "/"), (o ? "/" : "") + e
        }, t.isAbsolute = function (e) {
            return "/" === e.charAt(0)
        }, t.join = function () {
            var e = Array.prototype.slice.call(arguments, 0);
            return t.normalize(n(e, function (e, t) {
                if ("string" != typeof e) throw new TypeError("Arguments to path.join must be strings");
                return e
            }).join("/"))
        }, t.relative = function (e, r) {
            function n(e) {
                for (var t = 0; t < e.length && "" === e[t]; t++) ;
                for (var r = e.length - 1; r >= 0 && "" === e[r]; r--) ;
                return t > r ? [] : e.slice(t, r - t + 1)
            }

            e = t.resolve(e).substr(1), r = t.resolve(r).substr(1);
            for (var i = n(e.split("/")), o = n(r.split("/")), s = Math.min(i.length, o.length), a = s, c = 0; c < s; c++) if (i[c] !== o[c]) {
                a = c;
                break
            }
            var u = [];
            for (c = a; c < i.length; c++) u.push("..");
            return (u = u.concat(o.slice(a))).join("/")
        }, t.sep = "/", t.delimiter = ":", t.dirname = function (e) {
            if ("string" != typeof e && (e += ""), 0 === e.length) return ".";
            for (var t = e.charCodeAt(0), r = 47 === t, n = -1, i = !0, o = e.length - 1; o >= 1; --o) if (47 === (t = e.charCodeAt(o))) {
                if (!i) {
                    n = o;
                    break
                }
            } else i = !1;
            return -1 === n ? r ? "/" : "." : r && 1 === n ? "/" : e.slice(0, n)
        }, t.basename = function (e, t) {
            var r = function (e) {
                "string" != typeof e && (e += "");
                var t, r = 0, n = -1, i = !0;
                for (t = e.length - 1; t >= 0; --t) if (47 === e.charCodeAt(t)) {
                    if (!i) {
                        r = t + 1;
                        break
                    }
                } else -1 === n && (i = !1, n = t + 1);
                return -1 === n ? "" : e.slice(r, n)
            }(e);
            return t && r.substr(-1 * t.length) === t && (r = r.substr(0, r.length - t.length)), r
        }, t.extname = function (e) {
            "string" != typeof e && (e += "");
            for (var t = -1, r = 0, n = -1, i = !0, o = 0, s = e.length - 1; s >= 0; --s) {
                var a = e.charCodeAt(s);
                if (47 !== a) -1 === n && (i = !1, n = s + 1), 46 === a ? -1 === t ? t = s : 1 !== o && (o = 1) : -1 !== t && (o = -1); else if (!i) {
                    r = s + 1;
                    break
                }
            }
            return -1 === t || -1 === n || 0 === o || 1 === o && t === n - 1 && t === r + 1 ? "" : e.slice(t, n)
        };
        var i = "b" === "ab".substr(-1) ? function (e, t, r) {
            return e.substr(t, r)
        } : function (e, t, r) {
            return t < 0 && (t = e.length + t), e.substr(t, r)
        }
    }).call(this, r(14))
}, function (e) {
    e.exports = JSON.parse('{"_args":[["aws-iot-device-sdk@2.2.6","/Users/bigstep/Documents/Channelize-Livestream-Ecommerce-JSSDK"]],"_from":"aws-iot-device-sdk@2.2.6","_id":"aws-iot-device-sdk@2.2.6","_inBundle":false,"_integrity":"sha512-W481pAghXqF2PDrsFwQ6o0ngQfp0TOq78z8JuEHSrI2jhOynvsQzT2uTSl3lc2/rB8nLxJh6Ev7L/Xs+QD8NFQ==","_location":"/aws-iot-device-sdk","_phantomChildren":{},"_requested":{"type":"version","registry":true,"raw":"aws-iot-device-sdk@2.2.6","name":"aws-iot-device-sdk","escapedName":"aws-iot-device-sdk","rawSpec":"2.2.6","saveSpec":null,"fetchSpec":"2.2.6"},"_requiredBy":["/"],"_resolved":"https://registry.npmjs.org/aws-iot-device-sdk/-/aws-iot-device-sdk-2.2.6.tgz","_spec":"2.2.6","_where":"/Users/bigstep/Documents/Channelize-Livestream-Ecommerce-JSSDK","author":{"name":"Amazon Web Services","url":"http://aws.amazon.com"},"bugs":{"url":"http://github.com/aws/aws-iot-device-sdk-js/issues"},"dependencies":{"crypto-js":"3.1.6","minimist":"1.2.5","mqtt":"2.18.8","websocket-stream":"^5.0.1"},"description":"AWS IoT Node.js SDK for Embedded Devices","devDependencies":{"gulp":"^3.9.0","gulp-beautify":"^2.0.0","gulp-concat":"^2.6.0","gulp-coverage":"^0.3.38","gulp-jscs":"^4.0.0","gulp-jshint":"^2.0.0","gulp-mocha":"^3.0.1","jshint":"^2.9.1","jshint-stylish":"^2.2.1","rewire":"^2.5.1","sinon":"^1.17.3"},"engines":{"node":">=4.0.0"},"homepage":"https://github.com/aws/aws-iot-device-sdk-js","keywords":["api","amazon","aws","iot","mqtt"],"license":"Apache-2.0","main":"index.js","name":"aws-iot-device-sdk","repository":{"type":"git","url":"git://github.com/aws/aws-iot-device-sdk-js.git"},"scripts":{"beautify":"node ./node_modules/gulp/bin/gulp.js beautify","browserize":"./scripts/browserize.sh","test":"node ./node_modules/gulp/bin/gulp.js test --verbose"},"version":"2.2.6"}')
}, function (e, t, r) {
    var n = r(96);
    e.exports = function (e, t) {
        var r;

        function i(t) {
            e.emit("error", t), r.end()
        }

        return (r = n.connect(t)).on("secureConnect", function () {
            r.authorized ? r.removeListener("error", i) : r.emit("error", new Error("TLS not authorized"))
        }), r.on("error", i), r
    }
}, function (e, t, r) {
    const n = r(94);
    e.exports = function (e, t) {
        return n(t.url, ["mqttv3.1"], t.websocketOptions)
    }
}, function (e, t, r) {
    var n = r(29), i = r(50).inherits, o = r(88), s = r(61);

    function a(e, t, r) {
        return s(r) ? "$aws/things/" + e + "/shadow/" + t : "$aws/things/" + e + "/shadow/" + t + "/" + r
    }

    function c(e) {
        return "$aws/things/" === e.substring(0, 12)
    }

    function u(e, t) {
        if (!(this instanceof u)) return new u(e, t);
        var r = this, i = [{}], d = 0, l = 1e4, h = !0, p = o.DeviceClient(e);
        s(t) || s(t.operationTimeout) || (l = t.operationTimeout), this._handleSubscriptions = function (e, t, r, n) {
            for (var o = [], c = 0, u = t.length; c < u; c++) for (var d = 0, l = t[c].operations.length; d < l; d++) for (var h = 0, f = t[c].statii.length; h < f; h++) o.push(a(e, t[c].operations[d], t[c].statii[h]));
            !0 === i[e].debug && console.log(r + " on " + o);
            var m = [];
            m.push(o), "subscribe" === r ? (m.push({qos: i[e].qos}), m.push(function (e, t) {
                if (!s(n)) {
                    if (e) return void n(e);
                    for (var r = [], i = 0, o = t.length; i < o; i++) 128 === t[i].qos && r.push(t[i]);
                    if (r.length > 0) return void n("Not all subscriptions were granted", r);
                    n()
                }
            })) : s(n) || m.push(n), p[r].apply(p, m)
        }, this._handleMessages = function (t, r, n, o) {
            var a = {};
            try {
                a = JSON.parse(o.toString())
            } catch (t) {
                return void (!0 === e.debug && console.error("failed parsing JSON '" + o.toString() + "', " + t))
            }
            var c = a.clientToken, u = a.version;
            if (delete a.clientToken, !s(u) && "rejected" !== n) if (s(i[t].version) || u >= i[t].version) i[t].version = u; else if ("delete" !== r && !0 === i[t].discardStale) return void (!0 === e.debug && console.warn("out-of-date version '" + u + "' on '" + t + "' (local version '" + i[t].version + "')"));
            "delta" !== n ? s(i[t].clientToken) || i[t].clientToken !== c ? "accepted" === n && "get" !== r && this.emit("foreignStateChange", t, r, a) : (clearTimeout(i[t].timeout), delete i[t].timeout, delete i[t].clientToken, i[t].pending = !1, !1 === i[t].persistentSubscribe && this._handleSubscriptions(t, [{
                operations: [r],
                statii: ["accepted", "rejected"]
            }], "unsubscribe"), this.emit("status", t, n, c, a)) : this.emit("delta", t, a)
        }, p.on("connect", function () {
            r.emit("connect")
        }), p.on("close", function () {
            r.emit("close")
        }), p.on("reconnect", function () {
            r.emit("reconnect")
        }), p.on("offline", function () {
            r.emit("offline")
        }), p.on("error", function (e) {
            r.emit("error", e)
        }), p.on("packetsend", function (e) {
            r.emit("packetsend", e)
        }), p.on("packetreceive", function (e) {
            r.emit("packetreceive", e)
        }), p.on("message", function (e, t) {
            if (!0 === h) {
                var n = e.split("/");
                !function (e, t) {
                    var r = !1;
                    return "$aws" === e[0] && ("things" !== e[1] || "shadow" !== e[3] || "update" !== e[4] && "get" !== e[4] && "delete" !== e[4] || ("subscribe" === t ? "accepted" !== e[5] && "rejected" !== e[5] && "delta" !== e[5] || 6 !== e.length || (r = !0) : 5 === e.length && (r = !0))), r
                }(n, "subscribe") ? r.emit("message", e, t) : i.hasOwnProperty(n[2]) && r._handleMessages(n[2], n[4], n[5], t)
            }
        }), this._thingOperation = function (t, n, o) {
            var c = null;
            if (i.hasOwnProperty(t)) if (!1 === i[t].pending) {
                var u;
                if (i[t].pending = !0, s(o.clientToken)) {
                    var h = e.clientId.length;
                    u = h > 48 ? e.clientId.substr(h - 48) + "-" + d++ : e.clientId + "-" + d++
                } else u = o.clientToken;
                i[t].clientToken = u;
                var f = a(t, n);
                i[t].timeout = setTimeout(function (e, t) {
                    !1 === i[e].persistentSubscribe && r._handleSubscriptions(e, [{
                        operations: [n],
                        statii: ["accepted", "rejected"]
                    }], "unsubscribe"), i[e].pending = !1, delete i[e].timeout, delete i[e].clientToken, r.emit("timeout", e, t)
                }, l, t, u), !1 === i[t].persistentSubscribe ? this._handleSubscriptions(t, [{
                    operations: [n],
                    statii: ["accepted", "rejected"]
                }], "subscribe", function (e, r) {
                    s(e) && s(r) ? s(o) || (!s(i[t].version) && i[t].enableVersioning && (o.version = i[t].version), o.clientToken = u, p.publish(f, JSON.stringify(o), {qos: i[t].qos}), s(i[t]) || !0 !== i[t].debug || console.log("publishing '" + JSON.stringify(o) + " on '" + f + "'")) : console.warn("failed subscription to accepted/rejected topics")
                }) : (!s(i[t].version) && i[t].enableVersioning && (o.version = i[t].version), o.clientToken = u, p.publish(f, JSON.stringify(o), {qos: i[t].qos}), !0 === i[t].debug && console.log("publishing '" + JSON.stringify(o) + " on '" + f + "'")), c = u
            } else !0 === e.debug && console.error(n + " still in progress on thing: ", t); else !0 === e.debug && console.error("attempting to " + n + " unknown thing: ", t);
            return c
        }, this.register = function (t, r, n) {
            if (i.hasOwnProperty(t)) !0 === e.debug && console.error("thing already registered: ", t); else {
                var o = !1, a = [];
                i[t] = {
                    persistentSubscribe: !0,
                    debug: !1,
                    discardStale: !0,
                    enableVersioning: !0,
                    qos: 0,
                    pending: !0
                }, "function" == typeof r && (n = r, r = null), s(r) || (s(r.ignoreDeltas) || (o = r.ignoreDeltas), s(r.persistentSubscribe) || (i[t].persistentSubscribe = r.persistentSubscribe), s(r.debug) || (i[t].debug = r.debug), s(r.discardStale) || (i[t].discardStale = r.discardStale), s(r.enableVersioning) || (i[t].enableVersioning = r.enableVersioning), s(r.qos) || (i[t].qos = r.qos)), !1 === o && a.push({
                    operations: ["update"],
                    statii: ["delta"]
                }), !0 === i[t].persistentSubscribe && a.push({
                    operations: ["update", "get", "delete"],
                    statii: ["accepted", "rejected"]
                }), a.length > 0 ? this._handleSubscriptions(t, a, "subscribe", function (e, r) {
                    s(e) && s(r) && (i[t].pending = !1), s(n) || n(e, r)
                }) : (i[t].pending = !1, s(n) || n())
            }
        }, this.unregister = function (t) {
            if (i.hasOwnProperty(t)) {
                var r = [];
                r.push({
                    operations: ["update"],
                    statii: ["delta"]
                }), !0 === i[t].persistentSubscribe && r.push({
                    operations: ["update", "get", "delete"],
                    statii: ["accepted", "rejected"]
                }), this._handleSubscriptions(t, r, "unsubscribe"), s(i[t].timeout) || clearTimeout(i[t].timeout), delete i[t]
            } else !0 === e.debug && console.error("attempting to unregister unknown thing: ", t)
        }, this.update = function (e, t) {
            var n = null;
            return s(t.version) ? n = r._thingOperation(e, "update", t) : console.error("message can't contain 'version' property"), n
        }, this.get = function (e, t) {
            var n = {};
            return s(t) || (n.clientToken = t), r._thingOperation(e, "get", n)
        }, this.delete = function (e, t) {
            var n = {};
            return s(t) || (n.clientToken = t), r._thingOperation(e, "delete", n)
        }, this.publish = function (e, t, r, n) {
            if (c(e)) throw"cannot publish to reserved topic '" + e + "'";
            p.publish(e, t, r, n)
        }, this.subscribe = function (e, t, r) {
            var n = [];
            "string" == typeof e ? n.push(e) : "object" == typeof e && e.length && (n = e);
            for (var i = 0; i < n.length; i++) if (c(n[i])) throw"cannot subscribe to topic array since one of them is a reserved topic '" + n[i] + "'";
            p.subscribe(n, t, r)
        }, this.unsubscribe = function (e, t) {
            var r = [];
            "string" == typeof e ? r.push(e) : "object" == typeof e && e.length && (r = e);
            for (var n = 0; n < r.length; n++) if (c(r[n])) throw"cannot unsubscribe from topic array since one of them is a reserved topic '" + r[n] + "'";
            p.unsubscribe(r, t)
        }, this.end = function (e, t) {
            p.end(e, t)
        }, this.updateWebSocketCredentials = function (e, t, r, n) {
            p.updateWebSocketCredentials(e, t, r, n)
        }, this.updateCustomAuthHeaders = function (e) {
            p.updateCustomAuthHeaders(e)
        }, this.setConnectionStatus = function (e) {
            h = e
        }, n.EventEmitter.call(this)
    }

    i(u, n.EventEmitter), e.exports = u
}, function (e, t, r) {
    var n = r(29), i = r(50).inherits, o = r(88), s = r(61);

    function a(e, t, r) {
        var n = "$aws/things/" + e + "/jobs/";
        return s(r) ? r = t : n += t.toString() + "/", n += r
    }

    function c(e) {
        if (!(this instanceof c)) return new c(e);
        var t = this, r = [], n = o.DeviceClient(e);
        this._updateJobStatus = function (t, r, i, o, c) {
            "function" == typeof o && (c = o, o = void 0), s(e) || !0 !== e.debug || console.log("updateJobStatus:", {
                thingName: t,
                jobId: r.id,
                status: i,
                statusDetails: o
            }), n.publish(a(t, r.id, "update"), JSON.stringify({status: i, statusDetails: o}), null, function (e) {
                s(e) && (r.status = {status: i, statusDetails: o}), s(c) || c(e)
            })
        }, this._buildJobObject = function (e, r) {
            if (s(r) || s(r.jobId)) return null;
            var n = {};
            return n.id = r.jobId, n.document = r.jobDocument, n.operation = n.document.operation, n.status = {
                status: r.status,
                statusDetails: r.statusDetails
            }, n.inProgress = function (r, i) {
                t._updateJobStatus(e, n, "IN_PROGRESS", r, i)
            }, n.failed = function (r, i) {
                t._updateJobStatus(e, n, "FAILED", r, i)
            }, n.succeeded = function (r, i) {
                t._updateJobStatus(e, n, "SUCCEEDED", r, i)
            }, n
        }, this._handleMessages = function (n, i) {
            var o = n.split("/");
            if (function (e) {
                return "$aws" === e[0] && "things" === e[1] && "jobs" === e[3]
            }(o)) {
                var a = o[2], c = r.find(function (e) {
                    return e.thingName === a
                });
                if (!s(c)) {
                    var u = {};
                    try {
                        u = JSON.parse(i.toString())
                    } catch (t) {
                        return void (!0 === e.debug && console.error("failed parsing JSON '" + i.toString() + "', " + t))
                    }
                    if (!(s(u.execution) || s(u.execution.jobId) || s(u.execution.jobDocument))) {
                        var d = u.execution.jobDocument.operation, l = c.operations.find(function (e) {
                            return s(d) ? s(e.operationName) : d === e.operationName
                        });
                        s(l) && (l = c.operations.find(function (e) {
                            return s(e.operationName)
                        }), s(l)) || l.callback(null, t._buildJobObject(a, u.execution))
                    }
                }
            } else t.emit("message", n, i)
        }, this.subscribeToJobs = function (t, i, o) {
            s(o) && (o = i, i = null), s(e) || !0 !== e.debug || console.log("subscribeToJobs:", {
                thingName: t,
                operationName: i
            });
            var c = r.find(function (e) {
                return e.thingName === t
            });
            s(c) && (c = {
                thingName: t,
                operations: []
            }, r.push(c), n.subscribe([a(t, "$next/get/accepted"), a(t, "notify-next")], function (e, t) {
                s(e) || o(e)
            }));
            var u = c.operations.find(function (e) {
                return s(i) ? s(e.operationName) : i === e.operationName
            });
            s(u) ? (u = {operationName: i, callback: o}, c.operations.push(u)) : u.callback = o
        }, this.unsubscribeFromJobs = function (t, i, o) {
            s(o) && (o = i, i = null), s(e) || !0 !== e.debug || console.log("unsubscribeFromJobs:", {
                thingName: t,
                operationName: i
            });
            var c = r.findIndex(function (e) {
                return e.thingName === t
            }), u = new Error("subscription not found for given thing");
            if (c < 0) o(u); else {
                var d = r[c].operations.findIndex(function (e) {
                    return s(i) ? s(e.operationName) : i === e.operationName
                });
                if (d < 0) o(u); else {
                    if (r[c].operations.splice(d, 1), 0 === r[c].operations.length) return r.splice(c, 1), void n.unsubscribe([a(t, "$next/get/accepted"), a(t, "notify-next")], o);
                    o()
                }
            }
        }, this.startJobNotifications = function (t, r) {
            s(e) || !0 !== e.debug || console.log("startJobNotifications:", {thingName: t}), n.publish(a(t, "$next", "get"), "{}", r)
        }, n.on("connect", function () {
            t.emit("connect")
        }), n.on("close", function () {
            t.emit("close")
        }), n.on("reconnect", function () {
            t.emit("reconnect")
        }), n.on("offline", function () {
            t.emit("offline")
        }), n.on("error", function (e) {
            t.emit("error", e)
        }), n.on("message", t._handleMessages), this.publish = n.publish, this.subscribe = n.subscribe, this.unsubscribe = n.unsubscribe, this.end = n.end, this.handleMessage = n.handleMessage, this.updateWebSocketCredentials = n.updateWebSocketCredentials, this.simulateNetworkFailure = n.simulateNetworkFailure
    }

    i(c, n.EventEmitter), e.exports = c
}, function (e, t, r) {
    "use strict";
    r.r(t), r.d(t, "Agora", function () {
        return R
    });
    var n = r(12), i = r.n(n), o = r(6), s = r.n(o), a = r(8), c = r.n(a), u = r(3), d = r.n(u), l = r(5), h = r.n(l),
        p = r(40), f = r.n(p), m = r(2), _ = r(1), v = r(13);
    r(4);

    function g(e, t) {
        var r = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
            var n = Object.getOwnPropertySymbols(e);
            t && (n = n.filter(function (t) {
                return Object.getOwnPropertyDescriptor(e, t).enumerable
            })), r.push.apply(r, n)
        }
        return r
    }

    function E(e) {
        for (var t = 1; t < arguments.length; t++) {
            var r = null != arguments[t] ? arguments[t] : {};
            t % 2 ? g(Object(r), !0).forEach(function (t) {
                d()(e, t, r[t])
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : g(Object(r)).forEach(function (t) {
                Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t))
            })
        }
        return e
    }

    var y = r(0).errors, S = m.a.LOG_LEVELS, b = S.INFO, T = (S.WARN, S.ERROR), R = function () {
        function e() {
            s()(this, e), d()(this, "agoraClient", void 0), d()(this, "currentUser", void 0), d()(this, "rtcUserId", void 0), d()(this, "mediaViews", {}), d()(this, "localVideoTrack", null), d()(this, "localAudioTrack", null), d()(this, "remoteStreams", []), d()(this, "videoProfile", null), d()(this, "autoPlayPolicyError", !1), d()(this, "muted", !1), d()(this, "checkSystemRequirements", function () {
                return !0
            }), d()(this, "getDevices", function (e, t) {
                return f.a.getDevices(e, t)
            })
        }

        return c()(e, [{
            key: "init", value: function (e, t, r) {
                if (!t.appId) return _.a.log(T, y.INVALID_LIVE_BROADCAST_APP_ID, {}), r(y.INVALID_LIVE_BROADCAST_APP_ID);
                t = Object.assign(m.a.DEFAULT_AGORA_INIT_OPTIONS, t), this.options = t, this.currentUser = e, f.a.setLogLevel(v.a.LOGGER ? 0 : 4), this.agoraClient = f.a.createClient(t), this.agoraClient.enableDualStream(), this.subscribeAgoraEvents(), _.a.log(b, "WebRTC client connected", {}), r(null)
            }
        }, {
            key: "updateCurrentUser", value: function (e) {
                this.currentUser = e
            }
        }, {
            key: "close", value: function (e, t) {
                var r = this;
                this.leave(null, {}, function (e, n) {
                    r.__resetProperties(), _.a.log(b, "Webrtc client disconnected", {}), t()
                })
            }
        }, {
            key: "on", value: function () {
                var e;
                (e = this.getClient()).on.apply(e, arguments)
            }
        }, {
            key: "off", value: function () {
                var e;
                (e = this.getClient()).off.apply(e, arguments)
            }
        }, {
            key: "getUID", value: function () {
                return this.currentUser.id
            }
        }, {
            key: "getRTCUserId", value: function () {
                return this.rtcUserId
            }
        }, {
            key: "setRTCUserId", value: function (e) {
                this.rtcUserId = e
            }
        }, {
            key: "getClient", value: function () {
                return this.agoraClient
            }
        }, {
            key: "isAudioOn", value: function (e) {
                var t, r = this.getStream(e);
                return r ? null === (t = r.audioTrack) || void 0 === t ? void 0 : t.muted : null
            }
        }, {
            key: "isVideoOn", value: function (e) {
                var t, r = this.getStream(e);
                return r ? null === (t = r.videoTrack) || void 0 === t ? void 0 : t.isPlaying : null
            }
        }, {
            key: "muteAudio", value: function (e) {
                var t, r;
                this.muted = !0;
                var n = this.getStream(e);
                return _.a.log(b, "WebRTC function triggered - mute audio", {
                    rtcUserId: e,
                    stream: n
                }), n && null !== (t = n.audioTrack) && void 0 !== t && t.isPlaying ? null === (r = n.audioTrack) || void 0 === r ? void 0 : r.stop() : null
            }
        }, {
            key: "muteVideo", value: function (e) {
                var t, r = this.getStream(e);
                return r ? null === (t = r.videoTrack) || void 0 === t ? void 0 : t.stop() : null
            }
        }, {
            key: "unmuteAudio", value: function (e) {
                var t, r;
                this.muted = !1;
                var n = this.getStream(e);
                return _.a.log(b, "WebRTC function triggered - unmute audio", {
                    rtcUserId: e,
                    stream: n
                }), !n || null !== (t = n.audioTrack) && void 0 !== t && t.isPlaying ? null : null === (r = n.audioTrack) || void 0 === r ? void 0 : r.play()
            }
        }, {
            key: "unmuteVideo", value: function (e) {
                var t, r = this.getStream(e), n = this.mediaViews[e];
                if (n) {
                    var i = n.view, o = n.options;
                    return r ? null === (t = r.videoTrack) || void 0 === t ? void 0 : t.play(i, o) : null
                }
            }
        }, {
            key: "playLocalStream", value: function (e, t, r) {
                t = E(E({}, m.a.DEFAULT_AGORA_STREAM_OPTIONS), t);
                var n = this.getRTCUserId();
                this.mediaViews[n] = {
                    view: e,
                    options: t,
                    cb: r
                }, this.localVideoTrack && this.localVideoTrack.play(e, t)
            }
        }, {
            key: "playRemoteStream", value: function (e, t, r, n, i) {
                try {
                    _.a.log(b, "WebRTC function triggered - play remote stream", {
                        rtcUserId: e,
                        broadcastPlatform: t,
                        view: r,
                        options: n,
                        cb: i,
                        muted: this.muted,
                        autoPlayPolicyError: this.autoPlayPolicyError
                    }), n = E(E({}, m.a.DEFAULT_AGORA_STREAM_OPTIONS), n), this.mediaViews[e] = {
                        view: r,
                        options: n,
                        cb: i
                    };
                    var o = this.getStream(e);
                    o && (o.videoTrack && !o.videoTrack.isPlaying && o.videoTrack.play(r, n), !o.audioTrack || this.autoPlayPolicyError || this.muted || o.audioTrack.play(), i())
                } catch (e) {
                    _.a.log(T, "Error while playng remote stream", {error: e})
                }
            }
        }, {
            key: "resumeRemoteStream", value: function (e, t) {
                this.autoPlayPolicyError = !1;
                var r = this.getStream(e), n = this.mediaViews[e];
                r && r.videoTrack && n && (r.videoTrack.isPlaying || r.videoTrack.play(n.view, n.options), r.audioTrack.isPlaying || this.autoPlayPolicyError || r.audioTrack.play()), t(null, !0)
            }
        }, {
            key: "stopLocalStream", value: function () {
                this.localAudioTrack && this.localAudioTrack.close(), this.localVideoTrack && this.localVideoTrack.close()
            }
        }, {
            key: "stopRemoteStream", value: function (e) {
                var t = this.getStream(e);
                t && t.videoTrack && t.videoTrack.isPlaying && t.videoTrack.stop(), t && t.audioTrack && t.audioTrack.isPlaying && t.audioTrack.stop()
            }
        }, {
            key: "subscribeAgoraEvents", value: function () {
                var e = this;
                f.a.onAutoplayFailed = function () {
                    _.a.log(T, "WebRTC event triggered - auto play failed", {}), e.autoPlayPolicyError = !0;
                    for (var t = 0; t < Object.keys(e.mediaViews).length; t += 1) {
                        (0, e.mediaViews[Object.keys(e.mediaViews)[t]].cb)(new Error("Auto playback failed"), null)
                    }
                }, this.agoraClient.on("error", function (e) {
                    _.a.log(T, "Error in webRTC client", {err: e})
                }), this.agoraClient.on("stream-fallback", function (e, t) {
                    _.a.log(b, "WebRTC event triggered - stream-fallback", {uid: e, isFallbackOrRecover: t})
                }), this.agoraClient.on("user-joined", function (e) {
                    _.a.log(b, "WebRTC event triggered - user-joined", {user: e})
                }), this.agoraClient.on("user-left", function (t, r) {
                    var n = t.uid, i = e.getStream(n);
                    i && i.videoTrack && i.videoTrack.isPlaying && i.videoTrack.stop(), i && i.audioTrack && i.audioTrack.isPlaying && i.audioTrack.stop(), e.mediaViews[n] = void 0, _.a.log(b, "WebRTC event triggered - user-left", {
                        user: t,
                        reason: r,
                        stream: i
                    })
                }), this.agoraClient.on("user-published", function () {
                    var t = i()(h.a.mark(function t(r, n) {
                        var i, o, s, a, c;
                        return h.a.wrap(function (t) {
                            for (; ;) switch (t.prev = t.next) {
                                case 0:
                                    if (t.prev = 0, _.a.log(b, "WebRTC event triggered - user-published", {
                                        user: r,
                                        mediaType: n,
                                        autoPlayPolicyError: e.autoPlayPolicyError,
                                        muted: e.muted,
                                        audioTrack: r.audioTrack,
                                        videoTrack: r.videoTrack
                                    }), i = r.uid) {
                                        t.next = 5;
                                        break
                                    }
                                    return t.abrupt("return");
                                case 5:
                                    return t.next = 7, e.agoraClient.subscribe(r, n);
                                case 7:
                                    if ("video" !== n) {
                                        t.next = 10;
                                        break
                                    }
                                    return t.next = 10, e.agoraClient.setStreamFallbackOption(i, 1);
                                case 10:
                                    (o = e.mediaViews[i]) && (s = o.view, a = o.options, c = o.cb, "video" !== n || r.videoTrack.isPlaying || r.videoTrack.play(s, a), "audio" !== n || e.autoPlayPolicyError || (r.audioTrack.isPlaying || e.muted ? r.audioTrack.isPlaying && e.muted && r.audioTrack.stop() : r.audioTrack.play()), e.autoPlayPolicyError || c(null)), t.next = 17;
                                    break;
                                case 14:
                                    t.prev = 14, t.t0 = t.catch(0), _.a.log(T, "Error while publishing user", {
                                        error: t.t0,
                                        user: r,
                                        mediaType: n
                                    });
                                case 17:
                                case"end":
                                    return t.stop()
                            }
                        }, t, null, [[0, 14]])
                    }));
                    return function (e, r) {
                        return t.apply(this, arguments)
                    }
                }()), this.agoraClient.on("user-unpublished", function (t, r) {
                    try {
                        _.a.log(b, "WebRTC event triggered - user-unpublished", {
                            user: t,
                            mediaType: r,
                            autoPlayPolicyError: e.autoPlayPolicyError,
                            muted: e.muted,
                            audioTrack: t.audioTrack,
                            videoTrack: t.videoTrack
                        });
                        var n = t.uid, i = e.getStream(n);
                        i && i.videoTrack && i.videoTrack.isPlaying && "video" === r && i.videoTrack.stop(), i && i.audioTrack && i.audioTrack.isPlaying && "audio" === r && i.audioTrack.stop()
                    } catch (e) {
                        _.a.log(T, "Error while unpublishing user", {error: e, user: t, mediaType: r})
                    }
                }), this.agoraClient.on("stream-type-changed", function (e) {
                    var t = e.uid, r = e.streamType;
                    _.a.log(b, "WebRTC event triggered - stream-type-changed", {uid: t, streamType: r})
                })
            }
        }, {
            key: "joinAsAudience", value: function () {
                var e = i()(h.a.mark(function e(t, r, n, i, o) {
                    var s;
                    return h.a.wrap(function (e) {
                        for (; ;) switch (e.prev = e.next) {
                            case 0:
                                return e.prev = 0, this.agoraClient.setClientRole("audience"), e.next = 4, this.agoraClient.join(this.options.appId, t, n, r);
                            case 4:
                                s = e.sent, this.setRTCUserId(s), _.a.log(b, "Joined webRTC channel as audience", {rtcUserId: r}), o(null, r), e.next = 14;
                                break;
                            case 10:
                                e.prev = 10, e.t0 = e.catch(0), _.a.log(T, "Error while joining webRTC channel as audience", {err: e.t0}), o(e.t0);
                            case 14:
                            case"end":
                                return e.stop()
                        }
                    }, e, this, [[0, 10]])
                }));
                return function (t, r, n, i, o) {
                    return e.apply(this, arguments)
                }
            }()
        }, {
            key: "joinAsHost", value: function () {
                var e = i()(h.a.mark(function e(t, r, n, i, o, s, a) {
                    var c, u;
                    return h.a.wrap(function (e) {
                        for (; ;) switch (e.prev = e.next) {
                            case 0:
                                return e.prev = 0, this.agoraClient.setClientRole("host"), e.next = 4, this.agoraClient.join(this.options.appId, t, o, i);
                            case 4:
                                if (c = e.sent, this.setRTCUserId(c), _.a.log(b, "Joined webRTC channel as host", {uid: c}), !r) {
                                    e.next = 10;
                                    break
                                }
                                return this.videoProfile = n, e.abrupt("return", a(null, i));
                            case 10:
                                if (_.a.log(b, "Enabled dual stream for webRTC client", {}), s = E(E({
                                    audio: !0,
                                    video: !0
                                }, s), {}, {streamID: c}), u = [], !s.audio) {
                                    e.next = 18;
                                    break
                                }
                                return e.next = 16, f.a.createMicrophoneAudioTrack();
                            case 16:
                                this.localAudioTrack = e.sent, u.push(this.localAudioTrack);
                            case 18:
                                if (!s.video) {
                                    e.next = 23;
                                    break
                                }
                                return e.next = 21, f.a.createCameraVideoTrack({encoderConfig: n.name});
                            case 21:
                                this.localVideoTrack = e.sent, u.push(this.localVideoTrack);
                            case 23:
                                return e.next = 25, this.agoraClient.publish(u);
                            case 25:
                                a(null, i), e.next = 32;
                                break;
                            case 28:
                                e.prev = 28, e.t0 = e.catch(0), _.a.log(T, "Error while joining webRTC as a host", {err: e.t0}), a(e.t0);
                            case 32:
                            case"end":
                                return e.stop()
                        }
                    }, e, this, [[0, 28]])
                }));
                return function (t, r, n, i, o, s, a) {
                    return e.apply(this, arguments)
                }
            }()
        }, {
            key: "setVideoResolution", value: function (e) {
                this.localStream && this.localStream.setVideoEncoderConfiguration({resolution: e})
            }
        }, {
            key: "leave", value: function () {
                var e = i()(h.a.mark(function e(t, r, n) {
                    var i, o;
                    return h.a.wrap(function (e) {
                        for (; ;) switch (e.prev = e.next) {
                            case 0:
                                for (e.prev = 0, this.autoPlayPolicyError = !1, this.muted = !1, this.localAudioTrack && this.localAudioTrack.close(), this.localVideoTrack && this.localVideoTrack.close(), i = 0; i < this.agoraClient.remoteUsers.length; i += 1) (o = this.agoraClient.remoteUsers[i]).videoTrack && o.videoTrack.isPlaying && o.videoTrack.stop(), o.audioTrack && o.audioTrack.isPlaying && o.audioTrack.stop();
                                return e.next = 8, this.agoraClient.leave();
                            case 8:
                                _.a.log(b, "Left webRTC channel", {}), this.localAudioTrack = null, this.localVideoTrack = null, this.remoteStreams = [], n(), e.next = 18;
                                break;
                            case 15:
                                e.prev = 15, e.t0 = e.catch(0), _.a.log(T, "Error while leaving webRTC channel", {err: e.t0});
                            case 18:
                            case"end":
                                return e.stop()
                        }
                    }, e, this, [[0, 15]])
                }));
                return function (t, r, n) {
                    return e.apply(this, arguments)
                }
            }()
        }, {
            key: "getStream", value: function (e) {
                return this.localVideoTrack ? {
                    videoTrack: this.localVideoTrack,
                    audioTrack: this.localAudioTrack
                } : this.agoraClient.remoteUsers.find(function (t) {
                    return t.uid == e
                })
            }
        }, {
            key: "__resetProperties", value: function () {
                this.agoraClient = null, this.rtcUserId = null, this.currentUser = null, this.mediaViews = {}, this.remoteStreams = [], this.videoProfile = null, this.localAudioTrack = null, this.localVideoTrack = null
            }
        }]), e
    }()
}]);